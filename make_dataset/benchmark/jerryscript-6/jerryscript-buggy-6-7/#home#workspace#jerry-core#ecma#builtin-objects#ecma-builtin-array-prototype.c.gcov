        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-comparison.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers-number.h"
        -:   27:#include "ecma-helpers.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-string-object.h"
        -:   30:
        -:   31:#include "jcontext.h"
        -:   32:#include "jrt.h"
        -:   33:#include "lit-char-helpers.h"
        -:   34:
        -:   35:#if JERRY_BUILTIN_ARRAY
        -:   36:
        -:   37:#define ECMA_BUILTINS_INTERNAL
        -:   38:#include "ecma-builtins-internal.h"
        -:   39:
        -:   40:/**
        -:   41: * This object has a custom dispatch function.
        -:   42: */
        -:   43:#define BUILTIN_CUSTOM_DISPATCH
        -:   44:
        -:   45:/**
        -:   46: * List of built-in routine identifiers.
        -:   47: */
        -:   48:enum
        -:   49:{
        -:   50:  ECMA_ARRAY_PROTOTYPE_ROUTINE_START = 0,
        -:   51:/* Note: these 2 routine ids must be in this order */
        -:   52:#if !JERRY_ESNEXT
        -:   53:  ECMA_ARRAY_PROTOTYPE_TO_STRING,
        -:   54:#endif /* !JERRY_ESNEXT */
        -:   55:  ECMA_ARRAY_PROTOTYPE_SORT,
        -:   56:  ECMA_ARRAY_PROTOTYPE_CONCAT,
        -:   57:  ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING,
        -:   58:  ECMA_ARRAY_PROTOTYPE_JOIN,
        -:   59:  ECMA_ARRAY_PROTOTYPE_POP,
        -:   60:  ECMA_ARRAY_PROTOTYPE_PUSH,
        -:   61:  ECMA_ARRAY_PROTOTYPE_REVERSE,
        -:   62:  ECMA_ARRAY_PROTOTYPE_SHIFT,
        -:   63:  ECMA_ARRAY_PROTOTYPE_SLICE,
        -:   64:  ECMA_ARRAY_PROTOTYPE_SPLICE,
        -:   65:  ECMA_ARRAY_PROTOTYPE_UNSHIFT,
        -:   66:  ECMA_ARRAY_PROTOTYPE_AT,
        -:   67:  ECMA_ARRAY_PROTOTYPE_INDEX_OF,
        -:   68:  ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF,
        -:   69:  /* Note these 3 routines must be in this order */
        -:   70:  ECMA_ARRAY_PROTOTYPE_EVERY,
        -:   71:  ECMA_ARRAY_PROTOTYPE_SOME,
        -:   72:  ECMA_ARRAY_PROTOTYPE_FOR_EACH,
        -:   73:  ECMA_ARRAY_PROTOTYPE_MAP,
        -:   74:  ECMA_ARRAY_PROTOTYPE_FILTER,
        -:   75:  /* Note these 2 routines must be in this order */
        -:   76:  ECMA_ARRAY_PROTOTYPE_REDUCE,
        -:   77:  ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT,
        -:   78:  ECMA_ARRAY_PROTOTYPE_FIND,
        -:   79:  ECMA_ARRAY_PROTOTYPE_FIND_INDEX,
        -:   80:  ECMA_ARRAY_PROTOTYPE_ENTRIES,
        -:   81:  ECMA_ARRAY_PROTOTYPE_KEYS,
        -:   82:  ECMA_ARRAY_PROTOTYPE_SYMBOL_ITERATOR,
        -:   83:  ECMA_ARRAY_PROTOTYPE_FILL,
        -:   84:  ECMA_ARRAY_PROTOTYPE_COPY_WITHIN,
        -:   85:  ECMA_ARRAY_PROTOTYPE_INCLUDES,
        -:   86:  ECMA_ARRAY_PROTOTYPE_FLAT,
        -:   87:  ECMA_ARRAY_PROTOTYPE_FLATMAP,
        -:   88:};
        -:   89:
        -:   90:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-array-prototype.inc.h"
        -:   91:#define BUILTIN_UNDERSCORED_ID  array_prototype
        -:   92:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   93:
        -:   94:/** \addtogroup ecma ECMA
        -:   95: * @{
        -:   96: *
        -:   97: * \addtogroup ecmabuiltins
        -:   98: * @{
        -:   99: *
        -:  100: * \addtogroup arrayprototype ECMA Array.prototype object built-in
        -:  101: * @{
        -:  102: */
        -:  103:
        -:  104:/**
        -:  105: * Helper function to set an object's length property
        -:  106: *
        -:  107: * @return ecma value (return value of the [[Put]] method)
        -:  108: *         Calling ecma_free_value on the returned value is optional if it is not abrupt completion.
        -:  109: */
        -:  110:static ecma_value_t
    #####:  111:ecma_builtin_array_prototype_helper_set_length (ecma_object_t *object, /**< object*/
        -:  112:                                                ecma_number_t length) /**< new length */
        -:  113:{
    #####:  114:  ecma_value_t length_value = ecma_make_number_value (length);
    #####:  115:  ecma_value_t ret_value =
    #####:  116:    ecma_op_object_put (object, ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), length_value, true);
        -:  117:
    #####:  118:  ecma_free_value (length_value);
        -:  119:
    #####:  120:  JERRY_ASSERT (ecma_is_value_boolean (ret_value) || ecma_is_value_empty (ret_value)
        -:  121:                || ECMA_IS_VALUE_ERROR (ret_value));
    #####:  122:  return ret_value;
        -:  123:} /* ecma_builtin_array_prototype_helper_set_length */
        -:  124:
        -:  125:/**
        -:  126: * The Array.prototype object's 'toLocaleString' routine
        -:  127: *
        -:  128: * See also:
        -:  129: *          ECMA-262 v5, 15.4.4.3
        -:  130: *
        -:  131: * @return ecma value
        -:  132: *         Returned value must be freed with ecma_free_value.
        -:  133: */
        -:  134:static ecma_value_t
    #####:  135:ecma_builtin_array_prototype_object_to_locale_string (ecma_object_t *obj_p, /**< object */
        -:  136:                                                      ecma_length_t length) /**< object's length */
        -:  137:{
        -:  138:  /* 5. */
    #####:  139:  if (length == 0)
        -:  140:  {
    #####:  141:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  142:  }
        -:  143:
        -:  144:  /* 7-8. */
    #####:  145:  ecma_string_t *first_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, 0);
        -:  146:
    #####:  147:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  148:  {
    #####:  149:    return ECMA_VALUE_ERROR;
        -:  150:  }
        -:  151:
    #####:  152:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  153:  ecma_deref_ecma_string (first_string_p);
        -:  154:
        -:  155:  /* 9-10. */
    #####:  156:  for (ecma_length_t k = 1; k < length; k++)
        -:  157:  {
        -:  158:    /* 4. Implementation-defined: set the separator to a single comma character. */
    #####:  159:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
        -:  160:
    #####:  161:    ecma_string_t *next_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, k);
        -:  162:
    #####:  163:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  164:    {
    #####:  165:      ecma_stringbuilder_destroy (&builder);
    #####:  166:      return ECMA_VALUE_ERROR;
        -:  167:    }
        -:  168:
    #####:  169:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  170:    ecma_deref_ecma_string (next_string_p);
        -:  171:  }
        -:  172:
    #####:  173:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  174:} /* ecma_builtin_array_prototype_object_to_locale_string */
        -:  175:
        -:  176:/**
        -:  177: * The Array.prototype object's 'concat' routine
        -:  178: *
        -:  179: * See also:
        -:  180: *          ECMA-262 v5, 15.4.4.4
        -:  181: *
        -:  182: * @return ecma value
        -:  183: *         Returned value must be freed with ecma_free_value.
        -:  184: */
        -:  185:static ecma_value_t
    #####:  186:ecma_builtin_array_prototype_object_concat (const ecma_value_t args[], /**< arguments list */
        -:  187:                                            uint32_t args_number, /**< number of arguments */
        -:  188:                                            ecma_object_t *obj_p) /**< array object */
        -:  189:{
        -:  190:  /* 2. */
        -:  191:#if JERRY_ESNEXT
    #####:  192:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -:  193:
    #####:  194:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:#else /* !JERRY_ESNEXT */
    #####:  199:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  200:#endif /* JERRY_ESNEXT */
        -:  201:
    #####:  202:  ecma_length_t new_length = 0;
        -:  203:
        -:  204:  /* 5.b - 5.c for this_arg */
    #####:  205:  ecma_value_t concat_this_value =
    #####:  206:    ecma_builtin_helper_array_concat_value (new_array_p, &new_length, ecma_make_object_value (obj_p));
    #####:  207:  if (ECMA_IS_VALUE_ERROR (concat_this_value))
        -:  208:  {
    #####:  209:    ecma_deref_object (new_array_p);
    #####:  210:    return concat_this_value;
        -:  211:  }
        -:  212:
    #####:  213:  JERRY_ASSERT (ecma_is_value_empty (concat_this_value));
        -:  214:
        -:  215:  /* 5. */
    #####:  216:  for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -:  217:  {
    #####:  218:    ecma_value_t concat_value = ecma_builtin_helper_array_concat_value (new_array_p, &new_length, args[arg_index]);
        -:  219:
    #####:  220:    if (ECMA_IS_VALUE_ERROR (concat_value))
        -:  221:    {
    #####:  222:      ecma_deref_object (new_array_p);
    #####:  223:      return concat_value;
        -:  224:    }
        -:  225:
    #####:  226:    JERRY_ASSERT (ecma_is_value_empty (concat_value));
        -:  227:  }
        -:  228:
    #####:  229:  ecma_value_t set_length_value =
    #####:  230:    ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) new_length));
    #####:  231:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  232:  {
    #####:  233:    ecma_deref_object (new_array_p);
    #####:  234:    return set_length_value;
        -:  235:  }
        -:  236:
    #####:  237:  return ecma_make_object_value (new_array_p);
        -:  238:} /* ecma_builtin_array_prototype_object_concat */
        -:  239:
        -:  240:/**
        -:  241: * The Array.prototype.toString's separator creation routine
        -:  242: *
        -:  243: * See also:
        -:  244: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  245: *
        -:  246: * @return NULL - if the conversion fails
        -:  247: *         ecma_string_t * - otherwise
        -:  248: */
        -:  249:
        -:  250:static ecma_string_t *
    #####:  251:ecma_op_array_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  252:{
    #####:  253:  if (ecma_is_value_undefined (separator))
        -:  254:  {
    #####:  255:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  256:  }
        -:  257:
    #####:  258:  return ecma_op_to_string (separator);
        -:  259:} /* ecma_op_array_get_separator_string */
        -:  260:
        -:  261:/**
        -:  262: * The Array.prototype's 'toString' single element operation routine
        -:  263: *
        -:  264: * See also:
        -:  265: *          ECMA-262 v5.1, 15.4.4.2
        -:  266: *
        -:  267: * @return NULL - if the conversion fails
        -:  268: *         ecma_string_t * - otherwise
        -:  269: */
        -:  270:static ecma_string_t *
    #####:  271:ecma_op_array_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  272:                                      ecma_length_t index) /**< array index */
        -:  273:{
    #####:  274:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  275:
    #####:  276:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  277:  {
    #####:  278:    return NULL;
        -:  279:  }
        -:  280:
    #####:  281:  if (ecma_is_value_undefined (index_value) || ecma_is_value_null (index_value))
        -:  282:  {
    #####:  283:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  284:  }
        -:  285:
    #####:  286:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  287:
    #####:  288:  ecma_free_value (index_value);
        -:  289:
    #####:  290:  return ret_str_p;
        -:  291:} /* ecma_op_array_get_to_string_at_index */
        -:  292:
        -:  293:/**
        -:  294: * The Array.prototype object's 'join' routine
        -:  295: *
        -:  296: * See also:
        -:  297: *          ECMA-262 v5, 15.4.4.5
        -:  298: *
        -:  299: * @return ecma value
        -:  300: *         Returned value must be freed with ecma_free_value.
        -:  301: */
        -:  302:static ecma_value_t
    #####:  303:ecma_builtin_array_prototype_join (ecma_value_t separator_arg, /**< separator argument */
        -:  304:                                   ecma_object_t *obj_p, /**< object */
        -:  305:                                   ecma_length_t length) /**< object's length */
        -:  306:{
        -:  307:  /* 4-5. */
    #####:  308:  ecma_string_t *separator_string_p = ecma_op_array_get_separator_string (separator_arg);
        -:  309:
    #####:  310:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  311:  {
    #####:  312:    return ECMA_VALUE_ERROR;
        -:  313:  }
        -:  314:
    #####:  315:  if (length == 0)
        -:  316:  {
        -:  317:    /* 6. */
    #####:  318:    ecma_deref_ecma_string (separator_string_p);
    #####:  319:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  320:  }
        -:  321:
        -:  322:  /* 7-8. */
    #####:  323:  ecma_string_t *first_string_p = ecma_op_array_get_to_string_at_index (obj_p, 0);
        -:  324:
    #####:  325:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  326:  {
    #####:  327:    ecma_deref_ecma_string (separator_string_p);
    #####:  328:    return ECMA_VALUE_ERROR;
        -:  329:  }
        -:  330:
    #####:  331:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  332:  ecma_deref_ecma_string (first_string_p);
        -:  333:
        -:  334:  /* 9-10. */
    #####:  335:  for (ecma_length_t k = 1; k < length; k++)
        -:  336:  {
        -:  337:    /* 10.a */
    #####:  338:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  339:
        -:  340:    /* 10.d */
    #####:  341:    ecma_string_t *next_string_p = ecma_op_array_get_to_string_at_index (obj_p, k);
        -:  342:
    #####:  343:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  344:    {
    #####:  345:      ecma_deref_ecma_string (separator_string_p);
    #####:  346:      ecma_stringbuilder_destroy (&builder);
    #####:  347:      return ECMA_VALUE_ERROR;
        -:  348:    }
        -:  349:
    #####:  350:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  351:    ecma_deref_ecma_string (next_string_p);
        -:  352:  }
        -:  353:
    #####:  354:  ecma_deref_ecma_string (separator_string_p);
    #####:  355:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  356:} /* ecma_builtin_array_prototype_join */
        -:  357:
        -:  358:/**
        -:  359: * The Array.prototype object's 'pop' routine
        -:  360: *
        -:  361: * See also:
        -:  362: *          ECMA-262 v5, 15.4.4.6
        -:  363: *
        -:  364: * @return ecma value
        -:  365: *         Returned value must be freed with ecma_free_value.
        -:  366: */
        -:  367:static ecma_value_t
    #####:  368:ecma_builtin_array_prototype_object_pop (ecma_object_t *obj_p, /**< object */
        -:  369:                                         ecma_length_t len) /**< object's length */
        -:  370:{
        -:  371:  /* 4. */
    #####:  372:  if (len == 0)
        -:  373:  {
        -:  374:    /* 4.a */
    #####:  375:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  376:
        -:  377:    /* 4.b */
    #####:  378:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  379:  }
        -:  380:
        -:  381:  /* 5.b */
    #####:  382:  len--;
    #####:  383:  ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, len);
        -:  384:
    #####:  385:  if (ECMA_IS_VALUE_ERROR (get_value))
        -:  386:  {
    #####:  387:    return get_value;
        -:  388:  }
        -:  389:
    #####:  390:  if (ecma_op_object_is_fast_array (obj_p))
        -:  391:  {
    #####:  392:    ecma_delete_fast_array_properties (obj_p, (uint32_t) len);
        -:  393:
    #####:  394:    return get_value;
        -:  395:  }
        -:  396:
        -:  397:  /* 5.c */
    #####:  398:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, len, true);
        -:  399:
    #####:  400:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  401:  {
    #####:  402:    ecma_free_value (get_value);
    #####:  403:    return del_value;
        -:  404:  }
        -:  405:
    #####:  406:  ecma_free_value (del_value);
        -:  407:
        -:  408:  /* 5.d */
    #####:  409:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  410:
    #####:  411:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  412:  {
    #####:  413:    ecma_free_value (get_value);
    #####:  414:    return set_length_value;
        -:  415:  }
        -:  416:
    #####:  417:  return get_value;
        -:  418:} /* ecma_builtin_array_prototype_object_pop */
        -:  419:
        -:  420:/**
        -:  421: * The Array.prototype object's 'push' routine
        -:  422: *
        -:  423: * See also:
        -:  424: *          ECMA-262 v5, 15.4.4.7
        -:  425: *
        -:  426: * @return ecma value
        -:  427: *         Returned value must be freed with ecma_free_value.
        -:  428: */
        -:  429:static ecma_value_t
    #####:  430:ecma_builtin_array_prototype_object_push (const ecma_value_t *argument_list_p, /**< arguments list */
        -:  431:                                          uint32_t arguments_number, /**< number of arguments */
        -:  432:                                          ecma_object_t *obj_p, /**< object */
        -:  433:                                          ecma_length_t length) /**< object's length */
        -:  434:{
    #####:  435:  if (ecma_op_object_is_fast_array (obj_p))
        -:  436:  {
    #####:  437:    if ((ecma_number_t) (length + arguments_number) > UINT32_MAX)
        -:  438:    {
    #####:  439:      return ecma_raise_range_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
        -:  440:    }
        -:  441:
    #####:  442:    if (arguments_number == 0)
        -:  443:    {
    #####:  444:      return ecma_make_uint32_value ((uint32_t) length);
        -:  445:    }
        -:  446:
    #####:  447:    uint32_t new_length = ((uint32_t) length) + arguments_number;
    #####:  448:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  449:    ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length) + length;
        -:  450:
    #####:  451:    for (uint32_t index = 0; index < arguments_number; index++)
        -:  452:    {
    #####:  453:      buffer_p[index] = ecma_copy_value_if_not_object (argument_list_p[index]);
        -:  454:    }
        -:  455:
    #####:  456:    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE * arguments_number;
        -:  457:
    #####:  458:    return ecma_make_uint32_value (new_length);
        -:  459:  }
        -:  460:
        -:  461:#if JERRY_ESNEXT
        -:  462:  /* 5. */
    #####:  463:  if ((ecma_number_t) (length + arguments_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -:  464:  {
    #####:  465:    return ecma_raise_type_error (ECMA_ERR_PUSHING_TOO_HIGH_ELEMENT);
        -:  466:  }
        -:  467:
        -:  468:  /* 6. */
    #####:  469:  for (ecma_length_t index = 0; index < arguments_number; index++, length++)
        -:  470:  {
        -:  471:    /* 6.b */
    #####:  472:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, length, argument_list_p[index], true);
        -:  473:
    #####:  474:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  475:    {
    #####:  476:      return put_value;
        -:  477:    }
        -:  478:  }
        -:  479:
    #####:  480:  ecma_number_t n = (ecma_number_t) length;
        -:  481:#else /* JERRY_ESNEXT */
    #####:  482:  ecma_number_t n = (ecma_number_t) length;
        -:  483:
        -:  484:  /* 5. */
    #####:  485:  for (ecma_length_t index = 0; index < arguments_number; index++, n++)
        -:  486:  {
        -:  487:    /* 5.b */
    #####:  488:    ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (n);
    #####:  489:    ecma_value_t put_value = ecma_op_object_put (obj_p, index_str_p, argument_list_p[index], true);
    #####:  490:    ecma_deref_ecma_string (index_str_p);
        -:  491:
    #####:  492:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  493:    {
        -:  494:      return put_value;
        -:  495:    }
        -:  496:  }
        -:  497:
        -:  498:#endif /* JERRY_ESNEXT */
        -:  499:  /* 6 - 7. */
    #####:  500:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, n);
        -:  501:
    #####:  502:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  503:  {
    #####:  504:    return set_length_value;
        -:  505:  }
        -:  506:
    #####:  507:  return ecma_make_number_value (n);
        -:  508:} /* ecma_builtin_array_prototype_object_push */
        -:  509:
        -:  510:/**
        -:  511: * The Array.prototype object's 'reverse' routine
        -:  512: *
        -:  513: * See also:
        -:  514: *          ECMA-262 v5, 15.4.4.8
        -:  515: *
        -:  516: * @return ecma value
        -:  517: *         Returned value must be freed with ecma_free_value.
        -:  518: */
        -:  519:static ecma_value_t
    #####:  520:ecma_builtin_array_prototype_object_reverse (ecma_value_t this_arg, /**< this argument */
        -:  521:                                             ecma_object_t *obj_p, /**< object */
        -:  522:                                             ecma_length_t len) /**< object's length */
        -:  523:{
    #####:  524:  if (ecma_op_object_is_fast_array (obj_p))
        -:  525:  {
    #####:  526:    uint32_t middle = (uint32_t) len / 2;
    #####:  527:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  528:
    #####:  529:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE && len != 0)
        -:  530:    {
    #####:  531:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  532:
    #####:  533:      for (uint32_t i = 0; i < middle; i++)
        -:  534:      {
    #####:  535:        ecma_value_t tmp = buffer_p[i];
    #####:  536:        buffer_p[i] = buffer_p[len - 1 - i];
    #####:  537:        buffer_p[len - 1 - i] = tmp;
        -:  538:      }
        -:  539:
    #####:  540:      return ecma_copy_value (this_arg);
        -:  541:    }
        -:  542:  }
        -:  543:
    #####:  544:  ecma_length_t middle = len / 2;
    #####:  545:  for (ecma_length_t lower = 0; lower < middle; lower++)
        -:  546:  {
    #####:  547:    ecma_length_t upper = len - lower - 1;
    #####:  548:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  549:
    #####:  550:    ecma_string_t *lower_str_p = ecma_new_ecma_string_from_length (lower);
    #####:  551:    ecma_string_t *upper_str_p = ecma_new_ecma_string_from_length (upper);
        -:  552:
        -:  553:#if JERRY_ESNEXT
    #####:  554:    ecma_value_t lower_value = ECMA_VALUE_EMPTY;
    #####:  555:    ecma_value_t upper_value = ECMA_VALUE_EMPTY;
        -:  556:
    #####:  557:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
        -:  558:
        -:  559:#if JERRY_BUILTIN_PROXY
    #####:  560:    if (ECMA_IS_VALUE_ERROR (has_lower))
        -:  561:    {
    #####:  562:      goto clean_up;
        -:  563:    }
        -:  564:#endif /* JERRY_BUILTIN_PROXY */
        -:  565:
    #####:  566:    bool lower_exist = ecma_is_value_true (has_lower);
        -:  567:
    #####:  568:    if (lower_exist)
        -:  569:    {
    #####:  570:      lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  571:
    #####:  572:      if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  573:      {
    #####:  574:        goto clean_up;
        -:  575:      }
        -:  576:    }
        -:  577:
    #####:  578:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  579:
        -:  580:#if JERRY_BUILTIN_PROXY
    #####:  581:    if (ECMA_IS_VALUE_ERROR (has_upper))
        -:  582:    {
    #####:  583:      goto clean_up;
        -:  584:    }
        -:  585:#endif /* JERRY_BUILTIN_PROXY */
        -:  586:
    #####:  587:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  588:
    #####:  589:    if (upper_exist)
        -:  590:    {
    #####:  591:      upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  592:
    #####:  593:      if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  594:      {
    #####:  595:        goto clean_up;
        -:  596:      }
        -:  597:    }
        -:  598:#else /* !JERRY_ESNEXT */
    #####:  599:    ecma_value_t lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  600:
    #####:  601:    if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  602:    {
    #####:  603:      ecma_deref_ecma_string (lower_str_p);
    #####:  604:      ecma_deref_ecma_string (upper_str_p);
    #####:  605:      return ret_value;
        -:  606:    }
        -:  607:
    #####:  608:    ecma_value_t upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  609:
    #####:  610:    if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  611:    {
        -:  612:      goto clean_up;
        -:  613:    }
        -:  614:
    #####:  615:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
    #####:  616:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  617:
    #####:  618:    bool lower_exist = ecma_is_value_true (has_lower);
    #####:  619:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  620:#endif /* JERRY_ESNEXT */
        -:  621:
    #####:  622:    if (lower_exist && upper_exist)
    #####:  623:    {
    #####:  624:      ecma_value_t outer_put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  625:
    #####:  626:      if (ECMA_IS_VALUE_ERROR (outer_put_value))
        -:  627:      {
    #####:  628:        goto clean_up;
        -:  629:      }
        -:  630:
    #####:  631:      ecma_value_t inner_put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  632:
    #####:  633:      if (ECMA_IS_VALUE_ERROR (inner_put_value))
        -:  634:      {
    #####:  635:        goto clean_up;
        -:  636:      }
        -:  637:    }
    #####:  638:    else if (!lower_exist && upper_exist)
    #####:  639:    {
    #####:  640:      ecma_value_t put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  641:
    #####:  642:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  643:      {
    #####:  644:        goto clean_up;
        -:  645:      }
        -:  646:
    #####:  647:      ecma_value_t del_value = ecma_op_object_delete (obj_p, upper_str_p, true);
        -:  648:
    #####:  649:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  650:      {
    #####:  651:        goto clean_up;
        -:  652:      }
        -:  653:    }
    #####:  654:    else if (lower_exist)
        -:  655:    {
    #####:  656:      ecma_value_t del_value = ecma_op_object_delete (obj_p, lower_str_p, true);
        -:  657:
    #####:  658:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  659:      {
    #####:  660:        goto clean_up;
        -:  661:      }
        -:  662:
    #####:  663:      ecma_value_t put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  664:
    #####:  665:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  666:      {
    #####:  667:        goto clean_up;
        -:  668:      }
        -:  669:    }
        -:  670:
    #####:  671:    ret_value = ECMA_VALUE_EMPTY;
        -:  672:
    #####:  673:clean_up:
    #####:  674:    ecma_free_value (upper_value);
    #####:  675:    ecma_free_value (lower_value);
    #####:  676:    ecma_deref_ecma_string (lower_str_p);
    #####:  677:    ecma_deref_ecma_string (upper_str_p);
        -:  678:
    #####:  679:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  680:    {
    #####:  681:      return ret_value;
        -:  682:    }
        -:  683:  }
        -:  684:
    #####:  685:  return ecma_copy_value (this_arg);
        -:  686:} /* ecma_builtin_array_prototype_object_reverse */
        -:  687:
        -:  688:/**
        -:  689: * The Array.prototype object's 'shift' routine
        -:  690: *
        -:  691: * See also:
        -:  692: *          ECMA-262 v5, 15.4.4.9
        -:  693: *
        -:  694: * @return ecma value
        -:  695: *         Returned value must be freed with ecma_free_value.
        -:  696: */
        -:  697:static ecma_value_t
    #####:  698:ecma_builtin_array_prototype_object_shift (ecma_object_t *obj_p, /**< object */
        -:  699:                                           ecma_length_t len) /**< object's length */
        -:  700:{
        -:  701:  /* 4. */
    #####:  702:  if (len == 0)
        -:  703:  {
    #####:  704:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  705:
    #####:  706:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  707:  }
        -:  708:
    #####:  709:  if (ecma_op_object_is_fast_array (obj_p))
        -:  710:  {
    #####:  711:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  712:
    #####:  713:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE && len != 0)
        -:  714:    {
    #####:  715:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
    #####:  716:      ecma_value_t ret_value = buffer_p[0];
        -:  717:
    #####:  718:      if (ecma_is_value_object (ret_value))
        -:  719:      {
    #####:  720:        ecma_ref_object (ecma_get_object_from_value (ret_value));
        -:  721:      }
        -:  722:
    #####:  723:      memmove (buffer_p, buffer_p + 1, (size_t) (sizeof (ecma_value_t) * (len - 1)));
        -:  724:
    #####:  725:      buffer_p[len - 1] = ECMA_VALUE_UNDEFINED;
    #####:  726:      ecma_delete_fast_array_properties (obj_p, (uint32_t) (len - 1));
        -:  727:
    #####:  728:      return ret_value;
        -:  729:    }
        -:  730:  }
        -:  731:
        -:  732:  /* 5. */
    #####:  733:  ecma_value_t first_value = ecma_op_object_get_by_index (obj_p, 0);
        -:  734:
    #####:  735:  if (ECMA_IS_VALUE_ERROR (first_value))
        -:  736:  {
    #####:  737:    return first_value;
        -:  738:  }
        -:  739:
        -:  740:  /* 6. and 7. */
    #####:  741:  for (ecma_length_t k = 1; k < len; k++)
        -:  742:  {
        -:  743:    /* 7.a - 7.c */
    #####:  744:    ecma_value_t curr_value = ecma_op_object_find_by_index (obj_p, k);
        -:  745:
    #####:  746:    if (ECMA_IS_VALUE_ERROR (curr_value))
        -:  747:    {
    #####:  748:      ecma_free_value (first_value);
    #####:  749:      return curr_value;
        -:  750:    }
        -:  751:
        -:  752:    /* 7.b */
    #####:  753:    ecma_length_t to = k - 1;
        -:  754:    ecma_value_t operation_value;
        -:  755:
    #####:  756:    if (ecma_is_value_found (curr_value))
        -:  757:    {
        -:  758:      /* 7.d.i, 7.d.ii */
    #####:  759:      operation_value = ecma_op_object_put_by_index (obj_p, to, curr_value, true);
    #####:  760:      ecma_free_value (curr_value);
        -:  761:    }
        -:  762:    else
        -:  763:    {
        -:  764:      /* 7.e.i */
    #####:  765:      operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -:  766:    }
        -:  767:
    #####:  768:    if (ECMA_IS_VALUE_ERROR (operation_value))
        -:  769:    {
    #####:  770:      ecma_free_value (first_value);
    #####:  771:      return operation_value;
        -:  772:    }
        -:  773:  }
        -:  774:
        -:  775:  /* 8. */
    #####:  776:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, --len, true);
        -:  777:
    #####:  778:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  779:  {
    #####:  780:    ecma_free_value (first_value);
    #####:  781:    return del_value;
        -:  782:  }
        -:  783:
        -:  784:  /* 9. */
    #####:  785:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  786:
    #####:  787:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  788:  {
    #####:  789:    ecma_free_value (first_value);
    #####:  790:    return set_length_value;
        -:  791:  }
        -:  792:
        -:  793:  /* 10. */
    #####:  794:  return first_value;
        -:  795:} /* ecma_builtin_array_prototype_object_shift */
        -:  796:
        -:  797:/**
        -:  798: * The Array.prototype object's 'slice' routine
        -:  799: *
        -:  800: * See also:
        -:  801: *          ECMA-262 v5, 15.4.4.10
        -:  802: *
        -:  803: * @return ecma value
        -:  804: *         Returned value must be freed with ecma_free_value.
        -:  805: */
        -:  806:static ecma_value_t
    #####:  807:ecma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */
        -:  808:                                           ecma_value_t arg2, /**< end */
        -:  809:                                           ecma_object_t *obj_p, /**< object */
        -:  810:                                           ecma_length_t len) /**< object's length */
        -:  811:{
    #####:  812:  ecma_length_t start = 0, end = len;
        -:  813:
        -:  814:  /* 5. 6.*/
    #####:  815:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1, len, &start)))
        -:  816:  {
    #####:  817:    return ECMA_VALUE_ERROR;
        -:  818:  }
        -:  819:
        -:  820:  /* 7. */
    #####:  821:  if (ecma_is_value_undefined (arg2))
        -:  822:  {
    #####:  823:    end = len;
        -:  824:  }
        -:  825:  else
        -:  826:  {
        -:  827:    /* 7. part 2, 8.*/
    #####:  828:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2, len, &end)))
        -:  829:    {
    #####:  830:      return ECMA_VALUE_ERROR;
        -:  831:    }
        -:  832:  }
        -:  833:
    #####:  834:  JERRY_ASSERT (start <= len && end <= len);
        -:  835:
    #####:  836:  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);
    #####:  837:  ecma_length_t copied_length = (end > start) ? end - start : 0;
        -:  838:#if JERRY_ESNEXT
    #####:  839:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);
        -:  840:
    #####:  841:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  842:  {
    #####:  843:    return ECMA_VALUE_ERROR;
        -:  844:  }
        -:  845:
    #####:  846:  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);
        -:  847:#else /* !JERRY_ESNEXT */
    #####:  848:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  849:#endif /* JERRY_ESNEXT */
        -:  850:
    #####:  851:  if (use_fast_path && copied_length > 0)
        -:  852:  {
    #####:  853:    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;
        -:  854:
    #####:  855:    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -:  856:    {
    #####:  857:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -:  858:      {
        -:  859:        /**
        -:  860:         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.
        -:  861:         * There is no need to do any copy.
        -:  862:         */
    #####:  863:        return ecma_make_object_value (new_array_p);
        -:  864:      }
        -:  865:
        -:  866:      /* Source array's length could be changed during the start/end normalization.
        -:  867:       * If the "end" value is greater than the current length, clamp the value to avoid buffer-overflow. */
    #####:  868:      if (ext_from_obj_p->u.array.length < end)
        -:  869:      {
    #####:  870:        end = ext_from_obj_p->u.array.length;
        -:  871:      }
        -:  872:
    #####:  873:      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;
        -:  874:
        -:  875:#if JERRY_ESNEXT
    #####:  876:      uint32_t target_length = ext_to_obj_p->u.array.length;
        -:  877:      ecma_value_t *to_buffer_p;
    #####:  878:      JERRY_ASSERT (copied_length <= UINT32_MAX);
        -:  879:
    #####:  880:      if (copied_length == target_length)
        -:  881:      {
    #####:  882:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  883:      }
    #####:  884:      else if (copied_length > target_length)
        -:  885:      {
    #####:  886:        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);
        -:  887:      }
        -:  888:      else
        -:  889:      {
    #####:  890:        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);
    #####:  891:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  892:      }
        -:  893:#else /* !JERRY_ESNEXT */
    #####:  894:      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);
        -:  895:#endif /* JERRY_ESNEXT */
        -:  896:
    #####:  897:      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  898:
        -:  899:      /* 9. */
    #####:  900:      uint32_t n = 0;
        -:  901:
    #####:  902:      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)
        -:  903:      {
        -:  904:#if JERRY_ESNEXT
    #####:  905:        ecma_free_value_if_not_object (to_buffer_p[n]);
        -:  906:#endif /* JERRY_ESNEXT */
    #####:  907:        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);
        -:  908:      }
        -:  909:
    #####:  910:      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;
        -:  911:
    #####:  912:      return ecma_make_object_value (new_array_p);
        -:  913:    }
        -:  914:  }
        -:  915:
        -:  916:  /* 9. */
    #####:  917:  ecma_length_t n = 0;
        -:  918:
        -:  919:  /* 10. */
    #####:  920:  for (ecma_length_t k = start; k < end; k++, n++)
        -:  921:  {
        -:  922:    /* 10.c */
    #####:  923:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);
        -:  924:
    #####:  925:    if (ECMA_IS_VALUE_ERROR (get_value))
        -:  926:    {
    #####:  927:      ecma_deref_object (new_array_p);
    #####:  928:      return get_value;
        -:  929:    }
        -:  930:
    #####:  931:    if (ecma_is_value_found (get_value))
        -:  932:    {
        -:  933:      /* 10.c.ii */
        -:  934:      ecma_value_t put_comp;
        -:  935:#if JERRY_ESNEXT
    #####:  936:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  937:#else /* !JERRY_ESNEXT */
    #####:  938:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -:  939:#endif /* JERRY_ESNEXT */
    #####:  940:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p, n, get_value, prop_flags);
    #####:  941:      ecma_free_value (get_value);
        -:  942:
        -:  943:#if JERRY_ESNEXT
    #####:  944:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  945:      {
    #####:  946:        ecma_deref_object (new_array_p);
    #####:  947:        return put_comp;
        -:  948:      }
        -:  949:#else /* !JERRY_ESNEXT */
        -:  950:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  951:#endif /* JERRY_ESNEXT */
        -:  952:    }
        -:  953:  }
        -:  954:
        -:  955:#if JERRY_ESNEXT
    #####:  956:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));
        -:  957:
    #####:  958:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  959:  {
    #####:  960:    ecma_deref_object (new_array_p);
    #####:  961:    return set_length_value;
        -:  962:  }
        -:  963:#endif /* JERRY_ESNEXT */
        -:  964:
    #####:  965:  return ecma_make_object_value (new_array_p);
        -:  966:} /* ecma_builtin_array_prototype_object_slice */
        -:  967:
        -:  968:/**
        -:  969: * SortCompare abstract method
        -:  970: *
        -:  971: * See also:
        -:  972: *          ECMA-262 v5, 15.4.4.11
        -:  973: *
        -:  974: * @return ecma value
        -:  975: *         Returned value must be freed with ecma_free_value.
        -:  976: */
        -:  977:static ecma_value_t
    #####:  978:ecma_builtin_array_prototype_object_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -:  979:                                                         ecma_value_t rhs, /**< right value */
        -:  980:                                                         ecma_value_t compare_func, /**< compare function */
        -:  981:                                                         ecma_object_t *array_buffer_p) /**< arrayBuffer */
        -:  982:{
        -:  983:  JERRY_UNUSED (array_buffer_p);
        -:  984:  /*
        -:  985:   * ECMA-262 v5, 15.4.4.11 NOTE1: Because non-existent property values always
        -:  986:   * compare greater than undefined property values, and undefined always
        -:  987:   * compares greater than any other value, undefined property values always
        -:  988:   * sort to the end of the result, followed by non-existent property values.
        -:  989:   */
    #####:  990:  bool lhs_is_undef = ecma_is_value_undefined (lhs);
    #####:  991:  bool rhs_is_undef = ecma_is_value_undefined (rhs);
        -:  992:
    #####:  993:  if (lhs_is_undef)
        -:  994:  {
    #####:  995:    return ecma_make_integer_value (rhs_is_undef ? 0 : 1);
        -:  996:  }
        -:  997:
    #####:  998:  if (rhs_is_undef)
        -:  999:  {
    #####: 1000:    return ecma_make_integer_value (-1);
        -: 1001:  }
        -: 1002:
    #####: 1003:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1004:
    #####: 1005:  if (ecma_is_value_undefined (compare_func))
        -: 1006:  {
        -: 1007:    /* Default comparison when no compare_func is passed. */
    #####: 1008:    ecma_string_t *lhs_str_p = ecma_op_to_string (lhs);
    #####: 1009:    if (JERRY_UNLIKELY (lhs_str_p == NULL))
        -: 1010:    {
    #####: 1011:      return ECMA_VALUE_ERROR;
        -: 1012:    }
        -: 1013:
    #####: 1014:    ecma_string_t *rhs_str_p = ecma_op_to_string (rhs);
    #####: 1015:    if (JERRY_UNLIKELY (rhs_str_p == NULL))
        -: 1016:    {
    #####: 1017:      ecma_deref_ecma_string (lhs_str_p);
    #####: 1018:      return ECMA_VALUE_ERROR;
        -: 1019:    }
        -: 1020:
    #####: 1021:    if (ecma_compare_ecma_strings_relational (lhs_str_p, rhs_str_p))
        -: 1022:    {
    #####: 1023:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1024:    }
    #####: 1025:    else if (!ecma_compare_ecma_strings (lhs_str_p, rhs_str_p))
        -: 1026:    {
    #####: 1027:      result = ECMA_NUMBER_ONE;
        -: 1028:    }
        -: 1029:    else
        -: 1030:    {
    #####: 1031:      result = ECMA_NUMBER_ZERO;
        -: 1032:    }
        -: 1033:
    #####: 1034:    ecma_deref_ecma_string (rhs_str_p);
    #####: 1035:    ecma_deref_ecma_string (lhs_str_p);
        -: 1036:  }
        -: 1037:  else
        -: 1038:  {
        -: 1039:    /*
        -: 1040:     * compare_func, if not undefined, will always contain a callable function object.
        -: 1041:     * We checked this previously, before this function was called.
        -: 1042:     */
    #####: 1043:    JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1044:    ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1045:
    #####: 1046:    ecma_value_t compare_args[] = { lhs, rhs };
        -: 1047:
    #####: 1048:    ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p, ECMA_VALUE_UNDEFINED, compare_args, 2);
    #####: 1049:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1050:    {
    #####: 1051:      return call_value;
        -: 1052:    }
        -: 1053:
    #####: 1054:    if (!ecma_is_value_number (call_value))
        -: 1055:    {
    #####: 1056:      ecma_number_t ret_num;
        -: 1057:
    #####: 1058:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (call_value, &ret_num)))
        -: 1059:      {
    #####: 1060:        ecma_free_value (call_value);
    #####: 1061:        return ECMA_VALUE_ERROR;
        -: 1062:      }
        -: 1063:
    #####: 1064:      result = ret_num;
        -: 1065:    }
        -: 1066:    else
        -: 1067:    {
    #####: 1068:      result = ecma_get_number_from_value (call_value);
        -: 1069:    }
        -: 1070:
    #####: 1071:    ecma_free_value (call_value);
        -: 1072:  }
        -: 1073:
    #####: 1074:  return ecma_make_number_value (result);
        -: 1075:} /* ecma_builtin_array_prototype_object_sort_compare_helper */
        -: 1076:
        -: 1077:/**
        -: 1078: * The Array.prototype object's 'sort' routine
        -: 1079: *
        -: 1080: * See also:
        -: 1081: *          ECMA-262 v5, 15.4.4.11
        -: 1082: *
        -: 1083: * @return ecma value
        -: 1084: *         Returned value must be freed with ecma_free_value.
        -: 1085: */
        -: 1086:static ecma_value_t
    #####: 1087:ecma_builtin_array_prototype_object_sort (ecma_value_t this_arg, /**< this argument */
        -: 1088:                                          ecma_value_t arg1, /**< comparefn */
        -: 1089:                                          ecma_object_t *obj_p) /**< object */
        -: 1090:{
        -: 1091:  /* Check if the provided compare function is callable. */
    #####: 1092:  if (!ecma_is_value_undefined (arg1) && !ecma_op_is_callable (arg1))
        -: 1093:  {
    #####: 1094:    return ecma_raise_type_error (ECMA_ERR_COMPARE_FUNC_NOT_CALLABLE);
        -: 1095:  }
        -: 1096:
    #####: 1097:  ecma_length_t len;
    #####: 1098:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &len);
        -: 1099:
    #####: 1100:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1101:  {
    #####: 1102:    return len_value;
        -: 1103:  }
    #####: 1104:  ecma_collection_t *array_index_props_p = ecma_new_collection ();
        -: 1105:
    #####: 1106:  for (uint32_t i = 0; i < len; i++)
        -: 1107:  {
    #####: 1108:    ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -: 1109:
    #####: 1110:    ecma_property_descriptor_t prop_desc;
    #####: 1111:    ecma_value_t get_desc = ecma_op_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 1112:
    #####: 1113:    if (ECMA_IS_VALUE_ERROR (get_desc))
        -: 1114:    {
    #####: 1115:      ecma_collection_free (array_index_props_p);
    #####: 1116:      ecma_deref_ecma_string (prop_name_p);
    #####: 1117:      return get_desc;
        -: 1118:    }
        -: 1119:
    #####: 1120:    if (ecma_is_value_true (get_desc))
        -: 1121:    {
    #####: 1122:      ecma_ref_ecma_string (prop_name_p);
    #####: 1123:      ecma_collection_push_back (array_index_props_p, ecma_make_string_value (prop_name_p));
    #####: 1124:      ecma_free_property_descriptor (&prop_desc);
    #####: 1125:      continue;
        -: 1126:    }
        -: 1127:  }
        -: 1128:
    #####: 1129:  uint32_t defined_prop_count = array_index_props_p->item_count;
        -: 1130:
    #####: 1131:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####: 1132:  uint32_t copied_num = 0;
    #####: 1133:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, defined_prop_count, ecma_value_t);
        -: 1134:
    #####: 1135:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1136:
        -: 1137:  /* Copy unsorted array into a native c array. */
    #####: 1138:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1139:  {
    #####: 1140:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1141:
    #####: 1142:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1143:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1144:
    #####: 1145:    if (index >= len)
        -: 1146:    {
    #####: 1147:      break;
        -: 1148:    }
        -: 1149:
    #####: 1150:    ecma_value_t index_value = ecma_op_object_get (obj_p, property_name_p);
        -: 1151:
    #####: 1152:    if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1153:    {
    #####: 1154:      goto clean_up;
        -: 1155:    }
        -: 1156:
    #####: 1157:    values_buffer[copied_num++] = index_value;
        -: 1158:  }
        -: 1159:
    #####: 1160:  JERRY_ASSERT (copied_num == defined_prop_count);
        -: 1161:
        -: 1162:  /* Sorting. */
    #####: 1163:  if (copied_num > 1)
        -: 1164:  {
    #####: 1165:    const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_array_prototype_object_sort_compare_helper;
    #####: 1166:    ecma_value_t sort_value =
        -: 1167:      ecma_builtin_helper_array_merge_sort_helper (values_buffer, (uint32_t) (copied_num), arg1, sort_cb, NULL);
    #####: 1168:    if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1169:    {
    #####: 1170:      goto clean_up;
        -: 1171:    }
        -: 1172:
    #####: 1173:    ecma_free_value (sort_value);
        -: 1174:  }
        -: 1175:
        -: 1176:  /* Put sorted values to the front of the array. */
    #####: 1177:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1178:  {
    #####: 1179:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, index, values_buffer[index], true);
        -: 1180:
    #####: 1181:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1182:    {
    #####: 1183:      goto clean_up;
        -: 1184:    }
        -: 1185:  }
        -: 1186:
    #####: 1187:  ret_value = ECMA_VALUE_EMPTY;
        -: 1188:
    #####: 1189:clean_up:
        -: 1190:  /* Free values that were copied to the local array. */
    #####: 1191:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1192:  {
    #####: 1193:    ecma_free_value (values_buffer[index]);
        -: 1194:  }
        -: 1195:
    #####: 1196:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1197:
    #####: 1198:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1199:  {
    #####: 1200:    ecma_collection_free (array_index_props_p);
    #####: 1201:    return ret_value;
        -: 1202:  }
        -: 1203:
    #####: 1204:  JERRY_ASSERT (ecma_is_value_empty (ret_value));
        -: 1205:
        -: 1206:  /* Undefined properties should be in the back of the array. */
    #####: 1207:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1208:
    #####: 1209:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1210:  {
    #####: 1211:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1212:
    #####: 1213:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1214:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1215:
    #####: 1216:    if (index >= copied_num && index < len)
        -: 1217:    {
    #####: 1218:      ecma_value_t del_value = ecma_op_object_delete (obj_p, property_name_p, true);
        -: 1219:
    #####: 1220:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1221:      {
    #####: 1222:        ecma_collection_free (array_index_props_p);
    #####: 1223:        return del_value;
        -: 1224:      }
        -: 1225:    }
        -: 1226:  }
        -: 1227:
    #####: 1228:  ecma_collection_free (array_index_props_p);
        -: 1229:
    #####: 1230:  return ecma_copy_value (this_arg);
        -: 1231:} /* ecma_builtin_array_prototype_object_sort */
        -: 1232:
        -: 1233:/**
        -: 1234: * The Array.prototype object's 'splice' routine
        -: 1235: *
        -: 1236: * See also:
        -: 1237: *          ECMA-262 v11, 22.1.3.28
        -: 1238: *          ECMA-262 v5, 15.4.4.12
        -: 1239: *
        -: 1240: * @return ecma value
        -: 1241: *         Returned value must be freed with ecma_free_value.
        -: 1242: */
        -: 1243:static ecma_value_t
    #####: 1244:ecma_builtin_array_prototype_object_splice (const ecma_value_t args[], /**< arguments list */
        -: 1245:                                            uint32_t args_number, /**< number of arguments */
        -: 1246:                                            ecma_object_t *obj_p, /**< object */
        -: 1247:                                            ecma_length_t len) /**< object's length */
        -: 1248:{
    #####: 1249:  ecma_length_t actual_start = 0;
    #####: 1250:  ecma_length_t actual_delete_count = 0;
    #####: 1251:  ecma_length_t insert_count = 0;
        -: 1252:
    #####: 1253:  if (args_number > 0)
        -: 1254:  {
        -: 1255:    /* ES5.1: 6, ES11: 4. */
    #####: 1256:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0], len, &actual_start)))
        -: 1257:    {
    #####: 1258:      return ECMA_VALUE_ERROR;
        -: 1259:    }
        -: 1260:
        -: 1261:    /* ES11: 6. */
    #####: 1262:    if (args_number == 1)
        -: 1263:    {
    #####: 1264:      actual_delete_count = len - actual_start;
        -: 1265:    }
        -: 1266:    /* ES11: 7. */
        -: 1267:    else
        -: 1268:    {
    #####: 1269:      insert_count = args_number - 2;
        -: 1270:
    #####: 1271:      ecma_number_t delete_num;
    #####: 1272:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &delete_num)))
        -: 1273:      {
    #####: 1274:        return ECMA_VALUE_ERROR;
        -: 1275:      }
        -: 1276:
        -: 1277:      /* ES5.1: 7 */
    #####: 1278:      actual_delete_count =
    #####: 1279:        (ecma_length_t) (JERRY_MIN (JERRY_MAX (delete_num, 0), (ecma_number_t) (len - actual_start)));
        -: 1280:    }
        -: 1281:  }
        -: 1282:
    #####: 1283:  ecma_length_t new_length = len + insert_count - actual_delete_count;
        -: 1284:
        -: 1285:#if JERRY_ESNEXT
        -: 1286:  /* ES11: 8. */
    #####: 1287:  if ((ecma_number_t) new_length > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1288:  {
    #####: 1289:    return ecma_raise_type_error (ECMA_ERR_INVALID_NEW_ARRAY_LENGTH);
        -: 1290:  }
        -: 1291:
        -: 1292:  /* ES11: 9. */
    #####: 1293:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, actual_delete_count);
        -: 1294:
    #####: 1295:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1296:  {
    #####: 1297:    return ECMA_VALUE_ERROR;
        -: 1298:  }
        -: 1299:#else /* !JERRY_ESNEXT */
        -: 1300:  /* ES5.1: 2. */
    #####: 1301:  ecma_object_t *new_array_p = ecma_op_new_array_object (actual_delete_count);
        -: 1302:#endif /* JERRY_ESNEXT */
        -: 1303:
        -: 1304:  /* ES5.1: 8, ES11: 10. */
    #####: 1305:  ecma_length_t k = 0;
        -: 1306:
        -: 1307:  /* ES5.1: 9, ES11: 11. */
    #####: 1308:  for (; k < actual_delete_count; k++)
        -: 1309:  {
    #####: 1310:    ecma_length_t from = actual_start + k;
    #####: 1311:    ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1312:
    #####: 1313:    if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1314:    {
    #####: 1315:      ecma_deref_object (new_array_p);
    #####: 1316:      return from_present;
        -: 1317:    }
        -: 1318:
    #####: 1319:    if (ecma_is_value_found (from_present))
        -: 1320:    {
        -: 1321:#if JERRY_ESNEXT
    #####: 1322:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 1323:#else /* !JERRY_ESNEXT */
    #####: 1324:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 1325:#endif /* JERRY_ESNEXT */
        -: 1326:
    #####: 1327:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p, k, from_present, prop_flags);
    #####: 1328:      ecma_free_value (from_present);
        -: 1329:
        -: 1330:#if JERRY_ESNEXT
    #####: 1331:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 1332:      {
    #####: 1333:        ecma_deref_object (new_array_p);
    #####: 1334:        return put_comp;
        -: 1335:      }
        -: 1336:#else /* !JERRY_ESNEXT */
        -: 1337:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 1338:#endif /* JERRY_ESNEXT */
        -: 1339:    }
        -: 1340:  }
        -: 1341:
        -: 1342:#if JERRY_ESNEXT
        -: 1343:  /* ES11: 12. */
    #####: 1344:  ecma_value_t set_length =
    #####: 1345:    ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) actual_delete_count));
        -: 1346:
    #####: 1347:  if (ECMA_IS_VALUE_ERROR (set_length))
        -: 1348:  {
    #####: 1349:    ecma_deref_object (new_array_p);
    #####: 1350:    return set_length;
        -: 1351:  }
        -: 1352:#endif /* JERRY_ESNEXT */
        -: 1353:
        -: 1354:  /* ES5.1: 12, ES11: 15. */
    #####: 1355:  if (insert_count < actual_delete_count)
        -: 1356:  {
    #####: 1357:    for (k = actual_start; k < len - actual_delete_count; k++)
        -: 1358:    {
    #####: 1359:      ecma_length_t from = k + actual_delete_count;
    #####: 1360:      ecma_length_t to = k + insert_count;
        -: 1361:
    #####: 1362:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1363:
    #####: 1364:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1365:      {
    #####: 1366:        ecma_deref_object (new_array_p);
    #####: 1367:        return from_present;
        -: 1368:      }
        -: 1369:
        -: 1370:      ecma_value_t operation_value;
        -: 1371:
    #####: 1372:      if (ecma_is_value_found (from_present))
        -: 1373:      {
    #####: 1374:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1375:        ecma_free_value (from_present);
        -: 1376:      }
        -: 1377:      else
        -: 1378:      {
    #####: 1379:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1380:      }
        -: 1381:
    #####: 1382:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1383:      {
    #####: 1384:        ecma_deref_object (new_array_p);
    #####: 1385:        return operation_value;
        -: 1386:      }
        -: 1387:    }
        -: 1388:
    #####: 1389:    k = len;
        -: 1390:
    #####: 1391:    for (k = len; k > new_length; k--)
        -: 1392:    {
    #####: 1393:      ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, k - 1, true);
        -: 1394:
    #####: 1395:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1396:      {
    #####: 1397:        ecma_deref_object (new_array_p);
    #####: 1398:        return del_value;
        -: 1399:      }
        -: 1400:    }
        -: 1401:  }
        -: 1402:  /* ES5.1: 13, ES11: 16. */
    #####: 1403:  else if (insert_count > actual_delete_count)
        -: 1404:  {
    #####: 1405:    for (k = len - actual_delete_count; k > actual_start; k--)
        -: 1406:    {
    #####: 1407:      ecma_length_t from = k + actual_delete_count - 1;
    #####: 1408:      ecma_length_t to = k + insert_count - 1;
        -: 1409:
    #####: 1410:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1411:
    #####: 1412:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1413:      {
    #####: 1414:        ecma_deref_object (new_array_p);
    #####: 1415:        return from_present;
        -: 1416:      }
        -: 1417:
        -: 1418:      ecma_value_t operation_value;
        -: 1419:
    #####: 1420:      if (ecma_is_value_found (from_present))
        -: 1421:      {
    #####: 1422:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1423:        ecma_free_value (from_present);
        -: 1424:      }
        -: 1425:      else
        -: 1426:      {
    #####: 1427:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1428:      }
        -: 1429:
    #####: 1430:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1431:      {
    #####: 1432:        ecma_deref_object (new_array_p);
    #####: 1433:        return operation_value;
        -: 1434:      }
        -: 1435:    }
        -: 1436:  }
        -: 1437:
        -: 1438:  /* ES5.1: 14, ES11: 17. */
    #####: 1439:  k = actual_start;
        -: 1440:
        -: 1441:  /* ES5.1: 15, ES11: 18. */
    #####: 1442:  uint32_t idx = 0;
    #####: 1443:  for (uint32_t arg_index = 2; arg_index < args_number; arg_index++, idx++)
        -: 1444:  {
    #####: 1445:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, actual_start + idx, args[arg_index], true);
        -: 1446:
    #####: 1447:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1448:    {
    #####: 1449:      ecma_deref_object (new_array_p);
    #####: 1450:      return put_value;
        -: 1451:    }
        -: 1452:  }
        -: 1453:
        -: 1454:  /* ES5.1: 16, ES11: 19. */
    #####: 1455:  ecma_value_t set_new_length = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) new_length));
        -: 1456:
    #####: 1457:  if (ECMA_IS_VALUE_ERROR (set_new_length))
        -: 1458:  {
    #####: 1459:    ecma_deref_object (new_array_p);
    #####: 1460:    return set_new_length;
        -: 1461:  }
        -: 1462:
        -: 1463:  /* ES5.1: 17, ES11: 20. */
    #####: 1464:  return ecma_make_object_value (new_array_p);
        -: 1465:} /* ecma_builtin_array_prototype_object_splice */
        -: 1466:
        -: 1467:/**
        -: 1468: * The Array.prototype object's 'unshift' routine
        -: 1469: *
        -: 1470: * See also:
        -: 1471: *          ECMA-262  v5, 15.4.4.13
        -: 1472: *          ECMA-262 v11, 22.1.3.31
        -: 1473: *
        -: 1474: * @return ecma value
        -: 1475: *         Returned value must be freed with ecma_free_value.
        -: 1476: */
        -: 1477:static ecma_value_t
    #####: 1478:ecma_builtin_array_prototype_object_unshift (const ecma_value_t args[], /**< arguments list */
        -: 1479:                                             uint32_t args_number, /**< number of arguments */
        -: 1480:                                             ecma_object_t *obj_p, /**< object */
        -: 1481:                                             ecma_length_t len) /**< object's length */
        -: 1482:{
    #####: 1483:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1484:  {
    #####: 1485:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1486:
    #####: 1487:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE && len != 0)
        -: 1488:    {
    #####: 1489:      if (args_number > UINT32_MAX - len)
        -: 1490:      {
    #####: 1491:        return ecma_raise_range_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
        -: 1492:      }
        -: 1493:
    #####: 1494:      if (args_number == 0)
        -: 1495:      {
    #####: 1496:        return ecma_make_uint32_value ((uint32_t) len);
        -: 1497:      }
        -: 1498:
    #####: 1499:      uint32_t new_length = ((uint32_t) len) + args_number;
    #####: 1500:      ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length);
    #####: 1501:      memmove (buffer_p + args_number, buffer_p, (size_t) (sizeof (ecma_value_t) * len));
        -: 1502:
    #####: 1503:      uint32_t index = 0;
        -: 1504:
    #####: 1505:      while (index < args_number)
        -: 1506:      {
    #####: 1507:        buffer_p[index] = ecma_copy_value_if_not_object (args[index]);
    #####: 1508:        index++;
        -: 1509:      }
        -: 1510:
    #####: 1511:      ext_obj_p->u.array.length_prop_and_hole_count -= args_number * ECMA_FAST_ARRAY_HOLE_ONE;
        -: 1512:
    #####: 1513:      return ecma_make_uint32_value (new_length);
        -: 1514:    }
        -: 1515:  }
        -: 1516:
        -: 1517:#if JERRY_ESNEXT
    #####: 1518:  const bool should_iterate = args_number > 0;
        -: 1519:#else /* !JERRY_ESNEXT */
        -: 1520:  const bool should_iterate = true;
        -: 1521:#endif /* JERRY_ESNEXT */
    #####: 1522:  if (should_iterate)
        -: 1523:  {
        -: 1524:#if JERRY_ESNEXT
        -: 1525:    /* ES11:4.a. */
    #####: 1526:    if ((ecma_number_t) (len + args_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1527:    {
    #####: 1528:      return ecma_raise_type_error (ECMA_ERR_UNSHIFT_TOO_HIGH);
        -: 1529:    }
        -: 1530:#endif /* JERRY_ESNEXT */
        -: 1531:
        -: 1532:    /* ES5.1:5.,6. ES11: 4.b, 4.c */
    #####: 1533:    for (ecma_length_t k = len; k > 0; k--)
        -: 1534:    {
        -: 1535:      /* ES5.1:6.a, 6.c, ES11:4.c.i., 4.c.iii.  */
    #####: 1536:      ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k - 1);
        -: 1537:
    #####: 1538:      if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1539:      {
    #####: 1540:        return get_value;
        -: 1541:      }
        -: 1542:
        -: 1543:      /* ES5.1:6.b, ES11:4.c.ii. */
    #####: 1544:      ecma_number_t new_idx = ((ecma_number_t) k) + ((ecma_number_t) args_number) - 1;
    #####: 1545:      ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (new_idx);
        -: 1546:      ecma_value_t operation_value;
        -: 1547:
    #####: 1548:      if (ecma_is_value_found (get_value))
        -: 1549:      {
        -: 1550:        /* ES5.1:6.d.i, 6.d.ii, ES11:4.c.iv. */
    #####: 1551:        operation_value = ecma_op_object_put (obj_p, index_str_p, get_value, true);
    #####: 1552:        ecma_free_value (get_value);
        -: 1553:      }
        -: 1554:      else
        -: 1555:      {
        -: 1556:        /* ES5.1:6.e.i, ES11:4.c.v. */
    #####: 1557:        operation_value = ecma_op_object_delete (obj_p, index_str_p, true);
        -: 1558:      }
        -: 1559:
    #####: 1560:      ecma_deref_ecma_string (index_str_p);
        -: 1561:
    #####: 1562:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1563:      {
    #####: 1564:        return operation_value;
        -: 1565:      }
        -: 1566:    }
        -: 1567:
    #####: 1568:    for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -: 1569:    {
        -: 1570:      /* ES5.1:9.b, ES11:4.f.ii.  */
    #####: 1571:      ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, arg_index, args[arg_index], true);
        -: 1572:
    #####: 1573:      if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1574:      {
    #####: 1575:        return put_value;
        -: 1576:      }
        -: 1577:    }
        -: 1578:  }
        -: 1579:
        -: 1580:  /* ES5.1:10., ES11:5. */
    #####: 1581:  ecma_number_t new_len = ((ecma_number_t) len) + ((ecma_number_t) args_number);
    #####: 1582:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, new_len);
        -: 1583:
    #####: 1584:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -: 1585:  {
    #####: 1586:    return set_length_value;
        -: 1587:  }
        -: 1588:
    #####: 1589:  return ecma_make_number_value (new_len);
        -: 1590:} /* ecma_builtin_array_prototype_object_unshift */
        -: 1591:
        -: 1592:/**
        -: 1593: * The Array.prototype object's 'at' routine
        -: 1594: *
        -: 1595: * See also:
        -: 1596: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -: 1597: *          from: https://tc39.es/proposal-relative-indexing-method
        -: 1598: *
        -: 1599: * @return ecma value
        -: 1600: *         Returned value must be freed with ecma_free_value.
        -: 1601: */
        -: 1602:static ecma_value_t
    #####: 1603:ecma_builtin_array_prototype_object_at (const ecma_value_t index, /**< index argument */
        -: 1604:                                        ecma_object_t *obj_p, /**< object */
        -: 1605:                                        ecma_length_t len) /**< object's length */
        -: 1606:{
    #####: 1607:  ecma_length_t res_index;
    #####: 1608:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -: 1609:
    #####: 1610:  if (return_value != ECMA_VALUE_EMPTY)
        -: 1611:  {
    #####: 1612:    return return_value;
        -: 1613:  }
        -: 1614:
    #####: 1615:  return ecma_op_object_get_by_index (obj_p, res_index);
        -: 1616:} /* ecma_builtin_array_prototype_object_at */
        -: 1617:
        -: 1618:/**
        -: 1619: * The Array.prototype object's 'indexOf' routine
        -: 1620: *
        -: 1621: * See also:
        -: 1622: *          ECMA-262 v5, 15.4.4.14
        -: 1623: *
        -: 1624: * @return ecma value
        -: 1625: *         Returned value must be freed with ecma_free_value.
        -: 1626: */
        -: 1627:static ecma_value_t
    #####: 1628:ecma_builtin_array_prototype_object_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1629:                                              uint32_t args_number, /**< number of arguments */
        -: 1630:                                              ecma_object_t *obj_p, /**< object */
        -: 1631:                                              ecma_length_t len) /**< object's length */
        -: 1632:{
        -: 1633:  /* 4. */
    #####: 1634:  if (len == 0)
        -: 1635:  {
    #####: 1636:    return ecma_make_integer_value (-1);
        -: 1637:  }
        -: 1638:
        -: 1639:  /* 5. */
    #####: 1640:  ecma_number_t idx = 0;
    #####: 1641:  if (args_number > 1)
        -: 1642:  {
    #####: 1643:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1644:    {
    #####: 1645:      return ECMA_VALUE_ERROR;
        -: 1646:    }
        -: 1647:  }
        -: 1648:
        -: 1649:  /* 6. */
    #####: 1650:  if (idx >= (ecma_number_t) len)
        -: 1651:  {
    #####: 1652:    return ecma_make_number_value (-1);
        -: 1653:  }
        -: 1654:
        -: 1655:  /* 7. */
    #####: 1656:  ecma_length_t from_idx = (ecma_length_t) idx;
        -: 1657:
        -: 1658:  /* 8. */
    #####: 1659:  if (idx < 0)
        -: 1660:  {
    #####: 1661:    from_idx = (ecma_length_t) JERRY_MAX ((ecma_number_t) len + idx, 0);
        -: 1662:  }
        -: 1663:
    #####: 1664:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1665:  {
    #####: 1666:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1667:
    #####: 1668:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1669:    {
    #####: 1670:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1671:      {
    #####: 1672:        return ecma_make_integer_value (-1);
        -: 1673:      }
        -: 1674:
    #####: 1675:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1676:
    #####: 1677:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1678:
    #####: 1679:      while (from_idx < len)
        -: 1680:      {
    #####: 1681:        if (ecma_op_strict_equality_compare (args[0], buffer_p[from_idx]))
        -: 1682:        {
    #####: 1683:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1684:        }
        -: 1685:
    #####: 1686:        from_idx++;
        -: 1687:      }
        -: 1688:
    #####: 1689:      return ecma_make_integer_value (-1);
        -: 1690:    }
        -: 1691:  }
        -: 1692:
        -: 1693:  /* 6. */
    #####: 1694:  while (from_idx < len)
        -: 1695:  {
        -: 1696:    /* 9.a */
    #####: 1697:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1698:
    #####: 1699:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1700:    {
    #####: 1701:      return get_value;
        -: 1702:    }
        -: 1703:
        -: 1704:    /* 9.b.i, 9.b.ii */
    #####: 1705:    if (ecma_is_value_found (get_value) && ecma_op_strict_equality_compare (args[0], get_value))
        -: 1706:    {
    #####: 1707:      ecma_free_value (get_value);
    #####: 1708:      return ecma_make_length_value (from_idx);
        -: 1709:    }
        -: 1710:
    #####: 1711:    from_idx++;
        -: 1712:
    #####: 1713:    ecma_free_value (get_value);
        -: 1714:  }
        -: 1715:
    #####: 1716:  return ecma_make_integer_value (-1);
        -: 1717:} /* ecma_builtin_array_prototype_object_index_of */
        -: 1718:
        -: 1719:/**
        -: 1720: * The Array.prototype object's 'lastIndexOf' routine
        -: 1721: *
        -: 1722: * See also:
        -: 1723: *          ECMA-262 v5, 15.4.4.15
        -: 1724: *
        -: 1725: * @return ecma value
        -: 1726: *         Returned value must be freed with ecma_free_value.
        -: 1727: */
        -: 1728:static ecma_value_t
    #####: 1729:ecma_builtin_array_prototype_object_last_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1730:                                                   uint32_t args_number, /**< number of arguments */
        -: 1731:                                                   ecma_object_t *obj_p, /**< object */
        -: 1732:                                                   ecma_length_t len) /**< object's length */
        -: 1733:{
        -: 1734:  /* 4. */
    #####: 1735:  if (len == 0)
        -: 1736:  {
    #####: 1737:    return ecma_make_integer_value (-1);
        -: 1738:  }
        -: 1739:
        -: 1740:  /* 5. */
    #####: 1741:  ecma_number_t idx = (ecma_number_t) len - 1;
    #####: 1742:  if (args_number > 1)
        -: 1743:  {
    #####: 1744:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1745:    {
    #####: 1746:      return ECMA_VALUE_ERROR;
        -: 1747:    }
        -: 1748:  }
        -: 1749:
        -: 1750:  ecma_length_t from_idx;
        -: 1751:
        -: 1752:  /* 6 */
    #####: 1753:  if (idx >= 0)
        -: 1754:  {
    #####: 1755:    from_idx = (ecma_length_t) (JERRY_MIN (idx, (ecma_number_t) (len - 1)));
        -: 1756:  }
        -: 1757:  else
        -: 1758:  {
    #####: 1759:    ecma_number_t k = (ecma_number_t) len + idx;
    #####: 1760:    if (k < 0)
        -: 1761:    {
    #####: 1762:      return ecma_make_integer_value (-1);
        -: 1763:    }
    #####: 1764:    from_idx = (ecma_length_t) k;
        -: 1765:  }
        -: 1766:
    #####: 1767:  ecma_value_t search_element = (args_number > 0) ? args[0] : ECMA_VALUE_UNDEFINED;
        -: 1768:
    #####: 1769:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1770:  {
    #####: 1771:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1772:
    #####: 1773:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1774:    {
    #####: 1775:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1776:      {
    #####: 1777:        return ecma_make_integer_value (-1);
        -: 1778:      }
        -: 1779:
    #####: 1780:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1781:
    #####: 1782:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1783:
    #####: 1784:      while (from_idx < len)
        -: 1785:      {
    #####: 1786:        if (ecma_op_strict_equality_compare (search_element, buffer_p[from_idx]))
        -: 1787:        {
    #####: 1788:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1789:        }
    #####: 1790:        from_idx--;
        -: 1791:      }
    #####: 1792:      return ecma_make_integer_value (-1);
        -: 1793:    }
        -: 1794:  }
        -: 1795:
        -: 1796:  /* 8. */
    #####: 1797:  while (from_idx < len)
        -: 1798:  {
        -: 1799:    /* 8.a */
    #####: 1800:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1801:
    #####: 1802:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1803:    {
    #####: 1804:      return get_value;
        -: 1805:    }
        -: 1806:
        -: 1807:    /* 8.b.i, 8.b.ii */
    #####: 1808:    if (ecma_is_value_found (get_value) && ecma_op_strict_equality_compare (search_element, get_value))
        -: 1809:    {
    #####: 1810:      ecma_free_value (get_value);
    #####: 1811:      return ecma_make_length_value (from_idx);
        -: 1812:    }
        -: 1813:
    #####: 1814:    from_idx--;
        -: 1815:
    #####: 1816:    ecma_free_value (get_value);
        -: 1817:  }
        -: 1818:
    #####: 1819:  return ecma_make_integer_value (-1);
        -: 1820:} /* ecma_builtin_array_prototype_object_last_index_of */
        -: 1821:
        -: 1822:/**
        -: 1823: * Type of array routine.
        -: 1824: */
        -: 1825:typedef enum
        -: 1826:{
        -: 1827:  ARRAY_ROUTINE_EVERY, /**< Array.every: ECMA-262 v5, 15.4.4.16 */
        -: 1828:  ARRAY_ROUTINE_SOME, /**< Array.some: ECMA-262 v5, 15.4.4.17 */
        -: 1829:  ARRAY_ROUTINE_FOREACH, /**< Array.forEach: ECMA-262 v5, 15.4.4.18 */
        -: 1830:  ARRAY_ROUTINE__COUNT /**< count of the modes */
        -: 1831:} array_routine_mode;
        -: 1832:
        -: 1833:/**
        -: 1834: * Applies the provided function to each element of the array as long as
        -: 1835: * the return value stays empty. The common function for 'every', 'some'
        -: 1836: * and 'forEach' of the Array prototype.
        -: 1837: *
        -: 1838: * See also:
        -: 1839: *          ECMA-262 v5, 15.4.4.16
        -: 1840: *          ECMA-262 v5, 15.4.4.17
        -: 1841: *          ECMA-262 v5, 15.4.4.18
        -: 1842: *
        -: 1843: * @return ecma value
        -: 1844: *         Returned value must be freed with ecma_free_value.
        -: 1845: */
        -: 1846:static ecma_value_t
    #####: 1847:ecma_builtin_array_apply (ecma_value_t arg1, /**< callbackfn */
        -: 1848:                          ecma_value_t arg2, /**< thisArg */
        -: 1849:                          array_routine_mode mode, /**< array routine mode */
        -: 1850:                          ecma_object_t *obj_p, /**< object */
        -: 1851:                          ecma_length_t len) /**< object's length */
        -: 1852:
        -: 1853:{
    #####: 1854:  JERRY_ASSERT (mode < ARRAY_ROUTINE__COUNT);
        -: 1855:
        -: 1856:  /* 4. */
    #####: 1857:  if (!ecma_op_is_callable (arg1))
        -: 1858:  {
    #####: 1859:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 1860:  }
        -: 1861:
        -: 1862:  /* We already checked that arg1 is callable */
    #####: 1863:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1864:  ecma_value_t current_index;
        -: 1865:
        -: 1866:  /* 7. */
    #####: 1867:  for (ecma_length_t index = 0; index < len; index++)
        -: 1868:  {
        -: 1869:    /* 7.a - 7.c */
    #####: 1870:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1871:
    #####: 1872:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1873:    {
    #####: 1874:      return get_value;
        -: 1875:    }
        -: 1876:
    #####: 1877:    if (ecma_is_value_found (get_value))
        -: 1878:    {
        -: 1879:      /* 7.c.i */
    #####: 1880:      current_index = ecma_make_length_value (index);
        -: 1881:
    #####: 1882:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 1883:      /* 7.c.ii */
    #####: 1884:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 1885:
    #####: 1886:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1887:      {
    #####: 1888:        ecma_free_value (get_value);
    #####: 1889:        return call_value;
        -: 1890:      }
        -: 1891:
    #####: 1892:      bool to_boolean = ecma_op_to_boolean (call_value);
        -: 1893:
    #####: 1894:      ecma_free_value (call_value);
    #####: 1895:      ecma_free_value (get_value);
        -: 1896:
        -: 1897:      /* 7.c.iii */
    #####: 1898:      if (mode == ARRAY_ROUTINE_EVERY && !to_boolean)
        -: 1899:      {
    #####: 1900:        return ECMA_VALUE_FALSE;
        -: 1901:      }
    #####: 1902:      else if (mode == ARRAY_ROUTINE_SOME && to_boolean)
        -: 1903:      {
    #####: 1904:        return ECMA_VALUE_TRUE;
        -: 1905:      }
        -: 1906:    }
        -: 1907:  }
        -: 1908:
        -: 1909:  /* 8. */
        -: 1910:
    #####: 1911:  if (mode == ARRAY_ROUTINE_EVERY)
        -: 1912:  {
    #####: 1913:    return ECMA_VALUE_TRUE;
        -: 1914:  }
    #####: 1915:  else if (mode == ARRAY_ROUTINE_SOME)
        -: 1916:  {
    #####: 1917:    return ECMA_VALUE_FALSE;
        -: 1918:  }
        -: 1919:
    #####: 1920:  JERRY_ASSERT (mode == ARRAY_ROUTINE_FOREACH);
    #####: 1921:  return ECMA_VALUE_UNDEFINED;
        -: 1922:} /* ecma_builtin_array_apply */
        -: 1923:
        -: 1924:/**
        -: 1925: * The Array.prototype object's 'map' routine
        -: 1926: *
        -: 1927: * See also:
        -: 1928: *          ECMA-262 v5, 15.4.4.19
        -: 1929: *
        -: 1930: * @return ecma value
        -: 1931: *         Returned value must be freed with ecma_free_value.
        -: 1932: */
        -: 1933:static ecma_value_t
    #####: 1934:ecma_builtin_array_prototype_object_map (ecma_value_t arg1, /**< callbackfn */
        -: 1935:                                         ecma_value_t arg2, /**< thisArg */
        -: 1936:                                         ecma_object_t *obj_p, /**< object */
        -: 1937:                                         ecma_length_t len) /**< object's length */
        -: 1938:{
        -: 1939:  /* 4. */
    #####: 1940:  if (!ecma_op_is_callable (arg1))
        -: 1941:  {
    #####: 1942:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 1943:  }
        -: 1944:
        -: 1945:  /* 6. */
        -: 1946:#if JERRY_ESNEXT
    #####: 1947:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, len);
        -: 1948:
    #####: 1949:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1950:  {
    #####: 1951:    return ECMA_VALUE_ERROR;
        -: 1952:  }
        -: 1953:#else /* !JERRY_ESNEXT */
    #####: 1954:  ecma_object_t *new_array_p = ecma_op_new_array_object (len);
        -: 1955:#endif /* JERRY_ESNEXT */
        -: 1956:
    #####: 1957:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 1958:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1959:
        -: 1960:  /* 7-8. */
        -: 1961:  ecma_value_t current_index;
        -: 1962:
    #####: 1963:  for (ecma_length_t index = 0; index < len; index++)
        -: 1964:  {
        -: 1965:    /* 8.a - 8.b */
    #####: 1966:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1967:
    #####: 1968:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 1969:    {
    #####: 1970:      ecma_deref_object (new_array_p);
    #####: 1971:      return current_value;
        -: 1972:    }
        -: 1973:
    #####: 1974:    if (ecma_is_value_found (current_value))
        -: 1975:    {
        -: 1976:      /* 8.c.i, 8.c.ii */
    #####: 1977:      current_index = ecma_make_length_value (index);
    #####: 1978:      ecma_value_t call_args[] = { current_value, current_index, ecma_make_object_value (obj_p) };
        -: 1979:
    #####: 1980:      ecma_value_t mapped_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 1981:
    #####: 1982:      if (ECMA_IS_VALUE_ERROR (mapped_value))
        -: 1983:      {
    #####: 1984:        ecma_free_value (current_value);
    #####: 1985:        ecma_deref_object (new_array_p);
    #####: 1986:        return mapped_value;
        -: 1987:      }
        -: 1988:
        -: 1989:      /* 8.c.iii */
        -: 1990:      ecma_value_t put_comp;
        -: 1991:#if JERRY_ESNEXT
    #####: 1992:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 1993:#else /* !JERRY_ESNEXT */
    #####: 1994:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 1995:#endif /* JERRY_ESNEXT */
    #####: 1996:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p, index, mapped_value, prop_flags);
        -: 1997:
    #####: 1998:      ecma_free_value (mapped_value);
    #####: 1999:      ecma_free_value (current_value);
        -: 2000:#if JERRY_ESNEXT
    #####: 2001:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2002:      {
    #####: 2003:        ecma_deref_object (new_array_p);
    #####: 2004:        return put_comp;
        -: 2005:      }
        -: 2006:#else /* !JERRY_ESNEXT */
        -: 2007:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2008:#endif /* JERRY_ESNEXT */
        -: 2009:    }
        -: 2010:  }
        -: 2011:
    #####: 2012:  return ecma_make_object_value (new_array_p);
        -: 2013:} /* ecma_builtin_array_prototype_object_map */
        -: 2014:
        -: 2015:/**
        -: 2016: * The Array.prototype object's 'filter' routine
        -: 2017: *
        -: 2018: * See also:
        -: 2019: *          ECMA-262 v5, 15.4.4.20
        -: 2020: *
        -: 2021: * @return ecma value
        -: 2022: *         Returned value must be freed with ecma_free_value.
        -: 2023: */
        -: 2024:static ecma_value_t
    #####: 2025:ecma_builtin_array_prototype_object_filter (ecma_value_t arg1, /**< callbackfn */
        -: 2026:                                            ecma_value_t arg2, /**< thisArg */
        -: 2027:                                            ecma_object_t *obj_p, /**< object */
        -: 2028:                                            ecma_length_t len) /**< object's length */
        -: 2029:{
        -: 2030:  /* 4. */
    #####: 2031:  if (!ecma_op_is_callable (arg1))
        -: 2032:  {
    #####: 2033:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 2034:  }
        -: 2035:
        -: 2036:  /* 6. */
        -: 2037:#if JERRY_ESNEXT
    #####: 2038:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2039:
    #####: 2040:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2041:  {
    #####: 2042:    return ECMA_VALUE_ERROR;
        -: 2043:  }
        -: 2044:
        -: 2045:  /* ES11: 22.1.3.7. 7.c.iii.1 */
    #####: 2046:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 2047:#else /* !JERRY_ESNEXT */
    #####: 2048:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -: 2049:
        -: 2050:  /* ES5.1: 15.4.4.20. 9.c.iii.1 */
    #####: 2051:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 2052:#endif /* JERRY_ESNEXT */
        -: 2053:
        -: 2054:  /* We already checked that arg1 is callable, so it will always be an object. */
    #####: 2055:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 2056:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 2057:
        -: 2058:  /* 8. */
    #####: 2059:  ecma_length_t new_array_index = 0;
        -: 2060:  ecma_value_t current_index;
        -: 2061:
        -: 2062:  /* 9. */
    #####: 2063:  for (ecma_length_t index = 0; index < len; index++)
        -: 2064:  {
        -: 2065:    /* 9.a - 9.c */
    #####: 2066:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 2067:
    #####: 2068:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2069:    {
    #####: 2070:      ecma_deref_object (new_array_p);
    #####: 2071:      return get_value;
        -: 2072:    }
        -: 2073:
    #####: 2074:    if (ecma_is_value_found (get_value))
        -: 2075:    {
        -: 2076:      /* 9.c.i */
    #####: 2077:      current_index = ecma_make_length_value (index);
        -: 2078:
    #####: 2079:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2080:      /* 9.c.ii */
    #####: 2081:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2082:
    #####: 2083:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2084:      {
    #####: 2085:        ecma_free_value (get_value);
    #####: 2086:        ecma_deref_object (new_array_p);
    #####: 2087:        return call_value;
        -: 2088:      }
        -: 2089:
        -: 2090:      /* 9.c.iii */
    #####: 2091:      if (ecma_op_to_boolean (call_value))
        -: 2092:      {
        -: 2093:        ecma_value_t put_comp;
    #####: 2094:        put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p, new_array_index, get_value, prop_flags);
        -: 2095:#if JERRY_ESNEXT
    #####: 2096:        if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2097:        {
    #####: 2098:          ecma_free_value (call_value);
    #####: 2099:          ecma_free_value (get_value);
    #####: 2100:          ecma_deref_object (new_array_p);
        -: 2101:
    #####: 2102:          return put_comp;
        -: 2103:        }
        -: 2104:#else /* !JERRY_ESNEXT */
        -: 2105:        JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2106:#endif /* JERRY_ESNEXT */
    #####: 2107:        new_array_index++;
        -: 2108:      }
        -: 2109:
    #####: 2110:      ecma_free_value (call_value);
    #####: 2111:      ecma_free_value (get_value);
        -: 2112:    }
        -: 2113:  }
        -: 2114:
    #####: 2115:  return ecma_make_object_value (new_array_p);
        -: 2116:} /* ecma_builtin_array_prototype_object_filter */
        -: 2117:
        -: 2118:/**
        -: 2119: * The Array.prototype object's 'reduce' and 'reduceRight' routine
        -: 2120: *
        -: 2121: * See also:
        -: 2122: *         ECMA-262 v5, 15.4.4.21
        -: 2123: *         ECMA-262 v5, 15.4.4.22
        -: 2124: *
        -: 2125: * @return ecma value
        -: 2126: *         Returned value must be freed with ecma_free_value.
        -: 2127: */
        -: 2128:static ecma_value_t
    #####: 2129:ecma_builtin_array_reduce_from (const ecma_value_t args_p[], /**< routine's arguments */
        -: 2130:                                uint32_t args_number, /**< arguments list length */
        -: 2131:                                bool start_from_left, /**< whether the reduce starts from left or right */
        -: 2132:                                ecma_object_t *obj_p, /**< object */
        -: 2133:                                ecma_length_t len) /**< object's length */
        -: 2134:{
        -: 2135:  /* 4. */
    #####: 2136:  if (!ecma_op_is_callable (args_p[0]))
        -: 2137:  {
    #####: 2138:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 2139:  }
        -: 2140:
        -: 2141:  /* 5. */
    #####: 2142:  if (len == 0 && args_number == 1)
        -: 2143:  {
    #####: 2144:    return ecma_raise_type_error (ECMA_ERR_REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);
        -: 2145:  }
        -: 2146:
    #####: 2147:  JERRY_ASSERT (ecma_is_value_object (args_p[0]));
    #####: 2148:  ecma_object_t *func_object_p = ecma_get_object_from_value (args_p[0]);
        -: 2149:
    #####: 2150:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
        -: 2151:
        -: 2152:  /* 6. */
    #####: 2153:  ecma_length_t index = 0;
    #####: 2154:  const ecma_length_t last_index = len - 1;
        -: 2155:
        -: 2156:  /* 7.a */
    #####: 2157:  if (args_number > 1)
        -: 2158:  {
    #####: 2159:    accumulator = ecma_copy_value (args_p[1]);
        -: 2160:  }
        -: 2161:  else
        -: 2162:  {
        -: 2163:    /* 8.a */
    #####: 2164:    bool k_present = false;
        -: 2165:
        -: 2166:    /* 8.b */
    #####: 2167:    while (!k_present && index < len)
        -: 2168:    {
        -: 2169:      /* 8.b.i */
    #####: 2170:      k_present = true;
        -: 2171:
        -: 2172:      /* 8.b.ii-iii */
    #####: 2173:      ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, start_from_left ? index : last_index - index);
        -: 2174:
    #####: 2175:      if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2176:      {
    #####: 2177:        return current_value;
        -: 2178:      }
        -: 2179:
    #####: 2180:      if (ecma_is_value_found (current_value))
        -: 2181:      {
    #####: 2182:        accumulator = current_value;
        -: 2183:      }
        -: 2184:      else
        -: 2185:      {
    #####: 2186:        k_present = false;
        -: 2187:      }
        -: 2188:
        -: 2189:      /* 8.b.iv */
    #####: 2190:      index++;
        -: 2191:    }
        -: 2192:
        -: 2193:    /* 8.c */
    #####: 2194:    if (!k_present)
        -: 2195:    {
    #####: 2196:      return ecma_raise_type_error (ECMA_ERR_MISSING_ARRAY_ELEMENT);
        -: 2197:    }
        -: 2198:  }
        -: 2199:  /* 9. */
        -: 2200:  ecma_value_t current_index;
        -: 2201:
    #####: 2202:  for (; index < len; index++)
        -: 2203:  {
    #####: 2204:    const ecma_length_t corrected_index = start_from_left ? index : last_index - index;
        -: 2205:
        -: 2206:    /* 9.a - 9.b */
    #####: 2207:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, corrected_index);
        -: 2208:
    #####: 2209:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2210:    {
    #####: 2211:      ecma_free_value (accumulator);
    #####: 2212:      return current_value;
        -: 2213:    }
        -: 2214:
    #####: 2215:    if (ecma_is_value_found (current_value))
        -: 2216:    {
        -: 2217:      /* 9.c.i, 9.c.ii */
    #####: 2218:      current_index = ecma_make_length_value (corrected_index);
    #####: 2219:      ecma_value_t call_args[] = { accumulator, current_value, current_index, ecma_make_object_value (obj_p) };
        -: 2220:
    #####: 2221:      ecma_value_t call_value = ecma_op_function_call (func_object_p, ECMA_VALUE_UNDEFINED, call_args, 4);
    #####: 2222:      ecma_free_value (current_index);
    #####: 2223:      ecma_free_value (accumulator);
    #####: 2224:      ecma_free_value (current_value);
        -: 2225:
    #####: 2226:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2227:      {
    #####: 2228:        return call_value;
        -: 2229:      }
        -: 2230:
    #####: 2231:      accumulator = call_value;
        -: 2232:    }
        -: 2233:  }
        -: 2234:
    #####: 2235:  return accumulator;
        -: 2236:} /* ecma_builtin_array_reduce_from */
        -: 2237:
        -: 2238:#if JERRY_ESNEXT
        -: 2239:
        -: 2240:/**
        -: 2241: * The Array.prototype object's 'fill' routine
        -: 2242: *
        -: 2243: * Note: this method only supports length up to uint32, instead of max_safe_integer
        -: 2244: *
        -: 2245: * See also:
        -: 2246: *          ECMA-262 v6, 22.1.3.6
        -: 2247: *
        -: 2248: * @return ecma value
        -: 2249: *         Returned value must be freed with ecma_free_value.
        -: 2250: */
        -: 2251:static ecma_value_t
    #####: 2252:ecma_builtin_array_prototype_fill (ecma_value_t value, /**< value */
        -: 2253:                                   ecma_value_t start_val, /**< start value */
        -: 2254:                                   ecma_value_t end_val, /**< end value */
        -: 2255:                                   ecma_object_t *obj_p, /**< object */
        -: 2256:                                   ecma_length_t len) /**< object's length */
        -: 2257:{
    #####: 2258:  ecma_length_t k, final;
        -: 2259:
        -: 2260:  /* 5. 6. 7. */
    #####: 2261:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (start_val, len, &k)))
        -: 2262:  {
    #####: 2263:    return ECMA_VALUE_ERROR;
        -: 2264:  }
        -: 2265:
        -: 2266:  /* 8. */
    #####: 2267:  if (ecma_is_value_undefined (end_val))
        -: 2268:  {
    #####: 2269:    final = len;
        -: 2270:  }
        -: 2271:  else
        -: 2272:  {
        -: 2273:    /* 8 part 2, 9, 10 */
    #####: 2274:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (end_val, len, &final)))
        -: 2275:    {
    #####: 2276:      return ECMA_VALUE_ERROR;
        -: 2277:    }
        -: 2278:  }
        -: 2279:
    #####: 2280:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2281:  {
    #####: 2282:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2283:
    #####: 2284:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2285:    {
    #####: 2286:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 2287:      {
    #####: 2288:        ecma_ref_object (obj_p);
    #####: 2289:        return ecma_make_object_value (obj_p);
        -: 2290:      }
        -: 2291:
    #####: 2292:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2293:
    #####: 2294:      while (k < final)
        -: 2295:      {
    #####: 2296:        ecma_free_value_if_not_object (buffer_p[k]);
    #####: 2297:        buffer_p[k] = ecma_copy_value_if_not_object (value);
    #####: 2298:        k++;
        -: 2299:      }
        -: 2300:
    #####: 2301:      ecma_ref_object (obj_p);
    #####: 2302:      return ecma_make_object_value (obj_p);
        -: 2303:    }
        -: 2304:  }
        -: 2305:
        -: 2306:  /* 11. */
    #####: 2307:  while (k < final)
        -: 2308:  {
        -: 2309:    /* 11.a - 11.b */
    #####: 2310:    ecma_value_t put_val = ecma_op_object_put_by_index (obj_p, k, value, true);
        -: 2311:
        -: 2312:    /* 11. c */
    #####: 2313:    if (ECMA_IS_VALUE_ERROR (put_val))
        -: 2314:    {
    #####: 2315:      return put_val;
        -: 2316:    }
        -: 2317:
        -: 2318:    /* 11.d */
    #####: 2319:    k++;
        -: 2320:  }
        -: 2321:
    #####: 2322:  ecma_ref_object (obj_p);
    #####: 2323:  return ecma_make_object_value (obj_p);
        -: 2324:} /* ecma_builtin_array_prototype_fill */
        -: 2325:
        -: 2326:/**
        -: 2327: * The Array.prototype object's 'find' and 'findIndex' routine
        -: 2328: *
        -: 2329: * See also:
        -: 2330: *          ECMA-262 v6, 22.1.3.8
        -: 2331: *          ECMA-262 v6, 22.1.3.9
        -: 2332: *
        -: 2333: * @return ecma value
        -: 2334: *         Returned value must be freed with ecma_free_value.
        -: 2335: */
        -: 2336:static ecma_value_t
    #####: 2337:ecma_builtin_array_prototype_object_find (ecma_value_t predicate, /**< callback function */
        -: 2338:                                          ecma_value_t predicate_this_arg, /**< this argument for
        -: 2339:                                                                            *   invoke predicate */
        -: 2340:                                          bool is_find, /**< true - find routine
        -: 2341:                                                         *   false - findIndex routine */
        -: 2342:                                          ecma_object_t *obj_p, /**< object */
        -: 2343:                                          ecma_length_t len) /**< object's length */
        -: 2344:{
        -: 2345:  /* 5. */
    #####: 2346:  if (!ecma_op_is_callable (predicate))
        -: 2347:  {
    #####: 2348:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 2349:  }
        -: 2350:
        -: 2351:  /* We already checked that predicate is callable, so it will always be an object. */
    #####: 2352:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 2353:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
        -: 2354:
        -: 2355:  /* 7 - 8. */
    #####: 2356:  for (ecma_length_t index = 0; index < len; index++)
        -: 2357:  {
        -: 2358:    /* 8.a - 8.c */
    #####: 2359:    ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, index);
        -: 2360:
    #####: 2361:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2362:    {
    #####: 2363:      return get_value;
        -: 2364:    }
        -: 2365:
        -: 2366:    /* 8.d - 8.e */
    #####: 2367:    ecma_value_t current_index = ecma_make_length_value (index);
        -: 2368:
    #####: 2369:    ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2370:
    #####: 2371:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 2372:
    #####: 2373:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2374:    {
    #####: 2375:      ecma_free_value (get_value);
    #####: 2376:      return call_value;
        -: 2377:    }
        -: 2378:
    #####: 2379:    bool call_value_to_bool = ecma_op_to_boolean (call_value);
        -: 2380:
    #####: 2381:    ecma_free_value (call_value);
        -: 2382:
    #####: 2383:    if (call_value_to_bool)
        -: 2384:    {
        -: 2385:      /* 8.f */
    #####: 2386:      if (is_find)
        -: 2387:      {
    #####: 2388:        ecma_free_value (current_index);
    #####: 2389:        return get_value;
        -: 2390:      }
        -: 2391:
    #####: 2392:      ecma_free_value (get_value);
    #####: 2393:      return current_index;
        -: 2394:    }
        -: 2395:
    #####: 2396:    ecma_free_value (get_value);
    #####: 2397:    ecma_free_value (current_index);
        -: 2398:  }
        -: 2399:
        -: 2400:  /* 9. */
    #####: 2401:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 2402:} /* ecma_builtin_array_prototype_object_find */
        -: 2403:
        -: 2404:/**
        -: 2405: * The Array.prototype object's 'copyWithin' routine
        -: 2406: *
        -: 2407: * See also:
        -: 2408: *          ECMA-262 v6, 22.1.3.3
        -: 2409: *
        -: 2410: * @return ecma value
        -: 2411: *         Returned value must be freed with ecma_free_value.
        -: 2412: */
        -: 2413:static ecma_value_t
    #####: 2414:ecma_builtin_array_prototype_object_copy_within (const ecma_value_t args[], /**< arguments list */
        -: 2415:                                                 uint32_t args_number, /**< number of arguments */
        -: 2416:                                                 ecma_object_t *obj_p, /**< object */
        -: 2417:                                                 ecma_length_t len) /**< object's length */
        -: 2418:{
    #####: 2419:  if (args_number == 0)
        -: 2420:  {
    #####: 2421:    return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2422:  }
        -: 2423:
        -: 2424:  /* 5 - 7 */
    #####: 2425:  ecma_length_t target;
        -: 2426:
    #####: 2427:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0], len, &target)))
        -: 2428:  {
    #####: 2429:    return ECMA_VALUE_ERROR;
        -: 2430:  }
        -: 2431:
    #####: 2432:  ecma_length_t start = 0;
    #####: 2433:  ecma_length_t end = len;
        -: 2434:
    #####: 2435:  if (args_number > 1)
        -: 2436:  {
        -: 2437:    /* 8 - 10 */
    #####: 2438:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &start)))
        -: 2439:    {
    #####: 2440:      return ECMA_VALUE_ERROR;
        -: 2441:    }
        -: 2442:
    #####: 2443:    if (args_number > 2)
        -: 2444:    {
        -: 2445:      /* 11 */
    #####: 2446:      if (ecma_is_value_undefined (args[2]))
        -: 2447:      {
    #####: 2448:        end = len;
        -: 2449:      }
        -: 2450:      else
        -: 2451:      {
        -: 2452:        /* 11 part 2, 12, 13 */
    #####: 2453:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[2], len, &end)))
        -: 2454:        {
    #####: 2455:          return ECMA_VALUE_ERROR;
        -: 2456:        }
        -: 2457:      }
        -: 2458:    }
        -: 2459:  }
        -: 2460:
    #####: 2461:  ecma_length_t count = JERRY_MIN (end - start, len - target);
    #####: 2462:  if (end <= start || len <= target) /* count <= 0 check, but variables are unsigned */
        -: 2463:  {
    #####: 2464:    ecma_ref_object (obj_p);
    #####: 2465:    return ecma_make_object_value (obj_p);
        -: 2466:  }
        -: 2467:
    #####: 2468:  bool forward = true;
        -: 2469:
    #####: 2470:  if (start < target && target < start + count)
        -: 2471:  {
    #####: 2472:    start = start + count - 1;
    #####: 2473:    target = target + count - 1;
    #####: 2474:    forward = false;
        -: 2475:  }
        -: 2476:
    #####: 2477:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2478:  {
    #####: 2479:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####: 2480:    const uint32_t actual_length = ext_obj_p->u.array.length;
        -: 2481:
    #####: 2482:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 2483:        && ((forward && (target + count - 1 < actual_length)) || (!forward && (target < actual_length))))
        -: 2484:    {
    #####: 2485:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2486:      {
    #####: 2487:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2488:
    #####: 2489:        for (; count > 0; count--)
        -: 2490:        {
    #####: 2491:          ecma_value_t copy_value = ecma_copy_value_if_not_object (buffer_p[start]);
        -: 2492:
    #####: 2493:          ecma_free_value_if_not_object (buffer_p[target]);
        -: 2494:
    #####: 2495:          buffer_p[target] = copy_value;
        -: 2496:
    #####: 2497:          if (forward)
        -: 2498:          {
    #####: 2499:            start++;
    #####: 2500:            target++;
        -: 2501:          }
        -: 2502:          else
        -: 2503:          {
    #####: 2504:            start--;
    #####: 2505:            target--;
        -: 2506:          }
        -: 2507:        }
        -: 2508:      }
        -: 2509:
    #####: 2510:      ecma_ref_object (obj_p);
    #####: 2511:      return ecma_make_object_value (obj_p);
        -: 2512:    }
        -: 2513:  }
        -: 2514:
    #####: 2515:  while (count > 0)
        -: 2516:  {
    #####: 2517:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, start);
        -: 2518:
    #####: 2519:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2520:    {
    #####: 2521:      return get_value;
        -: 2522:    }
        -: 2523:
        -: 2524:    ecma_value_t op_value;
        -: 2525:
    #####: 2526:    if (ecma_is_value_found (get_value))
        -: 2527:    {
    #####: 2528:      op_value = ecma_op_object_put_by_index (obj_p, target, get_value, true);
        -: 2529:    }
        -: 2530:    else
        -: 2531:    {
    #####: 2532:      op_value = ecma_op_object_delete_by_index (obj_p, target, true);
        -: 2533:    }
        -: 2534:
    #####: 2535:    ecma_free_value (get_value);
        -: 2536:
    #####: 2537:    if (ECMA_IS_VALUE_ERROR (op_value))
        -: 2538:    {
    #####: 2539:      return op_value;
        -: 2540:    }
        -: 2541:
    #####: 2542:    ecma_free_value (op_value);
        -: 2543:
    #####: 2544:    if (forward)
        -: 2545:    {
    #####: 2546:      start++;
    #####: 2547:      target++;
        -: 2548:    }
        -: 2549:    else
        -: 2550:    {
    #####: 2551:      start--;
    #####: 2552:      target--;
        -: 2553:    }
        -: 2554:
    #####: 2555:    count--;
        -: 2556:  }
        -: 2557:
    #####: 2558:  return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2559:} /* ecma_builtin_array_prototype_object_copy_within */
        -: 2560:
        -: 2561:/**
        -: 2562: * The Array.prototype object's 'includes' routine
        -: 2563: *
        -: 2564: * See also:
        -: 2565: *          ECMA-262 v11, 22.1.3.13
        -: 2566: *
        -: 2567: * @return ECMA_VALUE_ERROR -if the operation fails
        -: 2568: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether the search element is in the array or not
        -: 2569: */
        -: 2570:static ecma_value_t
    #####: 2571:ecma_builtin_array_prototype_includes (const ecma_value_t args[], /**< arguments list */
        -: 2572:                                       uint32_t args_number, /**< number of arguments */
        -: 2573:                                       ecma_object_t *obj_p, /**< object */
        -: 2574:                                       ecma_length_t len) /**< object's length */
        -: 2575:{
        -: 2576:  /* 3. */
    #####: 2577:  if (len == 0)
        -: 2578:  {
    #####: 2579:    return ECMA_VALUE_FALSE;
        -: 2580:  }
        -: 2581:
    #####: 2582:  ecma_length_t from_index = 0;
        -: 2583:
        -: 2584:  /* 4-7. */
    #####: 2585:  if (args_number > 1)
        -: 2586:  {
    #####: 2587:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &from_index)))
        -: 2588:    {
    #####: 2589:      return ECMA_VALUE_ERROR;
        -: 2590:    }
        -: 2591:  }
        -: 2592:
        -: 2593:  /* Fast array path */
    #####: 2594:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2595:  {
    #####: 2596:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2597:
    #####: 2598:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2599:    {
    #####: 2600:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2601:      {
    #####: 2602:        len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 2603:
    #####: 2604:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2605:
    #####: 2606:        while (from_index < len)
        -: 2607:        {
    #####: 2608:          if (ecma_op_same_value_zero (buffer_p[from_index], args[0], false))
        -: 2609:          {
    #####: 2610:            return ECMA_VALUE_TRUE;
        -: 2611:          }
        -: 2612:
    #####: 2613:          from_index++;
        -: 2614:        }
        -: 2615:      }
        -: 2616:
    #####: 2617:      return ECMA_VALUE_FALSE;
        -: 2618:    }
        -: 2619:  }
        -: 2620:
        -: 2621:  /* 8. */
    #####: 2622:  while (from_index < len)
        -: 2623:  {
    #####: 2624:    ecma_value_t element = ecma_op_object_get_by_index (obj_p, from_index);
        -: 2625:
    #####: 2626:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2627:    {
    #####: 2628:      return element;
        -: 2629:    }
        -: 2630:
    #####: 2631:    if (ecma_op_same_value_zero (element, args[0], false))
        -: 2632:    {
    #####: 2633:      ecma_free_value (element);
    #####: 2634:      return ECMA_VALUE_TRUE;
        -: 2635:    }
        -: 2636:
    #####: 2637:    ecma_free_value (element);
    #####: 2638:    from_index++;
        -: 2639:  }
        -: 2640:
        -: 2641:  /* 9. */
    #####: 2642:  return ECMA_VALUE_FALSE;
        -: 2643:} /* ecma_builtin_array_prototype_includes */
        -: 2644:
        -: 2645:/**
        -: 2646: * Abstract operation: FlattenIntoArray
        -: 2647: *
        -: 2648: * See also:
        -: 2649: *          ECMA-262 v10, 22.1.3.10.1
        -: 2650: *
        -: 2651: * @return  ECMA_VALUE_ERROR -if the operation fails
        -: 2652: *          ecma value which contains target_index
        -: 2653: */
        -: 2654:static ecma_value_t
    #####: 2655:ecma_builtin_array_flatten_into_array (ecma_value_t target, /**< target will contains source's elements  */
        -: 2656:                                       ecma_object_t *source, /**< source object */
        -: 2657:                                       ecma_length_t source_len, /**< source object length */
        -: 2658:                                       ecma_length_t start, /**< remaining recursion depth */
        -: 2659:                                       ecma_number_t depth, /**< start index offset */
        -: 2660:                                       ecma_value_t mapped_value, /**< mapped value  */
        -: 2661:                                       ecma_value_t thisArg) /**< this arg */
        -: 2662:{
    #####: 2663:  ECMA_CHECK_STACK_USAGE ();
        -: 2664:
        -: 2665:  /* 7. */
    #####: 2666:  ecma_length_t target_index = start;
        -: 2667:
        -: 2668:  /* 9. */
    #####: 2669:  for (ecma_length_t source_index = 0; source_index < source_len; source_index++)
        -: 2670:  {
        -: 2671:    /* a. */
    #####: 2672:    ecma_value_t element = ecma_op_object_find_by_index (source, source_index);
        -: 2673:
    #####: 2674:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2675:    {
    #####: 2676:      return element;
        -: 2677:    }
        -: 2678:
    #####: 2679:    if (!ecma_is_value_found (element))
        -: 2680:    {
    #####: 2681:      continue;
        -: 2682:    }
        -: 2683:
        -: 2684:    /* b-c. */
    #####: 2685:    if (!ecma_is_value_undefined (mapped_value))
        -: 2686:    {
        -: 2687:      /* i-ii. */
    #####: 2688:      ecma_value_t source_val = ecma_make_length_value (source_index);
    #####: 2689:      ecma_value_t args[] = { element, source_val, ecma_make_object_value (source) };
    #####: 2690:      ecma_value_t temp_element = ecma_op_function_call (ecma_get_object_from_value (mapped_value), thisArg, args, 3);
        -: 2691:
    #####: 2692:      ecma_free_value (element);
    #####: 2693:      ecma_free_value (source_val);
        -: 2694:
    #####: 2695:      if (ECMA_IS_VALUE_ERROR (temp_element))
        -: 2696:      {
    #####: 2697:        return temp_element;
        -: 2698:      }
        -: 2699:
    #####: 2700:      element = temp_element;
        -: 2701:    }
        -: 2702:
        -: 2703:    /* iv-v. */
    #####: 2704:    if (depth > 0)
        -: 2705:    {
    #####: 2706:      ecma_value_t is_array = ecma_is_value_array (element);
        -: 2707:
    #####: 2708:      if (ECMA_IS_VALUE_ERROR (is_array))
        -: 2709:      {
    #####: 2710:        ecma_free_value (element);
    #####: 2711:        return is_array;
        -: 2712:      }
        -: 2713:
    #####: 2714:      if (ecma_is_value_true (is_array))
        -: 2715:      {
    #####: 2716:        ecma_object_t *element_obj = ecma_get_object_from_value (element);
    #####: 2717:        ecma_length_t element_len;
    #####: 2718:        ecma_value_t len_value = ecma_op_object_get_length (element_obj, &element_len);
        -: 2719:
    #####: 2720:        if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2721:        {
    #####: 2722:          ecma_deref_object (element_obj);
    #####: 2723:          return len_value;
        -: 2724:        }
        -: 2725:
    #####: 2726:        ecma_value_t target_index_val = ecma_builtin_array_flatten_into_array (target,
        -: 2727:                                                                               element_obj,
        -: 2728:                                                                               element_len,
        -: 2729:                                                                               target_index,
        -: 2730:                                                                               depth - 1,
        -: 2731:                                                                               ECMA_VALUE_UNDEFINED,
        -: 2732:                                                                               ECMA_VALUE_UNDEFINED);
        -: 2733:
    #####: 2734:        ecma_deref_object (element_obj);
        -: 2735:
    #####: 2736:        if (ECMA_IS_VALUE_ERROR (target_index_val))
        -: 2737:        {
    #####: 2738:          return target_index_val;
        -: 2739:        }
        -: 2740:
    #####: 2741:        target_index = (ecma_length_t) ecma_get_number_from_value (target_index_val);
    #####: 2742:        continue;
        -: 2743:      }
        -: 2744:    }
        -: 2745:
        -: 2746:    /* vi. */
    #####: 2747:    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####: 2748:    ecma_value_t element_temp =
    #####: 2749:      ecma_builtin_helper_def_prop_by_index (ecma_get_object_from_value (target), target_index, element, flags);
        -: 2750:
    #####: 2751:    ecma_free_value (element);
        -: 2752:
    #####: 2753:    if (ECMA_IS_VALUE_ERROR (element_temp))
        -: 2754:    {
    #####: 2755:      return element_temp;
        -: 2756:    }
        -: 2757:
    #####: 2758:    target_index++;
        -: 2759:  }
        -: 2760:  /* 10. */
    #####: 2761:  return ecma_make_length_value (target_index);
        -: 2762:} /* ecma_builtin_array_flatten_into_array */
        -: 2763:
        -: 2764:/**
        -: 2765: * The Array.prototype object's 'flat' routine
        -: 2766: *
        -: 2767: * See also:
        -: 2768: *          ECMA-262 v10, 22.1.3.10
        -: 2769: *
        -: 2770: * @return ecma value
        -: 2771: *         Returned value must be freed with ecma_free_value.
        -: 2772: */
        -: 2773:static ecma_value_t
    #####: 2774:ecma_builtin_array_prototype_object_flat (const ecma_value_t args[], /**< arguments list */
        -: 2775:                                          uint32_t args_number, /**< number of arguments */
        -: 2776:                                          ecma_object_t *obj_p, /**< array object */
        -: 2777:                                          ecma_length_t len) /**< array object's length */
        -: 2778:{
        -: 2779:  /* 3. */
    #####: 2780:  ecma_number_t depth_num = 1;
        -: 2781:
        -: 2782:  /* 4. */
    #####: 2783:  if (args_number > 0 && ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[0], &depth_num)))
        -: 2784:  {
    #####: 2785:    return ECMA_VALUE_ERROR;
        -: 2786:  }
        -: 2787:
        -: 2788:  /* 5. */
    #####: 2789:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2790:
    #####: 2791:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2792:  {
    #####: 2793:    return ECMA_VALUE_ERROR;
        -: 2794:  }
        -: 2795:
        -: 2796:  /* 6. */
    #####: 2797:  ecma_value_t flatten_val = ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p),
        -: 2798:                                                                    obj_p,
        -: 2799:                                                                    len,
        -: 2800:                                                                    0,
        -: 2801:                                                                    depth_num,
        -: 2802:                                                                    ECMA_VALUE_UNDEFINED,
        -: 2803:                                                                    ECMA_VALUE_UNDEFINED);
        -: 2804:
    #####: 2805:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2806:  {
    #####: 2807:    ecma_deref_object (new_array_p);
    #####: 2808:    return flatten_val;
        -: 2809:  }
        -: 2810:
        -: 2811:  /* 7. */
    #####: 2812:  return ecma_make_object_value (new_array_p);
        -: 2813:} /* ecma_builtin_array_prototype_object_flat */
        -: 2814:
        -: 2815:/**
        -: 2816: * The Array.prototype object's 'flatMap' routine
        -: 2817: *
        -: 2818: * See also:
        -: 2819: *          ECMA-262 v10, 22.1.3.11
        -: 2820: *
        -: 2821: * @return ecma value
        -: 2822: *         Returned value must be freed with ecma_free_value.
        -: 2823: */
        -: 2824:static ecma_value_t
    #####: 2825:ecma_builtin_array_prototype_object_flat_map (ecma_value_t callback, /**< callbackFn */
        -: 2826:                                              ecma_value_t this_arg, /**< thisArg */
        -: 2827:                                              ecma_object_t *obj_p, /**< array object */
        -: 2828:                                              ecma_length_t len) /**< array object's length */
        -: 2829:{
    #####: 2830:  if (!ecma_op_is_callable (callback))
        -: 2831:  {
    #####: 2832:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 2833:  }
        -: 2834:
        -: 2835:  /* 4. */
    #####: 2836:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2837:
    #####: 2838:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2839:  {
    #####: 2840:    return ECMA_VALUE_ERROR;
        -: 2841:  }
        -: 2842:
        -: 2843:  /* 5. */
    #####: 2844:  ecma_value_t flatten_val =
    #####: 2845:    ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p), obj_p, len, 0, 1, callback, this_arg);
    #####: 2846:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2847:  {
    #####: 2848:    ecma_deref_object (new_array_p);
    #####: 2849:    return flatten_val;
        -: 2850:  }
        -: 2851:
        -: 2852:  /* 6. */
    #####: 2853:  return ecma_make_object_value (new_array_p);
        -: 2854:} /* ecma_builtin_array_prototype_object_flat_map */
        -: 2855:#endif /* JERRY_ESNEXT */
        -: 2856:
        -: 2857:/**
        -: 2858: * Dispatcher of the built-in's routines
        -: 2859: *
        -: 2860: * @return ecma value
        -: 2861: *         Returned value must be freed with ecma_free_value.
        -: 2862: */
        -: 2863:ecma_value_t
    #####: 2864:ecma_builtin_array_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -: 2865:                                               ecma_value_t this_arg, /**< 'this' argument value */
        -: 2866:                                               const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 2867:                                                                                       *   passed to routine */
        -: 2868:                                               uint32_t arguments_number) /**< length of arguments' list */
        -: 2869:{
    #####: 2870:  ecma_value_t obj_this = ecma_op_to_object (this_arg);
        -: 2871:
    #####: 2872:  if (ECMA_IS_VALUE_ERROR (obj_this))
        -: 2873:  {
    #####: 2874:    return obj_this;
        -: 2875:  }
        -: 2876:
    #####: 2877:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);
        -: 2878:
    #####: 2879:  if (JERRY_UNLIKELY (builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_CONCAT))
        -: 2880:  {
    #####: 2881:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 2882:
        -: 2883:#if !JERRY_ESNEXT
    #####: 2884:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_TO_STRING)
        -: 2885:    {
    #####: 2886:      ret_value = ecma_array_object_to_string (obj_this);
        -: 2887:    }
        -: 2888:#endif /* !JERRY_ESNEXT */
    #####: 2889:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_SORT)
        -: 2890:    {
    #####: 2891:      ret_value = ecma_builtin_array_prototype_object_sort (this_arg, arguments_list_p[0], obj_p);
        -: 2892:    }
    #####: 2893:    else if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_CONCAT)
        -: 2894:    {
    #####: 2895:      ret_value = ecma_builtin_array_prototype_object_concat (arguments_list_p, arguments_number, obj_p);
        -: 2896:    }
        -: 2897:
    #####: 2898:    ecma_deref_object (obj_p);
    #####: 2899:    return ret_value;
        -: 2900:  }
        -: 2901:
        -: 2902:#if JERRY_ESNEXT
    #####: 2903:  if (JERRY_UNLIKELY (builtin_routine_id >= ECMA_ARRAY_PROTOTYPE_ENTRIES
        -: 2904:                      && builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_KEYS))
        -: 2905:  {
        -: 2906:    ecma_value_t ret_value;
        -: 2907:
    #####: 2908:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_ENTRIES)
        -: 2909:    {
    #####: 2910:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_ENTRIES);
        -: 2911:    }
        -: 2912:    else
        -: 2913:    {
    #####: 2914:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_KEYS);
    #####: 2915:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_KEYS);
        -: 2916:    }
        -: 2917:
    #####: 2918:    ecma_deref_object (obj_p);
    #####: 2919:    return ret_value;
        -: 2920:  }
        -: 2921:#endif /* JERRY_ESNEXT */
        -: 2922:
    #####: 2923:  ecma_length_t length;
    #####: 2924:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &length);
        -: 2925:
    #####: 2926:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2927:  {
    #####: 2928:    ecma_deref_object (obj_p);
    #####: 2929:    return len_value;
        -: 2930:  }
        -: 2931:
        -: 2932:  ecma_value_t ret_value;
        -: 2933:
    #####: 2934:  switch (builtin_routine_id)
        -: 2935:  {
    #####: 2936:    case ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING:
        -: 2937:    {
    #####: 2938:      ret_value = ecma_builtin_array_prototype_object_to_locale_string (obj_p, length);
    #####: 2939:      break;
        -: 2940:    }
    #####: 2941:    case ECMA_ARRAY_PROTOTYPE_JOIN:
        -: 2942:    {
    #####: 2943:      ret_value = ecma_builtin_array_prototype_join (arguments_list_p[0], obj_p, length);
    #####: 2944:      break;
        -: 2945:    }
    #####: 2946:    case ECMA_ARRAY_PROTOTYPE_POP:
        -: 2947:    {
    #####: 2948:      ret_value = ecma_builtin_array_prototype_object_pop (obj_p, length);
    #####: 2949:      break;
        -: 2950:    }
    #####: 2951:    case ECMA_ARRAY_PROTOTYPE_PUSH:
        -: 2952:    {
    #####: 2953:      ret_value = ecma_builtin_array_prototype_object_push (arguments_list_p, arguments_number, obj_p, length);
    #####: 2954:      break;
        -: 2955:    }
    #####: 2956:    case ECMA_ARRAY_PROTOTYPE_REVERSE:
        -: 2957:    {
    #####: 2958:      ret_value = ecma_builtin_array_prototype_object_reverse (this_arg, obj_p, length);
    #####: 2959:      break;
        -: 2960:    }
    #####: 2961:    case ECMA_ARRAY_PROTOTYPE_SHIFT:
        -: 2962:    {
    #####: 2963:      ret_value = ecma_builtin_array_prototype_object_shift (obj_p, length);
    #####: 2964:      break;
        -: 2965:    }
    #####: 2966:    case ECMA_ARRAY_PROTOTYPE_SLICE:
        -: 2967:    {
    #####: 2968:      ret_value = ecma_builtin_array_prototype_object_slice (arguments_list_p[0], arguments_list_p[1], obj_p, length);
    #####: 2969:      break;
        -: 2970:    }
    #####: 2971:    case ECMA_ARRAY_PROTOTYPE_SPLICE:
        -: 2972:    {
    #####: 2973:      ret_value = ecma_builtin_array_prototype_object_splice (arguments_list_p, arguments_number, obj_p, length);
    #####: 2974:      break;
        -: 2975:    }
    #####: 2976:    case ECMA_ARRAY_PROTOTYPE_UNSHIFT:
        -: 2977:    {
    #####: 2978:      ret_value = ecma_builtin_array_prototype_object_unshift (arguments_list_p, arguments_number, obj_p, length);
    #####: 2979:      break;
        -: 2980:    }
    #####: 2981:    case ECMA_ARRAY_PROTOTYPE_AT:
        -: 2982:    {
    #####: 2983:      ret_value = ecma_builtin_array_prototype_object_at (arguments_list_p[0], obj_p, length);
    #####: 2984:      break;
        -: 2985:    }
    #####: 2986:    case ECMA_ARRAY_PROTOTYPE_INDEX_OF:
        -: 2987:    {
    #####: 2988:      ret_value = ecma_builtin_array_prototype_object_index_of (arguments_list_p, arguments_number, obj_p, length);
    #####: 2989:      break;
        -: 2990:    }
    #####: 2991:    case ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF:
        -: 2992:    {
    #####: 2993:      ret_value = ecma_builtin_array_prototype_object_last_index_of (arguments_list_p, arguments_number, obj_p, length);
    #####: 2994:      break;
        -: 2995:    }
    #####: 2996:    case ECMA_ARRAY_PROTOTYPE_EVERY:
        -: 2997:    case ECMA_ARRAY_PROTOTYPE_SOME:
        -: 2998:    case ECMA_ARRAY_PROTOTYPE_FOR_EACH:
        -: 2999:    {
    #####: 3000:      ret_value = ecma_builtin_array_apply (arguments_list_p[0],
    #####: 3001:                                            arguments_list_p[1],
    #####: 3002:                                            (array_routine_mode) builtin_routine_id - ECMA_ARRAY_PROTOTYPE_EVERY,
        -: 3003:                                            obj_p,
        -: 3004:                                            length);
    #####: 3005:      break;
        -: 3006:    }
    #####: 3007:    case ECMA_ARRAY_PROTOTYPE_MAP:
        -: 3008:    {
    #####: 3009:      ret_value = ecma_builtin_array_prototype_object_map (arguments_list_p[0], arguments_list_p[1], obj_p, length);
    #####: 3010:      break;
        -: 3011:    }
    #####: 3012:    case ECMA_ARRAY_PROTOTYPE_REDUCE:
        -: 3013:    case ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT:
        -: 3014:    {
    #####: 3015:      ret_value = ecma_builtin_array_reduce_from (arguments_list_p,
        -: 3016:                                                  arguments_number,
        -: 3017:                                                  builtin_routine_id == ECMA_ARRAY_PROTOTYPE_REDUCE,
        -: 3018:                                                  obj_p,
        -: 3019:                                                  length);
    #####: 3020:      break;
        -: 3021:    }
        -: 3022:#if JERRY_ESNEXT
    #####: 3023:    case ECMA_ARRAY_PROTOTYPE_COPY_WITHIN:
        -: 3024:    {
    #####: 3025:      ret_value = ecma_builtin_array_prototype_object_copy_within (arguments_list_p, arguments_number, obj_p, length);
    #####: 3026:      break;
        -: 3027:    }
    #####: 3028:    case ECMA_ARRAY_PROTOTYPE_FIND:
        -: 3029:    case ECMA_ARRAY_PROTOTYPE_FIND_INDEX:
        -: 3030:    {
    #####: 3031:      ret_value = ecma_builtin_array_prototype_object_find (arguments_list_p[0],
    #####: 3032:                                                            arguments_list_p[1],
        -: 3033:                                                            builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FIND,
        -: 3034:                                                            obj_p,
        -: 3035:                                                            length);
    #####: 3036:      break;
        -: 3037:    }
    #####: 3038:    case ECMA_ARRAY_PROTOTYPE_FILL:
        -: 3039:    {
    #####: 3040:      ret_value = ecma_builtin_array_prototype_fill (arguments_list_p[0],
    #####: 3041:                                                     arguments_list_p[1],
    #####: 3042:                                                     arguments_list_p[2],
        -: 3043:                                                     obj_p,
        -: 3044:                                                     length);
    #####: 3045:      break;
        -: 3046:    }
    #####: 3047:    case ECMA_ARRAY_PROTOTYPE_INCLUDES:
        -: 3048:    {
    #####: 3049:      ret_value = ecma_builtin_array_prototype_includes (arguments_list_p, arguments_number, obj_p, length);
    #####: 3050:      break;
        -: 3051:    }
    #####: 3052:    case ECMA_ARRAY_PROTOTYPE_FLAT:
        -: 3053:    {
    #####: 3054:      ret_value = ecma_builtin_array_prototype_object_flat (arguments_list_p, arguments_number, obj_p, length);
    #####: 3055:      break;
        -: 3056:    }
    #####: 3057:    case ECMA_ARRAY_PROTOTYPE_FLATMAP:
        -: 3058:    {
    #####: 3059:      ret_value =
    #####: 3060:        ecma_builtin_array_prototype_object_flat_map (arguments_list_p[0], arguments_list_p[1], obj_p, length);
    #####: 3061:      break;
        -: 3062:    }
        -: 3063:#endif /* JERRY_ESNEXT */
    #####: 3064:    default:
        -: 3065:    {
    #####: 3066:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FILTER);
        -: 3067:
    #####: 3068:      ret_value = ecma_builtin_array_prototype_object_filter (arguments_list_p[0], arguments_list_p[1], obj_p, length);
    #####: 3069:      break;
        -: 3070:    }
        -: 3071:  }
        -: 3072:
    #####: 3073:  ecma_free_value (len_value);
    #####: 3074:  ecma_deref_object (obj_p);
        -: 3075:
    #####: 3076:  return ret_value;
        -: 3077:} /* ecma_builtin_array_prototype_dispatch_routine */
        -: 3078:
        -: 3079:/**
        -: 3080: * @}
        -: 3081: * @}
        -: 3082: * @}
        -: 3083: */
        -: 3084:
        -: 3085:#endif /* JERRY_BUILTIN_ARRAY */
