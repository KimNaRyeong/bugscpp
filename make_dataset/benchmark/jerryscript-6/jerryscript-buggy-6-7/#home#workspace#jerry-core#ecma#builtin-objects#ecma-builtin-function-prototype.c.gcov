        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-function-prototype.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-builtin-function-prototype.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-extended-info.h"
        -:   24:#include "ecma-function-object.h"
        -:   25:#include "ecma-gc.h"
        -:   26:#include "ecma-globals.h"
        -:   27:#include "ecma-helpers.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-proxy-object.h"
        -:   30:
        -:   31:#include "jrt.h"
        -:   32:
        -:   33:#define ECMA_BUILTINS_INTERNAL
        -:   34:#include "ecma-builtins-internal.h"
        -:   35:
        -:   36:/**
        -:   37: * This object has a custom dispatch function.
        -:   38: */
        -:   39:#define BUILTIN_CUSTOM_DISPATCH
        -:   40:
        -:   41:/**
        -:   42: * List of built-in routine identifiers.
        -:   43: */
        -:   44:enum
        -:   45:{
        -:   46:  ECMA_FUNCTION_PROTOTYPE_ROUTINE_START = 0,
        -:   47:  ECMA_FUNCTION_PROTOTYPE_TO_STRING,
        -:   48:  ECMA_FUNCTION_PROTOTYPE_CALL,
        -:   49:  ECMA_FUNCTION_PROTOTYPE_APPLY,
        -:   50:  ECMA_FUNCTION_PROTOTYPE_BIND,
        -:   51:#if JERRY_ESNEXT
        -:   52:  ECMA_FUNCTION_PROTOTYPE_SYMBOL_HAS_INSTANCE,
        -:   53:#endif /* JERRY_ESNEXT */
        -:   54:};
        -:   55:
        -:   56:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-function-prototype.inc.h"
        -:   57:#define BUILTIN_UNDERSCORED_ID  function_prototype
        -:   58:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   59:
        -:   60:/** \addtogroup ecma ECMA
        -:   61: * @{
        -:   62: *
        -:   63: * \addtogroup ecmabuiltins
        -:   64: * @{
        -:   65: *
        -:   66: * \addtogroup functionprototype ECMA Function.prototype object built-in
        -:   67: * @{
        -:   68: */
        -:   69:
        -:   70:/**
        -:   71: * Maximum number of arguments for an apply function.
        -:   72: */
        -:   73:#define ECMA_FUNCTION_APPLY_ARGUMENT_COUNT_LIMIT 65535
        -:   74:
        -:   75:/**
        -:   76: * The Function.prototype object's 'toString' routine
        -:   77: *
        -:   78: * See also:
        -:   79: *          ECMA-262 v5, 15.3.4.2
        -:   80: *
        -:   81: * @return ecma value
        -:   82: *         Returned value must be freed with ecma_free_value.
        -:   83: */
        -:   84:static ecma_value_t
    #####:   85:ecma_builtin_function_prototype_object_to_string (ecma_object_t *func_obj_p) /**< this argument object */
        -:   86:{
    #####:   87:  if (ecma_get_object_type (func_obj_p) != ECMA_OBJECT_TYPE_FUNCTION)
        -:   88:  {
    #####:   89:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_FUNCTION_TO_STRING_NATIVE);
        -:   90:  }
        -:   91:
        -:   92:#if JERRY_FUNCTION_TO_STRING
        -:   93:  const ecma_compiled_code_t *bytecode_p;
    #####:   94:  bytecode_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) func_obj_p);
        -:   95:
    #####:   96:  ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####:   97:  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -:   98:
    #####:   99:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)
        -:  100:  {
    #####:  101:    uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (bytecode_p);
    #####:  102:    uint8_t extended_info = *extended_info_p;
        -:  103:
    #####:  104:    if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_SOURCE_CODE_RANGE)
        -:  105:    {
        -:  106:#if JERRY_ESNEXT
    #####:  107:      if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)
        -:  108:      {
    #####:  109:        ecma_extended_info_decode_vlq (&extended_info_p);
        -:  110:      }
        -:  111:#endif /* JERRY_ESNEXT */
        -:  112:
    #####:  113:      uint32_t range_start = ecma_extended_info_decode_vlq (&extended_info_p);
    #####:  114:      uint32_t range_size = ecma_extended_info_decode_vlq (&extended_info_p);
        -:  115:      ecma_value_t source_code;
        -:  116:
    #####:  117:      if (!(extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS))
        -:  118:      {
    #####:  119:        source_code = script_p->source_code;
        -:  120:#if JERRY_SNAPSHOT_EXEC
    #####:  121:        if (ecma_is_value_magic_string (source_code, LIT_MAGIC_STRING__EMPTY))
        -:  122:        {
    #####:  123:          return ecma_make_magic_string_value (LIT_MAGIC_STRING_FUNCTION_TO_STRING_ECMA);
        -:  124:        }
        -:  125:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  126:      }
        -:  127:      else
        -:  128:      {
        -:  129:#if JERRY_SNAPSHOT_EXEC
    #####:  130:        if (!(script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS))
        -:  131:        {
    #####:  132:          return ecma_make_magic_string_value (LIT_MAGIC_STRING_FUNCTION_TO_STRING_ECMA);
        -:  133:        }
        -:  134:#else /* !JERRY_SNAPSHOT_EXEC */
        -:  135:        JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS);
        -:  136:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  137:
    #####:  138:        source_code = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -:  139:      }
        -:  140:
        -:  141:      ecma_string_t *result_string_p;
        -:  142:
    #####:  143:      ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (source_code), source_p, source_size);
    #####:  144:      result_string_p = ecma_new_ecma_string_from_utf8 (source_p + range_start, range_size);
    #####:  145:      ECMA_FINALIZE_UTF8_STRING (source_p, source_size);
        -:  146:
    #####:  147:      return ecma_make_string_value (result_string_p);
        -:  148:    }
        -:  149:  }
        -:  150:
        -:  151:#if JERRY_SNAPSHOT_EXEC
    #####:  152:  if (!(script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS))
        -:  153:  {
    #####:  154:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_FUNCTION_TO_STRING_ECMA);
        -:  155:  }
        -:  156:#else /* !JERRY_SNAPSHOT_EXEC */
        -:  157:  JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS);
        -:  158:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  159:
    #####:  160:  lit_magic_string_id_t header_id = LIT_MAGIC_STRING_FUNCTION_TO_STRING_ANON;
        -:  161:
        -:  162:#if JERRY_ESNEXT
    #####:  163:  switch (CBC_FUNCTION_GET_TYPE (bytecode_p->status_flags))
        -:  164:  {
        -:  165:    case CBC_FUNCTION_GENERATOR:
        -:  166:    {
        -:  167:      header_id = LIT_MAGIC_STRING_FUNCTION_TO_STRING_ANON_GENERATOR;
        -:  168:      break;
        -:  169:    }
        -:  170:    case CBC_FUNCTION_ASYNC_GENERATOR:
        -:  171:    {
        -:  172:      header_id = LIT_MAGIC_STRING_FUNCTION_TO_STRING_ANON_ASYNC_GENERATOR;
        -:  173:      break;
        -:  174:    }
        -:  175:    case CBC_FUNCTION_ASYNC:
        -:  176:    {
        -:  177:      header_id = LIT_MAGIC_STRING_FUNCTION_TO_STRING_ANON_ASYNC;
        -:  178:      break;
        -:  179:    }
        -:  180:  }
        -:  181:#endif /* JERRY_ESNEXT */
        -:  182:
    #####:  183:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (ecma_get_magic_string (header_id));
    #####:  184:  ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -:  185:
    #####:  186:  ecma_stringbuilder_append (&builder, ecma_get_string_from_value (function_arguments));
    #####:  187:  ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\n) {\n", 5);
    #####:  188:  ecma_stringbuilder_append (&builder, ecma_get_string_from_value (script_p->source_code));
    #####:  189:  ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\n}", 2);
        -:  190:
    #####:  191:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  192:#else /* !JERRY_FUNCTION_TO_STRING */
    #####:  193:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_FUNCTION_TO_STRING_ECMA);
        -:  194:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  195:} /* ecma_builtin_function_prototype_object_to_string */
        -:  196:
        -:  197:/**
        -:  198: * The Function.prototype object's 'apply' routine
        -:  199: *
        -:  200: * See also:
        -:  201: *          ECMA-262 v5, 15.3.4.3
        -:  202: *
        -:  203: * @return ecma value
        -:  204: *         Returned value must be freed with ecma_free_value.
        -:  205: */
        -:  206:ecma_value_t
    #####:  207:ecma_builtin_function_prototype_object_apply (ecma_object_t *func_obj_p, /**< this argument object */
        -:  208:                                              ecma_value_t arg1, /**< first argument */
        -:  209:                                              ecma_value_t arg2) /**< second argument */
        -:  210:{
        -:  211:  /* 2. */
    #####:  212:  if (ecma_is_value_null (arg2) || ecma_is_value_undefined (arg2))
        -:  213:  {
    #####:  214:    return ecma_op_function_call (func_obj_p, arg1, NULL, 0);
        -:  215:  }
        -:  216:
        -:  217:  /* 3. */
    #####:  218:  if (!ecma_is_value_object (arg2))
        -:  219:  {
    #####:  220:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_IS_NOT_AN_OBJECT);
        -:  221:  }
        -:  222:
    #####:  223:  ecma_object_t *obj_p = ecma_get_object_from_value (arg2);
        -:  224:
        -:  225:  /* 4-5. */
    #####:  226:  ecma_length_t length;
    #####:  227:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &length);
        -:  228:
    #####:  229:  if (ECMA_IS_VALUE_ERROR (len_value))
        -:  230:  {
    #####:  231:    return len_value;
        -:  232:  }
        -:  233:
    #####:  234:  if (length >= ECMA_FUNCTION_APPLY_ARGUMENT_COUNT_LIMIT)
        -:  235:  {
    #####:  236:    return ecma_raise_range_error (ECMA_ERR_TOO_MANY_ARGUMENTS_DECLARED_FOR_FUNCTION_APPLY);
        -:  237:  }
        -:  238:
        -:  239:  /* 6. */
    #####:  240:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####:  241:  JMEM_DEFINE_LOCAL_ARRAY (arguments_list_p, length, ecma_value_t);
    #####:  242:  ecma_length_t index = 0;
        -:  243:
        -:  244:  /* 7. */
    #####:  245:  for (index = 0; index < length; index++)
        -:  246:  {
    #####:  247:    ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, index);
        -:  248:
    #####:  249:    if (ECMA_IS_VALUE_ERROR (get_value))
        -:  250:    {
    #####:  251:      ret_value = get_value;
    #####:  252:      break;
        -:  253:    }
        -:  254:
    #####:  255:    arguments_list_p[index] = get_value;
        -:  256:  }
        -:  257:
    #####:  258:  if (ecma_is_value_empty (ret_value))
        -:  259:  {
    #####:  260:    JERRY_ASSERT (index == length);
    #####:  261:    ret_value = ecma_op_function_call (func_obj_p, arg1, arguments_list_p, (uint32_t) length);
        -:  262:  }
        -:  263:
    #####:  264:  for (uint32_t remove_index = 0; remove_index < index; remove_index++)
        -:  265:  {
    #####:  266:    ecma_free_value (arguments_list_p[remove_index]);
        -:  267:  }
        -:  268:
    #####:  269:  JMEM_FINALIZE_LOCAL_ARRAY (arguments_list_p);
        -:  270:
    #####:  271:  return ret_value;
        -:  272:} /* ecma_builtin_function_prototype_object_apply */
        -:  273:
        -:  274:/**
        -:  275: * The Function.prototype object's 'call' routine
        -:  276: *
        -:  277: * See also:
        -:  278: *          ECMA-262 v5, 15.3.4.4
        -:  279: *
        -:  280: * @return ecma value
        -:  281: *         Returned value must be freed with ecma_free_value.
        -:  282: */
        -:  283:static ecma_value_t
    #####:  284:ecma_builtin_function_prototype_object_call (ecma_object_t *func_obj_p, /**< this argument object */
        -:  285:                                             const ecma_value_t *arguments_list_p, /**< list of arguments */
        -:  286:                                             uint32_t arguments_number) /**< number of arguments */
        -:  287:{
    #####:  288:  if (arguments_number == 0)
        -:  289:  {
        -:  290:    /* Even a 'this' argument is missing. */
    #####:  291:    return ecma_op_function_call (func_obj_p, ECMA_VALUE_UNDEFINED, NULL, 0);
        -:  292:  }
        -:  293:
    #####:  294:  return ecma_op_function_call (func_obj_p,
        -:  295:                                arguments_list_p[0],
        -:  296:                                arguments_list_p + 1,
    #####:  297:                                (uint32_t) (arguments_number - 1u));
        -:  298:} /* ecma_builtin_function_prototype_object_call */
        -:  299:
        -:  300:/**
        -:  301: * The Function.prototype object's 'bind' routine
        -:  302: *
        -:  303: * See also:
        -:  304: *          ECMA-262 v5, 15.3.4.5
        -:  305: *
        -:  306: * @return ecma value
        -:  307: *         Returned value must be freed with ecma_free_value.
        -:  308: */
        -:  309:static ecma_value_t
    #####:  310:ecma_builtin_function_prototype_object_bind (ecma_object_t *this_arg_obj_p, /**< this argument object */
        -:  311:                                             const ecma_value_t *arguments_list_p, /**< list of arguments */
        -:  312:                                             uint32_t arguments_number) /**< number of arguments */
        -:  313:{
        -:  314:  /* 4. 11. 18. */
        -:  315:  ecma_object_t *prototype_obj_p;
        -:  316:
        -:  317:#if !JERRY_ESNEXT
    #####:  318:  prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);
        -:  319:#else /* JERRY_ESNEXT */
        -:  320:#if JERRY_BUILTIN_PROXY
    #####:  321:  if (ECMA_OBJECT_IS_PROXY (this_arg_obj_p))
        -:  322:  {
    #####:  323:    ecma_value_t proto = ecma_proxy_object_get_prototype_of (this_arg_obj_p);
        -:  324:
    #####:  325:    if (ECMA_IS_VALUE_ERROR (proto))
        -:  326:    {
    #####:  327:      return proto;
        -:  328:    }
    #####:  329:    prototype_obj_p = ecma_is_value_null (proto) ? NULL : ecma_get_object_from_value (proto);
        -:  330:  }
        -:  331:  else
        -:  332:  {
        -:  333:#endif /* JERRY_BUILTIN_PROXY */
    #####:  334:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (this_arg_obj_p);
    #####:  335:    if (proto_cp != JMEM_CP_NULL)
        -:  336:    {
    #####:  337:      prototype_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
    #####:  338:      ecma_ref_object (prototype_obj_p);
        -:  339:    }
        -:  340:    else
        -:  341:    {
    #####:  342:      prototype_obj_p = NULL;
        -:  343:    }
        -:  344:#if JERRY_BUILTIN_PROXY
        -:  345:  }
        -:  346:#endif /* JERRY_BUILTIN_PROXY */
        -:  347:#endif /* !JERRY_ESNEXT */
        -:  348:
        -:  349:  ecma_object_t *function_p;
        -:  350:  ecma_bound_function_t *bound_func_p;
        -:  351:
    #####:  352:  if (arguments_number == 0 || (arguments_number == 1 && !ecma_is_value_integer_number (arguments_list_p[0])))
        -:  353:  {
    #####:  354:    function_p = ecma_create_object (prototype_obj_p, sizeof (ecma_bound_function_t), ECMA_OBJECT_TYPE_BOUND_FUNCTION);
        -:  355:
        -:  356:    /* 8. */
    #####:  357:    bound_func_p = (ecma_bound_function_t *) function_p;
    #####:  358:    ECMA_SET_NON_NULL_POINTER_TAG (bound_func_p->header.u.bound_function.target_function, this_arg_obj_p, 0);
        -:  359:
    #####:  360:    bound_func_p->header.u.bound_function.args_len_or_this = ECMA_VALUE_UNDEFINED;
        -:  361:
    #####:  362:    if (arguments_number != 0)
        -:  363:    {
    #####:  364:      bound_func_p->header.u.bound_function.args_len_or_this = ecma_copy_value_if_not_object (arguments_list_p[0]);
        -:  365:    }
        -:  366:  }
        -:  367:  else
        -:  368:  {
    #####:  369:    JERRY_ASSERT (arguments_number > 0);
        -:  370:
    #####:  371:    size_t obj_size = sizeof (ecma_bound_function_t) + (arguments_number * sizeof (ecma_value_t));
        -:  372:
    #####:  373:    function_p = ecma_create_object (prototype_obj_p, obj_size, ECMA_OBJECT_TYPE_BOUND_FUNCTION);
        -:  374:
        -:  375:    /* 8. */
    #####:  376:    bound_func_p = (ecma_bound_function_t *) function_p;
    #####:  377:    ECMA_SET_NON_NULL_POINTER_TAG (bound_func_p->header.u.bound_function.target_function, this_arg_obj_p, 0);
        -:  378:
        -:  379:    /* NOTE: This solution provides temporary false data about the object's size
        -:  380:       but prevents GC from freeing it until it's not fully initialized. */
    #####:  381:    bound_func_p->header.u.bound_function.args_len_or_this = ECMA_VALUE_UNDEFINED;
    #####:  382:    ecma_value_t *args_p = (ecma_value_t *) (bound_func_p + 1);
        -:  383:
    #####:  384:    for (uint32_t i = 0; i < arguments_number; i++)
        -:  385:    {
    #####:  386:      *args_p++ = ecma_copy_value_if_not_object (arguments_list_p[i]);
        -:  387:    }
        -:  388:
    #####:  389:    ecma_value_t args_len_or_this = ecma_make_integer_value ((ecma_integer_value_t) arguments_number);
    #####:  390:    bound_func_p->header.u.bound_function.args_len_or_this = args_len_or_this;
        -:  391:  }
        -:  392:
        -:  393:#if JERRY_ESNEXT
    #####:  394:  if (prototype_obj_p != NULL)
        -:  395:  {
    #####:  396:    ecma_deref_object (prototype_obj_p);
        -:  397:  }
        -:  398:
    #####:  399:  bound_func_p->target_length = ecma_make_integer_value (0);
        -:  400:
    #####:  401:  ecma_string_t *len_string = ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH);
    #####:  402:  ecma_property_descriptor_t prop_desc;
    #####:  403:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (this_arg_obj_p, len_string, &prop_desc);
        -:  404:
        -:  405:#if JERRY_BUILTIN_PROXY
    #####:  406:  if (ECMA_IS_VALUE_ERROR (status))
        -:  407:  {
    #####:  408:    ecma_deref_object (function_p);
    #####:  409:    return status;
        -:  410:  }
        -:  411:#endif /* JERRY_BUILTIN_PROXY */
        -:  412:
    #####:  413:  if (ecma_is_value_true (status))
        -:  414:  {
    #####:  415:    ecma_free_property_descriptor (&prop_desc);
    #####:  416:    ecma_value_t len_value = ecma_op_object_get (this_arg_obj_p, len_string);
        -:  417:
    #####:  418:    if (ECMA_IS_VALUE_ERROR (len_value))
        -:  419:    {
    #####:  420:      ecma_deref_object (function_p);
    #####:  421:      return len_value;
        -:  422:    }
        -:  423:
    #####:  424:    if (ecma_is_value_number (len_value))
        -:  425:    {
    #####:  426:      ecma_number_t len_num;
    #####:  427:      ecma_op_to_integer (len_value, &len_num);
    #####:  428:      bound_func_p->target_length = ecma_make_number_value (len_num);
        -:  429:    }
    #####:  430:    ecma_free_value (len_value);
        -:  431:  }
        -:  432:
        -:  433:  /* 12. */
    #####:  434:  ecma_value_t name_value = ecma_op_object_get_by_magic_id (this_arg_obj_p, LIT_MAGIC_STRING_NAME);
    #####:  435:  if (ECMA_IS_VALUE_ERROR (name_value))
        -:  436:  {
    #####:  437:    ecma_deref_object (function_p);
    #####:  438:    return name_value;
        -:  439:  }
        -:  440:
        -:  441:  ecma_string_t *name_p;
        -:  442:
    #####:  443:  if (ecma_is_value_string (name_value))
        -:  444:  {
    #####:  445:    name_p = ecma_get_string_from_value (name_value);
        -:  446:  }
        -:  447:  else
        -:  448:  {
    #####:  449:    ecma_free_value (name_value);
    #####:  450:    name_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  451:  }
        -:  452:
    #####:  453:  ecma_value_t bound_function_name = ecma_op_function_form_name (name_p, "bound ", 6);
        -:  454:
    #####:  455:  ecma_deref_ecma_string (name_p);
        -:  456:
        -:  457:  ecma_property_value_t *name_prop_value_p;
    #####:  458:  name_prop_value_p = ecma_create_named_data_property (function_p,
        -:  459:                                                       ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -:  460:                                                       ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -:  461:                                                       NULL);
        -:  462:
    #####:  463:  name_prop_value_p->value = bound_function_name;
        -:  464:#endif /* JERRY_ESNEXT */
        -:  465:
        -:  466:  /*
        -:  467:   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_FUNCTION type.
        -:  468:   *
        -:  469:   * See also: ecma_object_get_class_name
        -:  470:   */
        -:  471:
        -:  472:  /* 22. */
    #####:  473:  return ecma_make_object_value (function_p);
        -:  474:} /* ecma_builtin_function_prototype_object_bind */
        -:  475:
        -:  476:/**
        -:  477: * Handle calling [[Call]] of built-in Function.prototype object
        -:  478: *
        -:  479: * @return ecma value
        -:  480: */
        -:  481:ecma_value_t
    #####:  482:ecma_builtin_function_prototype_dispatch_call (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  483:                                               uint32_t arguments_list_len) /**< number of arguments */
        -:  484:{
    #####:  485:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  486:
    #####:  487:  return ECMA_VALUE_UNDEFINED;
        -:  488:} /* ecma_builtin_function_prototype_dispatch_call */
        -:  489:
        -:  490:/**
        -:  491: * Handle calling [[Construct]] of built-in Function.prototype object
        -:  492: *
        -:  493: * @return ecma value
        -:  494: */
        -:  495:ecma_value_t
    #####:  496:ecma_builtin_function_prototype_dispatch_construct (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  497:                                                    uint32_t arguments_list_len) /**< number of arguments */
        -:  498:{
    #####:  499:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  500:
    #####:  501:  return ecma_raise_type_error (ECMA_ERR_FUNCTION_PROTOTYPE_NOT_A_CONSTRUCTOR);
        -:  502:} /* ecma_builtin_function_prototype_dispatch_construct */
        -:  503:
        -:  504:/**
        -:  505: * Dispatcher of the built-in's routines
        -:  506: *
        -:  507: * @return ecma value
        -:  508: *         Returned value must be freed with ecma_free_value.
        -:  509: */
        -:  510:ecma_value_t
    #####:  511:ecma_builtin_function_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  512:                                                  ecma_value_t this_arg, /**< 'this' argument value */
        -:  513:                                                  const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  514:                                                                                          *   passed to routine */
        -:  515:                                                  uint32_t arguments_number) /**< length of arguments' list */
        -:  516:{
    #####:  517:  if (!ecma_op_is_callable (this_arg))
        -:  518:  {
        -:  519:#if JERRY_ESNEXT
    #####:  520:    if (JERRY_UNLIKELY (builtin_routine_id == ECMA_FUNCTION_PROTOTYPE_SYMBOL_HAS_INSTANCE))
        -:  521:    {
    #####:  522:      return ECMA_VALUE_FALSE;
        -:  523:    }
        -:  524:#endif /* JERRY_ESNEXT */
        -:  525:
    #####:  526:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_FUNCTION);
        -:  527:  }
        -:  528:
    #####:  529:  ecma_object_t *func_obj_p = ecma_get_object_from_value (this_arg);
        -:  530:
    #####:  531:  switch (builtin_routine_id)
        -:  532:  {
    #####:  533:    case ECMA_FUNCTION_PROTOTYPE_TO_STRING:
        -:  534:    {
    #####:  535:      return ecma_builtin_function_prototype_object_to_string (func_obj_p);
        -:  536:    }
    #####:  537:    case ECMA_FUNCTION_PROTOTYPE_APPLY:
        -:  538:    {
    #####:  539:      return ecma_builtin_function_prototype_object_apply (func_obj_p, arguments_list_p[0], arguments_list_p[1]);
        -:  540:    }
    #####:  541:    case ECMA_FUNCTION_PROTOTYPE_CALL:
        -:  542:    {
    #####:  543:      return ecma_builtin_function_prototype_object_call (func_obj_p, arguments_list_p, arguments_number);
        -:  544:    }
    #####:  545:    case ECMA_FUNCTION_PROTOTYPE_BIND:
        -:  546:    {
    #####:  547:      return ecma_builtin_function_prototype_object_bind (func_obj_p, arguments_list_p, arguments_number);
        -:  548:    }
        -:  549:#if JERRY_ESNEXT
    #####:  550:    case ECMA_FUNCTION_PROTOTYPE_SYMBOL_HAS_INSTANCE:
        -:  551:    {
    #####:  552:      return ecma_op_object_has_instance (func_obj_p, arguments_list_p[0]);
        -:  553:    }
        -:  554:#endif /* JERRY_ESNEXT */
    #####:  555:    default:
        -:  556:    {
    #####:  557:      JERRY_UNREACHABLE ();
        -:  558:    }
        -:  559:  }
        -:  560:} /* ecma_builtin_function_prototype_dispatch_routine */
        -:  561:
        -:  562:/**
        -:  563: * @}
        -:  564: * @}
        -:  565: * @}
        -:  566: */
