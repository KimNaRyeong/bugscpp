        -:    0:Source:/home/workspace/jerry-core/jmem/jmem-allocator.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:/**
        -:   17: * Allocator implementation
        -:   18: */
        -:   19:#include "ecma-globals.h"
        -:   20:
        -:   21:#include "jcontext.h"
        -:   22:#include "jmem.h"
        -:   23:#include "jrt-libc-includes.h"
        -:   24:
        -:   25:#define JMEM_ALLOCATOR_INTERNAL
        -:   26:#include "jmem-allocator-internal.h"
        -:   27:
        -:   28:#if JERRY_MEM_STATS
        -:   29:/**
        -:   30: * Register byte code allocation.
        -:   31: */
        -:   32:void
    #####:   33:jmem_stats_allocate_byte_code_bytes (size_t byte_code_size)
        -:   34:{
    #####:   35:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:   36:
    #####:   37:  heap_stats->byte_code_bytes += byte_code_size;
        -:   38:
    #####:   39:  if (heap_stats->byte_code_bytes >= heap_stats->peak_byte_code_bytes)
        -:   40:  {
    #####:   41:    heap_stats->peak_byte_code_bytes = heap_stats->byte_code_bytes;
        -:   42:  }
    #####:   43:} /* jmem_stats_allocate_byte_code_bytes */
        -:   44:
        -:   45:/**
        -:   46: * Register byte code free.
        -:   47: */
        -:   48:void
    #####:   49:jmem_stats_free_byte_code_bytes (size_t byte_code_size)
        -:   50:{
    #####:   51:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:   52:
        -:   53:  JERRY_ASSERT (heap_stats->byte_code_bytes >= byte_code_size);
        -:   54:
    #####:   55:  heap_stats->byte_code_bytes -= byte_code_size;
    #####:   56:} /* jmem_stats_free_byte_code_bytes */
        -:   57:
        -:   58:/**
        -:   59: * Register string allocation.
        -:   60: */
        -:   61:void
    #####:   62:jmem_stats_allocate_string_bytes (size_t string_size)
        -:   63:{
    #####:   64:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:   65:
    #####:   66:  heap_stats->string_bytes += string_size;
        -:   67:
    #####:   68:  if (heap_stats->string_bytes >= heap_stats->peak_string_bytes)
        -:   69:  {
    #####:   70:    heap_stats->peak_string_bytes = heap_stats->string_bytes;
        -:   71:  }
    #####:   72:} /* jmem_stats_allocate_string_bytes */
        -:   73:
        -:   74:/**
        -:   75: * Register string free.
        -:   76: */
        -:   77:void
    #####:   78:jmem_stats_free_string_bytes (size_t string_size)
        -:   79:{
    #####:   80:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:   81:
        -:   82:  JERRY_ASSERT (heap_stats->string_bytes >= string_size);
        -:   83:
    #####:   84:  heap_stats->string_bytes -= string_size;
    #####:   85:} /* jmem_stats_free_string_bytes */
        -:   86:
        -:   87:/**
        -:   88: * Register object allocation.
        -:   89: */
        -:   90:void
    #####:   91:jmem_stats_allocate_object_bytes (size_t object_size)
        -:   92:{
    #####:   93:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:   94:
    #####:   95:  heap_stats->object_bytes += object_size;
        -:   96:
    #####:   97:  if (heap_stats->object_bytes >= heap_stats->peak_object_bytes)
        -:   98:  {
    #####:   99:    heap_stats->peak_object_bytes = heap_stats->object_bytes;
        -:  100:  }
    #####:  101:} /* jmem_stats_allocate_object_bytes */
        -:  102:
        -:  103:/**
        -:  104: * Register object free.
        -:  105: */
        -:  106:void
    #####:  107:jmem_stats_free_object_bytes (size_t object_size)
        -:  108:{
    #####:  109:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:  110:
        -:  111:  JERRY_ASSERT (heap_stats->object_bytes >= object_size);
        -:  112:
    #####:  113:  heap_stats->object_bytes -= object_size;
    #####:  114:} /* jmem_stats_free_object_bytes */
        -:  115:
        -:  116:/**
        -:  117: * Register property allocation.
        -:  118: */
        -:  119:void
    #####:  120:jmem_stats_allocate_property_bytes (size_t property_size)
        -:  121:{
    #####:  122:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:  123:
    #####:  124:  heap_stats->property_bytes += property_size;
        -:  125:
    #####:  126:  if (heap_stats->property_bytes >= heap_stats->peak_property_bytes)
        -:  127:  {
    #####:  128:    heap_stats->peak_property_bytes = heap_stats->property_bytes;
        -:  129:  }
    #####:  130:} /* jmem_stats_allocate_property_bytes */
        -:  131:
        -:  132:/**
        -:  133: * Register property free.
        -:  134: */
        -:  135:void
    #####:  136:jmem_stats_free_property_bytes (size_t property_size)
        -:  137:{
    #####:  138:  jmem_heap_stats_t *heap_stats = &JERRY_CONTEXT (jmem_heap_stats);
        -:  139:
        -:  140:  JERRY_ASSERT (heap_stats->property_bytes >= property_size);
        -:  141:
    #####:  142:  heap_stats->property_bytes -= property_size;
    #####:  143:} /* jmem_stats_free_property_bytes */
        -:  144:
        -:  145:#endif /* JERRY_MEM_STATS */
        -:  146:
        -:  147:/**
        -:  148: * Initialize memory allocators.
        -:  149: */
        -:  150:void
        1:  151:jmem_init (void)
        -:  152:{
        1:  153:  jmem_heap_init ();
        1:  154:} /* jmem_init */
        -:  155:
        -:  156:/**
        -:  157: * Finalize memory allocators.
        -:  158: */
        -:  159:void
        1:  160:jmem_finalize (void)
        -:  161:{
        1:  162:  jmem_pools_finalize ();
        -:  163:
        -:  164:#if JERRY_MEM_STATS
    #####:  165:  if (JERRY_CONTEXT (jerry_init_flags) & JERRY_INIT_MEM_STATS)
        -:  166:  {
    #####:  167:    jmem_heap_stats_print ();
        -:  168:  }
        -:  169:#endif /* JERRY_MEM_STATS */
        -:  170:
        1:  171:  jmem_heap_finalize ();
    #####:  172:} /* jmem_finalize */
        -:  173:
        -:  174:/**
        -:  175: * Compress pointer
        -:  176: *
        -:  177: * @return packed pointer
        -:  178: */
        -:  179:extern inline jmem_cpointer_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
      163:  180:jmem_compress_pointer (const void *pointer_p) /**< pointer to compress */
        -:  181:{
      163:  182:  JERRY_ASSERT (pointer_p != NULL);
      163:  183:  JERRY_ASSERT (jmem_is_heap_pointer (pointer_p));
        -:  184:
      163:  185:  uintptr_t uint_ptr = (uintptr_t) pointer_p;
        -:  186:
      163:  187:  JERRY_ASSERT (uint_ptr % JMEM_ALIGNMENT == 0);
        -:  188:
        -:  189:#if defined(ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY) && JERRY_CPOINTER_32_BIT
        -:  190:  JERRY_ASSERT (((jmem_cpointer_t) uint_ptr) == uint_ptr);
        -:  191:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY || !JERRY_CPOINTER_32_BIT */
    #####:  192:  const uintptr_t heap_start = (uintptr_t) &JERRY_HEAP_CONTEXT (first);
        -:  193:
    #####:  194:  uint_ptr -= heap_start;
    #####:  195:  uint_ptr >>= JMEM_ALIGNMENT_LOG;
        -:  196:
        -:  197:#if JERRY_CPOINTER_32_BIT
        -:  198:  JERRY_ASSERT (uint_ptr <= UINT32_MAX);
        -:  199:#else /* !JERRY_CPOINTER_32_BIT */
        -:  200:  JERRY_ASSERT (uint_ptr <= UINT16_MAX);
        -:  201:#endif /* JERRY_CPOINTER_32_BIT */
        -:  202:  JERRY_ASSERT (uint_ptr != JMEM_CP_NULL);
        -:  203:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY && JERRY_CPOINTER_32_BIT */
        -:  204:
      163:  205:  return (jmem_cpointer_t) uint_ptr;
        -:  206:} /* jmem_compress_pointer */
        -:  207:
        -:  208:/**
        -:  209: * Decompress pointer
        -:  210: *
        -:  211: * @return unpacked pointer
        -:  212: */
        -:  213:extern inline void *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
      347:  214:jmem_decompress_pointer (uintptr_t compressed_pointer) /**< pointer to decompress */
        -:  215:{
      347:  216:  JERRY_ASSERT (compressed_pointer != JMEM_CP_NULL);
        -:  217:
      347:  218:  uintptr_t uint_ptr = compressed_pointer;
        -:  219:
        -:  220:  JERRY_ASSERT (((jmem_cpointer_t) uint_ptr) == uint_ptr);
        -:  221:
        -:  222:#if defined(ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY) && JERRY_CPOINTER_32_BIT
      347:  223:  JERRY_ASSERT (uint_ptr % JMEM_ALIGNMENT == 0);
        -:  224:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY || !JERRY_CPOINTER_32_BIT */
    #####:  225:  const uintptr_t heap_start = (uintptr_t) &JERRY_HEAP_CONTEXT (first);
        -:  226:
    #####:  227:  uint_ptr <<= JMEM_ALIGNMENT_LOG;
    #####:  228:  uint_ptr += heap_start;
        -:  229:
        -:  230:  JERRY_ASSERT (jmem_is_heap_pointer ((void *) uint_ptr));
        -:  231:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY && JERRY_CPOINTER_32_BIT */
        -:  232:
      347:  233:  return (void *) uint_ptr;
        -:  234:} /* jmem_decompress_pointer */
