        -:    0:Source:/home/workspace/jerry-math/log.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: *
        -:   15: * This file is based on work under the following copyright and permission
        -:   16: * notice:
        -:   17: *
        -:   18: *     Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
        -:   19: *
        -:   20: *     Developed at SunSoft, a Sun Microsystems, Inc. business.
        -:   21: *     Permission to use, copy, modify, and distribute this
        -:   22: *     software is freely granted, provided that this notice
        -:   23: *     is preserved.
        -:   24: *
        -:   25: *     @(#)e_log.c 1.3 95/01/18
        -:   26: */
        -:   27:
        -:   28:#include "jerry-math-internal.h"
        -:   29:
        -:   30:/* log(x)
        -:   31: * Return the logrithm of x
        -:   32: *
        -:   33: * Method :
        -:   34: *   1. Argument Reduction: find k and f such that
        -:   35: *                      x = 2^k * (1+f),
        -:   36: *         where  sqrt(2)/2 < 1+f < sqrt(2) .
        -:   37: *
        -:   38: *   2. Approximation of log(1+f).
        -:   39: *      Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
        -:   40: *               = 2s + 2/3 s**3 + 2/5 s**5 + .....,
        -:   41: *               = 2s + s*R
        -:   42: *      We use a special Reme algorithm on [0,0.1716] to generate
        -:   43: *      a polynomial of degree 14 to approximate R The maximum error
        -:   44: *      of this polynomial approximation is bounded by 2**-58.45. In
        -:   45: *      other words,
        -:   46: *                      2      4      6      8      10      12      14
        -:   47: *          R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
        -:   48: *      (the values of Lg1 to Lg7 are listed in the program)
        -:   49: *      and
        -:   50: *          |      2          14          |     -58.45
        -:   51: *          | Lg1*s +...+Lg7*s    -  R(z) | <= 2
        -:   52: *          |                             |
        -:   53: *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
        -:   54: *      In order to guarantee error in log below 1ulp, we compute log
        -:   55: *      by
        -:   56: *              log(1+f) = f - s*(f - R)                (if f is not too large)
        -:   57: *              log(1+f) = f - (hfsq - s*(hfsq+R)).     (better accuracy)
        -:   58: *
        -:   59: *      3. Finally,  log(x) = k*ln2 + log(1+f).
        -:   60: *                          = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
        -:   61: *         Here ln2 is split into two floating point number:
        -:   62: *                      ln2_hi + ln2_lo,
        -:   63: *         where n*ln2_hi is always exact for |n| < 2000.
        -:   64: *
        -:   65: * Special cases:
        -:   66: *      log(x) is NaN with signal if x < 0 (including -INF) ;
        -:   67: *      log(+INF) is +INF; log(0) is -INF with signal;
        -:   68: *      log(NaN) is that NaN with no signal.
        -:   69: *
        -:   70: * Accuracy:
        -:   71: *      according to an error analysis, the error is always less than
        -:   72: *      1 ulp (unit in the last place).
        -:   73: *
        -:   74: * Constants:
        -:   75: * The hexadecimal values are the intended ones for the following
        -:   76: * constants. The decimal values may be used, provided that the
        -:   77: * compiler will convert from decimal to binary accurately enough
        -:   78: * to produce the hexadecimal values shown.
        -:   79: */
        -:   80:
        -:   81:#define zero   0.0
        -:   82:#define ln2_hi 6.93147180369123816490e-01 /* 3fe62e42 fee00000 */
        -:   83:#define ln2_lo 1.90821492927058770002e-10 /* 3dea39ef 35793c76 */
        -:   84:#define two54  1.80143985094819840000e+16 /* 43500000 00000000 */
        -:   85:#define Lg1    6.666666666666735130e-01 /* 3FE55555 55555593 */
        -:   86:#define Lg2    3.999999999940941908e-01 /* 3FD99999 9997FA04 */
        -:   87:#define Lg3    2.857142874366239149e-01 /* 3FD24924 94229359 */
        -:   88:#define Lg4    2.222219843214978396e-01 /* 3FCC71C5 1D8E78AF */
        -:   89:#define Lg5    1.818357216161805012e-01 /* 3FC74664 96CB03DE */
        -:   90:#define Lg6    1.531383769920937332e-01 /* 3FC39A09 D078C69F */
        -:   91:#define Lg7    1.479819860511658591e-01 /* 3FC2F112 DF3E5244 */
        -:   92:
        -:   93:double
    #####:   94:log (double x)
        -:   95:{
        -:   96:  double hfsq, f, s, z, R, w, t1, t2, dk;
        -:   97:  int k, hx, i, j;
        -:   98:  unsigned lx;
        -:   99:
    #####:  100:  hx = __HI (x); /* high word of x */
    #####:  101:  lx = __LO (x); /* low  word of x */
        -:  102:
    #####:  103:  k = 0;
    #####:  104:  if (hx < 0x00100000) /* x < 2**-1022  */
        -:  105:  {
    #####:  106:    if (((hx & 0x7fffffff) | lx) == 0) /* log(+-0) = -inf */
        -:  107:    {
    #####:  108:      return -INFINITY;
        -:  109:    }
    #####:  110:    if (hx < 0) /* log(-#) = NaN */
        -:  111:    {
    #####:  112:      return NAN;
        -:  113:    }
    #####:  114:    k -= 54;
    #####:  115:    x *= two54; /* subnormal number, scale up x */
    #####:  116:    hx = __HI (x); /* high word of x */
        -:  117:  }
    #####:  118:  if (hx >= 0x7ff00000)
        -:  119:  {
    #####:  120:    return x + x;
        -:  121:  }
    #####:  122:  k += (hx >> 20) - 1023;
    #####:  123:  hx &= 0x000fffff;
    #####:  124:  i = (hx + 0x95f64) & 0x100000;
        -:  125:
        -:  126:  double_accessor temp;
    #####:  127:  temp.dbl = x;
    #####:  128:  temp.as_int.hi = hx | (i ^ 0x3ff00000); /* normalize x or x / 2 */
    #####:  129:  k += (i >> 20);
    #####:  130:  f = temp.dbl - 1.0;
        -:  131:
    #####:  132:  if ((0x000fffff & (2 + hx)) < 3) /* |f| < 2**-20 */
        -:  133:  {
    #####:  134:    if (f == zero)
        -:  135:    {
    #####:  136:      if (k == 0)
        -:  137:      {
        -:  138:        return zero;
        -:  139:      }
        -:  140:      else
        -:  141:      {
    #####:  142:        dk = (double) k;
    #####:  143:        return dk * ln2_hi + dk * ln2_lo;
        -:  144:      }
        -:  145:    }
    #####:  146:    R = f * f * (0.5 - 0.33333333333333333 * f);
    #####:  147:    if (k == 0)
        -:  148:    {
    #####:  149:      return f - R;
        -:  150:    }
        -:  151:    else
        -:  152:    {
    #####:  153:      dk = (double) k;
    #####:  154:      return dk * ln2_hi - ((R - dk * ln2_lo) - f);
        -:  155:    }
        -:  156:  }
    #####:  157:  s = f / (2.0 + f);
    #####:  158:  dk = (double) k;
    #####:  159:  z = s * s;
    #####:  160:  i = hx - 0x6147a;
    #####:  161:  w = z * z;
    #####:  162:  j = 0x6b851 - hx;
    #####:  163:  t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
    #####:  164:  t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
    #####:  165:  i |= j;
    #####:  166:  R = t2 + t1;
    #####:  167:  if (i > 0)
        -:  168:  {
    #####:  169:    hfsq = 0.5 * f * f;
    #####:  170:    if (k == 0)
        -:  171:    {
    #####:  172:      return f - (hfsq - s * (hfsq + R));
        -:  173:    }
        -:  174:    else
        -:  175:    {
    #####:  176:      return dk * ln2_hi - ((hfsq - (s * (hfsq + R) + dk * ln2_lo)) - f);
        -:  177:    }
        -:  178:  }
        -:  179:  else
        -:  180:  {
    #####:  181:    if (k == 0)
        -:  182:    {
    #####:  183:      return f - s * (f - R);
        -:  184:    }
        -:  185:    else
        -:  186:    {
    #####:  187:      return dk * ln2_hi - ((s * (f - R) - dk * ln2_lo) - f);
        -:  188:    }
        -:  189:  }
        -:  190:} /* log */
        -:  191:
        -:  192:#undef zero
        -:  193:#undef ln2_hi
        -:  194:#undef ln2_lo
        -:  195:#undef two54
        -:  196:#undef Lg1
        -:  197:#undef Lg2
        -:  198:#undef Lg3
        -:  199:#undef Lg4
        -:  200:#undef Lg5
        -:  201:#undef Lg6
        -:  202:#undef Lg7
