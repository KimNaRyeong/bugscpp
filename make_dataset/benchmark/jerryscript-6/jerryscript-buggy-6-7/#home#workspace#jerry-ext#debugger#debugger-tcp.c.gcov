        -:    0:Source:/home/workspace/jerry-ext/debugger/debugger-tcp.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript-debugger-transport.h"
        -:   17:
        -:   18:#include "jerryscript-ext/debugger.h"
        -:   19:#include "jext-common.h"
        -:   20:
        -:   21:#if defined(JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1)
        -:   22:
        -:   23:#include <errno.h>
        -:   24:
        -:   25:#ifdef _WIN32
        -:   26:#include <BaseTsd.h>
        -:   27:
        -:   28:#include <WS2tcpip.h>
        -:   29:#include <winsock2.h>
        -:   30:
        -:   31:/* On Windows the WSAEWOULDBLOCK value can be returned for non-blocking operations */
        -:   32:#define JERRYX_EWOULDBLOCK WSAEWOULDBLOCK
        -:   33:
        -:   34:/* On Windows the invalid socket's value of INVALID_SOCKET */
        -:   35:#define JERRYX_SOCKET_INVALID INVALID_SOCKET
        -:   36:
        -:   37:/*
        -:   38: * On Windows, socket functions have the following signatures:
        -:   39: * int send(SOCKET s, const char *buf, int len, int flags);
        -:   40: * int recv(SOCKET s, char *buf, int len, int flags);
        -:   41: * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
        -:   42: */
        -:   43:typedef int jerryx_socket_ssize_t;
        -:   44:typedef SOCKET jerryx_socket_t;
        -:   45:typedef char jerryx_socket_void_t;
        -:   46:typedef int jerryx_socket_size_t;
        -:   47:#else /* !_WIN32 */
        -:   48:#include <fcntl.h>
        -:   49:#include <unistd.h>
        -:   50:
        -:   51:#include <arpa/inet.h>
        -:   52:#include <sys/socket.h>
        -:   53:
        -:   54:/* On *nix the EWOULDBLOCK errno value can be returned for non-blocking operations */
        -:   55:#define JERRYX_EWOULDBLOCK    EWOULDBLOCK
        -:   56:
        -:   57:/* On *nix the invalid socket has a value of -1 */
        -:   58:#define JERRYX_SOCKET_INVALID (-1)
        -:   59:
        -:   60:/*
        -:   61: * On *nix, socket functions have the following signatures:
        -:   62: * ssize_t send(int sockfd, const void *buf, size_t len, int flags);
        -:   63: * ssize_t recv(int sockfd, void *buf, size_t len, int flags);
        -:   64: * int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
        -:   65: */
        -:   66:typedef ssize_t jerryx_socket_ssize_t;
        -:   67:typedef int jerryx_socket_t;
        -:   68:typedef void jerryx_socket_void_t;
        -:   69:typedef size_t jerryx_socket_size_t;
        -:   70:#endif /* _WIN32 */
        -:   71:
        -:   72:/**
        -:   73: * Implementation of transport over tcp/ip.
        -:   74: */
        -:   75:typedef struct
        -:   76:{
        -:   77:  jerry_debugger_transport_header_t header; /**< transport header */
        -:   78:  jerryx_socket_t tcp_socket; /**< tcp socket */
        -:   79:} jerryx_debugger_transport_tcp_t;
        -:   80:
        -:   81:/**
        -:   82: * Get the network error value.
        -:   83: *
        -:   84: * On Windows this returns the result of the `WSAGetLastError ()` call and
        -:   85: * on any other system the `errno` value.
        -:   86: *
        -:   87: *
        -:   88: * @return last error value.
        -:   89: */
        -:   90:static inline int
        -:   91:jerryx_debugger_tcp_get_errno (void)
        -:   92:{
        -:   93:#ifdef _WIN32
        -:   94:  return WSAGetLastError ();
        -:   95:#else /* !_WIN32 */
        -:   96:  return errno;
        -:   97:#endif /* _WIN32 */
        -:   98:} /* jerryx_debugger_tcp_get_errno */
        -:   99:
        -:  100:/**
        -:  101: * Correctly close a single socket.
        -:  102: */
        -:  103:static inline void
        -:  104:jerryx_debugger_tcp_close_socket (jerryx_socket_t socket_id) /**< socket to close */
        -:  105:{
        -:  106:#ifdef _WIN32
        -:  107:  closesocket (socket_id);
        -:  108:#else /* !_WIN32 */
        -:  109:  close (socket_id);
        -:  110:#endif /* _WIN32 */
        -:  111:} /* jerryx_debugger_tcp_close_socket */
        -:  112:
        -:  113:/**
        -:  114: * Log tcp error message.
        -:  115: */
        -:  116:static void
        -:  117:jerryx_debugger_tcp_log_error (int errno_value) /**< error value to log */
        -:  118:{
        -:  119:  if (errno_value == 0)
        -:  120:  {
        -:  121:    return;
        -:  122:  }
        -:  123:
        -:  124:#ifdef _WIN32
        -:  125:  char *error_message = NULL;
        -:  126:  FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        -:  127:                 NULL,
        -:  128:                 (DWORD) errno_value,
        -:  129:                 MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
        -:  130:                 (LPTSTR) &error_message,
        -:  131:                 0,
        -:  132:                 NULL);
        -:  133:  jerry_port_log (JERRY_LOG_LEVEL_ERROR, "TCP Error: %s\n", error_message);
        -:  134:  LocalFree (error_message);
        -:  135:#else /* !_WIN32 */
        -:  136:  jerry_port_log (JERRY_LOG_LEVEL_ERROR, "TCP Error: %s\n", strerror (errno_value));
        -:  137:#endif /* _WIN32 */
        -:  138:} /* jerryx_debugger_tcp_log_error */
        -:  139:
        -:  140:/**
        -:  141: * Close a tcp connection.
        -:  142: */
        -:  143:static void
        -:  144:jerryx_debugger_tcp_close (jerry_debugger_transport_header_t *header_p) /**< tcp implementation */
        -:  145:{
        -:  146:  JERRYX_ASSERT (!jerry_debugger_transport_is_connected ());
        -:  147:
        -:  148:  jerryx_debugger_transport_tcp_t *tcp_p = (jerryx_debugger_transport_tcp_t *) header_p;
        -:  149:
        -:  150:  JERRYX_DEBUG_MSG ("TCP connection closed.\n");
        -:  151:
        -:  152:  jerryx_debugger_tcp_close_socket (tcp_p->tcp_socket);
        -:  153:
        -:  154:  jerry_heap_free ((void *) header_p, sizeof (jerryx_debugger_transport_tcp_t));
        -:  155:} /* jerryx_debugger_tcp_close */
        -:  156:
        -:  157:/**
        -:  158: * Send data over a tcp connection.
        -:  159: *
        -:  160: * @return true - if the data has been sent successfully
        -:  161: *         false - otherwise
        -:  162: */
        -:  163:static bool
        -:  164:jerryx_debugger_tcp_send (jerry_debugger_transport_header_t *header_p, /**< tcp implementation */
        -:  165:                          uint8_t *message_p, /**< message to be sent */
        -:  166:                          size_t message_length) /**< message length in bytes */
        -:  167:{
        -:  168:  JERRYX_ASSERT (jerry_debugger_transport_is_connected ());
        -:  169:
        -:  170:  jerryx_debugger_transport_tcp_t *tcp_p = (jerryx_debugger_transport_tcp_t *) header_p;
        -:  171:  jerryx_socket_size_t remaining_bytes = (jerryx_socket_size_t) message_length;
        -:  172:
        -:  173:  do
        -:  174:  {
        -:  175:#ifdef __linux__
        -:  176:    ssize_t is_err = recv (tcp_p->tcp_socket, NULL, 0, MSG_PEEK);
        -:  177:
        -:  178:    if (is_err == 0 && errno != JERRYX_EWOULDBLOCK)
        -:  179:    {
        -:  180:      int err_val = errno;
        -:  181:      jerry_debugger_transport_close ();
        -:  182:      jerryx_debugger_tcp_log_error (err_val);
        -:  183:      return false;
        -:  184:    }
        -:  185:#endif /* __linux__ */
        -:  186:
        -:  187:    jerryx_socket_ssize_t sent_bytes = send (tcp_p->tcp_socket, (jerryx_socket_void_t *) message_p, remaining_bytes, 0);
        -:  188:
        -:  189:    if (sent_bytes < 0)
        -:  190:    {
        -:  191:      int err_val = jerryx_debugger_tcp_get_errno ();
        -:  192:
        -:  193:      if (err_val == JERRYX_EWOULDBLOCK)
        -:  194:      {
        -:  195:        continue;
        -:  196:      }
        -:  197:
        -:  198:      jerry_debugger_transport_close ();
        -:  199:      jerryx_debugger_tcp_log_error (err_val);
        -:  200:      return false;
        -:  201:    }
        -:  202:
        -:  203:    message_p += sent_bytes;
        -:  204:    remaining_bytes -= (jerryx_socket_size_t) sent_bytes;
        -:  205:  } while (remaining_bytes > 0);
        -:  206:
        -:  207:  return true;
        -:  208:} /* jerryx_debugger_tcp_send */
        -:  209:
        -:  210:/**
        -:  211: * Receive data from a tcp connection.
        -:  212: */
        -:  213:static bool
        -:  214:jerryx_debugger_tcp_receive (jerry_debugger_transport_header_t *header_p, /**< tcp implementation */
        -:  215:                             jerry_debugger_transport_receive_context_t *receive_context_p) /**< receive context */
        -:  216:{
        -:  217:  jerryx_debugger_transport_tcp_t *tcp_p = (jerryx_debugger_transport_tcp_t *) header_p;
        -:  218:
        -:  219:  jerryx_socket_void_t *buffer_p =
        -:  220:    (jerryx_socket_void_t *) (receive_context_p->buffer_p + receive_context_p->received_length);
        -:  221:  jerryx_socket_size_t buffer_size =
        -:  222:    (jerryx_socket_size_t) (JERRY_DEBUGGER_TRANSPORT_MAX_BUFFER_SIZE - receive_context_p->received_length);
        -:  223:
        -:  224:  jerryx_socket_ssize_t length = recv (tcp_p->tcp_socket, buffer_p, buffer_size, 0);
        -:  225:
        -:  226:  if (length <= 0)
        -:  227:  {
        -:  228:    int err_val = jerryx_debugger_tcp_get_errno ();
        -:  229:
        -:  230:    if (err_val != JERRYX_EWOULDBLOCK || length == 0)
        -:  231:    {
        -:  232:      jerry_debugger_transport_close ();
        -:  233:      jerryx_debugger_tcp_log_error (err_val);
        -:  234:      return false;
        -:  235:    }
        -:  236:    length = 0;
        -:  237:  }
        -:  238:
        -:  239:  receive_context_p->received_length += (size_t) length;
        -:  240:
        -:  241:  if (receive_context_p->received_length > 0)
        -:  242:  {
        -:  243:    receive_context_p->message_p = receive_context_p->buffer_p;
        -:  244:    receive_context_p->message_length = receive_context_p->received_length;
        -:  245:  }
        -:  246:
        -:  247:  return true;
        -:  248:} /* jerryx_debugger_tcp_receive */
        -:  249:
        -:  250:/**
        -:  251: * Utility method to prepare the server socket to accept connections.
        -:  252: *
        -:  253: * The following steps are performed:
        -:  254: *  * Configure address re-use.
        -:  255: *  * Bind the socket to the given port
        -:  256: *  * Start listening on the socket.
        -:  257: *
        -:  258: * @return true if everything is ok
        -:  259: *         false if there was an error
        -:  260: */
        -:  261:static bool
        -:  262:jerryx_debugger_tcp_configure_socket (jerryx_socket_t server_socket, /** < socket to configure */
        -:  263:                                      uint16_t port) /** < port number to be used for the socket */
        -:  264:{
        -:  265:  struct sockaddr_in addr;
        -:  266:
        -:  267:  addr.sin_family = AF_INET;
        -:  268:  addr.sin_port = htons (port);
        -:  269:  addr.sin_addr.s_addr = INADDR_ANY;
        -:  270:
        -:  271:  const int opt_value = 1;
        -:  272:
        -:  273:  if (setsockopt (server_socket, SOL_SOCKET, SO_REUSEADDR, (const jerryx_socket_void_t *) &opt_value, sizeof (int))
        -:  274:      != 0)
        -:  275:  {
        -:  276:    return false;
        -:  277:  }
        -:  278:
        -:  279:  if (bind (server_socket, (struct sockaddr *) &addr, sizeof (struct sockaddr_in)) != 0)
        -:  280:  {
        -:  281:    return false;
        -:  282:  }
        -:  283:
        -:  284:  if (listen (server_socket, 1) != 0)
        -:  285:  {
        -:  286:    return false;
        -:  287:  }
        -:  288:
        -:  289:  return true;
        -:  290:} /* jerryx_debugger_tcp_configure_socket */
        -:  291:
        -:  292:/**
        -:  293: * Create a tcp connection.
        -:  294: *
        -:  295: * @return true if successful,
        -:  296: *         false otherwise
        -:  297: */
        -:  298:bool
        -:  299:jerryx_debugger_tcp_create (uint16_t port) /**< listening port */
        -:  300:{
        -:  301:#ifdef _WIN32
        -:  302:  WSADATA wsaData;
        -:  303:  int wsa_init_status = WSAStartup (MAKEWORD (2, 2), &wsaData);
        -:  304:  if (wsa_init_status != NO_ERROR)
        -:  305:  {
        -:  306:    JERRYX_ERROR_MSG ("WSA Error: %d\n", wsa_init_status);
        -:  307:    return false;
        -:  308:  }
        -:  309:#endif /* _WIN32*/
        -:  310:
        -:  311:  jerryx_socket_t server_socket = socket (AF_INET, SOCK_STREAM, 0);
        -:  312:  if (server_socket == JERRYX_SOCKET_INVALID)
        -:  313:  {
        -:  314:    jerryx_debugger_tcp_log_error (jerryx_debugger_tcp_get_errno ());
        -:  315:    return false;
        -:  316:  }
        -:  317:
        -:  318:  if (!jerryx_debugger_tcp_configure_socket (server_socket, port))
        -:  319:  {
        -:  320:    int error = jerryx_debugger_tcp_get_errno ();
        -:  321:    jerryx_debugger_tcp_close_socket (server_socket);
        -:  322:    jerryx_debugger_tcp_log_error (error);
        -:  323:    return false;
        -:  324:  }
        -:  325:
        -:  326:  JERRYX_DEBUG_MSG ("Waiting for client connection\n");
        -:  327:
        -:  328:  struct sockaddr_in addr;
        -:  329:  socklen_t sin_size = sizeof (struct sockaddr_in);
        -:  330:
        -:  331:  jerryx_socket_t tcp_socket = accept (server_socket, (struct sockaddr *) &addr, &sin_size);
        -:  332:
        -:  333:  jerryx_debugger_tcp_close_socket (server_socket);
        -:  334:
        -:  335:  if (tcp_socket == JERRYX_SOCKET_INVALID)
        -:  336:  {
        -:  337:    jerryx_debugger_tcp_log_error (jerryx_debugger_tcp_get_errno ());
        -:  338:    return false;
        -:  339:  }
        -:  340:
        -:  341:  /* Set non-blocking mode. */
        -:  342:#ifdef _WIN32
        -:  343:  u_long nonblocking_enabled = 1;
        -:  344:  if (ioctlsocket (tcp_socket, (long) FIONBIO, &nonblocking_enabled) != NO_ERROR)
        -:  345:  {
        -:  346:    jerryx_debugger_tcp_close_socket (tcp_socket);
        -:  347:    return false;
        -:  348:  }
        -:  349:#else /* !_WIN32 */
        -:  350:  int socket_flags = fcntl (tcp_socket, F_GETFL, 0);
        -:  351:
        -:  352:  if (socket_flags < 0)
        -:  353:  {
        -:  354:    close (tcp_socket);
        -:  355:    return false;
        -:  356:  }
        -:  357:
        -:  358:  if (fcntl (tcp_socket, F_SETFL, socket_flags | O_NONBLOCK) == -1)
        -:  359:  {
        -:  360:    close (tcp_socket);
        -:  361:    return false;
        -:  362:  }
        -:  363:#endif /* _WIN32 */
        -:  364:
        -:  365:  JERRYX_DEBUG_MSG ("Connected from: %s\n", inet_ntoa (addr.sin_addr));
        -:  366:
        -:  367:  jerry_size_t size = sizeof (jerryx_debugger_transport_tcp_t);
        -:  368:
        -:  369:  jerry_debugger_transport_header_t *header_p;
        -:  370:  header_p = (jerry_debugger_transport_header_t *) jerry_heap_alloc (size);
        -:  371:
        -:  372:  if (!header_p)
        -:  373:  {
        -:  374:    jerryx_debugger_tcp_close_socket (tcp_socket);
        -:  375:    return false;
        -:  376:  }
        -:  377:
        -:  378:  header_p->close = jerryx_debugger_tcp_close;
        -:  379:  header_p->send = jerryx_debugger_tcp_send;
        -:  380:  header_p->receive = jerryx_debugger_tcp_receive;
        -:  381:
        -:  382:  ((jerryx_debugger_transport_tcp_t *) header_p)->tcp_socket = tcp_socket;
        -:  383:
        -:  384:  jerry_debugger_transport_add (header_p,
        -:  385:                                0,
        -:  386:                                JERRY_DEBUGGER_TRANSPORT_MAX_BUFFER_SIZE,
        -:  387:                                0,
        -:  388:                                JERRY_DEBUGGER_TRANSPORT_MAX_BUFFER_SIZE);
        -:  389:
        -:  390:  return true;
        -:  391:} /* jerryx_debugger_tcp_create */
        -:  392:
        -:  393:#else /* !(defined (JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1)) */
        -:  394:
        -:  395:/**
        -:  396: * Dummy function when debugger is disabled.
        -:  397: *
        -:  398: * @return false
        -:  399: */
        -:  400:bool
    #####:  401:jerryx_debugger_tcp_create (uint16_t port)
        -:  402:{
        -:  403:  JERRYX_UNUSED (port);
    #####:  404:  return false;
        -:  405:} /* jerryx_debugger_tcp_create */
        -:  406:
        -:  407:#endif /* defined (JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1) */
