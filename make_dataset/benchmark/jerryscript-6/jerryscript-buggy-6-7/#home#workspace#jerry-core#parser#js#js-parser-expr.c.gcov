        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-expr.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if JERRY_PARSER
        -:   19:#include "ecma-helpers.h"
        -:   20:
        -:   21:#include "jcontext.h"
        -:   22:#include "js-parser-tagged-template-literal.h"
        -:   23:#include "lit-char-helpers.h"
        -:   24:
        -:   25:/** \addtogroup parser Parser
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser JavaScript
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup jsparser_expr Expression parser
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/**
        -:   36: * Maximum precedence for right-to-left binary operation evaluation.
        -:   37: */
        -:   38:#define PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE 7
        -:   39:
        -:   40:/**
        -:   41: * Precedence for ternary operation.
        -:   42: */
        -:   43:#define PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE 4
        -:   44:
        -:   45:/**
        -:   46: * Precedence for exponentiation operation.
        -:   47: */
        -:   48:#define PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION 16
        -:   49:
        -:   50:/**
        -:   51: * Value of grouping level increase and decrease.
        -:   52: */
        -:   53:#define PARSER_GROUPING_LEVEL_INCREASE 2
        -:   54:
        -:   55:/**
        -:   56: * Precedence of the binary tokens.
        -:   57: *
        -:   58: * See also:
        -:   59: *    lexer_token_type_t
        -:   60: */
        -:   61:static const uint8_t parser_binary_precedence_table[] = {
        -:   62:  3, /**< "=" */
        -:   63:  3, /**< "+=" */
        -:   64:  3, /**< "-=" */
        -:   65:  3, /**< "*=" */
        -:   66:  3, /**< "/=" */
        -:   67:  3, /**< "=" */
        -:   68:  3, /**< "<<=" */
        -:   69:  3, /**< ">>=" */
        -:   70:  3, /**< ">>>=" */
        -:   71:  3, /**< "&=" */
        -:   72:  3, /**< "|=" */
        -:   73:  3, /**< "^=" */
        -:   74:#if JERRY_ESNEXT
        -:   75:  3, /**< "**=" */
        -:   76:  3, /**< "??=" */
        -:   77:  3, /**< "||=" */
        -:   78:  3, /**< "&&=" */
        -:   79:#endif /* JERRY_ESNEXT */
        -:   80:  4, /**< "?"*/
        -:   81:#if JERRY_ESNEXT
        -:   82:  5, /**< "??" */
        -:   83:#endif /* JERRY_ESNEXT */
        -:   84:  6, /**< "||" */
        -:   85:  7, /**< "&&" */
        -:   86:  8, /**< "|" */
        -:   87:  9, /**< "^" */
        -:   88:  10, /**< "&" */
        -:   89:  11, /**< "==" */
        -:   90:  11, /**< "!=" */
        -:   91:  11, /**< "===" */
        -:   92:  11, /**< "!==" */
        -:   93:  12, /**< "<" */
        -:   94:  12, /**< ">" */
        -:   95:  12, /**< "<=" */
        -:   96:  12, /**< ">=" */
        -:   97:  12, /**< in */
        -:   98:  12, /**< instanceof */
        -:   99:  13, /**< "<<" */
        -:  100:  13, /**< ">>" */
        -:  101:  13, /**< ">>>" */
        -:  102:  14, /**< "+" */
        -:  103:  14, /**< "-" */
        -:  104:  15, /**< "*" */
        -:  105:  15, /**< "/" */
        -:  106:  15, /**< "%" */
        -:  107:#if JERRY_ESNEXT
        -:  108:  16, /**< "**" */
        -:  109:#endif /* JERRY_ESNEXT */
        -:  110:};
        -:  111:
        -:  112:#if JERRY_ESNEXT
        -:  113:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 42,
        -:  114:                     parser_binary_precedence_table_should_have_39_values_in_es2015);
        -:  115:#else /* !JERRY_ESNEXT */
        -:  116:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 36,
        -:  117:                     parser_binary_precedence_table_should_have_36_values_in_es51);
        -:  118:#endif /* JERRY_ESNEXT */
        -:  119:
        -:  120:/**
        -:  121: * Generate byte code for operators with lvalue.
        -:  122: */
        -:  123:static inline void
       11:  124:parser_push_result (parser_context_t *context_p) /**< context */
        -:  125:{
       11:  126:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -:  127:  {
    #####:  128:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 1));
        -:  129:
    #####:  130:    if ((context_p->last_cbc_opcode == CBC_POST_INCR || context_p->last_cbc_opcode == CBC_POST_DECR)
    #####:  131:        && context_p->stack_depth >= context_p->stack_limit)
        -:  132:    {
        -:  133:      /* Stack limit is increased for CBC_POST_INCR_PUSH_RESULT
        -:  134:       * and CBC_POST_DECR_PUSH_RESULT opcodes. Needed by vm.c. */
    #####:  135:      JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -:  136:
    #####:  137:      context_p->stack_limit++;
        -:  138:
    #####:  139:      if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  140:      {
    #####:  141:        parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  142:      }
        -:  143:    }
        -:  144:
    #####:  145:    context_p->last_cbc_opcode++;
    #####:  146:    parser_flush_cbc (context_p);
        -:  147:  }
       11:  148:} /* parser_push_result */
        -:  149:
        -:  150:/**
        -:  151: * Check for invalid assignment for "eval" and "arguments"
        -:  152: */
        -:  153:static void
    #####:  154:parser_check_invalid_assign (parser_context_t *context_p) /**< context */
        -:  155:{
    #####:  156:  JERRY_ASSERT (context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL);
        -:  157:
    #####:  158:  if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  159:  {
    #####:  160:    if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL)
        -:  161:    {
    #####:  162:      parser_raise_error (context_p, PARSER_ERR_EVAL_CANNOT_ASSIGNED);
        -:  163:    }
    #####:  164:    else if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_ARGUMENTS)
        -:  165:    {
    #####:  166:      parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_CANNOT_ASSIGNED);
        -:  167:    }
        -:  168:  }
    #####:  169:} /* parser_check_invalid_assign */
        -:  170:
        -:  171:#if JERRY_ESNEXT
        -:  172:
        -:  173:/**
        -:  174: * Check and throw an error if the "new.target" is invalid as a left-hand side expression.
        -:  175: */
        -:  176:static void
    #####:  177:parser_check_invalid_new_target (parser_context_t *context_p, /**< parser context */
        -:  178:                                 cbc_opcode_t opcode) /**< current opcode under parsing */
        -:  179:{
        -:  180:  /* new.target is an invalid left-hand side target */
    #####:  181:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NEW_TARGET))
        -:  182:  {
        -:  183:    /* Make sure that the call side is a post/pre increment or an assignment expression.
        -:  184:     * There should be no other ways the "new.target" expression should be here. */
    #####:  185:    JERRY_ASSERT (
        -:  186:      (opcode >= CBC_PRE_INCR && opcode <= CBC_POST_DECR)
        -:  187:      || (opcode == CBC_ASSIGN
        -:  188:          && (context_p->token.type == LEXER_ASSIGN || LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->token.type))));
        -:  189:
    #####:  190:    parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -:  191:  }
    #####:  192:} /* parser_check_invalid_new_target */
        -:  193:
        -:  194:#endif /* JERRY_ESNEXT */
        -:  195:
        -:  196:/**
        -:  197: * Emit identifier reference
        -:  198: */
        -:  199:static void
    #####:  200:parser_emit_ident_reference (parser_context_t *context_p, /**< context */
        -:  201:                             uint16_t opcode) /* opcode */
        -:  202:{
    #####:  203:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -:  204:  {
    #####:  205:    context_p->last_cbc_opcode = opcode;
    #####:  206:    return;
        -:  207:  }
        -:  208:
        -:  209:  uint16_t literal_index;
        -:  210:
    #####:  211:  if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -:  212:  {
    #####:  213:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  214:    literal_index = context_p->last_cbc.value;
        -:  215:  }
    #####:  216:  else if (context_p->last_cbc_opcode == CBC_PUSH_THIS_LITERAL)
        -:  217:  {
    #####:  218:    context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####:  219:    literal_index = context_p->last_cbc.literal_index;
        -:  220:  }
        -:  221:  else
        -:  222:  {
    #####:  223:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####:  224:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####:  225:    literal_index = context_p->last_cbc.third_literal_index;
        -:  226:  }
        -:  227:
    #####:  228:  parser_emit_cbc_literal (context_p, opcode, literal_index);
        -:  229:} /* parser_emit_ident_reference */
        -:  230:
        -:  231:/**
        -:  232: * Generate byte code for operators with lvalue.
        -:  233: */
        -:  234:static void
    #####:  235:parser_emit_unary_lvalue_opcode (parser_context_t *context_p, /**< context */
        -:  236:                                 cbc_opcode_t opcode) /**< opcode */
        -:  237:{
    #####:  238:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####:  239:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -:  240:  {
    #####:  241:    parser_check_invalid_assign (context_p);
        -:  242:
        -:  243:    uint16_t unary_opcode;
        -:  244:
    #####:  245:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  246:    {
    #####:  247:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  248:      {
    #####:  249:        parser_raise_error (context_p, PARSER_ERR_DELETE_IDENT_NOT_ALLOWED);
        -:  250:      }
        -:  251:
    #####:  252:      unary_opcode = CBC_DELETE_IDENT_PUSH_RESULT;
        -:  253:    }
        -:  254:    else
        -:  255:    {
    #####:  256:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, opcode + CBC_UNARY_LVALUE_WITH_IDENT));
    #####:  257:      unary_opcode = (uint16_t) (opcode + CBC_UNARY_LVALUE_WITH_IDENT);
        -:  258:    }
        -:  259:
    #####:  260:    parser_emit_ident_reference (context_p, unary_opcode);
        -:  261:
        -:  262:#if JERRY_ESNEXT
    #####:  263:    if (unary_opcode != CBC_DELETE_IDENT_PUSH_RESULT
    #####:  264:        && scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -:  265:    {
        -:  266:      /* The current value must be read, but it cannot be changed. */
    #####:  267:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  268:      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -:  269:    }
        -:  270:#endif /* JERRY_ESNEXT */
    #####:  271:    return;
        -:  272:  }
        -:  273:
    #####:  274:  if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -:  275:  {
    #####:  276:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, opcode));
    #####:  277:    context_p->last_cbc_opcode = (uint16_t) opcode;
    #####:  278:    return;
        -:  279:  }
        -:  280:
    #####:  281:  if (PARSER_IS_PUSH_PROP_LITERAL (context_p->last_cbc_opcode))
        -:  282:  {
    #####:  283:    context_p->last_cbc_opcode = PARSER_PUSH_PROP_LITERAL_TO_PUSH_LITERAL (context_p->last_cbc_opcode);
        -:  284:  }
        -:  285:  else
        -:  286:  {
        -:  287:    /* Invalid LeftHandSide expression. */
    #####:  288:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  289:    {
        -:  290:#if JERRY_ESNEXT
    #####:  291:      if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL))
        -:  292:      {
    #####:  293:        parser_raise_error (context_p, PARSER_ERR_DELETE_PRIVATE_FIELD);
        -:  294:      }
        -:  295:
    #####:  296:      if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL)
    #####:  297:          || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -:  298:      {
    #####:  299:        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
    #####:  300:        parser_emit_cbc (context_p, CBC_POP);
    #####:  301:        return;
        -:  302:      }
        -:  303:#endif /* JERRY_ESNEXT */
    #####:  304:      parser_emit_cbc (context_p, CBC_POP);
    #####:  305:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
    #####:  306:      return;
        -:  307:    }
        -:  308:
        -:  309:#if JERRY_ESNEXT
    #####:  310:    parser_check_invalid_new_target (context_p, opcode);
    #####:  311:    if (opcode == CBC_PRE_INCR || opcode == CBC_PRE_DECR)
        -:  312:    {
    #####:  313:      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_PREFIX_OP);
        -:  314:    }
        -:  315:    else
        -:  316:    {
    #####:  317:      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_POSTFIX_OP);
        -:  318:    }
        -:  319:#else /* JERRY_ESNEXT */
    #####:  320:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -:  321:#endif /* JERRY_ESNEXT */
        -:  322:  }
        -:  323:
    #####:  324:  parser_emit_cbc (context_p, (uint16_t) opcode);
        -:  325:} /* parser_emit_unary_lvalue_opcode */
        -:  326:
        -:  327:/**
        -:  328: * Parse array literal.
        -:  329: */
        -:  330:static void
    #####:  331:parser_parse_array_literal (parser_context_t *context_p) /**< context */
        -:  332:{
    #####:  333:  uint32_t pushed_items = 0;
    #####:  334:  uint16_t opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  335:
    #####:  336:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
        -:  337:
    #####:  338:  parser_emit_cbc (context_p, CBC_CREATE_ARRAY);
    #####:  339:  lexer_next_token (context_p);
        -:  340:
        -:  341:  while (true)
        -:  342:  {
    #####:  343:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  344:    {
    #####:  345:      if (pushed_items > 0)
        -:  346:      {
    #####:  347:        parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  348:      }
    #####:  349:      return;
        -:  350:    }
        -:  351:
    #####:  352:    pushed_items++;
        -:  353:
    #####:  354:    if (context_p->token.type == LEXER_COMMA)
        -:  355:    {
    #####:  356:      parser_emit_cbc (context_p, CBC_PUSH_ELISION);
    #####:  357:      lexer_next_token (context_p);
        -:  358:    }
        -:  359:    else
        -:  360:    {
        -:  361:#if JERRY_ESNEXT
    #####:  362:      if (context_p->token.type == LEXER_THREE_DOTS)
        -:  363:      {
    #####:  364:        opcode = (uint16_t) (PARSER_TO_EXT_OPCODE (CBC_EXT_SPREAD_ARRAY_APPEND));
    #####:  365:        pushed_items++;
    #####:  366:        lexer_next_token (context_p);
    #####:  367:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
        -:  368:      }
        -:  369:#endif /* JERRY_ESNEXT */
        -:  370:
    #####:  371:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -:  372:
    #####:  373:      if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -:  374:      {
    #####:  375:        parser_flush_cbc (context_p);
        -:  376:      }
        -:  377:
    #####:  378:      if (context_p->token.type == LEXER_COMMA)
        -:  379:      {
    #####:  380:        lexer_next_token (context_p);
        -:  381:      }
    #####:  382:      else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -:  383:      {
    #####:  384:        parser_raise_error (context_p, PARSER_ERR_ARRAY_ITEM_SEPARATOR_EXPECTED);
        -:  385:      }
        -:  386:    }
        -:  387:
    #####:  388:    if (pushed_items >= 64)
        -:  389:    {
    #####:  390:      parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  391:#if JERRY_ESNEXT
    #####:  392:      opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  393:#endif /* JERRY_ESNEXT */
    #####:  394:      pushed_items = 0;
        -:  395:    }
        -:  396:  }
        -:  397:} /* parser_parse_array_literal */
        -:  398:
        -:  399:#if !JERRY_ESNEXT
        -:  400:/**
        -:  401: * Object literal item types.
        -:  402: */
        -:  403:typedef enum
        -:  404:{
        -:  405:  PARSER_OBJECT_PROPERTY_START, /**< marks the start of the property list */
        -:  406:  PARSER_OBJECT_PROPERTY_VALUE, /**< value property */
        -:  407:  PARSER_OBJECT_PROPERTY_GETTER, /**< getter property */
        -:  408:  PARSER_OBJECT_PROPERTY_SETTER, /**< setter property */
        -:  409:  PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS, /**< both getter and setter properties are set */
        -:  410:} parser_object_literal_item_types_t;
        -:  411:
        -:  412:/**
        -:  413: * Parse object literal.
        -:  414: */
        -:  415:static void
    #####:  416:parser_append_object_literal_item (parser_context_t *context_p, /**< context */
        -:  417:                                   uint16_t item_index, /**< index of the item name */
        -:  418:                                   parser_object_literal_item_types_t item_type) /**< type of the item */
        -:  419:{
        -:  420:  parser_stack_iterator_t iterator;
        -:  421:  uint8_t *current_item_type_p;
        -:  422:
    #####:  423:  iterator.current_p = context_p->stack.first_p;
    #####:  424:  iterator.current_position = context_p->stack.last_position;
        -:  425:
        -:  426:  while (true)
        -:  427:  {
    #####:  428:    current_item_type_p = iterator.current_p->bytes + iterator.current_position - 1;
        -:  429:
    #####:  430:    if (*current_item_type_p == PARSER_OBJECT_PROPERTY_START)
        -:  431:    {
    #####:  432:      parser_stack_push_uint16 (context_p, item_index);
    #####:  433:      parser_stack_push_uint8 (context_p, (uint8_t) item_type);
    #####:  434:      return;
        -:  435:    }
        -:  436:
    #####:  437:    iterator.current_position--;
    #####:  438:    if (iterator.current_position == 0)
        -:  439:    {
    #####:  440:      iterator.current_p = iterator.current_p->next_p;
    #####:  441:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  442:    }
        -:  443:
    #####:  444:    uint32_t current_item_index = iterator.current_p->bytes[iterator.current_position - 1];
        -:  445:
    #####:  446:    iterator.current_position--;
    #####:  447:    if (iterator.current_position == 0)
        -:  448:    {
    #####:  449:      iterator.current_p = iterator.current_p->next_p;
    #####:  450:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  451:    }
        -:  452:
    #####:  453:    current_item_index |= ((uint32_t) iterator.current_p->bytes[iterator.current_position - 1]) << 8;
        -:  454:
    #####:  455:    iterator.current_position--;
    #####:  456:    if (iterator.current_position == 0)
        -:  457:    {
    #####:  458:      iterator.current_p = iterator.current_p->next_p;
    #####:  459:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  460:    }
        -:  461:
    #####:  462:    if (current_item_index == item_index)
        -:  463:    {
    #####:  464:      if (item_type == PARSER_OBJECT_PROPERTY_VALUE && *current_item_type_p == PARSER_OBJECT_PROPERTY_VALUE
    #####:  465:          && !(context_p->status_flags & PARSER_IS_STRICT))
        -:  466:      {
        -:  467:        return;
        -:  468:      }
        -:  469:
    #####:  470:      if (item_type == PARSER_OBJECT_PROPERTY_GETTER && *current_item_type_p == PARSER_OBJECT_PROPERTY_SETTER)
        -:  471:      {
        -:  472:        break;
        -:  473:      }
        -:  474:
    #####:  475:      if (item_type == PARSER_OBJECT_PROPERTY_SETTER && *current_item_type_p == PARSER_OBJECT_PROPERTY_GETTER)
        -:  476:      {
        -:  477:        break;
        -:  478:      }
        -:  479:
    #####:  480:      parser_raise_error (context_p, PARSER_ERR_OBJECT_PROPERTY_REDEFINED);
        -:  481:    }
        -:  482:  }
        -:  483:
    #####:  484:  uint8_t *last_page_p = context_p->stack.first_p->bytes;
        -:  485:
    #####:  486:  *current_item_type_p = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  487:
    #####:  488:  if (current_item_type_p == (last_page_p + context_p->stack.last_position - 1))
        -:  489:  {
    #####:  490:    context_p->stack_top_uint8 = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  491:  }
        -:  492:} /* parser_append_object_literal_item */
        -:  493:#endif /* !JERRY_ESNEXT */
        -:  494:
        -:  495:#if JERRY_ESNEXT
        -:  496:/** Forward definition of parse array initializer. */
        -:  497:static void parser_parse_array_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  498:
        -:  499:/** Forward definition of parse object initializer. */
        -:  500:static void parser_parse_object_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  501:
        -:  502:/**
        -:  503: * Class literal parsing options.
        -:  504: */
        -:  505:typedef enum
        -:  506:{
        -:  507:  PARSER_CLASS_LITERAL_NO_OPTS = 0, /**< no options are provided */
        -:  508:  PARSER_CLASS_LITERAL_CTOR_PRESENT = (1 << 0), /**< class constructor is present */
        -:  509:  PARSER_CLASS_LITERAL_HERTIAGE_PRESENT = (1 << 1), /**< class heritage is present */
        -:  510:} parser_class_literal_opts_t;
        -:  511:
        -:  512:/**
        -:  513: * Checks whether the current string or identifier literal is constructor
        -:  514: *
        -:  515: * @return true, if constructor and false otherwise
        -:  516: */
        -:  517:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  518:parser_is_constructor_literal (parser_context_t *context_p) /**< context */
        -:  519:{
    #####:  520:  return (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####:  521:          && lexer_compare_literal_to_string (context_p, "constructor", 11));
        -:  522:} /* parser_is_constructor_literal */
        -:  523:
        -:  524:/**
        -:  525: * Checks if current private field is already declared
        -:  526: */
        -:  527:static void
    #####:  528:parser_check_duplicated_private_field (parser_context_t *context_p, /**< context */
        -:  529:                                       uint8_t opts) /**< options */
        -:  530:{
    #####:  531:  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL);
    #####:  532:  JERRY_ASSERT (context_p->private_context_p);
    #####:  533:  scanner_class_private_member_t *iter = context_p->private_context_p->members_p;
        -:  534:
    #####:  535:  bool search_for_property = (opts & SCANNER_PRIVATE_FIELD_PROPERTY);
        -:  536:
    #####:  537:  while (iter != NULL)
        -:  538:  {
    #####:  539:    if (lexer_compare_identifiers (context_p, &context_p->token.lit_location, &iter->loc) && (iter->u8_arg & opts))
        -:  540:    {
    #####:  541:      if (iter->u8_arg & SCANNER_PRIVATE_FIELD_SEEN)
        -:  542:      {
    #####:  543:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PRIVATE_FIELD);
        -:  544:      }
        -:  545:
    #####:  546:      iter->u8_arg |= SCANNER_PRIVATE_FIELD_SEEN;
        -:  547:
    #####:  548:      if (!search_for_property)
        -:  549:      {
    #####:  550:        break;
        -:  551:      }
        -:  552:    }
        -:  553:
    #####:  554:    iter = iter->prev_p;
        -:  555:  }
    #####:  556:} /* parser_check_duplicated_private_field */
        -:  557:
        -:  558:/**
        -:  559: * Parse class literal.
        -:  560: *
        -:  561: * @return true - if the class has static fields, false - otherwise
        -:  562: */
        -:  563:static bool
    #####:  564:parser_parse_class_body (parser_context_t *context_p, /**< context */
        -:  565:                         parser_class_literal_opts_t opts, /**< class literal parsing options */
        -:  566:                         uint16_t class_name_index) /**< class literal index */
        -:  567:{
    #####:  568:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -:  569:
    #####:  570:  lexer_literal_t *ctor_literal_p = NULL;
    #####:  571:  lexer_literal_t *static_fields_literal_p = NULL;
        -:  572:
    #####:  573:  if (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT)
        -:  574:  {
    #####:  575:    ctor_literal_p = lexer_construct_unused_literal (context_p);
    #####:  576:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, (uint16_t) (context_p->literal_count++));
        -:  577:  }
    #####:  578:  else if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  579:  {
    #####:  580:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE);
        -:  581:  }
        -:  582:  else
        -:  583:  {
    #####:  584:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR);
        -:  585:  }
        -:  586:
    #####:  587:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -:  588:  {
    #####:  589:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, class_name_index);
        -:  590:  }
        -:  591:
    #####:  592:  parser_emit_cbc_ext (context_p, CBC_EXT_INIT_CLASS);
        -:  593:
    #####:  594:  bool is_static = false;
    #####:  595:  bool is_private = false;
    #####:  596:  size_t fields_size = 0;
    #####:  597:  uint32_t computed_field_count = 0;
        -:  598:
        -:  599:  while (true)
    #####:  600:  {
    #####:  601:    if (!is_static)
        -:  602:    {
    #####:  603:      lexer_skip_empty_statements (context_p);
        -:  604:    }
        -:  605:
    #####:  606:    uint32_t flags = (LEXER_OBJ_IDENT_CLASS_IDENTIFIER | LEXER_OBJ_IDENT_SET_FUNCTION_START);
        -:  607:
    #####:  608:    if (!is_static)
        -:  609:    {
    #####:  610:      flags |= LEXER_OBJ_IDENT_CLASS_NO_STATIC;
        -:  611:    }
        -:  612:
    #####:  613:    if (is_private)
        -:  614:    {
    #####:  615:      flags |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
        -:  616:    }
        -:  617:
    #####:  618:    lexer_expect_object_literal_id (context_p, flags);
        -:  619:
    #####:  620:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -:  621:    {
    #####:  622:      JERRY_ASSERT (!is_static);
    #####:  623:      break;
        -:  624:    }
        -:  625:
    #####:  626:    if (context_p->token.type == LEXER_HASHMARK)
        -:  627:    {
    #####:  628:      is_private = true;
    #####:  629:      lexer_next_token (context_p);
    #####:  630:      context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  631:      continue;
        -:  632:    }
        -:  633:
    #####:  634:    if (context_p->token.type == LEXER_KEYW_STATIC)
        -:  635:    {
    #####:  636:      JERRY_ASSERT (!is_static);
    #####:  637:      is_static = true;
    #####:  638:      continue;
        -:  639:    }
        -:  640:
    #####:  641:    if (is_private)
        -:  642:    {
    #####:  643:      parser_check_duplicated_private_field (context_p, SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER);
        -:  644:    }
        -:  645:
    #####:  646:    bool is_constructor_literal = context_p->token.type == LEXER_LITERAL && parser_is_constructor_literal (context_p);
        -:  647:
    #####:  648:    if (is_private && is_constructor_literal && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  649:    {
    #####:  650:      parser_raise_error (context_p, PARSER_ERR_CLASS_PRIVATE_CONSTRUCTOR);
        -:  651:    }
        -:  652:
    #####:  653:    if (!is_static && is_constructor_literal)
        -:  654:    {
    #####:  655:      JERRY_ASSERT (!is_static);
    #####:  656:      JERRY_ASSERT (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT);
    #####:  657:      JERRY_ASSERT (ctor_literal_p != NULL);
        -:  658:
    #####:  659:      if (ctor_literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  660:      {
        -:  661:        /* 14.5.1 */
    #####:  662:        parser_raise_error (context_p, PARSER_ERR_MULTIPLE_CLASS_CONSTRUCTORS);
        -:  663:      }
        -:  664:
    #####:  665:      uint32_t constructor_status_flags =
        -:  666:        (PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER | PARSER_CLASS_CONSTRUCTOR | PARSER_LEXICAL_ENV_NEEDED);
        -:  667:
    #####:  668:      if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  669:      {
    #####:  670:        constructor_status_flags |= PARSER_ALLOW_SUPER_CALL;
        -:  671:      }
        -:  672:
    #####:  673:      if (context_p->status_flags & PARSER_INSIDE_WITH)
        -:  674:      {
    #####:  675:        constructor_status_flags |= PARSER_INSIDE_WITH;
        -:  676:      }
        -:  677:
    #####:  678:      parser_flush_cbc (context_p);
    #####:  679:      ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, constructor_status_flags);
    #####:  680:      ctor_literal_p->u.bytecode_p = compiled_code_p;
    #####:  681:      ctor_literal_p->type = LEXER_FUNCTION_LITERAL;
    #####:  682:      continue;
        -:  683:    }
        -:  684:
    #####:  685:    bool is_computed = false;
        -:  686:
    #####:  687:    if (context_p->token.type == LEXER_PROPERTY_GETTER || context_p->token.type == LEXER_PROPERTY_SETTER)
        -:  688:    {
        -:  689:      uint16_t literal_index, function_literal_index;
    #####:  690:      bool is_getter = (context_p->token.type == LEXER_PROPERTY_GETTER);
        -:  691:
    #####:  692:      uint32_t accessor_status_flags = PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER;
    #####:  693:      accessor_status_flags |= (is_getter ? PARSER_IS_PROPERTY_GETTER : PARSER_IS_PROPERTY_SETTER);
        -:  694:
    #####:  695:      uint8_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
        -:  696:
    #####:  697:      if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -:  698:      {
    #####:  699:        lexer_next_token (context_p);
    #####:  700:        context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  701:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
    #####:  702:        is_private = true;
        -:  703:      }
        -:  704:
    #####:  705:      lexer_expect_object_literal_id (context_p, ident_opts);
        -:  706:
    #####:  707:      if (is_private)
        -:  708:      {
    #####:  709:        parser_check_duplicated_private_field (context_p,
        -:  710:                                               is_getter ? SCANNER_PRIVATE_FIELD_GETTER : SCANNER_PRIVATE_FIELD_SETTER);
        -:  711:      }
        -:  712:
    #####:  713:      literal_index = context_p->lit_object.index;
        -:  714:
    #####:  715:      if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  716:      {
    #####:  717:        is_computed = true;
        -:  718:      }
    #####:  719:      else if (is_static && !is_private)
        -:  720:      {
    #####:  721:        if (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####:  722:            && lexer_compare_identifier_to_string (&context_p->token.lit_location, (uint8_t *) "prototype", 9))
        -:  723:        {
    #####:  724:          parser_raise_error (context_p, PARSER_ERR_CLASS_STATIC_PROTOTYPE);
        -:  725:        }
        -:  726:      }
    #####:  727:      else if (parser_is_constructor_literal (context_p))
        -:  728:      {
    #####:  729:        JERRY_ASSERT (!is_static || is_private);
    #####:  730:        parser_raise_error (context_p, PARSER_ERR_CLASS_CONSTRUCTOR_AS_ACCESSOR);
        -:  731:      }
        -:  732:
    #####:  733:      function_literal_index = lexer_construct_function_object (context_p, accessor_status_flags);
        -:  734:
    #####:  735:      parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -:  736:
    #####:  737:      JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -:  738:
        -:  739:      cbc_ext_opcode_t opcode;
        -:  740:
    #####:  741:      if (is_computed)
        -:  742:      {
    #####:  743:        context_p->last_cbc.literal_index = function_literal_index;
        -:  744:
    #####:  745:        if (is_getter)
        -:  746:        {
    #####:  747:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_GETTER;
        -:  748:        }
        -:  749:        else
        -:  750:        {
    #####:  751:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_SETTER : CBC_EXT_SET_COMPUTED_SETTER;
        -:  752:        }
        -:  753:      }
        -:  754:      else
        -:  755:      {
    #####:  756:        context_p->last_cbc.value = function_literal_index;
        -:  757:
    #####:  758:        if (is_getter)
        -:  759:        {
    #####:  760:          opcode = is_static ? (is_private ? CBC_EXT_COLLECT_PRIVATE_STATIC_GETTER : CBC_EXT_SET_STATIC_GETTER)
    #####:  761:                             : (is_private ? CBC_EXT_COLLECT_PRIVATE_GETTER : CBC_EXT_SET_GETTER);
        -:  762:        }
        -:  763:        else
        -:  764:        {
    #####:  765:          opcode = is_static ? (is_private ? CBC_EXT_COLLECT_PRIVATE_STATIC_SETTER : CBC_EXT_SET_STATIC_SETTER)
    #####:  766:                             : (is_private ? CBC_EXT_COLLECT_PRIVATE_SETTER : CBC_EXT_SET_SETTER);
        -:  767:        }
        -:  768:      }
        -:  769:
    #####:  770:      if (is_computed)
        -:  771:      {
    #####:  772:        parser_emit_cbc_ext (context_p,
        -:  773:                             is_getter ? CBC_EXT_SET_COMPUTED_GETTER_NAME : CBC_EXT_SET_COMPUTED_SETTER_NAME);
    #####:  774:        parser_emit_cbc_ext (context_p, opcode);
        -:  775:      }
        -:  776:      else
        -:  777:      {
    #####:  778:        if (is_private)
        -:  779:        {
    #####:  780:          accessor_status_flags |= PARSER_PRIVATE_FUNCTION_NAME;
        -:  781:        }
    #####:  782:        parser_set_function_name (context_p, function_literal_index, literal_index, accessor_status_flags);
    #####:  783:        context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
        -:  784:      }
        -:  785:
    #####:  786:      is_static = false;
    #####:  787:      is_private = false;
    #####:  788:      continue;
        -:  789:    }
        -:  790:
    #####:  791:    uint32_t status_flags = PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER;
        -:  792:
    #####:  793:    if (context_p->token.type == LEXER_KEYW_ASYNC)
        -:  794:    {
    #####:  795:      status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  796:
    #####:  797:      uint8_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
        -:  798:
    #####:  799:      if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -:  800:      {
    #####:  801:        lexer_next_token (context_p);
    #####:  802:        context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  803:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
    #####:  804:        is_private = true;
        -:  805:      }
        -:  806:
    #####:  807:      if (!lexer_consume_generator (context_p))
        -:  808:      {
    #####:  809:        lexer_expect_object_literal_id (context_p, ident_opts);
        -:  810:      }
        -:  811:
    #####:  812:      if (is_private)
        -:  813:      {
    #####:  814:        if (context_p->token.type == LEXER_LITERAL && parser_is_constructor_literal (context_p))
        -:  815:        {
    #####:  816:          parser_raise_error (context_p, PARSER_ERR_CLASS_PRIVATE_CONSTRUCTOR);
        -:  817:        }
        -:  818:
    #####:  819:        parser_check_duplicated_private_field (context_p, SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER);
        -:  820:      }
        -:  821:    }
        -:  822:
    #####:  823:    if (context_p->token.type == LEXER_MULTIPLY)
        -:  824:    {
    #####:  825:      uint8_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
        -:  826:
    #####:  827:      if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -:  828:      {
    #####:  829:        lexer_next_token (context_p);
    #####:  830:        context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  831:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
    #####:  832:        is_private = true;
        -:  833:      }
        -:  834:
    #####:  835:      lexer_expect_object_literal_id (context_p, ident_opts);
        -:  836:
    #####:  837:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  838:
    #####:  839:      if (is_private)
        -:  840:      {
    #####:  841:        if (context_p->token.type == LEXER_LITERAL && parser_is_constructor_literal (context_p))
        -:  842:        {
    #####:  843:          parser_raise_error (context_p, PARSER_ERR_CLASS_PRIVATE_CONSTRUCTOR);
        -:  844:        }
        -:  845:
    #####:  846:        parser_check_duplicated_private_field (context_p, SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER);
        -:  847:      }
        -:  848:    }
        -:  849:
    #####:  850:    bool is_static_block = context_p->token.type == LEXER_LEFT_BRACE;
        -:  851:
    #####:  852:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  853:    {
    #####:  854:      is_computed = true;
        -:  855:    }
    #####:  856:    else if (!is_static_block && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type))
        -:  857:    {
    #####:  858:      if (is_static && !is_private)
        -:  859:      {
    #####:  860:        if (lexer_compare_identifier_to_string (&context_p->token.lit_location, (uint8_t *) "prototype", 9))
        -:  861:        {
    #####:  862:          parser_raise_error (context_p, PARSER_ERR_CLASS_STATIC_PROTOTYPE);
        -:  863:        }
        -:  864:      }
    #####:  865:      else if ((status_flags & (PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION))
    #####:  866:               && lexer_compare_literal_to_string (context_p, "constructor", 11))
        -:  867:      {
    #####:  868:        parser_raise_error (context_p, PARSER_ERR_INVALID_CLASS_CONSTRUCTOR);
        -:  869:      }
        -:  870:    }
        -:  871:
    #####:  872:    if (!(status_flags & (PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION)))
        -:  873:    {
    #####:  874:      if (is_static_block || !lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  875:      {
        -:  876:        /* Class field. */
    #####:  877:        if (fields_size == 0)
        -:  878:        {
    #####:  879:          parser_stack_push_uint8 (context_p, PARSER_CLASS_FIELD_END);
        -:  880:        }
        -:  881:
    #####:  882:        scanner_range_t range;
    #####:  883:        uint8_t class_field_type = is_static ? PARSER_CLASS_FIELD_STATIC : 0;
        -:  884:
    #####:  885:        if (!is_computed)
        -:  886:        {
    #####:  887:          if (is_private)
        -:  888:          {
    #####:  889:            lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####:  890:            uint8_t field_opcode = is_static ? CBC_EXT_COLLECT_PRIVATE_STATIC_FIELD : CBC_EXT_COLLECT_PRIVATE_FIELD;
    #####:  891:            parser_emit_cbc_ext_literal_from_token (context_p, field_opcode);
        -:  892:          }
        -:  893:
    #####:  894:          if (is_static && !is_static_block && parser_is_constructor_literal (context_p))
        -:  895:          {
    #####:  896:            parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);
        -:  897:          }
        -:  898:
    #####:  899:          range.start_location.source_p = context_p->token.lit_location.char_p;
    #####:  900:          range.start_location.line = context_p->token.line;
    #####:  901:          range.start_location.column = context_p->token.column;
    #####:  902:          class_field_type |= PARSER_CLASS_FIELD_NORMAL;
        -:  903:
    #####:  904:          if (context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -:  905:          {
    #####:  906:            range.start_location.source_p--;
        -:  907:          }
        -:  908:        }
        -:  909:        else
        -:  910:        {
    #####:  911:          if (++computed_field_count > ECMA_INTEGER_NUMBER_MAX)
        -:  912:          {
    #####:  913:            parser_raise_error (context_p, PARSER_ERR_TOO_MANY_CLASS_FIELDS);
        -:  914:          }
        -:  915:
    #####:  916:          if (is_static && static_fields_literal_p == NULL)
        -:  917:          {
    #####:  918:            static_fields_literal_p = lexer_construct_unused_literal (context_p);
    #####:  919:            parser_emit_cbc_ext_literal (context_p,
        -:  920:                                         CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC,
        -:  921:                                         (uint16_t) (context_p->literal_count++));
        -:  922:          }
        -:  923:          else
        -:  924:          {
    #####:  925:            parser_emit_cbc_ext (context_p,
        -:  926:                                 (is_static ? CBC_EXT_ADD_STATIC_COMPUTED_FIELD : CBC_EXT_ADD_COMPUTED_FIELD));
        -:  927:          }
        -:  928:        }
        -:  929:
    #####:  930:        if (is_static_block)
        -:  931:        {
    #####:  932:          class_field_type |= PARSER_CLASS_FIELD_STATIC_BLOCK;
        -:  933:
    #####:  934:          if (context_p->next_scanner_info_p->type != SCANNER_TYPE_CLASS_STATIC_BLOCK_END)
        -:  935:          {
    #####:  936:            parser_flush_cbc (context_p);
    #####:  937:            parser_parse_class_static_block (context_p);
        -:  938:          }
        -:  939:
    #####:  940:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CLASS_STATIC_BLOCK_END);
        -:  941:
    #####:  942:          scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####:  943:          scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####:  944:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
    #####:  945:          range.start_location.source_p = context_p->next_scanner_info_p->source_p - 1;
        -:  946:
    #####:  947:          scanner_seek (context_p);
        -:  948:
    #####:  949:          parser_stack_push (context_p, &range.start_location, sizeof (scanner_location_t));
    #####:  950:          fields_size += sizeof (scanner_location_t);
        -:  951:
    #####:  952:          lexer_consume_next_character (context_p);
        -:  953:        }
    #####:  954:        else if (lexer_consume_assign (context_p))
        -:  955:        {
    #####:  956:          class_field_type |= PARSER_CLASS_FIELD_INITIALIZED;
        -:  957:
    #####:  958:          if (context_p->next_scanner_info_p->source_p != context_p->source_p)
        -:  959:          {
    #####:  960:            lexer_next_token (context_p);
    #####:  961:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####:  962:            parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -:  963:          }
        -:  964:
    #####:  965:          if (is_computed)
        -:  966:          {
    #####:  967:            scanner_get_location (&range.start_location, context_p);
        -:  968:          }
        -:  969:
    #####:  970:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END);
    #####:  971:          range.source_end_p = ((scanner_location_info_t *) context_p->next_scanner_info_p)->location.source_p;
        -:  972:
    #####:  973:          scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####:  974:          scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####:  975:          scanner_seek (context_p);
        -:  976:
    #####:  977:          parser_stack_push (context_p, &range, sizeof (scanner_range_t));
    #####:  978:          fields_size += sizeof (scanner_range_t);
        -:  979:        }
        -:  980:        else
        -:  981:        {
    #####:  982:          if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####:  983:              && !lexer_check_next_characters (context_p, LIT_CHAR_SEMICOLON, LIT_CHAR_RIGHT_BRACE))
        -:  984:          {
    #####:  985:            lexer_next_token (context_p);
    #####:  986:            parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -:  987:          }
        -:  988:
    #####:  989:          if (!is_computed)
        -:  990:          {
    #####:  991:            parser_stack_push (context_p, &range.start_location, sizeof (scanner_location_t));
    #####:  992:            fields_size += sizeof (scanner_location_t);
        -:  993:          }
        -:  994:        }
        -:  995:
    #####:  996:        parser_stack_push_uint8 (context_p, class_field_type);
    #####:  997:        fields_size++;
    #####:  998:        is_static = false;
    #####:  999:        is_private = false;
    #####: 1000:        continue;
        -: 1001:      }
        -: 1002:
    #####: 1003:      if (!is_computed)
        -: 1004:      {
    #####: 1005:        if (context_p->token.lit_location.type != LEXER_NUMBER_LITERAL)
        -: 1006:        {
    #####: 1007:          JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL
        -: 1008:                        || context_p->token.lit_location.type == LEXER_STRING_LITERAL);
    #####: 1009:          if (is_private)
        -: 1010:          {
    #####: 1011:            parser_resolve_private_identifier (context_p);
        -: 1012:          }
        -: 1013:          else
        -: 1014:          {
    #####: 1015:            lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
        -: 1016:          }
        -: 1017:        }
        -: 1018:        else
        -: 1019:        {
    #####: 1020:          lexer_construct_number_object (context_p, false, false);
        -: 1021:        }
        -: 1022:      }
        -: 1023:    }
        -: 1024:
    #####: 1025:    uint16_t literal_index = context_p->lit_object.index;
    #####: 1026:    uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags | PARSER_IS_METHOD);
        -: 1027:
    #####: 1028:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1029:
    #####: 1030:    if (is_computed)
        -: 1031:    {
    #####: 1032:      parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1033:      parser_emit_cbc_ext (context_p, is_static ? CBC_EXT_SET_STATIC_COMPUTED_PROPERTY : CBC_EXT_SET_COMPUTED_PROPERTY);
    #####: 1034:      is_static = false;
    #####: 1035:      continue;
        -: 1036:    }
        -: 1037:
    #####: 1038:    uint32_t function_name_status_flags = 0;
        -: 1039:
    #####: 1040:    if (is_private)
        -: 1041:    {
    #####: 1042:      function_name_status_flags = PARSER_PRIVATE_FUNCTION_NAME;
        -: 1043:    }
        -: 1044:
    #####: 1045:    parser_set_function_name (context_p, function_literal_index, literal_index, function_name_status_flags);
        -: 1046:
    #####: 1047:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1048:
    #####: 1049:    context_p->last_cbc.value = literal_index;
        -: 1050:
    #####: 1051:    if (is_static)
        -: 1052:    {
    #####: 1053:      context_p->last_cbc_opcode = (is_private ? PARSER_TO_EXT_OPCODE (CBC_EXT_COLLECT_PRIVATE_STATIC_METHOD)
        -: 1054:                                               : PARSER_TO_EXT_OPCODE (CBC_EXT_SET_STATIC_PROPERTY_LITERAL));
    #####: 1055:      is_static = false;
        -: 1056:    }
    #####: 1057:    else if (is_private)
        -: 1058:    {
    #####: 1059:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_COLLECT_PRIVATE_METHOD);
        -: 1060:    }
        -: 1061:    else
        -: 1062:    {
    #####: 1063:      context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
        -: 1064:    }
        -: 1065:
    #####: 1066:    is_private = false;
        -: 1067:  }
        -: 1068:
    #####: 1069:  if (fields_size == 0)
        -: 1070:  {
    #####: 1071:    return false;
        -: 1072:  }
        -: 1073:
    #####: 1074:  parser_reverse_class_fields (context_p, fields_size);
        -: 1075:
        -: 1076:  /* Since PARSER_IS_ARROW_FUNCTION and PARSER_CLASS_CONSTRUCTOR bits cannot
        -: 1077:   * be set at the same time, this bit combination triggers class field parsing. */
        -: 1078:
    #####: 1079:  if (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_STATIC))
        -: 1080:  {
    #####: 1081:    lexer_literal_t *literal_p = lexer_construct_unused_literal (context_p);
        -: 1082:
    #####: 1083:    uint16_t function_literal_index = (uint16_t) (context_p->literal_count++);
    #####: 1084:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_FIELD_INIT, function_literal_index);
    #####: 1085:    parser_flush_cbc (context_p);
        -: 1086:
    #####: 1087:    literal_p->u.bytecode_p = parser_parse_class_fields (context_p);
    #####: 1088:    literal_p->type = LEXER_FUNCTION_LITERAL;
        -: 1089:  }
        -: 1090:
    #####: 1091:  bool has_static_field = false;
        -: 1092:
    #####: 1093:  if (context_p->stack_top_uint8 & PARSER_CLASS_FIELD_STATIC)
        -: 1094:  {
    #####: 1095:    if (static_fields_literal_p == NULL)
        -: 1096:    {
    #####: 1097:      static_fields_literal_p = lexer_construct_unused_literal (context_p);
    #####: 1098:      uint16_t function_literal_index = (uint16_t) (context_p->literal_count++);
    #####: 1099:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_STATIC_FIELD_FUNC, function_literal_index);
        -: 1100:    }
        -: 1101:
    #####: 1102:    parser_flush_cbc (context_p);
    #####: 1103:    static_fields_literal_p->u.bytecode_p = parser_parse_class_fields (context_p);
    #####: 1104:    static_fields_literal_p->type = LEXER_FUNCTION_LITERAL;
        -: 1105:
    #####: 1106:    has_static_field = true;
        -: 1107:  }
        -: 1108:
    #####: 1109:  parser_stack_pop_uint8 (context_p);
    #####: 1110:  return has_static_field;
        -: 1111:} /* parser_parse_class_body */
        -: 1112:
        -: 1113:/**
        -: 1114: * Parse class statement or expression.
        -: 1115: */
        -: 1116:void
    #####: 1117:parser_parse_class (parser_context_t *context_p, /**< context */
        -: 1118:                    bool is_statement) /**< true - if class is parsed as a statement
        -: 1119:                                        *   false - otherwise (as an expression) */
        -: 1120:{
    #####: 1121:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -: 1122:
    #####: 1123:  uint16_t class_ident_index = PARSER_INVALID_LITERAL_INDEX;
    #####: 1124:  uint16_t class_name_index = PARSER_INVALID_LITERAL_INDEX;
    #####: 1125:  parser_class_literal_opts_t opts = PARSER_CLASS_LITERAL_NO_OPTS;
    #####: 1126:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -: 1127:
    #####: 1128:  scanner_class_info_t *class_info_p = (scanner_class_info_t *) scanner_info_p;
    #####: 1129:  parser_private_context_t private_ctx;
        -: 1130:
    #####: 1131:  if (scanner_info_p->source_p == context_p->source_p)
        -: 1132:  {
    #####: 1133:    JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_CLASS_CONSTRUCTOR);
    #####: 1134:    parser_save_private_context (context_p, &private_ctx, class_info_p);
        -: 1135:
    #####: 1136:    if (scanner_info_p->u8_arg & SCANNER_CONSTRUCTOR_EXPLICIT)
        -: 1137:    {
    #####: 1138:      opts |= PARSER_CLASS_LITERAL_CTOR_PRESENT;
        -: 1139:    }
        -: 1140:
    #####: 1141:    scanner_release_next (context_p, sizeof (scanner_class_info_t));
        -: 1142:  }
        -: 1143:
    #####: 1144:  if (is_statement)
        -: 1145:  {
        -: 1146:    /* Class statement must contain an identifier. */
    #####: 1147:    lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
    #####: 1148:    JERRY_ASSERT (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1149:
    #####: 1150:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1151:    {
    #####: 1152:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 1153:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 1154:    }
    #####: 1155:    class_ident_index = context_p->lit_object.index;
        -: 1156:
    #####: 1157:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
    #####: 1158:    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####: 1159:    class_name_index = context_p->lit_object.index;
        -: 1160:
        -: 1161:#if JERRY_MODULE_SYSTEM
    #####: 1162:    parser_module_append_export_name (context_p);
    #####: 1163:    context_p->status_flags &= (uint32_t) ~PARSER_MODULE_STORE_IDENT;
        -: 1164:#endif /* JERRY_MODULE_SYSTEM */
        -: 1165:
    #####: 1166:    lexer_next_token (context_p);
        -: 1167:  }
        -: 1168:  else
        -: 1169:  {
    #####: 1170:    lexer_next_token (context_p);
        -: 1171:
        -: 1172:    /* Class expression may contain an identifier. */
    #####: 1173:    if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1174:    {
    #####: 1175:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
    #####: 1176:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####: 1177:      class_name_index = context_p->lit_object.index;
    #####: 1178:      lexer_next_token (context_p);
        -: 1179:    }
        -: 1180:  }
        -: 1181:
    #####: 1182:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 1183:  {
    #####: 1184:    if (JERRY_UNLIKELY (context_p->scope_stack_top >= context_p->scope_stack_size))
        -: 1185:    {
    #####: 1186:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 1187:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 1188:    }
        -: 1189:
    #####: 1190:    parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 1191:
    #####: 1192:    PARSER_PLUS_EQUAL_U16 (context_p->scope_stack_top, 1);
    #####: 1193:    scope_stack_p->map_from = class_name_index;
    #####: 1194:    scope_stack_p->map_to = 0;
        -: 1195:
    #####: 1196:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_NAMED_CLASS_ENV, class_name_index);
        -: 1197:  }
        -: 1198:  else
        -: 1199:  {
    #####: 1200:    parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 1201:  }
        -: 1202:
    #####: 1203:  bool is_strict = (context_p->status_flags & PARSER_IS_STRICT) != 0;
        -: 1204:
        -: 1205:  /* 14.5. A ClassBody is always strict code. */
    #####: 1206:  context_p->status_flags |= PARSER_IS_STRICT;
        -: 1207:
    #####: 1208:  if (context_p->token.type == LEXER_KEYW_EXTENDS)
        -: 1209:  {
    #####: 1210:    lexer_next_token (context_p);
    #####: 1211:    parser_parse_expression (context_p, PARSE_EXPR | PARSE_EXPR_LEFT_HAND_SIDE);
    #####: 1212:    opts |= PARSER_CLASS_LITERAL_HERTIAGE_PRESENT;
        -: 1213:  }
        -: 1214:  else
        -: 1215:  {
        -: 1216:    /* Elisions represents that the classHeritage is not present */
    #####: 1217:    parser_emit_cbc (context_p, CBC_PUSH_ELISION);
        -: 1218:  }
        -: 1219:
    #####: 1220:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1221:  {
    #####: 1222:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 1223:  }
        -: 1224:
    #####: 1225:  context_p->private_context_p->opts |= SCANNER_PRIVATE_FIELD_ACTIVE;
        -: 1226:
        -: 1227:  /* ClassDeclaration is parsed. Continue with class body. */
    #####: 1228:  bool has_static_field = parser_parse_class_body (context_p, opts, class_name_index);
        -: 1229:
    #####: 1230:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 1231:  {
    #####: 1232:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_FINALIZE_NAMED_CLASS, class_name_index);
    #####: 1233:    PARSER_MINUS_EQUAL_U16 (context_p->scope_stack_top, 1);
        -: 1234:  }
        -: 1235:  else
        -: 1236:  {
    #####: 1237:    parser_emit_cbc_ext (context_p, CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 1238:  }
        -: 1239:
    #####: 1240:  if (has_static_field)
        -: 1241:  {
    #####: 1242:    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_STATIC_FIELD_INIT);
        -: 1243:  }
        -: 1244:
    #####: 1245:  if (is_statement)
        -: 1246:  {
    #####: 1247:    cbc_opcode_t opcode = CBC_MOV_IDENT;
        -: 1248:
    #####: 1249:    if (class_ident_index < PARSER_REGISTER_START)
        -: 1250:    {
    #####: 1251:      opcode = (scanner_literal_is_created (context_p, class_ident_index) ? CBC_ASSIGN_LET_CONST : CBC_INIT_LET);
        -: 1252:    }
        -: 1253:
    #####: 1254:    parser_emit_cbc_literal (context_p, (uint16_t) opcode, class_ident_index);
    #####: 1255:    parser_flush_cbc (context_p);
        -: 1256:  }
        -: 1257:
    #####: 1258:  if (!is_strict)
        -: 1259:  {
        -: 1260:    /* Restore flag */
    #####: 1261:    context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 1262:  }
    #####: 1263:  context_p->status_flags &= (uint32_t) ~PARSER_ALLOW_SUPER;
        -: 1264:
    #####: 1265:  parser_restore_private_context (context_p, &private_ctx);
        -: 1266:
    #####: 1267:  lexer_next_token (context_p);
    #####: 1268:} /* parser_parse_class */
        -: 1269:#endif /* JERRY_ESNEXT */
        -: 1270:
        -: 1271:#if JERRY_ESNEXT
        -: 1272:/**
        -: 1273: * Parse object initializer method definition.
        -: 1274: *
        -: 1275: * See also: ES2015 14.3
        -: 1276: */
        -: 1277:static void
    #####: 1278:parser_parse_object_method (parser_context_t *context_p) /**< context */
        -: 1279:{
    #####: 1280:  context_p->source_p--;
    #####: 1281:  context_p->column--;
    #####: 1282:  uint16_t function_literal_index =
        -: 1283:    lexer_construct_function_object (context_p, (PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER | PARSER_IS_METHOD));
        -: 1284:
    #####: 1285:  parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1286:
    #####: 1287:  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;
        -: 1288:
    #####: 1289:  lexer_next_token (context_p);
    #####: 1290:} /* parser_parse_object_method */
        -: 1291:
        -: 1292:/**
        -: 1293: * Reparse the current literal as a common identifier.
        -: 1294: */
        -: 1295:static void
    #####: 1296:parser_reparse_as_common_identifier (parser_context_t *context_p, /**< context */
        -: 1297:                                     parser_line_counter_t start_line, /**< start line */
        -: 1298:                                     parser_line_counter_t start_column) /**< start column */
        -: 1299:{
        -: 1300:  /* context_p->token.lit_location.char_p is showing the character after the string start,
        -: 1301:     so it is not suitable for reparsing as identifier.
        -: 1302:     e.g.: { 'foo' } */
    #####: 1303:  if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1304:  {
    #####: 1305:    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1306:  }
        -: 1307:
    #####: 1308:  context_p->source_p = context_p->token.lit_location.char_p;
    #####: 1309:  context_p->line = start_line;
    #####: 1310:  context_p->column = start_column;
        -: 1311:
    #####: 1312:  lexer_next_token (context_p);
        -: 1313:
    #####: 1314:  if (context_p->token.type != LEXER_LITERAL)
        -: 1315:  {
    #####: 1316:    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1317:  }
        -: 1318:
    #####: 1319:  JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1320:
    #####: 1321:  lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 1322:
    #####: 1323:} /* parser_reparse_as_common_identifier */
        -: 1324:#endif /* JERRY_ESNEXT */
        -: 1325:
        -: 1326:/**
        -: 1327: * Parse object literal.
        -: 1328: */
        -: 1329:static void
    #####: 1330:parser_parse_object_literal (parser_context_t *context_p) /**< context */
        -: 1331:{
    #####: 1332:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -: 1333:
    #####: 1334:  parser_emit_cbc (context_p, CBC_CREATE_OBJECT);
        -: 1335:
        -: 1336:#if !JERRY_ESNEXT
    #####: 1337:  parser_stack_push_uint8 (context_p, PARSER_OBJECT_PROPERTY_START);
        -: 1338:#endif /* !JERRY_ESNEXT */
        -: 1339:
        -: 1340:#if JERRY_ESNEXT
    #####: 1341:  bool proto_seen = false;
    #####: 1342:  bool has_super_env = false;
        -: 1343:
    #####: 1344:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1345:  {
    #####: 1346:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 1347:
    #####: 1348:    if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_SUPER)
        -: 1349:    {
    #####: 1350:      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT);
    #####: 1351:      has_super_env = true;
        -: 1352:    }
        -: 1353:
    #####: 1354:    scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1355:  }
        -: 1356:#endif /* JERRY_ESNEXT */
        -: 1357:
        -: 1358:  while (true)
        -: 1359:  {
    #####: 1360:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_SET_FUNCTION_START);
        -: 1361:
    #####: 1362:    switch (context_p->token.type)
        -: 1363:    {
    #####: 1364:      case LEXER_RIGHT_BRACE:
        -: 1365:      {
    #####: 1366:        break;
        -: 1367:      }
    #####: 1368:      case LEXER_PROPERTY_GETTER:
        -: 1369:      case LEXER_PROPERTY_SETTER:
        -: 1370:      {
        -: 1371:        uint32_t status_flags;
        -: 1372:        cbc_ext_opcode_t opcode;
        -: 1373:#if !JERRY_ESNEXT
        -: 1374:        parser_object_literal_item_types_t item_type;
        -: 1375:#endif /* !JERRY_ESNEXT */
    #####: 1376:        bool is_getter = context_p->token.type == LEXER_PROPERTY_GETTER;
        -: 1377:
    #####: 1378:        if (is_getter)
        -: 1379:        {
    #####: 1380:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_GETTER;
    #####: 1381:          opcode = CBC_EXT_SET_GETTER;
        -: 1382:#if !JERRY_ESNEXT
        -: 1383:          item_type = PARSER_OBJECT_PROPERTY_GETTER;
        -: 1384:#endif /* !JERRY_ESNEXT */
        -: 1385:        }
        -: 1386:        else
        -: 1387:        {
    #####: 1388:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_SETTER;
    #####: 1389:          opcode = CBC_EXT_SET_SETTER;
        -: 1390:#if !JERRY_ESNEXT
    #####: 1391:          item_type = PARSER_OBJECT_PROPERTY_SETTER;
        -: 1392:#endif /* !JERRY_ESNEXT */
        -: 1393:        }
        -: 1394:
        -: 1395:#if JERRY_ESNEXT
    #####: 1396:        status_flags |= PARSER_ALLOW_SUPER;
        -: 1397:#endif /* !JERRY_ESNEXT */
        -: 1398:
    #####: 1399:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 1400:
        -: 1401:        /* This assignment is a nop for computed getters/setters. */
    #####: 1402:        uint16_t literal_index = context_p->lit_object.index;
        -: 1403:
        -: 1404:#if JERRY_ESNEXT
    #####: 1405:        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;
        -: 1406:
    #####: 1407:        if (is_computed)
        -: 1408:        {
    #####: 1409:          opcode = ((opcode == CBC_EXT_SET_GETTER) ? CBC_EXT_SET_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_SETTER);
        -: 1410:        }
        -: 1411:#else /* !JERRY_ESNEXT */
    #####: 1412:        parser_append_object_literal_item (context_p, literal_index, item_type);
        -: 1413:#endif /* JERRY_ESNEXT */
        -: 1414:
    #####: 1415:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1416:
        -: 1417:#if JERRY_ESNEXT
    #####: 1418:        if (opcode >= CBC_EXT_SET_COMPUTED_GETTER)
        -: 1419:        {
    #####: 1420:          literal_index = function_literal_index;
        -: 1421:        }
        -: 1422:#endif /* JERRY_ESNEXT */
        -: 1423:
    #####: 1424:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -: 1425:
    #####: 1426:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1427:
        -: 1428:#if JERRY_ESNEXT
    #####: 1429:        if (is_computed)
        -: 1430:        {
    #####: 1431:          parser_emit_cbc_ext (context_p,
        -: 1432:                               is_getter ? CBC_EXT_SET_COMPUTED_GETTER_NAME : CBC_EXT_SET_COMPUTED_SETTER_NAME);
        -: 1433:
    #####: 1434:          if (has_super_env)
        -: 1435:          {
    #####: 1436:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1437:          }
    #####: 1438:          parser_emit_cbc_ext (context_p, opcode);
    #####: 1439:          lexer_next_token (context_p);
    #####: 1440:          break;
        -: 1441:        }
        -: 1442:
    #####: 1443:        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);
        -: 1444:
    #####: 1445:        if (has_super_env)
        -: 1446:        {
    #####: 1447:          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1448:          context_p->last_cbc.value = function_literal_index;
    #####: 1449:          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
    #####: 1450:          parser_emit_cbc_ext (context_p, is_getter ? CBC_EXT_SET_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_SETTER);
        -: 1451:        }
        -: 1452:        else
        -: 1453:#endif /* JERRY_ESNEXT */
        -: 1454:        {
    #####: 1455:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
    #####: 1456:          context_p->last_cbc.value = function_literal_index;
        -: 1457:        }
        -: 1458:
    #####: 1459:        lexer_next_token (context_p);
    #####: 1460:        break;
        -: 1461:      }
        -: 1462:#if JERRY_ESNEXT
    #####: 1463:      case LEXER_RIGHT_SQUARE:
        -: 1464:      {
    #####: 1465:        lexer_next_token (context_p);
        -: 1466:
    #####: 1467:        if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1468:        {
    #####: 1469:          parser_parse_object_method (context_p);
    #####: 1470:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1471:
    #####: 1472:          if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)
        -: 1473:          {
    #####: 1474:            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1475:            if (has_super_env)
        -: 1476:            {
    #####: 1477:              parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1478:            }
    #####: 1479:            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);
        -: 1480:          }
        -: 1481:          else
        -: 1482:          {
    #####: 1483:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1484:          }
        -: 1485:
    #####: 1486:          break;
        -: 1487:        }
        -: 1488:
    #####: 1489:        if (context_p->token.type != LEXER_COLON)
        -: 1490:        {
    #####: 1491:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1492:        }
        -: 1493:
    #####: 1494:        lexer_next_token (context_p);
    #####: 1495:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1496:
    #####: 1497:        if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)
        -: 1498:        {
    #####: 1499:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
        -: 1500:        }
        -: 1501:
    #####: 1502:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1503:        {
    #####: 1504:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1505:        }
        -: 1506:        else
        -: 1507:        {
    #####: 1508:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);
        -: 1509:        }
    #####: 1510:        break;
        -: 1511:      }
    #####: 1512:      case LEXER_THREE_DOTS:
        -: 1513:      {
    #####: 1514:        lexer_next_token (context_p);
    #####: 1515:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 1516:        parser_emit_cbc_ext (context_p, CBC_EXT_COPY_DATA_PROPERTIES);
    #####: 1517:        break;
        -: 1518:      }
    #####: 1519:      case LEXER_KEYW_ASYNC:
        -: 1520:      case LEXER_MULTIPLY:
        -: 1521:      {
    #####: 1522:        uint32_t status_flags = PARSER_FUNCTION_CLOSURE;
        -: 1523:
    #####: 1524:        if (context_p->token.type == LEXER_KEYW_ASYNC)
        -: 1525:        {
    #####: 1526:          status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1527:          lexer_consume_generator (context_p);
        -: 1528:        }
        -: 1529:
    #####: 1530:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1531:        {
    #####: 1532:          status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1533:        }
        -: 1534:
    #####: 1535:        if (has_super_env)
        -: 1536:        {
    #####: 1537:          status_flags |= PARSER_ALLOW_SUPER;
        -: 1538:        }
        -: 1539:
    #####: 1540:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 1541:
    #####: 1542:        uint16_t opcode = CBC_SET_LITERAL_PROPERTY;
        -: 1543:        /* This assignment is a nop for CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL. */
    #####: 1544:        uint16_t literal_index = context_p->lit_object.index;
    #####: 1545:        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;
        -: 1546:
    #####: 1547:        if (is_computed)
        -: 1548:        {
    #####: 1549:          opcode = CBC_EXT_SET_COMPUTED_PROPERTY;
        -: 1550:        }
        -: 1551:
    #####: 1552:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1553:
    #####: 1554:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1555:
    #####: 1556:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1557:
    #####: 1558:        if (is_computed)
        -: 1559:        {
    #####: 1560:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1561:          if (has_super_env)
        -: 1562:          {
    #####: 1563:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1564:          }
    #####: 1565:          parser_emit_cbc_ext (context_p, opcode);
    #####: 1566:          lexer_next_token (context_p);
    #####: 1567:          break;
        -: 1568:        }
        -: 1569:
    #####: 1570:        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);
        -: 1571:
    #####: 1572:        if (has_super_env)
        -: 1573:        {
    #####: 1574:          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);
    #####: 1575:          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
        -: 1576:        }
        -: 1577:        else
        -: 1578:        {
    #####: 1579:          context_p->last_cbc_opcode = opcode;
    #####: 1580:          context_p->last_cbc.value = literal_index;
        -: 1581:        }
        -: 1582:
    #####: 1583:        lexer_next_token (context_p);
    #####: 1584:        break;
        -: 1585:      }
        -: 1586:#endif /* JERRY_ESNEXT */
    #####: 1587:      default:
        -: 1588:      {
        -: 1589:#if JERRY_ESNEXT
    #####: 1590:        const lexer_lit_location_t *literal_p = (const lexer_lit_location_t *) context_p->lit_object.literal_p;
    #####: 1591:        bool is_proto = ((context_p->token.lit_location.type == LEXER_IDENT_LITERAL
    #####: 1592:                          || context_p->token.lit_location.type == LEXER_STRING_LITERAL)
    #####: 1593:                         && lexer_compare_identifier_to_string (literal_p, (uint8_t *) "__proto__", 9)
    #####: 1594:                         && lexer_check_next_character (context_p, LIT_CHAR_COLON));
    #####: 1595:        if (is_proto)
        -: 1596:        {
    #####: 1597:          if (proto_seen)
        -: 1598:          {
    #####: 1599:            parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PROTO);
        -: 1600:          }
        -: 1601:
    #####: 1602:          proto_seen = true;
        -: 1603:        }
        -: 1604:#endif /* JERRY_ESNEXT */
        -: 1605:
    #####: 1606:        uint16_t literal_index = context_p->lit_object.index;
        -: 1607:
        -: 1608:#if JERRY_ESNEXT
    #####: 1609:        parser_line_counter_t start_line = context_p->token.line;
    #####: 1610:        parser_line_counter_t start_column = context_p->token.column;
        -: 1611:#else /* !JERRY_ESNEXT */
    #####: 1612:        parser_append_object_literal_item (context_p, literal_index, PARSER_OBJECT_PROPERTY_VALUE);
        -: 1613:#endif /* JERRY_ESNEXT */
        -: 1614:
    #####: 1615:        lexer_next_token (context_p);
        -: 1616:
        -: 1617:#if JERRY_ESNEXT
    #####: 1618:        if (context_p->token.type == LEXER_LEFT_PAREN && !is_proto)
        -: 1619:        {
    #####: 1620:          parser_parse_object_method (context_p);
        -: 1621:
    #####: 1622:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 1623:          parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);
        -: 1624:
    #####: 1625:          if (has_super_env)
        -: 1626:          {
    #####: 1627:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);
    #####: 1628:            parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
    #####: 1629:            break;
        -: 1630:          }
        -: 1631:
    #####: 1632:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1633:          context_p->last_cbc.value = literal_index;
    #####: 1634:          break;
        -: 1635:        }
        -: 1636:
    #####: 1637:        if ((context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_COMMA) && !is_proto)
        -: 1638:        {
    #####: 1639:          parser_reparse_as_common_identifier (context_p, start_line, start_column);
    #####: 1640:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1641:
    #####: 1642:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1643:          context_p->last_cbc.value = literal_index;
        -: 1644:
    #####: 1645:          lexer_next_token (context_p);
    #####: 1646:          break;
        -: 1647:        }
        -: 1648:#endif /* JERRY_ESNEXT */
        -: 1649:
    #####: 1650:        if (context_p->token.type != LEXER_COLON)
        -: 1651:        {
    #####: 1652:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1653:        }
        -: 1654:
    #####: 1655:        lexer_next_token (context_p);
    #####: 1656:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1657:
        -: 1658:#if JERRY_ESNEXT
    #####: 1659:        if (is_proto)
        -: 1660:        {
    #####: 1661:          parser_emit_cbc_ext (context_p, CBC_EXT_SET__PROTO__);
    #####: 1662:          break;
        -: 1663:        }
        -: 1664:#endif /* JERRY_ESNEXT */
        -: 1665:
    #####: 1666:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1667:        {
        -: 1668:#if JERRY_ESNEXT
    #####: 1669:          if (context_p->last_cbc.literal_type == LEXER_FUNCTION_LITERAL)
        -: 1670:          {
    #####: 1671:            parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);
        -: 1672:          }
        -: 1673:#endif /* JERRY_ESNEXT */
    #####: 1674:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1675:          context_p->last_cbc.value = literal_index;
        -: 1676:        }
        -: 1677:        else
        -: 1678:        {
        -: 1679:#if JERRY_ESNEXT
    #####: 1680:          if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))
        -: 1681:          {
    #####: 1682:            uint16_t name_index = scanner_save_literal (context_p, literal_index);
    #####: 1683:            parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 1684:          }
        -: 1685:#endif /* JERRY_ESNEXT */
    #####: 1686:          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
        -: 1687:        }
        -: 1688:
    #####: 1689:        break;
        -: 1690:      }
        -: 1691:    }
        -: 1692:
    #####: 1693:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 1694:    {
    #####: 1695:      break;
        -: 1696:    }
    #####: 1697:    else if (context_p->token.type != LEXER_COMMA)
        -: 1698:    {
    #####: 1699:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 1700:    }
        -: 1701:  }
        -: 1702:
        -: 1703:#if !JERRY_ESNEXT
    #####: 1704:  while (context_p->stack_top_uint8 != PARSER_OBJECT_PROPERTY_START)
        -: 1705:  {
    #####: 1706:    parser_stack_pop (context_p, NULL, 3);
        -: 1707:  }
        -: 1708:
    #####: 1709:  parser_stack_pop_uint8 (context_p);
        -: 1710:#else /* JERRY_ESNEXT */
    #####: 1711:  if (has_super_env)
        -: 1712:  {
    #####: 1713:    parser_emit_cbc_ext (context_p, CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
        -: 1714:  }
        -: 1715:#endif /* !JERRY_ESNEXT */
    #####: 1716:} /* parser_parse_object_literal */
        -: 1717:
        -: 1718:/**
        -: 1719: * Parse function literal.
        -: 1720: */
        -: 1721:static void
    #####: 1722:parser_parse_function_expression (parser_context_t *context_p, /**< context */
        -: 1723:                                  uint32_t status_flags) /**< function status flags */
        -: 1724:{
    #####: 1725:  int literals = 0;
    #####: 1726:  uint16_t literal1 = 0;
    #####: 1727:  uint16_t literal2 = 0;
        -: 1728:  uint16_t function_literal_index;
    #####: 1729:  int32_t function_name_index = -1;
        -: 1730:
        -: 1731:#if !JERRY_ESNEXT
        -: 1732:  JERRY_ASSERT (status_flags & PARSER_IS_FUNC_EXPRESSION);
        -: 1733:#endif /* !JERRY_ESNEXT */
        -: 1734:
        -: 1735:#if JERRY_ESNEXT
    #####: 1736:  if (status_flags & PARSER_IS_FUNC_EXPRESSION)
        -: 1737:  {
        -: 1738:#endif /* !JERRY_ESNEXT */
        -: 1739:
        -: 1740:#if JERRY_DEBUGGER
        -: 1741:    parser_line_counter_t debugger_line = context_p->token.line;
        -: 1742:    parser_line_counter_t debugger_column = context_p->token.column;
        -: 1743:#endif /* JERRY_DEBUGGER */
        -: 1744:
        -: 1745:#if JERRY_ESNEXT
    #####: 1746:    uint32_t parent_status_flags = context_p->status_flags;
        -: 1747:
    #####: 1748:    context_p->status_flags &=
        -: 1749:      (uint32_t) ~(PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD);
        -: 1750:
    #####: 1751:    if (status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1752:    {
        -: 1753:      /* The name of the function cannot be await. */
    #####: 1754:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1755:    }
        -: 1756:
    #####: 1757:    if (lexer_consume_generator (context_p))
        -: 1758:    {
        -: 1759:      /* The name of the function cannot be yield. */
    #####: 1760:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1761:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1762:    }
        -: 1763:#endif /* JERRY_ESNEXT */
        -: 1764:
    #####: 1765:    if (!lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1766:    {
        -: 1767:#if JERRY_ESNEXT
        -: 1768:      /* The `await` keyword is interpreted as an IdentifierReference within function expressions */
    #####: 1769:      context_p->status_flags &= (uint32_t) ~PARSER_IS_CLASS_STATIC_BLOCK;
        -: 1770:#endif /* JERRY_ESNEXT */
        -: 1771:
    #####: 1772:      lexer_next_token (context_p);
        -: 1773:
        -: 1774:#if JERRY_ESNEXT
    #####: 1775:      context_p->status_flags |= parent_status_flags & PARSER_IS_CLASS_STATIC_BLOCK;
        -: 1776:#endif /* JERRY_ESNEXT */
        -: 1777:
    #####: 1778:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1779:      {
    #####: 1780:        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1781:      }
        -: 1782:
    #####: 1783:      parser_flush_cbc (context_p);
        -: 1784:
    #####: 1785:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
        -: 1786:
        -: 1787:#if JERRY_DEBUGGER
        -: 1788:      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1789:      {
        -: 1790:        jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,
        -: 1791:                                    JERRY_DEBUGGER_NO_SUBTYPE,
        -: 1792:                                    context_p->lit_object.literal_p->u.char_p,
        -: 1793:                                    context_p->lit_object.literal_p->prop.length);
        -: 1794:
        -: 1795:        /* Reset token position for the function. */
        -: 1796:        context_p->token.line = debugger_line;
        -: 1797:        context_p->token.column = debugger_column;
        -: 1798:      }
        -: 1799:#endif /* JERRY_DEBUGGER */
        -: 1800:
    #####: 1801:      if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1802:      {
    #####: 1803:        status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1804:      }
        -: 1805:
    #####: 1806:      function_name_index = context_p->lit_object.index;
        -: 1807:    }
        -: 1808:
        -: 1809:#if JERRY_ESNEXT
    #####: 1810:    context_p->status_flags = parent_status_flags;
        -: 1811:  }
        -: 1812:#endif /* JERRY_ESNEXT */
        -: 1813:
    #####: 1814:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1815:  {
    #####: 1816:    literals = 1;
    #####: 1817:    literal1 = context_p->last_cbc.literal_index;
    #####: 1818:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1819:  }
    #####: 1820:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1821:  {
    #####: 1822:    literals = 2;
    #####: 1823:    literal1 = context_p->last_cbc.literal_index;
    #####: 1824:    literal2 = context_p->last_cbc.value;
    #####: 1825:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1826:  }
        -: 1827:
    #####: 1828:  function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1829:
    #####: 1830:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1831:
        -: 1832:#if JERRY_ESNEXT
    #####: 1833:  if (function_name_index != -1)
        -: 1834:  {
    #####: 1835:    parser_set_function_name (context_p, function_literal_index, (uint16_t) function_name_index, 0);
        -: 1836:  }
        -: 1837:#endif /* JERRY_ESNEXT */
        -: 1838:
    #####: 1839:  if (literals == 1)
        -: 1840:  {
    #####: 1841:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1842:    context_p->last_cbc.literal_index = literal1;
    #####: 1843:    context_p->last_cbc.value = function_literal_index;
        -: 1844:  }
    #####: 1845:  else if (literals == 2)
        -: 1846:  {
    #####: 1847:    context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 1848:    context_p->last_cbc.literal_index = literal1;
    #####: 1849:    context_p->last_cbc.value = literal2;
    #####: 1850:    context_p->last_cbc.third_literal_index = function_literal_index;
        -: 1851:  }
        -: 1852:  else
        -: 1853:  {
    #####: 1854:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1855:
    #####: 1856:    if (function_name_index != -1)
        -: 1857:    {
    #####: 1858:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NAMED_FUNC_EXPRESSION);
    #####: 1859:      context_p->last_cbc.value = (uint16_t) function_name_index;
        -: 1860:    }
        -: 1861:  }
        -: 1862:
    #####: 1863:  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;
    #####: 1864:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####: 1865:} /* parser_parse_function_expression */
        -: 1866:
        -: 1867:#if JERRY_ESNEXT
        -: 1868:
        -: 1869:/**
        -: 1870: * Parse template literal.
        -: 1871: */
        -: 1872:static void
    #####: 1873:parser_parse_template_literal (parser_context_t *context_p) /**< context */
        -: 1874:{
    #####: 1875:  bool is_empty_head = true;
        -: 1876:
    #####: 1877:  if (context_p->token.lit_location.length > 0)
        -: 1878:  {
    #####: 1879:    is_empty_head = false;
        -: 1880:
    #####: 1881:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 1882:
    #####: 1883:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1884:  }
        -: 1885:
    #####: 1886:  lexer_next_token (context_p);
    #####: 1887:  parser_parse_expression (context_p, PARSE_EXPR);
        -: 1888:
    #####: 1889:  if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1890:  {
    #####: 1891:    parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1892:  }
        -: 1893:
    #####: 1894:  if (!is_empty_head)
        -: 1895:  {
    #####: 1896:    if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1897:    {
    #####: 1898:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
        -: 1899:    }
    #####: 1900:    else if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1901:    {
    #####: 1902:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1903:    }
        -: 1904:    else
        -: 1905:    {
    #####: 1906:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1907:    }
        -: 1908:  }
        -: 1909:
    #####: 1910:  context_p->source_p--;
    #####: 1911:  context_p->column--;
    #####: 1912:  lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1913:
    #####: 1914:  if (is_empty_head || context_p->token.lit_location.length > 0)
        -: 1915:  {
    #####: 1916:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 1917:
    #####: 1918:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1919:    {
    #####: 1920:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
    #####: 1921:      context_p->last_cbc.value = context_p->lit_object.index;
    #####: 1922:      context_p->last_cbc.literal_type = context_p->token.lit_location.type;
    #####: 1923:      context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        -: 1924:    }
        -: 1925:    else
        -: 1926:    {
    #####: 1927:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1928:    }
        -: 1929:  }
        -: 1930:
    #####: 1931:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1932:  {
    #####: 1933:    lexer_next_token (context_p);
        -: 1934:
    #####: 1935:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1936:
    #####: 1937:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1938:    {
    #####: 1939:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1940:    }
        -: 1941:
    #####: 1942:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1943:    {
    #####: 1944:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1945:    }
        -: 1946:    else
        -: 1947:    {
    #####: 1948:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1949:    }
        -: 1950:
    #####: 1951:    context_p->source_p--;
    #####: 1952:    context_p->column--;
    #####: 1953:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1954:
    #####: 1955:    if (context_p->token.lit_location.length > 0)
        -: 1956:    {
    #####: 1957:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 1958:
    #####: 1959:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1960:    }
        -: 1961:  }
    #####: 1962:} /* parser_parse_template_literal */
        -: 1963:
        -: 1964:/**
        -: 1965: * Parse tagged template literal.
        -: 1966: */
        -: 1967:static size_t
    #####: 1968:parser_parse_tagged_template_literal (parser_context_t *context_p) /**< context */
        -: 1969:{
    #####: 1970:  JERRY_ASSERT (context_p->token.type == LEXER_TEMPLATE_LITERAL);
        -: 1971:
    #####: 1972:  uint32_t call_arguments = 0;
        -: 1973:  ecma_collection_t *collection_p;
        -: 1974:
    #####: 1975:  if (context_p->tagged_template_literal_cp == JMEM_CP_NULL)
        -: 1976:  {
    #####: 1977:    collection_p = ecma_new_collection ();
    #####: 1978:    ECMA_SET_INTERNAL_VALUE_POINTER (context_p->tagged_template_literal_cp, collection_p);
        -: 1979:  }
        -: 1980:  else
        -: 1981:  {
    #####: 1982:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_p->tagged_template_literal_cp);
    #####: 1983:    if (collection_p->item_count > CBC_MAXIMUM_BYTE_VALUE)
        -: 1984:    {
    #####: 1985:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1986:    }
        -: 1987:  }
        -: 1988:
    #####: 1989:  const uint32_t tagged_id = collection_p->item_count;
    #####: 1990:  uint32_t prop_idx = 0;
    #####: 1991:  ecma_object_t *raw_strings_p;
    #####: 1992:  ecma_object_t *template_obj_p = parser_new_tagged_template_literal (&raw_strings_p);
    #####: 1993:  ecma_collection_push_back (collection_p, ecma_make_object_value (template_obj_p));
        -: 1994:
    #####: 1995:  parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 1996:
    #####: 1997:  call_arguments++;
    #####: 1998:  parser_emit_cbc_ext_call (context_p, CBC_EXT_GET_TAGGED_TEMPLATE_LITERAL, tagged_id);
        -: 1999:
    #####: 2000:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 2001:  {
    #####: 2002:    JERRY_ASSERT (context_p->source_p[-1] == LIT_CHAR_LEFT_BRACE);
    #####: 2003:    lexer_next_token (context_p);
        -: 2004:
    #####: 2005:    if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2006:    {
    #####: 2007:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2008:    }
        -: 2009:
    #####: 2010:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 2011:
    #####: 2012:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 2013:    {
    #####: 2014:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 2015:    }
        -: 2016:
    #####: 2017:    context_p->source_p--;
    #####: 2018:    context_p->column--;
    #####: 2019:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 2020:
    #####: 2021:    parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 2022:  }
        -: 2023:
    #####: 2024:  parser_tagged_template_literal_finalize (template_obj_p, raw_strings_p);
        -: 2025:
    #####: 2026:  return call_arguments;
        -: 2027:} /* parser_parse_tagged_template_literal */
        -: 2028:
        -: 2029:/**
        -: 2030: * Checks wheteher the current expression can be an assignment expression.
        -: 2031: *
        -: 2032: * @return true if the current expression can be an assignment expression, false otherwise
        -: 2033: */
        -: 2034:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 2035:parser_is_assignment_expr (parser_context_t *context_p)
        -: 2036:{
    #####: 2037:  return (context_p->stack_top_uint8 == LEXER_EXPRESSION_START || context_p->stack_top_uint8 == LEXER_LEFT_PAREN
    #####: 2038:          || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST
    #####: 2039:          || LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->stack_top_uint8));
        -: 2040:} /* parser_is_assignment_expr */
        -: 2041:
        -: 2042:/**
        -: 2043: * Throws an error if the current expression is not an assignment expression.
        -: 2044: */
        -: 2045:static inline void JERRY_ATTR_ALWAYS_INLINE
        -: 2046:parser_check_assignment_expr (parser_context_t *context_p)
        -: 2047:{
    #####: 2048:  if (!parser_is_assignment_expr (context_p))
        -: 2049:  {
    #####: 2050:    parser_raise_error (context_p, PARSER_ERR_ASSIGNMENT_EXPECTED);
        -: 2051:  }
        -: 2052:} /* parser_check_assignment_expr */
        -: 2053:
        -: 2054:/**
        -: 2055: * Checks whether the next token is a valid continuation token after an AssignmentExpression.
        -: 2056: */
        -: 2057:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 2058:parser_abort_parsing_after_assignment_expression (parser_context_t *context_p)
        -: 2059:{
    #####: 2060:  return (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_COMMA);
        -: 2061:} /* parser_abort_parsing_after_assignment_expression */
        -: 2062:
        -: 2063:#endif /* JERRY_ESNEXT */
        -: 2064:
        -: 2065:/**
        -: 2066: * Parse and record unary operators, and parse the primary literal.
        -: 2067: *
        -: 2068: * @return true if parsing should be aborted, true otherwise
        -: 2069: */
        -: 2070:static bool
        8: 2071:parser_parse_unary_expression (parser_context_t *context_p, /**< context */
        -: 2072:                               size_t *grouping_level_p) /**< grouping level */
        -: 2073:{
        8: 2074:  bool new_was_seen = false;
        -: 2075:
        -: 2076:  /* Collect unary operators. */
        -: 2077:  while (true)
        -: 2078:  {
        -: 2079:    /* Convert plus and minus binary operators to unary operators. */
       14: 2080:    switch (context_p->token.type)
        -: 2081:    {
    #####: 2082:      case LEXER_ADD:
        -: 2083:      {
    #####: 2084:        context_p->token.type = LEXER_PLUS;
    #####: 2085:        break;
        -: 2086:      }
        1: 2087:      case LEXER_SUBTRACT:
        -: 2088:      {
        1: 2089:        context_p->token.type = LEXER_NEGATE;
        1: 2090:        break;
        -: 2091:      }
        -: 2092:#if JERRY_ESNEXT
    #####: 2093:      case LEXER_KEYW_AWAIT:
        -: 2094:      {
        -: 2095:#if JERRY_MODULE_SYSTEM
    #####: 2096:        if ((context_p->global_status_flags & ECMA_PARSE_MODULE)
    #####: 2097:            && !(context_p->status_flags & PARSER_IS_ASYNC_FUNCTION))
        -: 2098:        {
    #####: 2099:          parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);
        -: 2100:        }
        -: 2101:#endif /* JERRY_MODULE_SYSTEM */
        -: 2102:
    #####: 2103:        if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 2104:        {
    #####: 2105:          parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 2106:        }
    #####: 2107:        break;
        -: 2108:      }
        -: 2109:#endif /* JERRY_ESNEXT */
        -: 2110:    }
        -: 2111:
        -: 2112:    /* Bracketed expressions are primary expressions. At this
        -: 2113:     * point their left paren is pushed onto the stack and
        -: 2114:     * they are processed when their closing paren is reached. */
       11: 2115:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2116:    {
        -: 2117:#if JERRY_ESNEXT
    #####: 2118:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2119:      {
    #####: 2120:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
    #####: 2121:        break;
        -: 2122:      }
        -: 2123:#endif /* JERRY_ESNEXT */
    #####: 2124:      (*grouping_level_p) += PARSER_GROUPING_LEVEL_INCREASE;
    #####: 2125:      new_was_seen = false;
        -: 2126:    }
       11: 2127:    else if (context_p->token.type == LEXER_KEYW_NEW)
        -: 2128:    {
        -: 2129:      /* After 'new' unary operators are not allowed. */
        2: 2130:      new_was_seen = true;
        -: 2131:
        -: 2132:#if JERRY_ESNEXT
        -: 2133:      /* Check if "new.target" is written here. */
        2: 2134:      if (scanner_try_scan_new_target (context_p))
        -: 2135:      {
    #####: 2136:        if (!(context_p->status_flags & PARSER_ALLOW_NEW_TARGET))
        -: 2137:        {
    #####: 2138:          parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -: 2139:        }
        -: 2140:
    #####: 2141:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_NEW_TARGET);
    #####: 2142:        lexer_next_token (context_p);
        -: 2143:        /* Found "new.target" return here */
    #####: 2144:        return false;
        -: 2145:      }
        -: 2146:#endif /* JERRY_ESNEXT */
        -: 2147:    }
        9: 2148:    else if (new_was_seen || (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE)
        7: 2149:             || !LEXER_IS_UNARY_OP_TOKEN (context_p->token.type))
        -: 2150:    {
        -: 2151:      break;
        -: 2152:    }
        -: 2153:
        3: 2154:    parser_stack_push_uint8 (context_p, context_p->token.type);
        3: 2155:    lexer_next_token (context_p);
        -: 2156:  }
        -: 2157:
        -: 2158:  /* Parse primary expression. */
        8: 2159:  switch (context_p->token.type)
        -: 2160:  {
        -: 2161:#if JERRY_ESNEXT
    #####: 2162:    case LEXER_HASHMARK:
        -: 2163:    {
    #####: 2164:      if (!lexer_scan_private_identifier (context_p))
        -: 2165:      {
    #####: 2166:        parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 2167:      }
        -: 2168:
    #####: 2169:      parser_resolve_private_identifier (context_p);
        -: 2170:
    #####: 2171:      lexer_next_token (context_p);
        -: 2172:
    #####: 2173:      if (context_p->token.type != LEXER_KEYW_IN)
        -: 2174:      {
    #####: 2175:        parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 2176:      }
        -: 2177:
    #####: 2178:      parser_stack_push_uint16 (context_p, context_p->lit_object.index);
    #####: 2179:      parser_stack_push_uint8 (context_p, LEXER_PRIVATE_PRIMARY_EXPR);
    #####: 2180:      return false;
        -: 2181:    }
    #####: 2182:    case LEXER_TEMPLATE_LITERAL:
        -: 2183:    {
    #####: 2184:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 2185:      {
    #####: 2186:        parser_parse_template_literal (context_p);
    #####: 2187:        break;
        -: 2188:      }
        -: 2189:
        -: 2190:      /* The string is a normal string literal. */
        -: 2191:      /* FALLTHRU */
        -: 2192:    }
        -: 2193:#endif /* JERRY_ESNEXT */
    #####: 2194:    case LEXER_LITERAL:
        -: 2195:    {
        -: 2196:#if JERRY_ESNEXT
        8: 2197:      if (JERRY_UNLIKELY (context_p->next_scanner_info_p->source_p == context_p->source_p))
        -: 2198:      {
    #####: 2199:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2200:
        -: 2201:#if JERRY_FUNCTION_TO_STRING
    #####: 2202:        context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2203:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2204:
    #####: 2205:        uint32_t arrow_status_flags =
        -: 2206:          (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION
    #####: 2207:           | (context_p->status_flags & (PARSER_INSIDE_CLASS_FIELD | PARSER_IS_CLASS_STATIC_BLOCK)));
        -: 2208:
    #####: 2209:        if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)
        -: 2210:        {
    #####: 2211:          JERRY_ASSERT (lexer_token_is_async (context_p));
    #####: 2212:          JERRY_ASSERT (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT));
        -: 2213:
    #####: 2214:          uint32_t saved_status_flags = context_p->status_flags;
        -: 2215:
    #####: 2216:          context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 2217:          lexer_next_token (context_p);
    #####: 2218:          context_p->status_flags = saved_status_flags;
        -: 2219:
    #####: 2220:          if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -: 2221:          {
    #####: 2222:            uint32_t status_flags = (PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION | PARSER_IS_ASYNC_FUNCTION
        -: 2223:                                     | PARSER_DISALLOW_AWAIT_YIELD);
    #####: 2224:            parser_parse_function_expression (context_p, status_flags);
    #####: 2225:            break;
        -: 2226:          }
        -: 2227:
    #####: 2228:          arrow_status_flags =
        -: 2229:            (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION | PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD);
        -: 2230:        }
        -: 2231:
    #####: 2232:        parser_check_assignment_expr (context_p);
    #####: 2233:        parser_parse_function_expression (context_p, arrow_status_flags);
    #####: 2234:        return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2235:      }
        -: 2236:#endif /* JERRY_ESNEXT */
        -: 2237:
        8: 2238:      uint8_t type = context_p->token.lit_location.type;
        -: 2239:
        8: 2240:      if (type == LEXER_IDENT_LITERAL || type == LEXER_STRING_LITERAL)
        -: 2241:      {
        5: 2242:        lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 2243:      }
        3: 2244:      else if (type == LEXER_NUMBER_LITERAL)
        -: 2245:      {
        3: 2246:        bool is_negative_number = false;
        -: 2247:
        3: 2248:        if ((context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE)
        1: 2249:            && !lexer_check_post_primary_exp (context_p))
        -: 2250:        {
        -: 2251:          do
        -: 2252:          {
        1: 2253:            if (context_p->stack_top_uint8 == LEXER_NEGATE)
        -: 2254:            {
        1: 2255:              is_negative_number = !is_negative_number;
        -: 2256:            }
        -: 2257:#if JERRY_BUILTIN_BIGINT
    #####: 2258:            else if (JERRY_LIKELY (context_p->token.extra_value == LEXER_NUMBER_BIGINT))
        -: 2259:            {
    #####: 2260:              break;
        -: 2261:            }
        -: 2262:#endif /* JERRY_BUILTIN_BIGINT */
        1: 2263:            parser_stack_pop_uint8 (context_p);
        1: 2264:          } while (context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE);
        -: 2265:        }
        -: 2266:
        3: 2267:        if (lexer_construct_number_object (context_p, true, is_negative_number))
        -: 2268:        {
        2: 2269:          JERRY_ASSERT (context_p->lit_object.index <= CBC_PUSH_NUMBER_BYTE_RANGE_END);
        -: 2270:
        2: 2271:          parser_emit_cbc_push_number (context_p, is_negative_number);
        2: 2272:          break;
        -: 2273:        }
        -: 2274:      }
        -: 2275:
        6: 2276:      cbc_opcode_t opcode = CBC_PUSH_LITERAL;
        -: 2277:
        6: 2278:      if (context_p->token.keyword_type != LEXER_KEYW_EVAL)
        -: 2279:      {
        6: 2280:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2281:        {
        2: 2282:          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        2: 2283:          context_p->last_cbc.value = context_p->lit_object.index;
        2: 2284:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
        2: 2285:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        2: 2286:          break;
        -: 2287:        }
        -: 2288:
        4: 2289:        if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2290:        {
    #####: 2291:          context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 2292:          context_p->last_cbc.third_literal_index = context_p->lit_object.index;
    #####: 2293:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
    #####: 2294:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
    #####: 2295:          break;
        -: 2296:        }
        -: 2297:
        4: 2298:        if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 2299:        {
    #####: 2300:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 2301:          opcode = CBC_PUSH_THIS_LITERAL;
        -: 2302:        }
        -: 2303:      }
        -: 2304:
        4: 2305:      parser_emit_cbc_literal_from_token (context_p, (uint16_t) opcode);
        4: 2306:      break;
        -: 2307:    }
    #####: 2308:    case LEXER_KEYW_FUNCTION:
        -: 2309:    {
        -: 2310:#if JERRY_FUNCTION_TO_STRING
    #####: 2311:      context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2312:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 2313:      parser_parse_function_expression (context_p, PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION);
    #####: 2314:      break;
        -: 2315:    }
    #####: 2316:    case LEXER_LEFT_BRACE:
        -: 2317:    {
        -: 2318:#if JERRY_ESNEXT
    #####: 2319:      if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 2320:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 2321:      {
    #####: 2322:        if (parser_is_assignment_expr (context_p))
        -: 2323:        {
    #####: 2324:          uint32_t flags = PARSER_PATTERN_NO_OPTS;
        -: 2325:
    #####: 2326:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 2327:          {
    #####: 2328:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 2329:          }
        -: 2330:
    #####: 2331:          parser_parse_object_initializer (context_p, flags);
    #####: 2332:          return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2333:        }
        -: 2334:
    #####: 2335:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 2336:      }
        -: 2337:#endif /* JERRY_ESNEXT */
        -: 2338:
    #####: 2339:      parser_parse_object_literal (context_p);
    #####: 2340:      break;
        -: 2341:    }
    #####: 2342:    case LEXER_LEFT_SQUARE:
        -: 2343:    {
        -: 2344:#if JERRY_ESNEXT
    #####: 2345:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2346:      {
    #####: 2347:        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 2348:        {
    #####: 2349:          if (parser_is_assignment_expr (context_p))
        -: 2350:          {
    #####: 2351:            parser_parse_array_initializer (context_p, PARSER_PATTERN_NO_OPTS);
    #####: 2352:            return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2353:          }
        -: 2354:
    #####: 2355:          scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 2356:        }
        -: 2357:        else
        -: 2358:        {
    #####: 2359:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
        -: 2360:                        && context_p->next_scanner_info_p->u8_arg == SCANNER_LITERAL_NO_DESTRUCTURING);
        -: 2361:
    #####: 2362:          scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 2363:        }
        -: 2364:      }
        -: 2365:#endif /* JERRY_ESNEXT */
        -: 2366:
    #####: 2367:      parser_parse_array_literal (context_p);
    #####: 2368:      break;
        -: 2369:    }
    #####: 2370:    case LEXER_DIVIDE:
        -: 2371:    case LEXER_ASSIGN_DIVIDE:
        -: 2372:    {
    #####: 2373:      lexer_construct_regexp_object (context_p, false);
    #####: 2374:      uint16_t literal_index = (uint16_t) (context_p->literal_count - 1);
        -: 2375:
    #####: 2376:      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2377:      {
    #####: 2378:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 2379:        context_p->last_cbc.value = literal_index;
        -: 2380:      }
    #####: 2381:      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2382:      {
    #####: 2383:        context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 2384:        context_p->last_cbc.third_literal_index = literal_index;
        -: 2385:      }
        -: 2386:      else
        -: 2387:      {
    #####: 2388:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -: 2389:      }
        -: 2390:
    #####: 2391:      context_p->last_cbc.literal_type = LEXER_REGEXP_LITERAL;
    #####: 2392:      context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####: 2393:      break;
        -: 2394:    }
    #####: 2395:    case LEXER_KEYW_THIS:
        -: 2396:    {
        -: 2397:#if JERRY_ESNEXT
    #####: 2398:      if (context_p->status_flags & PARSER_ALLOW_SUPER_CALL)
        -: 2399:      {
    #####: 2400:        parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_LEXICAL_THIS);
        -: 2401:      }
        -: 2402:      else
        -: 2403:      {
        -: 2404:#endif /* JERRY_ESNEXT */
    #####: 2405:        parser_emit_cbc (context_p, CBC_PUSH_THIS);
        -: 2406:#if JERRY_ESNEXT
        -: 2407:      }
        -: 2408:#endif /* JERRY_ESNEXT */
    #####: 2409:      break;
        -: 2410:    }
    #####: 2411:    case LEXER_LIT_TRUE:
        -: 2412:    {
    #####: 2413:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
    #####: 2414:      break;
        -: 2415:    }
    #####: 2416:    case LEXER_LIT_FALSE:
        -: 2417:    {
    #####: 2418:      parser_emit_cbc (context_p, CBC_PUSH_FALSE);
    #####: 2419:      break;
        -: 2420:    }
    #####: 2421:    case LEXER_LIT_NULL:
        -: 2422:    {
    #####: 2423:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
    #####: 2424:      break;
        -: 2425:    }
        -: 2426:#if JERRY_ESNEXT
    #####: 2427:    case LEXER_KEYW_CLASS:
        -: 2428:    {
    #####: 2429:      parser_parse_class (context_p, false);
    #####: 2430:      return false;
        -: 2431:    }
    #####: 2432:    case LEXER_KEYW_SUPER:
        -: 2433:    {
    #####: 2434:      if (context_p->status_flags & PARSER_ALLOW_SUPER)
        -: 2435:      {
    #####: 2436:        if (lexer_check_next_characters (context_p, LIT_CHAR_DOT, LIT_CHAR_LEFT_SQUARE))
        -: 2437:        {
    #####: 2438:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER);
    #####: 2439:          break;
        -: 2440:        }
        -: 2441:
    #####: 2442:        if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN)
    #####: 2443:            && (context_p->status_flags & PARSER_ALLOW_SUPER_CALL))
        -: 2444:        {
    #####: 2445:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_CONSTRUCTOR);
    #####: 2446:          break;
        -: 2447:        }
        -: 2448:      }
        -: 2449:
    #####: 2450:      parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_SUPER_KEYWORD);
        -: 2451:    }
    #####: 2452:    case LEXER_LEFT_PAREN:
        -: 2453:    {
    #####: 2454:      JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p
        -: 2455:                    && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2456:
    #####: 2457:      parser_check_assignment_expr (context_p);
        -: 2458:
        -: 2459:#if JERRY_FUNCTION_TO_STRING
    #####: 2460:      context_p->function_start_p = context_p->source_p - 1;
        -: 2461:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2462:
    #####: 2463:      uint32_t arrow_status_flags =
        -: 2464:        (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION
    #####: 2465:         | (context_p->status_flags & (PARSER_INSIDE_CLASS_FIELD | PARSER_IS_CLASS_STATIC_BLOCK)));
    #####: 2466:      parser_parse_function_expression (context_p, arrow_status_flags);
    #####: 2467:      return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2468:    }
    #####: 2469:    case LEXER_KEYW_YIELD:
        -: 2470:    {
    #####: 2471:      JERRY_ASSERT ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 2472:                    && !(context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD));
        -: 2473:
    #####: 2474:      if (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)
        -: 2475:      {
    #####: 2476:        parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 2477:      }
        -: 2478:
    #####: 2479:      parser_check_assignment_expr (context_p);
    #####: 2480:      lexer_next_token (context_p);
        -: 2481:
    #####: 2482:      cbc_ext_opcode_t opcode =
    #####: 2483:        ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD : CBC_EXT_YIELD);
    #####: 2484:      if (!lexer_check_yield_no_arg (context_p))
        -: 2485:      {
    #####: 2486:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 2487:        {
    #####: 2488:          lexer_next_token (context_p);
    #####: 2489:          opcode = ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD_ITERATOR
    #####: 2490:                                                                         : CBC_EXT_YIELD_ITERATOR);
        -: 2491:        }
        -: 2492:
    #####: 2493:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2494:      }
        -: 2495:      else
        -: 2496:      {
    #####: 2497:        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 2498:      }
        -: 2499:
    #####: 2500:      parser_emit_cbc_ext (context_p, opcode);
        -: 2501:
    #####: 2502:      return (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_COMMA);
        -: 2503:    }
        -: 2504:#endif /* JERRY_ESNEXT */
        -: 2505:#if JERRY_MODULE_SYSTEM
    #####: 2506:    case LEXER_KEYW_IMPORT:
        -: 2507:    {
    #####: 2508:      lexer_next_token (context_p);
        -: 2509:
    #####: 2510:      if (context_p->token.type == LEXER_DOT)
        -: 2511:      {
    #####: 2512:        lexer_next_token (context_p);
        -: 2513:
    #####: 2514:        if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL
    #####: 2515:            || context_p->token.keyword_type != LEXER_KEYW_META
    #####: 2516:            || (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 2517:        {
    #####: 2518:          parser_raise_error (context_p, PARSER_ERR_META_EXPECTED);
        -: 2519:        }
        -: 2520:
    #####: 2521:        if (!(context_p->global_status_flags & ECMA_PARSE_MODULE))
        -: 2522:        {
    #####: 2523:          parser_raise_error (context_p, PARSER_ERR_IMPORT_META_REQUIRE_MODULE);
        -: 2524:        }
        -: 2525:
    #####: 2526:        JERRY_ASSERT (context_p->global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META);
        -: 2527:
    #####: 2528:        parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT_META);
    #####: 2529:        break;
        -: 2530:      }
        -: 2531:
    #####: 2532:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2533:      {
    #####: 2534:        parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 2535:      }
        -: 2536:
    #####: 2537:      if (new_was_seen)
        -: 2538:      {
    #####: 2539:        parser_raise_error (context_p, PARSER_ERR_IMPORT_AFTER_NEW);
        -: 2540:      }
        -: 2541:
    #####: 2542:      lexer_next_token (context_p);
    #####: 2543:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2544:
    #####: 2545:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2546:      {
    #####: 2547:        parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2548:      }
        -: 2549:
    #####: 2550:      parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT);
    #####: 2551:      break;
        -: 2552:    }
        -: 2553:#endif /* JERRY_MODULE_SYSTEM */
    #####: 2554:    default:
        -: 2555:    {
    #####: 2556:      bool is_left_hand_side = (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE);
    #####: 2557:      parser_raise_error (context_p,
        -: 2558:                          (is_left_hand_side ? PARSER_ERR_LEFT_HAND_SIDE_EXP_EXPECTED : PARSER_ERR_UNEXPECTED_END));
    #####: 2559:      break;
        -: 2560:    }
        -: 2561:  }
        8: 2562:  lexer_next_token (context_p);
        8: 2563:  return false;
        -: 2564:} /* parser_parse_unary_expression */
        -: 2565:
        -: 2566:/**
        -: 2567: * Parse the postfix part of unary operators, and
        -: 2568: * generate byte code for the whole expression.
        -: 2569: */
        -: 2570:static void
       12: 2571:parser_process_unary_expression (parser_context_t *context_p, /**< context */
        -: 2572:                                 size_t grouping_level) /**< grouping level */
        -: 2573:{
        -: 2574:  /* Parse postfix part of a primary expression. */
        -: 2575:  while (true)
        -: 2576:  {
        -: 2577:    /* Since break would only break the switch, we use
        -: 2578:     * continue to continue this loop. Without continue,
        -: 2579:     * the code abandons the loop. */
       16: 2580:    switch (context_p->token.type)
        -: 2581:    {
        1: 2582:      case LEXER_DOT:
        -: 2583:      {
        1: 2584:        parser_push_result (context_p);
        -: 2585:
        -: 2586:#if JERRY_ESNEXT
        1: 2587:        if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -: 2588:        {
    #####: 2589:          lexer_next_token (context_p);
        -: 2590:
    #####: 2591:          if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2592:          {
    #####: 2593:            parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_PRIVATE_FIELD);
        -: 2594:          }
        -: 2595:
    #####: 2596:          if (!lexer_scan_private_identifier (context_p))
        -: 2597:          {
    #####: 2598:            parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 2599:          }
        -: 2600:
    #####: 2601:          parser_resolve_private_identifier (context_p);
        -: 2602:
    #####: 2603:          parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_PRIVATE_PROP_LITERAL, context_p->lit_object.index);
    #####: 2604:          lexer_next_token (context_p);
    #####: 2605:          continue;
        -: 2606:        }
        -: 2607:#endif /* JERRY_ESNEXT */
        1: 2608:        lexer_expect_identifier (context_p, LEXER_STRING_LITERAL);
        -: 2609:
        1: 2610:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 2611:                      && context_p->lit_object.literal_p->type == LEXER_STRING_LITERAL);
        1: 2612:        context_p->token.lit_location.type = LEXER_STRING_LITERAL;
        -: 2613:
        1: 2614:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2615:        {
        1: 2616:          JERRY_ASSERT (CBC_ARGS_EQ (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        1: 2617:          context_p->last_cbc_opcode = CBC_PUSH_PROP_LITERAL_LITERAL;
        1: 2618:          context_p->last_cbc.value = context_p->lit_object.index;
        -: 2619:        }
    #####: 2620:        else if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 2621:        {
    #####: 2622:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 2623:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_THIS_LITERAL);
        -: 2624:        }
        -: 2625:#if JERRY_ESNEXT
    #####: 2626:        else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2627:        {
    #####: 2628:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL);
    #####: 2629:          context_p->last_cbc.literal_index = context_p->lit_object.index;
        -: 2630:        }
        -: 2631:#endif /* JERRY_ESNEXT */
        -: 2632:        else
        -: 2633:        {
    #####: 2634:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_LITERAL);
        -: 2635:        }
        1: 2636:        lexer_next_token (context_p);
        1: 2637:        continue;
        -: 2638:      }
        -: 2639:
    #####: 2640:      case LEXER_LEFT_SQUARE:
        -: 2641:      {
    #####: 2642:        parser_push_result (context_p);
        -: 2643:
        -: 2644:#if JERRY_ESNEXT
    #####: 2645:        uint16_t last_cbc_opcode = context_p->last_cbc_opcode;
        -: 2646:
    #####: 2647:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2648:        {
    #####: 2649:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2650:        }
        -: 2651:#endif /* JERRY_ESNEXT */
        -: 2652:
    #####: 2653:        lexer_next_token (context_p);
    #####: 2654:        parser_parse_expression (context_p, PARSE_EXPR);
    #####: 2655:        if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 2656:        {
    #####: 2657:          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);
        -: 2658:        }
    #####: 2659:        lexer_next_token (context_p);
        -: 2660:
        -: 2661:#if JERRY_ESNEXT
    #####: 2662:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2663:        {
    #####: 2664:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_PROP);
    #####: 2665:          continue;
        -: 2666:        }
        -: 2667:#endif /* JERRY_ESNEXT */
        -: 2668:
    #####: 2669:        if (PARSER_IS_MUTABLE_PUSH_LITERAL (context_p->last_cbc_opcode))
        -: 2670:        {
    #####: 2671:          context_p->last_cbc_opcode = PARSER_PUSH_LITERAL_TO_PUSH_PROP_LITERAL (context_p->last_cbc_opcode);
        -: 2672:        }
        -: 2673:        else
        -: 2674:        {
    #####: 2675:          parser_emit_cbc (context_p, CBC_PUSH_PROP);
        -: 2676:        }
    #####: 2677:        continue;
        -: 2678:      }
        -: 2679:
        -: 2680:#if JERRY_ESNEXT
        3: 2681:      case LEXER_TEMPLATE_LITERAL:
        -: 2682:#endif /* JERRY_ESNEXT */
    #####: 2683:      case LEXER_LEFT_PAREN:
        -: 2684:      {
        3: 2685:        size_t call_arguments = 0;
        3: 2686:        uint16_t opcode = CBC_CALL;
        3: 2687:        bool is_eval = false;
        -: 2688:
        3: 2689:        parser_push_result (context_p);
        -: 2690:
        3: 2691:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2692:        {
        -: 2693:#if JERRY_ESNEXT
        2: 2694:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2695:#endif /* JERRY_ESNEXT */
        -: 2696:          {
        2: 2697:            parser_stack_pop_uint8 (context_p);
        2: 2698:            opcode = CBC_NEW;
        -: 2699:          }
        -: 2700:        }
        -: 2701:        else
        -: 2702:        {
        1: 2703:          if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL
    #####: 2704:              && context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL
    #####: 2705:              && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2706:          {
    #####: 2707:            is_eval = true;
        -: 2708:          }
        -: 2709:
        1: 2710:          if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 2711:          {
        1: 2712:            opcode = CBC_CALL_PROP;
        1: 2713:            context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 2714:          }
        -: 2715:#if JERRY_ESNEXT
    #####: 2716:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_CONSTRUCTOR))
        -: 2717:          {
    #####: 2718:            opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL);
        -: 2719:          }
    #####: 2720:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 2721:          {
    #####: 2722:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_REFERENCE);
    #####: 2723:            opcode = CBC_CALL_PROP;
        -: 2724:          }
    #####: 2725:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 2726:          {
    #####: 2727:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_REFERENCE);
    #####: 2728:            opcode = CBC_CALL_PROP;
        -: 2729:          }
    #####: 2730:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL))
        -: 2731:          {
    #####: 2732:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL_REFERENCE);
    #####: 2733:            opcode = CBC_CALL_PROP;
        -: 2734:          }
        -: 2735:#endif /* JERRY_ESNEXT */
    #####: 2736:          else if (JERRY_UNLIKELY (context_p->status_flags & PARSER_INSIDE_WITH)
    #####: 2737:                   && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2738:                   && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2739:          {
    #####: 2740:            opcode = CBC_CALL_PROP;
    #####: 2741:            parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
    #####: 2742:            parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_BASE);
        -: 2743:          }
        -: 2744:        }
        -: 2745:
        -: 2746:#if JERRY_ESNEXT
        3: 2747:        bool has_spread_element = false;
        -: 2748:
        3: 2749:        if (context_p->token.type == LEXER_TEMPLATE_LITERAL)
        -: 2750:        {
    #####: 2751:          call_arguments = parser_parse_tagged_template_literal (context_p);
        -: 2752:        }
        -: 2753:        else
        -: 2754:        {
        3: 2755:          lexer_next_token (context_p);
        -: 2756:
        3: 2757:          while (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2758:          {
        5: 2759:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2760:            {
    #####: 2761:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2762:            }
        -: 2763:
        5: 2764:            if (context_p->token.type == LEXER_THREE_DOTS)
        -: 2765:            {
    #####: 2766:              has_spread_element = true;
    #####: 2767:              call_arguments++;
    #####: 2768:              parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
    #####: 2769:              lexer_next_token (context_p);
        -: 2770:            }
        -: 2771:
        5: 2772:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2773:
        5: 2774:            if (context_p->token.type == LEXER_COMMA)
        -: 2775:            {
        2: 2776:              lexer_next_token (context_p);
        2: 2777:              continue;
        -: 2778:            }
        -: 2779:
        3: 2780:            if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2781:            {
    #####: 2782:              parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2783:            }
        -: 2784:
        3: 2785:            break;
        -: 2786:          }
        -: 2787:        }
        -: 2788:#else /* !JERRY_ESNEXT */
    #####: 2789:        lexer_next_token (context_p);
        -: 2790:
    #####: 2791:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2792:        {
        -: 2793:          while (true)
        -: 2794:          {
    #####: 2795:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2796:            {
    #####: 2797:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2798:            }
        -: 2799:
    #####: 2800:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2801:
    #####: 2802:            if (context_p->token.type != LEXER_COMMA)
        -: 2803:            {
        -: 2804:              break;
        -: 2805:            }
    #####: 2806:            lexer_next_token (context_p);
        -: 2807:          }
        -: 2808:
    #####: 2809:          if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2810:          {
    #####: 2811:            parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2812:          }
        -: 2813:        }
        -: 2814:#endif /* JERRY_ESNEXT */
        -: 2815:
        3: 2816:        lexer_next_token (context_p);
        -: 2817:
        3: 2818:        if (is_eval)
        -: 2819:        {
    #####: 2820:          context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2821:
        -: 2822:#if JERRY_ESNEXT
    #####: 2823:          uint16_t eval_flags = PARSER_SAVE_STATUS_FLAGS (context_p->status_flags);
    #####: 2824:          const uint32_t required_flags = PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2825:
    #####: 2826:          if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2827:          {
    #####: 2828:            context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2829:          }
    #####: 2830:          else if (((context_p->status_flags & (required_flags | PARSER_IS_STRICT)) == required_flags)
    #####: 2831:                   || ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
    #####: 2832:                       && !(context_p->status_flags & PARSER_IS_FUNCTION)))
        -: 2833:          {
    #####: 2834:            eval_flags |= PARSER_GET_EVAL_FLAG (ECMA_PARSE_FUNCTION_CONTEXT);
        -: 2835:          }
        -: 2836:
    #####: 2837:          if (eval_flags != 0)
        -: 2838:          {
    #####: 2839:            parser_emit_cbc_ext_call (context_p, CBC_EXT_LOCAL_EVAL, eval_flags);
        -: 2840:          }
        -: 2841:          else
        -: 2842:          {
        -: 2843:#endif /* JERRY_ESNEXT */
    #####: 2844:            parser_emit_cbc (context_p, CBC_EVAL);
        -: 2845:#if JERRY_ESNEXT
        -: 2846:          }
        -: 2847:#endif /* JERRY_ESNEXT */
        -: 2848:        }
        -: 2849:
        -: 2850:#if JERRY_ESNEXT
        3: 2851:        if (has_spread_element)
        -: 2852:        {
        -: 2853:          uint16_t spread_opcode;
        -: 2854:
    #####: 2855:          if (opcode == CBC_CALL)
        -: 2856:          {
    #####: 2857:            spread_opcode = CBC_EXT_SPREAD_CALL;
        -: 2858:          }
    #####: 2859:          else if (opcode == CBC_CALL_PROP)
        -: 2860:          {
    #####: 2861:            spread_opcode = CBC_EXT_SPREAD_CALL_PROP;
        -: 2862:          }
    #####: 2863:          else if (opcode == CBC_NEW)
        -: 2864:          {
    #####: 2865:            spread_opcode = CBC_EXT_SPREAD_NEW;
        -: 2866:          }
        -: 2867:          else
        -: 2868:          {
        -: 2869:            /* opcode is unchanged */
    #####: 2870:            JERRY_ASSERT (opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL));
    #####: 2871:            spread_opcode = CBC_EXT_SPREAD_SUPER_CALL;
        -: 2872:          }
        -: 2873:
    #####: 2874:          parser_emit_cbc_ext_call (context_p, spread_opcode, call_arguments);
    #####: 2875:          continue;
        -: 2876:        }
        -: 2877:#endif /* JERRY_ESNEXT */
        -: 2878:
        3: 2879:        if (call_arguments <= 1)
        -: 2880:        {
        2: 2881:          if (opcode == CBC_CALL)
        -: 2882:          {
    #####: 2883:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0 + (call_arguments * 6)));
    #####: 2884:            continue;
        -: 2885:          }
        2: 2886:          if (opcode == CBC_CALL_PROP)
        -: 2887:          {
    #####: 2888:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0_PROP + (call_arguments * 6)));
    #####: 2889:            continue;
        -: 2890:          }
        2: 2891:          if (opcode == CBC_NEW)
        -: 2892:          {
        2: 2893:            parser_emit_cbc (context_p, (uint16_t) (CBC_NEW0 + call_arguments));
        2: 2894:            continue;
        -: 2895:          }
        -: 2896:        }
        1: 2897:        else if (call_arguments == 2)
        -: 2898:        {
    #####: 2899:          if (opcode == CBC_CALL)
        -: 2900:          {
    #####: 2901:            parser_emit_cbc (context_p, CBC_CALL2);
    #####: 2902:            continue;
        -: 2903:          }
    #####: 2904:          if (opcode == CBC_CALL_PROP)
        -: 2905:          {
    #####: 2906:            parser_flush_cbc (context_p);
        -: 2907:            /* Manually adjusting stack usage. */
    #####: 2908:            JERRY_ASSERT (context_p->stack_depth > 0);
    #####: 2909:            context_p->stack_depth--;
    #####: 2910:            parser_emit_cbc (context_p, CBC_CALL2_PROP);
    #####: 2911:            continue;
        -: 2912:          }
        -: 2913:        }
        -: 2914:
        1: 2915:        parser_emit_cbc_call (context_p, opcode, call_arguments);
        1: 2916:        continue;
        -: 2917:      }
        8: 2918:      default:
        -: 2919:      {
        8: 2920:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2921:        {
    #####: 2922:          parser_push_result (context_p);
    #####: 2923:          parser_emit_cbc (context_p, CBC_NEW0);
    #####: 2924:          parser_stack_pop_uint8 (context_p);
    #####: 2925:          continue;
        -: 2926:        }
        -: 2927:
        8: 2928:        if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
        8: 2929:            && (context_p->token.type == LEXER_INCREASE || context_p->token.type == LEXER_DECREASE)
    #####: 2930:            && grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)
        -: 2931:        {
    #####: 2932:          cbc_opcode_t opcode = (context_p->token.type == LEXER_INCREASE) ? CBC_POST_INCR : CBC_POST_DECR;
    #####: 2933:          parser_push_result (context_p);
    #####: 2934:          parser_emit_unary_lvalue_opcode (context_p, opcode);
    #####: 2935:          lexer_next_token (context_p);
        -: 2936:        }
        8: 2937:        break;
        -: 2938:      }
        -: 2939:    }
        8: 2940:    break;
        -: 2941:  }
        -: 2942:
        -: 2943:#if JERRY_ESNEXT
        8: 2944:  uint8_t last_unary_token = LEXER_INCREASE;
        -: 2945:#endif /* JERRY_ESNEXT */
        -: 2946:
        -: 2947:  /* Generate byte code for the unary operators. */
        -: 2948:  while (true)
    #####: 2949:  {
        8: 2950:    uint8_t token = context_p->stack_top_uint8;
        8: 2951:    if (!LEXER_IS_UNARY_OP_TOKEN (token))
        -: 2952:    {
        -: 2953:#if JERRY_ESNEXT
        8: 2954:      if (context_p->token.type == LEXER_EXPONENTIATION && last_unary_token != LEXER_INCREASE
    #####: 2955:          && last_unary_token != LEXER_DECREASE)
        -: 2956:      {
    #####: 2957:        parser_raise_error (context_p, PARSER_ERR_INVALID_EXPONENTIATION);
        -: 2958:      }
        -: 2959:#endif /* JERRY_ESNEXT */
        8: 2960:      break;
        -: 2961:    }
        -: 2962:
        -: 2963:#if JERRY_ESNEXT
    #####: 2964:    last_unary_token = token;
        -: 2965:#endif /* JERRY_ESNEXT */
        -: 2966:
    #####: 2967:    parser_push_result (context_p);
    #####: 2968:    parser_stack_pop_uint8 (context_p);
        -: 2969:
    #####: 2970:    if (LEXER_IS_UNARY_LVALUE_OP_TOKEN (token))
        -: 2971:    {
    #####: 2972:      if (token == LEXER_KEYW_DELETE)
        -: 2973:      {
    #####: 2974:        token = CBC_DELETE_PUSH_RESULT;
        -: 2975:      }
        -: 2976:      else
        -: 2977:      {
    #####: 2978:        token = (uint8_t) (LEXER_UNARY_LVALUE_OP_TOKEN_TO_OPCODE (token));
        -: 2979:      }
    #####: 2980:      parser_emit_unary_lvalue_opcode (context_p, (cbc_opcode_t) token);
        -: 2981:    }
        -: 2982:#if JERRY_ESNEXT
    #####: 2983:    else if (JERRY_UNLIKELY (token == LEXER_KEYW_AWAIT))
        -: 2984:    {
    #####: 2985:      cbc_ext_opcode_t opcode =
    #####: 2986:        ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION) ? CBC_EXT_GENERATOR_AWAIT : CBC_EXT_AWAIT);
    #####: 2987:      parser_emit_cbc_ext (context_p, opcode);
        -: 2988:    }
        -: 2989:#endif /* JERRY_ESNEXT */
        -: 2990:    else
        -: 2991:    {
    #####: 2992:      token = (uint8_t) (LEXER_UNARY_OP_TOKEN_TO_OPCODE (token));
        -: 2993:
    #####: 2994:      if (token == CBC_TYPEOF)
        -: 2995:      {
    #####: 2996:        if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2997:            && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2998:        {
    #####: 2999:          parser_emit_ident_reference (context_p, CBC_TYPEOF_IDENT);
        -: 3000:        }
        -: 3001:        else
        -: 3002:        {
    #####: 3003:          parser_emit_cbc (context_p, token);
        -: 3004:        }
        -: 3005:      }
        -: 3006:      else
        -: 3007:      {
    #####: 3008:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3009:        {
        -: 3010:          /* It is not worth to combine with push multiple literals
        -: 3011:           * since the byte code size will not decrease. */
    #####: 3012:          JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, token + 1));
    #####: 3013:          context_p->last_cbc_opcode = (uint16_t) (token + 1);
        -: 3014:        }
        -: 3015:        else
        -: 3016:        {
    #####: 3017:          parser_emit_cbc (context_p, token);
        -: 3018:        }
        -: 3019:      }
        -: 3020:    }
        -: 3021:  }
        8: 3022:} /* parser_process_unary_expression */
        -: 3023:
        -: 3024:/**
        -: 3025: * Append a binary '=' token.
        -: 3026: *
        -: 3027: * @return - pushed assignment opcode onto the parser stack
        -: 3028: */
        -: 3029:static void
    #####: 3030:parser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */
        -: 3031:                                              uint32_t pattern_flags) /**< pattern flags */
        -: 3032:{
        -: 3033:  JERRY_UNUSED (pattern_flags);
        -: 3034:
        -: 3035:  /* Unlike other tokens, the whole byte code is saved for binary
        -: 3036:   * assignment, since it has multiple forms depending on the
        -: 3037:   * previous instruction. */
        -: 3038:
    #####: 3039:  uint8_t assign_opcode = CBC_ASSIGN;
        -: 3040:
    #####: 3041:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 3042:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
    #####: 3043:  {
    #####: 3044:    parser_check_invalid_assign (context_p);
        -: 3045:
        -: 3046:    uint16_t literal_index;
        -: 3047:
    #####: 3048:    switch (context_p->last_cbc_opcode)
        -: 3049:    {
    #####: 3050:      case CBC_PUSH_LITERAL:
        -: 3051:      {
    #####: 3052:        literal_index = context_p->last_cbc.literal_index;
    #####: 3053:        context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 3054:        break;
        -: 3055:      }
    #####: 3056:      case CBC_PUSH_TWO_LITERALS:
        -: 3057:      {
    #####: 3058:        literal_index = context_p->last_cbc.value;
    #####: 3059:        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####: 3060:        break;
        -: 3061:      }
    #####: 3062:      case CBC_PUSH_THIS_LITERAL:
        -: 3063:      {
    #####: 3064:        literal_index = context_p->last_cbc.literal_index;
    #####: 3065:        context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####: 3066:        parser_flush_cbc (context_p);
    #####: 3067:        break;
        -: 3068:      }
    #####: 3069:      default:
        -: 3070:      {
    #####: 3071:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####: 3072:        literal_index = context_p->last_cbc.third_literal_index;
    #####: 3073:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 3074:        break;
        -: 3075:      }
        -: 3076:    }
        -: 3077:
    #####: 3078:    assign_opcode = CBC_ASSIGN_SET_IDENT;
        -: 3079:
        -: 3080:#if JERRY_ESNEXT
    #####: 3081:    if (!(pattern_flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST | PARSER_PATTERN_LOCAL)))
        -: 3082:    {
    #####: 3083:      if (scanner_literal_is_const_reg (context_p, literal_index))
        -: 3084:      {
    #####: 3085:        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 3086:      }
        -: 3087:    }
    #####: 3088:    else if (literal_index < PARSER_REGISTER_START)
        -: 3089:    {
    #####: 3090:      assign_opcode = CBC_INIT_LET;
        -: 3091:
    #####: 3092:      if (scanner_literal_is_created (context_p, literal_index))
        -: 3093:      {
    #####: 3094:        assign_opcode = CBC_ASSIGN_LET_CONST;
        -: 3095:      }
    #####: 3096:      else if (pattern_flags & PARSER_PATTERN_CONST)
        -: 3097:      {
    #####: 3098:        assign_opcode = CBC_INIT_CONST;
        -: 3099:      }
    #####: 3100:      else if (pattern_flags & PARSER_PATTERN_LOCAL)
        -: 3101:      {
    #####: 3102:        assign_opcode = CBC_INIT_ARG_OR_CATCH;
        -: 3103:      }
        -: 3104:    }
        -: 3105:#endif /* JERRY_ESNEXT */
        -: 3106:
    #####: 3107:    parser_stack_push_uint16 (context_p, literal_index);
    #####: 3108:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, assign_opcode));
        -: 3109:  }
    #####: 3110:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -: 3111:  {
    #####: 3112:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, CBC_ASSIGN));
    #####: 3113:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 3114:  }
    #####: 3115:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL)
        -: 3116:  {
    #####: 3117:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 3118:    {
    #####: 3119:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL, CBC_ASSIGN_PROP_LITERAL));
    #####: 3120:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
    #####: 3121:      assign_opcode = CBC_ASSIGN_PROP_LITERAL;
    #####: 3122:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 3123:    }
        -: 3124:    else
        -: 3125:    {
    #####: 3126:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
        -: 3127:    }
        -: 3128:  }
    #####: 3129:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL_LITERAL)
        -: 3130:  {
    #####: 3131:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_PUSH_TWO_LITERALS));
    #####: 3132:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        -: 3133:  }
    #####: 3134:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_THIS_LITERAL)
        -: 3135:  {
    #####: 3136:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 3137:    {
    #####: 3138:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_THIS_LITERAL, CBC_ASSIGN_PROP_THIS_LITERAL));
    #####: 3139:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
    #####: 3140:      assign_opcode = CBC_ASSIGN_PROP_THIS_LITERAL;
    #####: 3141:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 3142:    }
        -: 3143:    else
        -: 3144:    {
    #####: 3145:      context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;
        -: 3146:    }
        -: 3147:  }
        -: 3148:#if JERRY_ESNEXT
    #####: 3149:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 3150:  {
    #####: 3151:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
    #####: 3152:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);
    #####: 3153:    assign_opcode = CBC_EXT_OPCODE;
        -: 3154:  }
    #####: 3155:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 3156:  {
    #####: 3157:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE);
    #####: 3158:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);
    #####: 3159:    assign_opcode = CBC_EXT_OPCODE;
        -: 3160:  }
    #####: 3161:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL))
        -: 3162:  {
    #####: 3163:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####: 3164:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_PRIVATE);
    #####: 3165:    assign_opcode = CBC_EXT_OPCODE;
        -: 3166:  }
        -: 3167:#endif /* JERRY_ESNEXT */
        -: 3168:  else
        -: 3169:  {
        -: 3170:    /* Invalid LeftHandSide expression. */ // 3820, 3815
        -: 3171:#if JERRY_ESNEXT
    #####: 3172:    parser_check_invalid_new_target (context_p, CBC_ASSIGN);
    #####: 3173:    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 3174:#else /* !JERRY_ESNEXT */
    #####: 3175:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 3176:#endif /* JERRY_ESNEXT */
        -: 3177:  }
        -: 3178:
    #####: 3179:  parser_stack_push_uint8 (context_p, assign_opcode);
    #####: 3180:  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
    #####: 3181:} /* parser_append_binary_single_assignment_token */
        -: 3182:
        -: 3183:#if JERRY_ESNEXT
        -: 3184:
        -: 3185:/**
        -: 3186: * Check for invalid chain of logical operators
        -: 3187: */
        -: 3188:static void
    #####: 3189:parser_check_invalid_logical_op (parser_context_t *context_p, /**< context */
        -: 3190:                                 uint8_t invalid_token1, /**< token id of first invalid token */
        -: 3191:                                 uint8_t invalid_token2) /**< token id of second invalid token */
        -: 3192:{
    #####: 3193:  parser_stack_iterator_t iterator;
    #####: 3194:  parser_stack_iterator_init (context_p, &iterator);
        -: 3195:
        -: 3196:  while (true)
    #####: 3197:  {
    #####: 3198:    uint8_t token = parser_stack_iterator_read_uint8 (&iterator);
        -: 3199:
    #####: 3200:    if (!LEXER_IS_BINARY_NON_LVALUE_OP_TOKEN (token))
        -: 3201:    {
    #####: 3202:      return;
        -: 3203:    }
        -: 3204:
    #####: 3205:    if (token == invalid_token1 || token == invalid_token2)
        -: 3206:    {
    #####: 3207:      parser_raise_error (context_p, PARSER_ERR_INVALID_NULLISH_COALESCING);
        -: 3208:    }
        -: 3209:
        -: 3210:    /* If a logical operator is found, and there is no SyntaxError, the scan can be terminated
        -: 3211:     * since there was no SyntaxError when the logical operator was pushed onto the stack. */
    #####: 3212:    if (token == LEXER_LOGICAL_OR || token == LEXER_LOGICAL_AND || token == LEXER_NULLISH_COALESCING)
        -: 3213:    {
    #####: 3214:      return;
        -: 3215:    }
        -: 3216:
    #####: 3217:    parser_stack_iterator_skip (&iterator, sizeof (uint8_t));
        -: 3218:  }
        -: 3219:} /* parser_check_invalid_logical_op */
        -: 3220:
        -: 3221:#endif /* JERRY_ESNEXT */
        -: 3222:
        -: 3223:/**
        -: 3224: * Append a binary lvalue token.
        -: 3225: */
        -: 3226:static void
    #####: 3227:parser_append_binary_lvalue_token (parser_context_t *context_p, /**< context */
        -: 3228:                                   bool is_logical_assignment) /**< true - if form logical assignment reference
        -: 3229:                                                                *   false - otherwise */
        -: 3230:{
    #####: 3231:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 3232:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 3233:  {
    #####: 3234:    parser_check_invalid_assign (context_p);
        -: 3235:
    #####: 3236:    parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
        -: 3237:
        -: 3238:#if JERRY_ESNEXT
    #####: 3239:    if (!is_logical_assignment && scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -: 3240:    {
    #####: 3241:      parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 3242:    }
        -: 3243:#endif /* JERRY_ESNEXT */
        -: 3244:  }
    #####: 3245:  else if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 3246:  {
    #####: 3247:    context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 3248:  }
        -: 3249:  else
        -: 3250:  {
        -: 3251:    /* Invalid LeftHandSide expression. */
        -: 3252:#if JERRY_ESNEXT
    #####: 3253:    parser_check_invalid_new_target (context_p, CBC_ASSIGN);
    #####: 3254:    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 3255:#else /* !JERRY_ESNEXT */
    #####: 3256:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 3257:#endif /* JERRY_ESNEXT */
        -: 3258:
    #####: 3259:    parser_emit_cbc (context_p, CBC_PUSH_PROP_REFERENCE);
        -: 3260:  }
        -: 3261:
    #####: 3262:  if (!is_logical_assignment)
        -: 3263:  {
    #####: 3264:    parser_stack_push_uint8 (context_p, (uint8_t) context_p->token.type);
        -: 3265:  }
    #####: 3266:} /* parser_append_binary_lvalue_token */
        -: 3267:
        -: 3268:/**
        -: 3269: * Append a logical token.
        -: 3270: */
        -: 3271:static void
    #####: 3272:parser_append_logical_token (parser_context_t *context_p, /**< context */
        -: 3273:                             uint16_t opcode) /**< opcode */
        -: 3274:{
        -: 3275:#if JERRY_ESNEXT
    #####: 3276:  if (opcode != PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH))
        -: 3277:  {
    #####: 3278:    parser_check_invalid_logical_op (context_p, LEXER_NULLISH_COALESCING, LEXER_NULLISH_COALESCING);
        -: 3279:  }
        -: 3280:#endif /* JERRY_ESNEXT */
        -: 3281:
    #####: 3282:  parser_branch_t branch;
        -: 3283:
    #####: 3284:  parser_emit_cbc_forward_branch (context_p, opcode, &branch);
    #####: 3285:  parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
    #####: 3286:  parser_stack_push_uint8 (context_p, (uint8_t) context_p->token.type);
    #####: 3287:} /* parser_append_logical_token */
        -: 3288:
        -: 3289:#if JERRY_ESNEXT
        -: 3290:/**
        -: 3291: * Append a logical token.
        -: 3292: */
        -: 3293:static void
    #####: 3294:parser_append_logical_assignment_token (parser_context_t *context_p, /**< context */
        -: 3295:                                        uint16_t opcode) /**< opcode */
        -: 3296:{
    #####: 3297:  uint16_t last_cbc_opcode = context_p->last_cbc_opcode;
    #####: 3298:  parser_append_binary_single_assignment_token (context_p, 0);
    #####: 3299:  parser_stack_change_last_uint8 (context_p, LEXER_ASSIGN_REFERENCE);
    #####: 3300:  context_p->last_cbc_opcode = last_cbc_opcode;
        -: 3301:
    #####: 3302:  parser_append_binary_lvalue_token (context_p, true);
    #####: 3303:  parser_append_logical_token (context_p, opcode);
    #####: 3304:} /* parser_append_logical_assignment_token */
        -: 3305:#endif /* JERRY_ESNEXT */
        -: 3306:
        -: 3307:/**
        -: 3308: * Append a binary token.
        -: 3309: */
        -: 3310:static void
    #####: 3311:parser_append_binary_token (parser_context_t *context_p) /**< context */
        -: 3312:{
    #####: 3313:  JERRY_ASSERT (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type));
    #####: 3314:  parser_push_result (context_p);
        -: 3315:
    #####: 3316:  switch (context_p->token.type)
        -: 3317:  {
    #####: 3318:    case LEXER_ASSIGN:
        -: 3319:    {
    #####: 3320:      parser_append_binary_single_assignment_token (context_p, 0);
    #####: 3321:      break;
        -: 3322:    }
        -: 3323:    /* Binary lvalue-opcodes */
    #####: 3324:    case LEXER_ASSIGN_ADD:
        -: 3325:    case LEXER_ASSIGN_SUBTRACT:
        -: 3326:    case LEXER_ASSIGN_MULTIPLY:
        -: 3327:    case LEXER_ASSIGN_DIVIDE:
        -: 3328:    case LEXER_ASSIGN_MODULO:
        -: 3329:#if JERRY_ESNEXT
        -: 3330:    case LEXER_ASSIGN_EXPONENTIATION:
        -: 3331:#endif /* JERRY_ESNEXT */
        -: 3332:    case LEXER_ASSIGN_LEFT_SHIFT:
        -: 3333:    case LEXER_ASSIGN_RIGHT_SHIFT:
        -: 3334:    case LEXER_ASSIGN_UNS_RIGHT_SHIFT:
        -: 3335:    case LEXER_ASSIGN_BIT_AND:
        -: 3336:    case LEXER_ASSIGN_BIT_OR:
        -: 3337:    case LEXER_ASSIGN_BIT_XOR:
        -: 3338:    {
    #####: 3339:      parser_append_binary_lvalue_token (context_p, false);
    #####: 3340:      break;
        -: 3341:    }
        -: 3342:#if JERRY_ESNEXT
    #####: 3343:    case LEXER_ASSIGN_NULLISH_COALESCING:
        -: 3344:    {
    #####: 3345:      parser_append_logical_assignment_token (context_p, PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH));
    #####: 3346:      break;
        -: 3347:    }
    #####: 3348:    case LEXER_ASSIGN_LOGICAL_OR:
        -: 3349:    {
    #####: 3350:      parser_append_logical_assignment_token (context_p, CBC_BRANCH_IF_LOGICAL_TRUE);
    #####: 3351:      break;
        -: 3352:    }
    #####: 3353:    case LEXER_ASSIGN_LOGICAL_AND:
        -: 3354:    {
    #####: 3355:      parser_append_logical_assignment_token (context_p, CBC_BRANCH_IF_LOGICAL_FALSE);
    #####: 3356:      break;
        -: 3357:    }
    #####: 3358:    case LEXER_NULLISH_COALESCING:
        -: 3359:    {
    #####: 3360:      parser_append_logical_token (context_p, PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH));
    #####: 3361:      break;
        -: 3362:    }
        -: 3363:#endif /* JERRY_ESNEXT */
    #####: 3364:    case LEXER_LOGICAL_OR:
        -: 3365:    {
    #####: 3366:      parser_append_logical_token (context_p, CBC_BRANCH_IF_LOGICAL_TRUE);
    #####: 3367:      break;
        -: 3368:    }
    #####: 3369:    case LEXER_LOGICAL_AND:
        -: 3370:    {
    #####: 3371:      parser_append_logical_token (context_p, CBC_BRANCH_IF_LOGICAL_FALSE);
    #####: 3372:      break;
        -: 3373:    }
    #####: 3374:    default:
        -: 3375:    {
    #####: 3376:      parser_stack_push_uint8 (context_p, (uint8_t) context_p->token.type);
    #####: 3377:      break;
        -: 3378:    }
        -: 3379:  }
    #####: 3380:} /* parser_append_binary_token */
        -: 3381:
        -: 3382:/**
        -: 3383: * Emit opcode for binary assignment token.
        -: 3384: */
        -: 3385:static void
    #####: 3386:parser_process_binary_assignment_token (parser_context_t *context_p, /**< context */
        -: 3387:                                        uint8_t token) /**< token */
        -: 3388:{
        -: 3389:#if !JERRY_ESNEXT
        -: 3390:  JERRY_UNUSED (token);
        -: 3391:#endif /* !JERRY_ESNEXT */
        -: 3392:
    #####: 3393:  uint16_t index = PARSER_INVALID_LITERAL_INDEX;
    #####: 3394:  uint16_t opcode = context_p->stack_top_uint8;
        -: 3395:
        -: 3396:#if JERRY_ESNEXT
    #####: 3397:  if (JERRY_UNLIKELY (opcode == CBC_EXT_OPCODE))
        -: 3398:  {
    #####: 3399:    parser_stack_pop_uint8 (context_p);
    #####: 3400:    JERRY_ASSERT (context_p->stack_top_uint8 == CBC_EXT_ASSIGN_SUPER
        -: 3401:                  || context_p->stack_top_uint8 == CBC_EXT_ASSIGN_PRIVATE);
    #####: 3402:    opcode = PARSER_TO_EXT_OPCODE (context_p->stack_top_uint8);
    #####: 3403:    parser_stack_pop_uint8 (context_p);
        -: 3404:  }
        -: 3405:  else
        -: 3406:#endif /* JERRY_ESNEXT */
        -: 3407:  {
    #####: 3408:    parser_stack_pop_uint8 (context_p);
        -: 3409:
    #####: 3410:    if (cbc_flags[opcode] & CBC_HAS_LITERAL_ARG)
        -: 3411:    {
    #####: 3412:      JERRY_ASSERT (opcode == CBC_ASSIGN_SET_IDENT || opcode == CBC_ASSIGN_PROP_LITERAL
        -: 3413:                    || opcode == CBC_ASSIGN_PROP_THIS_LITERAL || opcode == CBC_ASSIGN_LET_CONST
        -: 3414:                    || opcode == CBC_INIT_ARG_OR_CATCH || opcode == CBC_INIT_LET || opcode == CBC_INIT_CONST);
        -: 3415:
    #####: 3416:      index = parser_stack_pop_uint16 (context_p);
        -: 3417:    }
        -: 3418:  }
        -: 3419:
        -: 3420:#if JERRY_ESNEXT
    #####: 3421:  bool group_expr_assingment = false;
        -: 3422:
    #####: 3423:  if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_GROUP_EXPR))
        -: 3424:  {
    #####: 3425:    group_expr_assingment = true;
    #####: 3426:    parser_stack_pop_uint8 (context_p);
        -: 3427:  }
        -: 3428:
    #####: 3429:  if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_CONST))
        -: 3430:  {
    #####: 3431:    parser_stack_pop_uint8 (context_p);
    #####: 3432:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -: 3433:  }
        -: 3434:#endif /* JERRY_ESNEXT */
        -: 3435:
    #####: 3436:  if (index == PARSER_INVALID_LITERAL_INDEX)
        -: 3437:  {
        -: 3438:#if JERRY_ESNEXT
    #####: 3439:    if (JERRY_UNLIKELY (token == LEXER_ASSIGN_REFERENCE))
        -: 3440:    {
    #####: 3441:      opcode = CBC_ASSIGN_PUSH_RESULT;
        -: 3442:    }
        -: 3443:#endif /* JERRY_ESNEXT */
        -: 3444:
    #####: 3445:    parser_emit_cbc (context_p, opcode);
    #####: 3446:    return;
        -: 3447:  }
        -: 3448:
        -: 3449:#if JERRY_ESNEXT
    #####: 3450:  if (!group_expr_assingment)
        -: 3451:  {
    #####: 3452:    uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3453:
    #####: 3454:    if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3455:    {
    #####: 3456:      uint16_t name_index = scanner_save_literal (context_p, index);
    #####: 3457:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 3458:    }
    #####: 3459:    else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3460:    {
    #####: 3461:      parser_set_function_name (context_p, function_literal_index, (uint16_t) index, 0);
        -: 3462:    }
        -: 3463:  }
        -: 3464:
    #####: 3465:  if (JERRY_UNLIKELY (token == LEXER_ASSIGN_REFERENCE))
        -: 3466:  {
    #####: 3467:    parser_emit_cbc (context_p, CBC_ASSIGN_PUSH_RESULT);
    #####: 3468:    return;
        -: 3469:  }
        -: 3470:#endif /* JERRY_ESNEXT */
        -: 3471:
    #####: 3472:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL && opcode == CBC_ASSIGN_SET_IDENT)
        -: 3473:  {
    #####: 3474:    JERRY_ASSERT (CBC_ARGS_EQ (CBC_ASSIGN_LITERAL_SET_IDENT, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        -: 3475:
    #####: 3476:    context_p->last_cbc.value = index;
    #####: 3477:    context_p->last_cbc_opcode = CBC_ASSIGN_LITERAL_SET_IDENT;
    #####: 3478:    return;
        -: 3479:  }
        -: 3480:
    #####: 3481:  parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);
        -: 3482:
    #####: 3483:  if (opcode == CBC_ASSIGN_PROP_THIS_LITERAL && (context_p->stack_depth >= context_p->stack_limit))
        -: 3484:  {
        -: 3485:    /* Stack limit is increased for VM_OC_ASSIGN_PROP_THIS. Needed by vm.c. */
    #####: 3486:    JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -: 3487:
    #####: 3488:    context_p->stack_limit++;
        -: 3489:
    #####: 3490:    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 3491:    {
    #####: 3492:      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 3493:    }
        -: 3494:  }
        -: 3495:} /* parser_process_binary_opcodes */
        -: 3496:
        -: 3497:/**
        -: 3498: * Emit opcode for logical tokens.
        -: 3499: */
        -: 3500:static void
    #####: 3501:parser_process_logical_token (parser_context_t *context_p) /**< context */
        -: 3502:{
    #####: 3503:  parser_branch_t branch;
    #####: 3504:  parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####: 3505:  parser_set_branch_to_current_position (context_p, &branch);
    #####: 3506:} /* parser_process_logical_token */
        -: 3507:
        -: 3508:#if JERRY_ESNEXT
        -: 3509:/**
        -: 3510: * Emit opcode for logical assignment tokens.
        -: 3511: */
        -: 3512:static void
    #####: 3513:parser_process_logical_assignment_token (parser_context_t *context_p) /**< context */
        -: 3514:{
    #####: 3515:  parser_branch_t condition_branch;
    #####: 3516:  parser_stack_pop (context_p, &condition_branch, sizeof (parser_branch_t));
        -: 3517:
    #####: 3518:  uint8_t token = context_p->stack_top_uint8;
    #####: 3519:  JERRY_ASSERT (token == LEXER_ASSIGN_REFERENCE);
    #####: 3520:  parser_stack_pop_uint8 (context_p);
    #####: 3521:  parser_process_binary_assignment_token (context_p, token);
        -: 3522:
    #####: 3523:  parser_branch_t prop_reference_branch;
    #####: 3524:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &prop_reference_branch);
        -: 3525:
    #####: 3526:  parser_set_branch_to_current_position (context_p, &condition_branch);
    #####: 3527:  parser_emit_cbc_ext (context_p, CBC_EXT_POP_REFERENCE);
        -: 3528:
    #####: 3529:  JERRY_ASSERT (context_p->stack_limit - context_p->stack_depth >= 2);
    #####: 3530:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, 2);
        -: 3531:
    #####: 3532:  parser_set_branch_to_current_position (context_p, &prop_reference_branch);
    #####: 3533:} /* parser_process_logical_assignment_token */
        -: 3534:
        -: 3535:#endif /* JERRY_ESNEXT */
        -: 3536:
        -: 3537:/**
        -: 3538: * Emit opcode for binary tokens.
        -: 3539: */
        -: 3540:static void
    #####: 3541:parser_process_binary_token (parser_context_t *context_p, /**< context */
        -: 3542:                             uint8_t token) /**< token */
        -: 3543:{
    #####: 3544:  uint16_t opcode = LEXER_BINARY_OP_TOKEN_TO_OPCODE (token);
        -: 3545:
    #####: 3546:  if (PARSER_IS_PUSH_NUMBER (context_p->last_cbc_opcode))
        -: 3547:  {
    #####: 3548:    lexer_convert_push_number_to_push_literal (context_p);
        -: 3549:  }
        -: 3550:
    #####: 3551:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3552:  {
    #####: 3553:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, opcode + CBC_BINARY_WITH_LITERAL));
    #####: 3554:    context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_LITERAL);
    #####: 3555:    return;
        -: 3556:  }
        -: 3557:
    #####: 3558:  if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 3559:  {
    #####: 3560:    JERRY_ASSERT (CBC_ARGS_EQ (opcode + CBC_BINARY_WITH_TWO_LITERALS, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
    #####: 3561:    context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_TWO_LITERALS);
    #####: 3562:    return;
        -: 3563:  }
        -: 3564:
    #####: 3565:  parser_emit_cbc (context_p, opcode);
        -: 3566:} /* parser_process_binary_token */
        -: 3567:
        -: 3568:/**
        -: 3569: * Emit opcode for binary lvalue tokens.
        -: 3570: */
        -: 3571:static void
    #####: 3572:parser_process_binary_lvalue_token (parser_context_t *context_p, /**< context */
        -: 3573:                                    uint8_t token) /**< token */
        -: 3574:{
    #####: 3575:  parser_stack_push_uint8 (context_p, CBC_ASSIGN);
    #####: 3576:  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
    #####: 3577:  parser_stack_push_uint8 (context_p, lexer_convert_binary_lvalue_token_to_binary (token));
    #####: 3578:} /* parser_process_binary_lvalue_token */
        -: 3579:
        -: 3580:/**
        -: 3581: * Emit opcode for binary computations.
        -: 3582: */
        -: 3583:static void
        8: 3584:parser_process_binary_opcodes (parser_context_t *context_p, /**< context */
        -: 3585:                               uint8_t min_prec_treshold) /**< minimal precedence of tokens */
        -: 3586:{
        -: 3587:  while (true)
    #####: 3588:  {
        8: 3589:    uint8_t token = context_p->stack_top_uint8;
        -: 3590:
        -: 3591:    /* For left-to-right operators (all binary operators except assignment
        -: 3592:     * and logical operators), the byte code is flushed if the precedence
        -: 3593:     * of the next operator is less or equal than the current operator. For
        -: 3594:     * assignment and logical operators, we add 1 to the min precendence to
        -: 3595:     * force right-to-left evaluation order. */
        -: 3596:
        8: 3597:    if (!LEXER_IS_BINARY_OP_TOKEN (token)
    #####: 3598:        || parser_binary_precedence_table[token - LEXER_FIRST_BINARY_OP] < min_prec_treshold)
        -: 3599:    {
       16: 3600:      return;
        -: 3601:    }
        -: 3602:
    #####: 3603:    parser_push_result (context_p);
    #####: 3604:    parser_stack_pop_uint8 (context_p);
        -: 3605:
    #####: 3606:    switch (token)
        -: 3607:    {
    #####: 3608:      case LEXER_ASSIGN:
        -: 3609:      {
    #####: 3610:        parser_process_binary_assignment_token (context_p, token);
    #####: 3611:        continue;
        -: 3612:      }
        -: 3613:        /* Binary lvalue-opcodes */
    #####: 3614:      case LEXER_ASSIGN_ADD:
        -: 3615:      case LEXER_ASSIGN_SUBTRACT:
        -: 3616:      case LEXER_ASSIGN_MULTIPLY:
        -: 3617:      case LEXER_ASSIGN_DIVIDE:
        -: 3618:      case LEXER_ASSIGN_MODULO:
        -: 3619:#if JERRY_ESNEXT
        -: 3620:      case LEXER_ASSIGN_EXPONENTIATION:
        -: 3621:#endif /* JERRY_ESNEXT */
        -: 3622:      case LEXER_ASSIGN_LEFT_SHIFT:
        -: 3623:      case LEXER_ASSIGN_RIGHT_SHIFT:
        -: 3624:      case LEXER_ASSIGN_UNS_RIGHT_SHIFT:
        -: 3625:      case LEXER_ASSIGN_BIT_AND:
        -: 3626:      case LEXER_ASSIGN_BIT_OR:
        -: 3627:      case LEXER_ASSIGN_BIT_XOR:
        -: 3628:      {
    #####: 3629:        parser_process_binary_lvalue_token (context_p, token);
    #####: 3630:        continue;
        -: 3631:      }
        -: 3632:#if JERRY_ESNEXT
    #####: 3633:      case LEXER_ASSIGN_NULLISH_COALESCING:
        -: 3634:      case LEXER_ASSIGN_LOGICAL_OR:
        -: 3635:      case LEXER_ASSIGN_LOGICAL_AND:
        -: 3636:      {
    #####: 3637:        parser_process_logical_assignment_token (context_p);
    #####: 3638:        continue;
        -: 3639:      }
    #####: 3640:      case LEXER_NULLISH_COALESCING:
        -: 3641:#endif /* JERRY_ESNEXT */
    #####: 3642:      case LEXER_LOGICAL_OR:
        -: 3643:      case LEXER_LOGICAL_AND:
        -: 3644:      {
    #####: 3645:        parser_process_logical_token (context_p);
    #####: 3646:        continue;
        -: 3647:      }
        -: 3648:#if JERRY_ESNEXT
    #####: 3649:      case LEXER_KEYW_IN:
        -: 3650:      {
    #####: 3651:        if (context_p->stack_top_uint8 == LEXER_PRIVATE_PRIMARY_EXPR)
        -: 3652:        {
    #####: 3653:          parser_stack_pop_uint8 (context_p);
    #####: 3654:          uint16_t lit_id = parser_stack_pop_uint16 (context_p);
    #####: 3655:          parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_PRIVATE_PROP_LITERAL_IN, lit_id);
    #####: 3656:          continue;
        -: 3657:        }
        -: 3658:
        -: 3659:        /* FALLTHRU */
        -: 3660:      }
        -: 3661:#endif /* JERRY_ESNEXT */
    #####: 3662:      default:
        -: 3663:      {
    #####: 3664:        parser_process_binary_token (context_p, token);
    #####: 3665:        continue;
        -: 3666:      }
        -: 3667:    }
        -: 3668:  }
        -: 3669:} /* parser_process_binary_opcodes */
        -: 3670:
        -: 3671:#if JERRY_ESNEXT
        -: 3672:/**
        -: 3673: * End position marker of a pattern.
        -: 3674: */
        -: 3675:typedef struct
        -: 3676:{
        -: 3677:  scanner_location_t location; /**< end position of the pattern */
        -: 3678:  lexer_token_t token; /**< token at the end position */
        -: 3679:} parser_pattern_end_marker_t;
        -: 3680:
        -: 3681:/**
        -: 3682: * Literal index should not be emitted while processing rhs target value
        -: 3683: */
        -: 3684:#define PARSER_PATTERN_RHS_NO_LIT PARSER_INVALID_LITERAL_INDEX
        -: 3685:
        -: 3686:/**
        -: 3687: * Process the target of an initializer pattern.
        -: 3688: */
        -: 3689:static parser_pattern_end_marker_t
    #####: 3690:parser_pattern_get_target (parser_context_t *context_p, /**< context */
        -: 3691:                           parser_pattern_flags_t flags) /**< flags */
        -: 3692:{
    #####: 3693:  parser_pattern_end_marker_t end_marker;
    #####: 3694:  end_marker.token.type = LEXER_INVALID_PATTERN;
    #####: 3695:  parser_branch_t skip_init;
        -: 3696:
    #####: 3697:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 3698:  {
    #####: 3699:    JERRY_ASSERT (flags & PARSER_PATTERN_TARGET_ON_STACK);
        -: 3700:
    #####: 3701:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 3702:  }
        -: 3703:
    #####: 3704:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 3705:  {
    #####: 3706:    scanner_location_t start_location;
        -: 3707:
    #####: 3708:    if (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 3709:        || context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED || (flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3710:    {
        -: 3711:      /* Found invalid pattern, push null value to fake the rhs target. */
    #####: 3712:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
        -: 3713:    }
        -: 3714:    else
        -: 3715:    {
    #####: 3716:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);
    #####: 3717:      scanner_get_location (&start_location, context_p);
        -: 3718:
    #####: 3719:      scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 3720:      scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 3721:      scanner_seek (context_p);
    #####: 3722:      lexer_next_token (context_p);
        -: 3723:
    #####: 3724:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 3725:      scanner_get_location (&(end_marker.location), context_p);
    #####: 3726:      end_marker.token = context_p->token;
        -: 3727:
    #####: 3728:      scanner_set_location (context_p, &start_location);
    #####: 3729:      scanner_seek (context_p);
    #####: 3730:      parser_flush_cbc (context_p);
        -: 3731:    }
        -: 3732:  }
        -: 3733:
    #####: 3734:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 3735:  {
    #####: 3736:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 3737:  }
        -: 3738:
    #####: 3739:  return end_marker;
        -: 3740:} /* parser_pattern_get_target */
        -: 3741:
        -: 3742:/**
        -: 3743: * Finalize an assignment/binding pattern.
        -: 3744: */
        -: 3745:static void
    #####: 3746:parser_pattern_finalize (parser_context_t *context_p, /**< context */
        -: 3747:                         parser_pattern_flags_t flags, /**< flags */
        -: 3748:                         parser_pattern_end_marker_t *end_marker_p) /**< pattern end position  */
        -: 3749:{
    #####: 3750:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 3751:  {
    #####: 3752:    if (end_marker_p->token.type == LEXER_INVALID_PATTERN)
        -: 3753:    {
    #####: 3754:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3755:    }
        -: 3756:
    #####: 3757:    scanner_set_location (context_p, &(end_marker_p->location));
    #####: 3758:    context_p->token = end_marker_p->token;
        -: 3759:  }
        -: 3760:  else
        -: 3761:  {
    #####: 3762:    JERRY_ASSERT (!(flags & PARSER_PATTERN_TARGET_DEFAULT));
    #####: 3763:    lexer_next_token (context_p);
        -: 3764:  }
        -: 3765:
    #####: 3766:  if ((flags & (PARSER_PATTERN_BINDING | PARSER_PATTERN_NESTED_PATTERN)) == PARSER_PATTERN_BINDING)
        -: 3767:  {
        -: 3768:    /* Pop the result of the expression. */
    #####: 3769:    parser_emit_cbc (context_p, CBC_POP);
        -: 3770:  }
        -: 3771:
    #####: 3772:  parser_flush_cbc (context_p);
    #####: 3773:} /* parser_pattern_finalize */
        -: 3774:
        -: 3775:/**
        -: 3776: * Emit right-hand-side target value.
        -: 3777: */
        -: 3778:static void
    #####: 3779:parser_pattern_emit_rhs (parser_context_t *context_p, /**< context */
        -: 3780:                         uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3781:                         uint16_t literal_index) /**< literal index for object pattern */
        -: 3782:{
    #####: 3783:  if (literal_index != PARSER_PATTERN_RHS_NO_LIT)
        -: 3784:  {
    #####: 3785:    parser_emit_cbc_ext_literal (context_p, rhs_opcode, literal_index);
        -: 3786:  }
        -: 3787:  else
        -: 3788:  {
    #####: 3789:    parser_emit_cbc_ext (context_p, rhs_opcode);
        -: 3790:  }
    #####: 3791:} /* parser_pattern_emit_rhs */
        -: 3792:
        -: 3793:/**
        -: 3794: * Form an assignment from a pattern.
        -: 3795: */
        -: 3796:static void
    #####: 3797:parser_pattern_form_assignment (parser_context_t *context_p, /**< context */
        -: 3798:                                parser_pattern_flags_t flags, /**< flags */
        -: 3799:                                uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3800:                                uint16_t literal_index, /**< literal index for object pattern */
        -: 3801:                                parser_line_counter_t ident_line_counter) /**< identifier line counter */
        -: 3802:{
        -: 3803:  JERRY_UNUSED (ident_line_counter);
        -: 3804:
    #####: 3805:  uint16_t name_index = PARSER_INVALID_LITERAL_INDEX;
        -: 3806:
    #####: 3807:  if ((flags & PARSER_PATTERN_BINDING)
    #####: 3808:      || (context_p->last_cbc_opcode == CBC_PUSH_LITERAL && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL))
        -: 3809:  {
    #####: 3810:    name_index = context_p->lit_object.index;
        -: 3811:  }
        -: 3812:
    #####: 3813:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
    #####: 3814:  parser_append_binary_single_assignment_token (context_p, flags);
    #####: 3815:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 3816:
    #####: 3817:  if (context_p->token.type == LEXER_ASSIGN && !(flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3818:  {
    #####: 3819:    parser_branch_t skip_init;
    #####: 3820:    lexer_next_token (context_p);
    #####: 3821:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 3822:
    #####: 3823:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 3824:
    #####: 3825:    if (name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 3826:    {
    #####: 3827:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3828:
    #####: 3829:      if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3830:      {
    #####: 3831:        name_index = scanner_save_literal (context_p, name_index);
    #####: 3832:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 3833:      }
    #####: 3834:      else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3835:      {
    #####: 3836:        parser_set_function_name (context_p, function_literal_index, name_index, 0);
        -: 3837:      }
        -: 3838:    }
    #####: 3839:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 3840:  }
        -: 3841:
    #####: 3842:  parser_process_binary_opcodes (context_p, 0);
        -: 3843:
    #####: 3844:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
    #####: 3845:  parser_stack_pop_uint8 (context_p);
        -: 3846:
        -: 3847:#if JERRY_DEBUGGER
        -: 3848:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 3849:      && ident_line_counter != context_p->last_breakpoint_line)
        -: 3850:  {
        -: 3851:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 3852:    parser_flush_cbc (context_p);
        -: 3853:
        -: 3854:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);
        -: 3855:
        -: 3856:    context_p->last_breakpoint_line = ident_line_counter;
        -: 3857:  }
        -: 3858:#endif /* JERRY_DEBUGGER */
    #####: 3859:} /* parser_pattern_form_assignment */
        -: 3860:
        -: 3861:/**
        -: 3862: * Parse pattern inside a pattern.
        -: 3863: */
        -: 3864:static void
    #####: 3865:parser_pattern_process_nested_pattern (parser_context_t *context_p, /**< context */
        -: 3866:                                       parser_pattern_flags_t flags, /**< flags */
        -: 3867:                                       uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3868:                                       uint16_t literal_index) /**< literal index for object pattern */
        -: 3869:{
    #####: 3870:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE);
        -: 3871:
    #####: 3872:  parser_pattern_flags_t options = (PARSER_PATTERN_NESTED_PATTERN | PARSER_PATTERN_TARGET_ON_STACK
        -: 3873:                                    | (flags
    #####: 3874:                                       & (PARSER_PATTERN_BINDING | PARSER_PATTERN_LET | PARSER_PATTERN_CONST
        -: 3875:                                          | PARSER_PATTERN_LOCAL | PARSER_PATTERN_ARGUMENTS)));
        -: 3876:
    #####: 3877:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p
        -: 3878:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER
        -: 3879:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 3880:
    #####: 3881:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3882:  {
    #####: 3883:    if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 3884:    {
    #####: 3885:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 3886:      {
    #####: 3887:        options |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 3888:      }
        -: 3889:
    #####: 3890:      if (!(flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3891:      {
    #####: 3892:        options |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 3893:      }
        -: 3894:      else
        -: 3895:      {
    #####: 3896:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 3897:      }
        -: 3898:    }
        -: 3899:    else
        -: 3900:    {
    #####: 3901:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 3902:      {
    #####: 3903:        options |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 3904:      }
    #####: 3905:      scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3906:    }
        -: 3907:  }
        -: 3908:
    #####: 3909:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 3910:
    #####: 3911:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 3912:  {
    #####: 3913:    parser_parse_object_initializer (context_p, options);
        -: 3914:  }
        -: 3915:  else
        -: 3916:  {
    #####: 3917:    parser_parse_array_initializer (context_p, options);
        -: 3918:  }
        -: 3919:
    #####: 3920:  parser_emit_cbc (context_p, CBC_POP);
    #####: 3921:} /* parser_pattern_process_nested_pattern */
        -: 3922:
        -: 3923:/**
        -: 3924: * Process the current {Binding, Assignment}Property
        -: 3925: *
        -: 3926: * @return true, if a nested pattern is processed, false otherwise
        -: 3927: */
        -: 3928:static bool
    #####: 3929:parser_pattern_process_assignment (parser_context_t *context_p, /**< context */
        -: 3930:                                   parser_pattern_flags_t flags, /**< flags */
        -: 3931:                                   uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3932:                                   uint16_t literal_index, /**< literal index for object pattern */
        -: 3933:                                   lexer_token_type_t end_type) /**< end type token */
        -: 3934:{
    #####: 3935:  if ((context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE)
    #####: 3936:      && (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 3937:          || !(context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_NO_DESTRUCTURING)))
        -: 3938:  {
    #####: 3939:    parser_pattern_process_nested_pattern (context_p, flags, rhs_opcode, literal_index);
    #####: 3940:    return true;
        -: 3941:  }
        -: 3942:
    #####: 3943:  parser_line_counter_t ident_line_counter = context_p->token.line;
        -: 3944:#if JERRY_LINE_INFO
    #####: 3945:  parser_line_counter_t ident_column_counter = context_p->token.column;
        -: 3946:#endif /* JERRY_LINE_INFO */
        -: 3947:
    #####: 3948:  if (flags & PARSER_PATTERN_BINDING)
        -: 3949:  {
    #####: 3950:    if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3951:    {
    #####: 3952:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 3953:    }
        -: 3954:
    #####: 3955:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 3956:
    #####: 3957:    if (flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST) && context_p->token.keyword_type == LEXER_KEYW_LET)
        -: 3958:    {
    #####: 3959:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -: 3960:    }
        -: 3961:
    #####: 3962:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3963:    {
    #####: 3964:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 3965:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3966:    }
        -: 3967:
    #####: 3968:    if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 3969:    {
    #####: 3970:      if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 3971:      {
    #####: 3972:        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3973:      }
    #####: 3974:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 3975:    }
        -: 3976:#if JERRY_MODULE_SYSTEM
    #####: 3977:    parser_module_append_export_name (context_p);
        -: 3978:#endif /* JERRY_MODULE_SYSTEM */
        -: 3979:
    #####: 3980:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
    #####: 3981:    lexer_next_token (context_p);
        -: 3982:
    #####: 3983:    if (context_p->token.type != end_type && context_p->token.type != LEXER_ASSIGN
    #####: 3984:        && context_p->token.type != LEXER_COMMA)
        -: 3985:    {
    #####: 3986:      parser_raise_error (context_p, PARSER_ERR_ILLEGAL_PROPERTY_IN_DECLARATION);
        -: 3987:    }
        -: 3988:  }
        -: 3989:  else
        -: 3990:  {
    #####: 3991:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA | PARSE_EXPR_LEFT_HAND_SIDE);
        -: 3992:
    #####: 3993:    if (!PARSER_IS_PUSH_LITERAL (context_p->last_cbc_opcode) && !PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 3994:    {
    #####: 3995:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3996:    }
        -: 3997:  }
        -: 3998:
    #####: 3999:  parser_pattern_form_assignment (context_p, flags, rhs_opcode, literal_index, ident_line_counter);
        -: 4000:#if JERRY_LINE_INFO
    #####: 4001:  parser_line_info_append (context_p, ident_line_counter, ident_column_counter);
        -: 4002:#endif /* JERRY_LINE_INFO */
    #####: 4003:  return false;
        -: 4004:} /* parser_pattern_process_assignment */
        -: 4005:
        -: 4006:/**
        -: 4007: * Parse array initializer.
        -: 4008: */
        -: 4009:static void
    #####: 4010:parser_parse_array_initializer (parser_context_t *context_p, /**< context */
        -: 4011:                                parser_pattern_flags_t flags) /**< flags */
        -: 4012:{
    #####: 4013:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
        -: 4014:
    #####: 4015:  lexer_next_token (context_p);
    #####: 4016:  parser_emit_cbc_ext (context_p, CBC_EXT_ITERATOR_CONTEXT_CREATE);
        -: 4017:
    #####: 4018:  while (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 4019:  {
    #####: 4020:    uint16_t rhs_opcode = CBC_EXT_ITERATOR_STEP;
        -: 4021:
    #####: 4022:    if (context_p->token.type == LEXER_COMMA)
        -: 4023:    {
    #####: 4024:      parser_emit_cbc_ext (context_p, rhs_opcode);
    #####: 4025:      parser_emit_cbc (context_p, CBC_POP);
    #####: 4026:      lexer_next_token (context_p);
    #####: 4027:      continue;
        -: 4028:    }
        -: 4029:
    #####: 4030:    parser_pattern_flags_t options = flags;
        -: 4031:
    #####: 4032:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 4033:    {
    #####: 4034:      lexer_next_token (context_p);
    #####: 4035:      rhs_opcode = CBC_EXT_REST_INITIALIZER;
    #####: 4036:      options |= PARSER_PATTERN_REST_ELEMENT;
        -: 4037:    }
        -: 4038:
    #####: 4039:    parser_pattern_process_assignment (context_p, options, rhs_opcode, PARSER_PATTERN_RHS_NO_LIT, LEXER_RIGHT_SQUARE);
        -: 4040:
    #####: 4041:    if (context_p->token.type == LEXER_COMMA && rhs_opcode != CBC_EXT_REST_INITIALIZER)
        -: 4042:    {
    #####: 4043:      lexer_next_token (context_p);
        -: 4044:    }
    #####: 4045:    else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 4046:    {
    #####: 4047:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 4048:    }
        -: 4049:  }
        -: 4050:
        -: 4051:  /* close the iterator */
    #####: 4052:  parser_emit_cbc_ext (context_p, CBC_EXT_ITERATOR_CONTEXT_END);
        -: 4053:
    #####: 4054:  parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 4055:} /* parser_parse_array_initializer */
        -: 4056:
        -: 4057:/**
        -: 4058: * Parse object initializer.
        -: 4059: */
        -: 4060:static void
    #####: 4061:parser_parse_object_initializer (parser_context_t *context_p, /**< context */
        -: 4062:                                 parser_pattern_flags_t flags) /**< flags */
        -: 4063:{
    #####: 4064:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
        -: 4065:
        -: 4066:  /* 12.14.5.2:  ObjectAssignmentPattern : { } */
    #####: 4067:  if (lexer_check_next_character (context_p, LIT_CHAR_RIGHT_BRACE))
        -: 4068:  {
    #####: 4069:    parser_emit_cbc_ext (context_p, CBC_EXT_REQUIRE_OBJECT_COERCIBLE);
    #####: 4070:    lexer_consume_next_character (context_p);
    #####: 4071:    parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 4072:    return;
        -: 4073:  }
        -: 4074:
    #####: 4075:  cbc_ext_opcode_t context_opcode = CBC_EXT_OBJ_INIT_CONTEXT_CREATE;
        -: 4076:
    #####: 4077:  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 4078:  {
    #####: 4079:    context_opcode = CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE;
        -: 4080:  }
        -: 4081:
    #####: 4082:  parser_emit_cbc_ext (context_p, context_opcode);
        -: 4083:
        -: 4084:  while (true)
    #####: 4085:  {
    #####: 4086:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_OBJECT_PATTERN);
        -: 4087:
    #####: 4088:    uint16_t prop_index = context_p->lit_object.index;
    #####: 4089:    parser_line_counter_t start_line = context_p->token.line;
    #####: 4090:    parser_line_counter_t start_column = context_p->token.column;
    #####: 4091:    uint16_t push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_PROP_LITERAL;
        -: 4092:
    #####: 4093:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 4094:    {
    #####: 4095:      break;
        -: 4096:    }
        -: 4097:
    #####: 4098:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 4099:    {
    #####: 4100:      lexer_next_token (context_p);
        -: 4101:
    #####: 4102:      flags |= PARSER_PATTERN_REST_ELEMENT;
        -: 4103:
    #####: 4104:      if (parser_pattern_process_assignment (context_p,
        -: 4105:                                             flags,
        -: 4106:                                             CBC_EXT_OBJ_INIT_PUSH_REST,
        -: 4107:                                             PARSER_PATTERN_RHS_NO_LIT,
        -: 4108:                                             LEXER_RIGHT_BRACE))
        -: 4109:      {
    #####: 4110:        parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 4111:      }
        -: 4112:
    #####: 4113:      if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 4114:      {
    #####: 4115:        parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 4116:      }
        -: 4117:
        -: 4118:      /* Checked at the end because there might be syntax errors before. */
    #####: 4119:      JERRY_ASSERT (flags & PARSER_PATTERN_HAS_REST_ELEMENT);
    #####: 4120:      break;
        -: 4121:    }
        -: 4122:
    #####: 4123:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -: 4124:    {
    #####: 4125:      prop_index = PARSER_PATTERN_RHS_NO_LIT;
    #####: 4126:      push_prop_opcode =
    #####: 4127:        ((flags & PARSER_PATTERN_HAS_REST_ELEMENT) ? CBC_EXT_INITIALIZER_PUSH_NAME : CBC_EXT_INITIALIZER_PUSH_PROP);
        -: 4128:    }
    #####: 4129:    else if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 4130:    {
    #####: 4131:      push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_NAME_LITERAL;
        -: 4132:    }
        -: 4133:
    #####: 4134:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 4135:    {
    #####: 4136:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 4137:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 4138:    }
        -: 4139:
    #####: 4140:    lexer_next_token (context_p);
        -: 4141:
    #####: 4142:    if (context_p->token.type == LEXER_COLON)
        -: 4143:    {
    #####: 4144:      lexer_next_token (context_p);
    #####: 4145:      parser_pattern_process_assignment (context_p, flags, push_prop_opcode, prop_index, LEXER_RIGHT_BRACE);
        -: 4146:    }
        -: 4147:    else
        -: 4148:    {
    #####: 4149:      if (push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_NAME || push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 4150:      {
    #####: 4151:        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 4152:      }
        -: 4153:
    #####: 4154:      if (context_p->token.type != LEXER_RIGHT_BRACE && context_p->token.type != LEXER_ASSIGN
    #####: 4155:          && context_p->token.type != LEXER_COMMA)
        -: 4156:      {
    #####: 4157:        parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 4158:      }
        -: 4159:
    #####: 4160:      parser_reparse_as_common_identifier (context_p, start_line, start_column);
        -: 4161:
    #####: 4162:      if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 4163:      {
    #####: 4164:        if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 4165:        {
    #####: 4166:          parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 4167:        }
    #####: 4168:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 4169:      }
        -: 4170:
        -: 4171:#if JERRY_MODULE_SYSTEM
    #####: 4172:      parser_module_append_export_name (context_p);
        -: 4173:#endif /* JERRY_MODULE_SYSTEM */
        -: 4174:
    #####: 4175:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 4176:
    #####: 4177:      lexer_next_token (context_p);
    #####: 4178:      JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_ASSIGN
        -: 4179:                    || context_p->token.type == LEXER_COMMA);
        -: 4180:
    #####: 4181:      parser_pattern_form_assignment (context_p, flags, push_prop_opcode, prop_index, start_line);
        -: 4182:#if JERRY_LINE_INFO
    #####: 4183:      parser_line_info_append (context_p, start_line, start_column);
        -: 4184:#endif /* JERRY_LINE_INFO */
        -: 4185:    }
        -: 4186:
    #####: 4187:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 4188:    {
    #####: 4189:      break;
        -: 4190:    }
    #####: 4191:    else if (context_p->token.type != LEXER_COMMA)
        -: 4192:    {
    #####: 4193:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 4194:    }
        -: 4195:  }
        -: 4196:
    #####: 4197:  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 4198:  {
    #####: 4199:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth,
        -: 4200:                            (PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION - PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION));
        -: 4201:  }
        -: 4202:
    #####: 4203:  parser_emit_cbc_ext (context_p, CBC_EXT_OBJ_INIT_CONTEXT_END);
        -: 4204:
    #####: 4205:  parser_pattern_finalize (context_p, flags, &end_pos);
        -: 4206:} /* parser_parse_object_initializer */
        -: 4207:
        -: 4208:/**
        -: 4209: * Parse an initializer.
        -: 4210: */
        -: 4211:void
    #####: 4212:parser_parse_initializer (parser_context_t *context_p, /**< context */
        -: 4213:                          parser_pattern_flags_t flags) /**< flags */
        -: 4214:{
    #####: 4215:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 4216:  {
    #####: 4217:    parser_parse_object_initializer (context_p, flags);
        -: 4218:  }
        -: 4219:  else
        -: 4220:  {
    #####: 4221:    JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
    #####: 4222:    parser_parse_array_initializer (context_p, flags);
        -: 4223:  }
    #####: 4224:} /* parser_parse_initializer */
        -: 4225:
        -: 4226:/**
        -: 4227: * Parse an initializer using the next character.
        -: 4228: */
        -: 4229:void
    #####: 4230:parser_parse_initializer_by_next_char (parser_context_t *context_p, /**< context */
        -: 4231:                                       parser_pattern_flags_t flags) /**< flags */
        -: 4232:{
    #####: 4233:  JERRY_ASSERT (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE));
        -: 4234:
    #####: 4235:  if (lexer_consume_next_character (context_p) == LIT_CHAR_LEFT_BRACE)
        -: 4236:  {
    #####: 4237:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 4238:    {
    #####: 4239:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER
        -: 4240:                    || context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 4241:
    #####: 4242:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 4243:      {
    #####: 4244:        flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 4245:      }
        -: 4246:
    #####: 4247:      if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)
        -: 4248:      {
    #####: 4249:        scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 4250:      }
        -: 4251:    }
        -: 4252:
    #####: 4253:    parser_parse_object_initializer (context_p, flags);
        -: 4254:  }
        -: 4255:  else
        -: 4256:  {
    #####: 4257:    parser_parse_array_initializer (context_p, flags);
        -: 4258:  }
    #####: 4259:} /* parser_parse_initializer_by_next_char */
        -: 4260:
        -: 4261:#endif /* JERRY_ESNEXT */
        -: 4262:
        -: 4263:/**
        -: 4264: * Process ternary expression.
        -: 4265: */
        -: 4266:static void
    #####: 4267:parser_process_ternary_expression (parser_context_t *context_p) /**< context */
        -: 4268:{
    #####: 4269:  JERRY_ASSERT (context_p->token.type == LEXER_QUESTION_MARK);
        -: 4270:
    #####: 4271:  cbc_opcode_t opcode = CBC_BRANCH_IF_FALSE_FORWARD;
    #####: 4272:  parser_branch_t cond_branch;
    #####: 4273:  parser_branch_t uncond_branch;
        -: 4274:
    #####: 4275:  parser_push_result (context_p);
        -: 4276:
    #####: 4277:  if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 4278:  {
    #####: 4279:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 4280:    opcode = CBC_BRANCH_IF_TRUE_FORWARD;
        -: 4281:  }
        -: 4282:
    #####: 4283:  parser_emit_cbc_forward_branch (context_p, (uint16_t) opcode, &cond_branch);
        -: 4284:
    #####: 4285:  lexer_next_token (context_p);
    #####: 4286:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 4287:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &uncond_branch);
    #####: 4288:  parser_set_branch_to_current_position (context_p, &cond_branch);
        -: 4289:
        -: 4290:  /* Although byte code is constructed for two branches,
        -: 4291:   * only one of them will be executed. To reflect this
        -: 4292:   * the stack is manually adjusted. */
    #####: 4293:  JERRY_ASSERT (context_p->stack_depth > 0);
    #####: 4294:  context_p->stack_depth--;
        -: 4295:
    #####: 4296:  if (context_p->token.type != LEXER_COLON)
        -: 4297:  {
    #####: 4298:    parser_raise_error (context_p, PARSER_ERR_COLON_FOR_CONDITIONAL_EXPECTED);
        -: 4299:  }
        -: 4300:
    #####: 4301:  lexer_next_token (context_p);
        -: 4302:
    #####: 4303:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 4304:  parser_set_branch_to_current_position (context_p, &uncond_branch);
        -: 4305:
        -: 4306:  /* Last opcode rewrite is not allowed because
        -: 4307:   * the result may come from the first branch. */
    #####: 4308:  parser_flush_cbc (context_p);
        -: 4309:
    #####: 4310:  parser_process_binary_opcodes (context_p, 0);
    #####: 4311:} /* parser_process_ternary_expression */
        -: 4312:
        -: 4313:/**
        -: 4314: * Process expression sequence.
        -: 4315: */
        -: 4316:static void
    #####: 4317:parser_process_expression_sequence (parser_context_t *context_p) /**< context */
        -: 4318:{
    #####: 4319:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 4320:  {
    #####: 4321:    parser_emit_cbc (context_p, CBC_POP);
        -: 4322:  }
        -: 4323:
    #####: 4324:  if (context_p->stack_top_uint8 == LEXER_LEFT_PAREN)
        -: 4325:  {
    #####: 4326:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -: 4327:
    #####: 4328:    JERRY_ASSERT (page_p != NULL);
        -: 4329:
    #####: 4330:    page_p->bytes[context_p->stack.last_position - 1] = LEXER_COMMA_SEP_LIST;
    #####: 4331:    context_p->stack_top_uint8 = LEXER_COMMA_SEP_LIST;
        -: 4332:  }
        -: 4333:
    #####: 4334:  lexer_next_token (context_p);
    #####: 4335:} /* parser_process_expression_sequence */
        -: 4336:
        -: 4337:/**
        -: 4338: * Process group expression.
        -: 4339: */
        -: 4340:static void
    #####: 4341:parser_process_group_expression (parser_context_t *context_p, /**< context */
        -: 4342:                                 size_t *grouping_level_p) /**< grouping level */
        -: 4343:{
    #####: 4344:  JERRY_ASSERT (*grouping_level_p >= PARSER_GROUPING_LEVEL_INCREASE);
    #####: 4345:  (*grouping_level_p) -= PARSER_GROUPING_LEVEL_INCREASE;
        -: 4346:
    #####: 4347:  uint8_t token = context_p->stack_top_uint8;
        -: 4348:
    #####: 4349:  if (token == LEXER_COMMA_SEP_LIST)
        -: 4350:  {
    #####: 4351:    parser_push_result (context_p);
    #####: 4352:    parser_flush_cbc (context_p);
        -: 4353:  }
        -: 4354:
    #####: 4355:  parser_stack_pop_uint8 (context_p);
    #####: 4356:  lexer_next_token (context_p);
        -: 4357:
        -: 4358:#if JERRY_ESNEXT
        -: 4359:  /* Lookahead for anonymous function declaration after '=' token when the assignment base is LHS expression
        -: 4360:     with a single indentifier in it. e.g.: (a) = function () {} */
    #####: 4361:  if (JERRY_UNLIKELY (context_p->token.type == LEXER_ASSIGN
        -: 4362:                      && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
        -: 4363:                      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL
        -: 4364:                      && parser_is_assignment_expr (context_p) && *grouping_level_p != PARSE_EXPR_LEFT_HAND_SIDE))
        -: 4365:  {
    #####: 4366:    parser_stack_push_uint8 (context_p, LEXER_ASSIGN_GROUP_EXPR);
        -: 4367:  }
        -: 4368:#endif /* JERRY_ESNEXT */
    #####: 4369:} /* parser_process_group_expression */
        -: 4370:
        -: 4371:/**
        -: 4372: * Parse block expression.
        -: 4373: */
        -: 4374:void
        1: 4375:parser_parse_block_expression (parser_context_t *context_p, /**< context */
        -: 4376:                               int options) /**< option flags */
        -: 4377:{
        1: 4378:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 4379:
        1: 4380:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 4381:  {
        1: 4382:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 2));
        1: 4383:    PARSER_PLUS_EQUAL_U16 (context_p->last_cbc_opcode, 2);
        1: 4384:    parser_flush_cbc (context_p);
        -: 4385:  }
        -: 4386:  else
        -: 4387:  {
    #####: 4388:    parser_emit_cbc (context_p, CBC_POP_BLOCK);
        -: 4389:  }
        1: 4390:} /* parser_parse_block_expression */
        -: 4391:
        -: 4392:/**
        -: 4393: * Parse expression statement.
        -: 4394: */
        -: 4395:void
    #####: 4396:parser_parse_expression_statement (parser_context_t *context_p, /**< context */
        -: 4397:                                   int options) /**< option flags */
        -: 4398:{
    #####: 4399:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 4400:
    #####: 4401:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 4402:  {
    #####: 4403:    parser_emit_cbc (context_p, CBC_POP);
        -: 4404:  }
    #####: 4405:} /* parser_parse_expression_statement */
        -: 4406:
        -: 4407:JERRY_STATIC_ASSERT (PARSE_EXPR_LEFT_HAND_SIDE == 0x1, value_of_parse_expr_left_hand_side_must_be_1);
        -: 4408:
        -: 4409:/**
        -: 4410: * Parse expression.
        -: 4411: */
        -: 4412:void
        8: 4413:parser_parse_expression (parser_context_t *context_p, /**< context */
        -: 4414:                         int options) /**< option flags */
        -: 4415:{
        8: 4416:  size_t grouping_level = (options & PARSE_EXPR_LEFT_HAND_SIDE);
        -: 4417:
        8: 4418:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
        -: 4419:
        8: 4420:  if (options & PARSE_EXPR_HAS_LITERAL)
        -: 4421:  {
    #####: 4422:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 4423:    goto process_unary_expression;
        -: 4424:  }
        -: 4425:
        -: 4426:  while (true)
        -: 4427:  {
        8: 4428:    if (parser_parse_unary_expression (context_p, &grouping_level))
        -: 4429:    {
    #####: 4430:      parser_process_binary_opcodes (context_p, 0);
    #####: 4431:      break;
        -: 4432:    }
        -: 4433:
        -: 4434:    while (true)
        -: 4435:    {
        8: 4436:process_unary_expression:
        8: 4437:      parser_process_unary_expression (context_p, grouping_level);
        -: 4438:
        8: 4439:      if (JERRY_LIKELY (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE))
        -: 4440:      {
        8: 4441:        uint8_t min_prec_treshold = 0;
        -: 4442:
        8: 4443:        if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 4444:        {
        -: 4445:#if JERRY_ESNEXT
    #####: 4446:          if (JERRY_UNLIKELY (context_p->token.type == LEXER_NULLISH_COALESCING))
        -: 4447:          {
    #####: 4448:            parser_check_invalid_logical_op (context_p, LEXER_LOGICAL_OR, LEXER_LOGICAL_AND);
        -: 4449:          }
        -: 4450:#endif /* JERRY_ESNEXT */
        -: 4451:
    #####: 4452:          min_prec_treshold = parser_binary_precedence_table[context_p->token.type - LEXER_FIRST_BINARY_OP];
        -: 4453:
        -: 4454:#if JERRY_ESNEXT
        -: 4455:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND + LEXER_EXPONENTIATION */
    #####: 4456:          if ((min_prec_treshold == PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION)
    #####: 4457:              || (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
    #####: 4458:                  && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE))
        -: 4459:          {
        -: 4460:            /* Right-to-left evaluation order. */
    #####: 4461:            min_prec_treshold++;
        -: 4462:          }
        -: 4463:#else /* !JERRY_ESNEXT */
        -: 4464:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND */
    #####: 4465:          if (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
    #####: 4466:              && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE)
        -: 4467:          {
        -: 4468:            /* Right-to-left evaluation order. */
    #####: 4469:            min_prec_treshold++;
        -: 4470:          }
        -: 4471:#endif /* JERRY_ESNEXT */
        -: 4472:        }
        -: 4473:
        8: 4474:        parser_process_binary_opcodes (context_p, min_prec_treshold);
        -: 4475:      }
        8: 4476:      if (context_p->token.type == LEXER_RIGHT_PAREN
        3: 4477:          && (context_p->stack_top_uint8 == LEXER_LEFT_PAREN || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST))
        -: 4478:      {
    #####: 4479:        parser_process_group_expression (context_p, &grouping_level);
    #####: 4480:        continue;
        -: 4481:      }
        -: 4482:
        8: 4483:      break;
        -: 4484:    }
        -: 4485:
        8: 4486:    if (grouping_level == PARSE_EXPR_LEFT_HAND_SIDE)
        -: 4487:    {
    #####: 4488:      break;
        -: 4489:    }
        -: 4490:
        8: 4491:    if (JERRY_UNLIKELY (context_p->token.type == LEXER_QUESTION_MARK))
        -: 4492:    {
    #####: 4493:      parser_process_ternary_expression (context_p);
        -: 4494:
    #####: 4495:      if (context_p->token.type == LEXER_RIGHT_PAREN)
        -: 4496:      {
    #####: 4497:        goto process_unary_expression;
        -: 4498:      }
        -: 4499:    }
        8: 4500:    else if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 4501:    {
    #####: 4502:      parser_append_binary_token (context_p);
    #####: 4503:      lexer_next_token (context_p);
    #####: 4504:      continue;
        -: 4505:    }
        -: 4506:
        8: 4507:    if (JERRY_UNLIKELY (context_p->token.type == LEXER_COMMA)
        2: 4508:        && (!(options & PARSE_EXPR_NO_COMMA) || grouping_level >= PARSER_GROUPING_LEVEL_INCREASE))
        -: 4509:    {
    #####: 4510:      parser_process_expression_sequence (context_p);
    #####: 4511:      continue;
        -: 4512:    }
        -: 4513:
        8: 4514:    break;
        -: 4515:  }
        -: 4516:
        8: 4517:  if (grouping_level >= PARSER_GROUPING_LEVEL_INCREASE)
        -: 4518:  {
    #####: 4519:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 4520:  }
        -: 4521:
        8: 4522:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
        8: 4523:  parser_stack_pop_uint8 (context_p);
        -: 4524:
        8: 4525:  if (!(options & PARSE_EXPR_NO_PUSH_RESULT))
        -: 4526:  {
        7: 4527:    parser_push_result (context_p);
        -: 4528:  }
        8: 4529:} /* parser_parse_expression */
        -: 4530:
        -: 4531:/**
        -: 4532: * @}
        -: 4533: * @}
        -: 4534: * @}
        -: 4535: */
        -: 4536:
        -: 4537:#endif /* JERRY_PARSER */
