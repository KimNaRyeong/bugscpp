        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-json.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-objects-general.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#include "jcontext.h"
        -:   30:#include "jrt-libc-includes.h"
        -:   31:#include "jrt.h"
        -:   32:#include "lit-char-helpers.h"
        -:   33:#include "lit-globals.h"
        -:   34:
        -:   35:#if JERRY_BUILTIN_JSON
        -:   36:
        -:   37:#define ECMA_BUILTINS_INTERNAL
        -:   38:#include "ecma-builtins-internal.h"
        -:   39:
        -:   40:/**
        -:   41: * This object has a custom dispatch function.
        -:   42: */
        -:   43:#define BUILTIN_CUSTOM_DISPATCH
        -:   44:
        -:   45:/**
        -:   46: * List of built-in routine identifiers.
        -:   47: */
        -:   48:enum
        -:   49:{
        -:   50:  ECMA_BUILTIN_JSON_ROUTINE_START = 0,
        -:   51:  ECMA_BUILTIN_JSON_PARSE,
        -:   52:  ECMA_BUILTIN_JSON_STRINGIFY,
        -:   53:};
        -:   54:
        -:   55:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-json.inc.h"
        -:   56:#define BUILTIN_UNDERSCORED_ID  json
        -:   57:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   58:
        -:   59:/**
        -:   60: * The number of expected hexidecimal characters in a hex escape sequence
        -:   61: */
        -:   62:#define ECMA_JSON_HEX_ESCAPE_SEQUENCE_LENGTH (4)
        -:   63:
        -:   64:/** \addtogroup ecma ECMA
        -:   65: * @{
        -:   66: *
        -:   67: * \addtogroup ecmabuiltins
        -:   68: * @{
        -:   69: *
        -:   70: * \addtogroup json ECMA JSON object built-in
        -:   71: * @{
        -:   72: */
        -:   73:
        -:   74:/**
        -:   75: * JSON token type
        -:   76: */
        -:   77:typedef enum
        -:   78:{
        -:   79:  TOKEN_INVALID, /**< error token */
        -:   80:  TOKEN_END, /**< end of stream reached */
        -:   81:  TOKEN_NUMBER, /**< JSON number */
        -:   82:  TOKEN_STRING, /**< JSON string */
        -:   83:  TOKEN_NULL, /**< JSON null primitive value */
        -:   84:  TOKEN_TRUE, /**< JSON true primitive value */
        -:   85:  TOKEN_FALSE, /**< JSON false primitive value */
        -:   86:  TOKEN_LEFT_BRACE, /**< JSON left brace */
        -:   87:  TOKEN_RIGHT_BRACE, /**< JSON right brace */
        -:   88:  TOKEN_LEFT_SQUARE, /**< JSON left square bracket */
        -:   89:  TOKEN_RIGHT_SQUARE, /**< JSON right square bracket */
        -:   90:  TOKEN_COMMA, /**< JSON comma */
        -:   91:  TOKEN_COLON /**< JSON colon */
        -:   92:} ecma_json_token_type_t;
        -:   93:
        -:   94:/**
        -:   95: * JSON token
        -:   96: */
        -:   97:typedef struct
        -:   98:{
        -:   99:  ecma_json_token_type_t type; /**< type of the current token */
        -:  100:  const lit_utf8_byte_t *current_p; /**< current position of the string processed by the parser */
        -:  101:  const lit_utf8_byte_t *end_p; /**< end of the string processed by the parser */
        -:  102:
        -:  103:  /**
        -:  104:   * Fields depending on type.
        -:  105:   */
        -:  106:  union
        -:  107:  {
        -:  108:    ecma_string_t *string_p; /**< when type is string_token it contains the string */
        -:  109:    ecma_number_t number; /**< when type is number_token, it contains the value of the number */
        -:  110:  } u;
        -:  111:} ecma_json_token_t;
        -:  112:
        -:  113:/**
        -:  114: * Parse and extract string token.
        -:  115: */
        -:  116:static void
    #####:  117:ecma_builtin_json_parse_string (ecma_json_token_t *token_p) /**< token argument */
        -:  118:{
    #####:  119:  const lit_utf8_byte_t *current_p = token_p->current_p;
    #####:  120:  const lit_utf8_byte_t *end_p = token_p->end_p;
        -:  121:
    #####:  122:  ecma_stringbuilder_t result_builder = ecma_stringbuilder_create ();
    #####:  123:  const lit_utf8_byte_t *unappended_p = current_p;
        -:  124:
        -:  125:  while (true)
        -:  126:  {
    #####:  127:    if (current_p >= end_p || *current_p <= 0x1f)
        -:  128:    {
        -:  129:      goto invalid_string;
        -:  130:    }
        -:  131:
    #####:  132:    if (*current_p == LIT_CHAR_DOUBLE_QUOTE)
        -:  133:    {
    #####:  134:      break;
        -:  135:    }
        -:  136:
    #####:  137:    if (*current_p >= LIT_UTF8_4_BYTE_MARKER)
        -:  138:    {
    #####:  139:      ecma_stringbuilder_append_raw (&result_builder, unappended_p, (lit_utf8_size_t) (current_p - unappended_p));
    #####:  140:      JERRY_ASSERT (current_p + 4 <= end_p);
        -:  141:
    #####:  142:      lit_code_point_t cp;
    #####:  143:      lit_utf8_size_t read_size = lit_read_code_point_from_utf8 (current_p, 4, &cp);
    #####:  144:      JERRY_ASSERT (read_size == 4);
        -:  145:
    #####:  146:      ecma_stringbuilder_append_codepoint (&result_builder, cp);
    #####:  147:      current_p += 4;
        -:  148:
    #####:  149:      unappended_p = current_p;
    #####:  150:      continue;
        -:  151:    }
        -:  152:
    #####:  153:    if (*current_p == LIT_CHAR_BACKSLASH)
        -:  154:    {
    #####:  155:      ecma_stringbuilder_append_raw (&result_builder, unappended_p, (lit_utf8_size_t) (current_p - unappended_p));
        -:  156:
    #####:  157:      current_p++;
        -:  158:
        -:  159:      /* If there is an escape sequence but there's no escapable character just return */
    #####:  160:      if (current_p >= end_p)
        -:  161:      {
    #####:  162:        goto invalid_string;
        -:  163:      }
        -:  164:
    #####:  165:      const lit_utf8_byte_t c = *current_p;
    #####:  166:      switch (c)
        -:  167:      {
    #####:  168:        case LIT_CHAR_DOUBLE_QUOTE:
        -:  169:        case LIT_CHAR_SLASH:
        -:  170:        case LIT_CHAR_BACKSLASH:
        -:  171:        {
    #####:  172:          ecma_stringbuilder_append_byte (&result_builder, c);
    #####:  173:          current_p++;
    #####:  174:          break;
        -:  175:        }
    #####:  176:        case LIT_CHAR_LOWERCASE_B:
        -:  177:        {
    #####:  178:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_BS);
    #####:  179:          current_p++;
    #####:  180:          break;
        -:  181:        }
    #####:  182:        case LIT_CHAR_LOWERCASE_F:
        -:  183:        {
    #####:  184:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_FF);
    #####:  185:          current_p++;
    #####:  186:          break;
        -:  187:        }
    #####:  188:        case LIT_CHAR_LOWERCASE_N:
        -:  189:        {
    #####:  190:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_LF);
    #####:  191:          current_p++;
    #####:  192:          break;
        -:  193:        }
    #####:  194:        case LIT_CHAR_LOWERCASE_R:
        -:  195:        {
    #####:  196:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_CR);
    #####:  197:          current_p++;
    #####:  198:          break;
        -:  199:        }
    #####:  200:        case LIT_CHAR_LOWERCASE_T:
        -:  201:        {
    #####:  202:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_TAB);
    #####:  203:          current_p++;
    #####:  204:          break;
        -:  205:        }
    #####:  206:        case LIT_CHAR_LOWERCASE_U:
        -:  207:        {
    #####:  208:          uint32_t hex_value = lit_char_hex_lookup (current_p + 1, end_p, ECMA_JSON_HEX_ESCAPE_SEQUENCE_LENGTH);
    #####:  209:          if (hex_value == UINT32_MAX)
        -:  210:          {
    #####:  211:            goto invalid_string;
        -:  212:          }
        -:  213:
    #####:  214:          ecma_stringbuilder_append_char (&result_builder, (ecma_char_t) hex_value);
    #####:  215:          current_p += ECMA_JSON_HEX_ESCAPE_SEQUENCE_LENGTH + 1;
    #####:  216:          break;
        -:  217:        }
    #####:  218:        default:
        -:  219:        {
    #####:  220:          goto invalid_string;
        -:  221:        }
        -:  222:      }
        -:  223:
    #####:  224:      unappended_p = current_p;
    #####:  225:      continue;
        -:  226:    }
        -:  227:
    #####:  228:    current_p++;
        -:  229:  }
        -:  230:
    #####:  231:  ecma_stringbuilder_append_raw (&result_builder, unappended_p, (lit_utf8_size_t) (current_p - unappended_p));
    #####:  232:  token_p->u.string_p = ecma_stringbuilder_finalize (&result_builder);
    #####:  233:  token_p->current_p = current_p + 1;
    #####:  234:  token_p->type = TOKEN_STRING;
    #####:  235:  return;
        -:  236:
    #####:  237:invalid_string:
    #####:  238:  ecma_stringbuilder_destroy (&result_builder);
        -:  239:} /* ecma_builtin_json_parse_string */
        -:  240:
        -:  241:/**
        -:  242: * Parse and extract string token.
        -:  243: */
        -:  244:static void
    #####:  245:ecma_builtin_json_parse_number (ecma_json_token_t *token_p) /**< token argument */
        -:  246:{
    #####:  247:  const lit_utf8_byte_t *current_p = token_p->current_p;
    #####:  248:  const lit_utf8_byte_t *end_p = token_p->end_p;
    #####:  249:  const lit_utf8_byte_t *start_p = current_p;
        -:  250:
    #####:  251:  JERRY_ASSERT (current_p < end_p);
        -:  252:
    #####:  253:  if (*current_p == LIT_CHAR_MINUS)
        -:  254:  {
    #####:  255:    current_p++;
        -:  256:  }
        -:  257:
    #####:  258:  if (current_p >= end_p)
        -:  259:  {
    #####:  260:    return;
        -:  261:  }
        -:  262:
    #####:  263:  if (*current_p == LIT_CHAR_0)
        -:  264:  {
    #####:  265:    current_p++;
        -:  266:
    #####:  267:    if (current_p < end_p && lit_char_is_decimal_digit (*current_p))
        -:  268:    {
    #####:  269:      return;
        -:  270:    }
        -:  271:  }
    #####:  272:  else if (lit_char_is_decimal_digit (*current_p))
        -:  273:  {
        -:  274:    do
        -:  275:    {
    #####:  276:      current_p++;
    #####:  277:    } while (current_p < end_p && lit_char_is_decimal_digit (*current_p));
        -:  278:  }
        -:  279:
    #####:  280:  if (current_p < end_p && *current_p == LIT_CHAR_DOT)
        -:  281:  {
    #####:  282:    current_p++;
        -:  283:
    #####:  284:    if (current_p >= end_p || !lit_char_is_decimal_digit (*current_p))
        -:  285:    {
    #####:  286:      return;
        -:  287:    }
        -:  288:
        -:  289:    do
        -:  290:    {
    #####:  291:      current_p++;
    #####:  292:    } while (current_p < end_p && lit_char_is_decimal_digit (*current_p));
        -:  293:  }
        -:  294:
    #####:  295:  if (current_p < end_p && (*current_p == LIT_CHAR_LOWERCASE_E || *current_p == LIT_CHAR_UPPERCASE_E))
        -:  296:  {
    #####:  297:    current_p++;
        -:  298:
    #####:  299:    if (current_p < end_p && (*current_p == LIT_CHAR_PLUS || *current_p == LIT_CHAR_MINUS))
        -:  300:    {
    #####:  301:      current_p++;
        -:  302:    }
        -:  303:
    #####:  304:    if (current_p >= end_p || !lit_char_is_decimal_digit (*current_p))
        -:  305:    {
    #####:  306:      return;
        -:  307:    }
        -:  308:
        -:  309:    do
        -:  310:    {
    #####:  311:      current_p++;
    #####:  312:    } while (current_p < end_p && lit_char_is_decimal_digit (*current_p));
        -:  313:  }
        -:  314:
    #####:  315:  token_p->type = TOKEN_NUMBER;
    #####:  316:  token_p->u.number = ecma_utf8_string_to_number (start_p, (lit_utf8_size_t) (current_p - start_p), 0);
        -:  317:
    #####:  318:  token_p->current_p = current_p;
        -:  319:} /* ecma_builtin_json_parse_number */
        -:  320:
        -:  321:/**
        -:  322: * Parse next token.
        -:  323: *
        -:  324: * The function fills the fields of the ecma_json_token_t
        -:  325: * argument and advances the string pointer.
        -:  326: */
        -:  327:static void
    #####:  328:ecma_builtin_json_parse_next_token (ecma_json_token_t *token_p, /**< token argument */
        -:  329:                                    bool parse_string) /**< strings are allowed to parse */
        -:  330:{
    #####:  331:  const lit_utf8_byte_t *current_p = token_p->current_p;
    #####:  332:  const lit_utf8_byte_t *end_p = token_p->end_p;
    #####:  333:  token_p->type = TOKEN_INVALID;
        -:  334:
    #####:  335:  while (current_p < end_p
    #####:  336:         && (*current_p == LIT_CHAR_SP || *current_p == LIT_CHAR_CR || *current_p == LIT_CHAR_LF
    #####:  337:             || *current_p == LIT_CHAR_TAB))
        -:  338:  {
    #####:  339:    current_p++;
        -:  340:  }
        -:  341:
    #####:  342:  if (current_p == end_p)
        -:  343:  {
    #####:  344:    token_p->type = TOKEN_END;
    #####:  345:    return;
        -:  346:  }
        -:  347:
    #####:  348:  switch (*current_p)
        -:  349:  {
    #####:  350:    case LIT_CHAR_LEFT_BRACE:
        -:  351:    {
    #####:  352:      token_p->type = TOKEN_LEFT_BRACE;
    #####:  353:      token_p->current_p = current_p + 1;
    #####:  354:      return;
        -:  355:    }
    #####:  356:    case LIT_CHAR_RIGHT_BRACE:
        -:  357:    {
    #####:  358:      token_p->type = TOKEN_RIGHT_BRACE;
    #####:  359:      token_p->current_p = current_p + 1;
    #####:  360:      return;
        -:  361:    }
    #####:  362:    case LIT_CHAR_LEFT_SQUARE:
        -:  363:    {
    #####:  364:      token_p->type = TOKEN_LEFT_SQUARE;
    #####:  365:      token_p->current_p = current_p + 1;
    #####:  366:      return;
        -:  367:    }
    #####:  368:    case LIT_CHAR_RIGHT_SQUARE:
        -:  369:    {
    #####:  370:      token_p->type = TOKEN_RIGHT_SQUARE;
    #####:  371:      token_p->current_p = current_p + 1;
    #####:  372:      return;
        -:  373:    }
    #####:  374:    case LIT_CHAR_COMMA:
        -:  375:    {
    #####:  376:      token_p->type = TOKEN_COMMA;
    #####:  377:      token_p->current_p = current_p + 1;
    #####:  378:      return;
        -:  379:    }
    #####:  380:    case LIT_CHAR_COLON:
        -:  381:    {
    #####:  382:      token_p->type = TOKEN_COLON;
    #####:  383:      token_p->current_p = current_p + 1;
    #####:  384:      return;
        -:  385:    }
    #####:  386:    case LIT_CHAR_DOUBLE_QUOTE:
        -:  387:    {
    #####:  388:      if (parse_string)
        -:  389:      {
    #####:  390:        token_p->current_p = current_p + 1;
    #####:  391:        ecma_builtin_json_parse_string (token_p);
        -:  392:      }
    #####:  393:      return;
        -:  394:    }
    #####:  395:    case LIT_CHAR_LOWERCASE_N:
        -:  396:    {
    #####:  397:      lit_utf8_size_t size = lit_get_magic_string_size (LIT_MAGIC_STRING_NULL);
    #####:  398:      if (current_p + size <= end_p)
        -:  399:      {
    #####:  400:        if (!memcmp (lit_get_magic_string_utf8 (LIT_MAGIC_STRING_NULL), current_p, size))
        -:  401:        {
    #####:  402:          token_p->type = TOKEN_NULL;
    #####:  403:          token_p->current_p = current_p + size;
    #####:  404:          return;
        -:  405:        }
        -:  406:      }
    #####:  407:      break;
        -:  408:    }
    #####:  409:    case LIT_CHAR_LOWERCASE_T:
        -:  410:    {
    #####:  411:      lit_utf8_size_t size = lit_get_magic_string_size (LIT_MAGIC_STRING_TRUE);
    #####:  412:      if (current_p + size <= end_p)
        -:  413:      {
    #####:  414:        if (!memcmp (lit_get_magic_string_utf8 (LIT_MAGIC_STRING_TRUE), current_p, size))
        -:  415:        {
    #####:  416:          token_p->type = TOKEN_TRUE;
    #####:  417:          token_p->current_p = current_p + size;
    #####:  418:          return;
        -:  419:        }
        -:  420:      }
    #####:  421:      break;
        -:  422:    }
    #####:  423:    case LIT_CHAR_LOWERCASE_F:
        -:  424:    {
    #####:  425:      lit_utf8_size_t size = lit_get_magic_string_size (LIT_MAGIC_STRING_FALSE);
    #####:  426:      if (current_p + size <= end_p)
        -:  427:      {
    #####:  428:        if (!memcmp (lit_get_magic_string_utf8 (LIT_MAGIC_STRING_FALSE), current_p, size))
        -:  429:        {
    #####:  430:          token_p->type = TOKEN_FALSE;
    #####:  431:          token_p->current_p = current_p + size;
    #####:  432:          return;
        -:  433:        }
        -:  434:      }
    #####:  435:      break;
        -:  436:    }
    #####:  437:    default:
        -:  438:    {
    #####:  439:      if (*current_p == LIT_CHAR_MINUS || lit_char_is_decimal_digit (*current_p))
        -:  440:      {
    #####:  441:        token_p->current_p = current_p;
    #####:  442:        ecma_builtin_json_parse_number (token_p);
    #####:  443:        return;
        -:  444:      }
    #####:  445:      break;
        -:  446:    }
        -:  447:  }
        -:  448:} /* ecma_builtin_json_parse_next_token */
        -:  449:
        -:  450:/**
        -:  451: * Utility for defining properties.
        -:  452: *
        -:  453: * It silently ignores all errors.
        -:  454: */
        -:  455:static void
    #####:  456:ecma_builtin_json_define_value_property (ecma_object_t *obj_p, /**< this object */
        -:  457:                                         ecma_string_t *property_name_p, /**< property name */
        -:  458:                                         ecma_value_t value) /**< value */
        -:  459:{
    #####:  460:  ecma_value_t completion_value =
        -:  461:    ecma_builtin_helper_def_prop (obj_p, property_name_p, value, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -:  462:
    #####:  463:  JERRY_ASSERT (ecma_is_value_boolean (completion_value));
    #####:  464:} /* ecma_builtin_json_define_value_property */
        -:  465:
        -:  466:/**
        -:  467: * Parse next value.
        -:  468: *
        -:  469: * The function fills the fields of the ecma_json_token_t
        -:  470: * argument and advances the string pointer.
        -:  471: *
        -:  472: * @return ecma_value with the property value
        -:  473: */
        -:  474:static ecma_value_t
    #####:  475:ecma_builtin_json_parse_value (ecma_json_token_t *token_p) /**< token argument */
        -:  476:{
    #####:  477:  switch (token_p->type)
        -:  478:  {
    #####:  479:    case TOKEN_NUMBER:
        -:  480:    {
    #####:  481:      return ecma_make_number_value (token_p->u.number);
        -:  482:    }
    #####:  483:    case TOKEN_STRING:
        -:  484:    {
    #####:  485:      return ecma_make_string_value (token_p->u.string_p);
        -:  486:    }
    #####:  487:    case TOKEN_NULL:
        -:  488:    {
    #####:  489:      return ECMA_VALUE_NULL;
        -:  490:    }
    #####:  491:    case TOKEN_TRUE:
        -:  492:    {
    #####:  493:      return ECMA_VALUE_TRUE;
        -:  494:    }
    #####:  495:    case TOKEN_FALSE:
        -:  496:    {
    #####:  497:      return ECMA_VALUE_FALSE;
        -:  498:    }
    #####:  499:    case TOKEN_LEFT_BRACE:
        -:  500:    {
    #####:  501:      ecma_object_t *object_p = ecma_op_create_object_object_noarg ();
        -:  502:
    #####:  503:      ecma_builtin_json_parse_next_token (token_p, true);
        -:  504:
    #####:  505:      if (token_p->type == TOKEN_RIGHT_BRACE)
        -:  506:      {
    #####:  507:        return ecma_make_object_value (object_p);
        -:  508:      }
        -:  509:
        -:  510:      while (true)
    #####:  511:      {
    #####:  512:        if (token_p->type != TOKEN_STRING)
        -:  513:        {
    #####:  514:          break;
        -:  515:        }
        -:  516:
    #####:  517:        ecma_string_t *name_p = token_p->u.string_p;
        -:  518:
    #####:  519:        ecma_builtin_json_parse_next_token (token_p, false);
    #####:  520:        if (token_p->type != TOKEN_COLON)
        -:  521:        {
    #####:  522:          ecma_deref_ecma_string (name_p);
    #####:  523:          break;
        -:  524:        }
        -:  525:
    #####:  526:        ecma_builtin_json_parse_next_token (token_p, true);
    #####:  527:        ecma_value_t value = ecma_builtin_json_parse_value (token_p);
        -:  528:
    #####:  529:        if (ecma_is_value_empty (value))
        -:  530:        {
    #####:  531:          ecma_deref_ecma_string (name_p);
    #####:  532:          break;
        -:  533:        }
        -:  534:
    #####:  535:        ecma_builtin_json_define_value_property (object_p, name_p, value);
    #####:  536:        ecma_deref_ecma_string (name_p);
    #####:  537:        ecma_free_value (value);
        -:  538:
    #####:  539:        ecma_builtin_json_parse_next_token (token_p, false);
    #####:  540:        if (token_p->type == TOKEN_RIGHT_BRACE)
        -:  541:        {
    #####:  542:          return ecma_make_object_value (object_p);
        -:  543:        }
        -:  544:
    #####:  545:        if (token_p->type != TOKEN_COMMA)
        -:  546:        {
    #####:  547:          break;
        -:  548:        }
        -:  549:
    #####:  550:        ecma_builtin_json_parse_next_token (token_p, true);
        -:  551:      }
        -:  552:
        -:  553:      /*
        -:  554:       * Parse error occurred.
        -:  555:       */
    #####:  556:      ecma_deref_object (object_p);
    #####:  557:      return ECMA_VALUE_EMPTY;
        -:  558:    }
    #####:  559:    case TOKEN_LEFT_SQUARE:
        -:  560:    {
    #####:  561:      uint32_t length = 0;
    #####:  562:      ecma_object_t *array_p = ecma_op_new_array_object (0);
        -:  563:
    #####:  564:      ecma_builtin_json_parse_next_token (token_p, true);
        -:  565:
    #####:  566:      if (token_p->type == TOKEN_RIGHT_SQUARE)
        -:  567:      {
    #####:  568:        return ecma_make_object_value (array_p);
        -:  569:      }
        -:  570:
        -:  571:      while (true)
    #####:  572:      {
    #####:  573:        ecma_value_t value = ecma_builtin_json_parse_value (token_p);
        -:  574:
    #####:  575:        if (ecma_is_value_empty (value))
        -:  576:        {
    #####:  577:          JERRY_ASSERT (token_p->type != TOKEN_STRING);
    #####:  578:          break;
        -:  579:        }
        -:  580:
        -:  581:        ecma_value_t completion;
    #####:  582:        completion = ecma_builtin_helper_def_prop_by_index (array_p,
        -:  583:                                                            length,
        -:  584:                                                            value,
        -:  585:                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  586:        JERRY_ASSERT (ecma_is_value_true (completion));
    #####:  587:        ecma_free_value (value);
        -:  588:
    #####:  589:        ecma_builtin_json_parse_next_token (token_p, false);
        -:  590:
    #####:  591:        if (token_p->type == TOKEN_RIGHT_SQUARE)
        -:  592:        {
    #####:  593:          return ecma_make_object_value (array_p);
        -:  594:        }
        -:  595:
    #####:  596:        if (token_p->type != TOKEN_COMMA)
        -:  597:        {
    #####:  598:          JERRY_ASSERT (token_p->type != TOKEN_STRING);
    #####:  599:          break;
        -:  600:        }
        -:  601:
    #####:  602:        ecma_builtin_json_parse_next_token (token_p, true);
    #####:  603:        length++;
        -:  604:      }
        -:  605:
    #####:  606:      ecma_deref_object (array_p);
    #####:  607:      return ECMA_VALUE_EMPTY;
        -:  608:    }
    #####:  609:    default:
        -:  610:    {
    #####:  611:      return ECMA_VALUE_EMPTY;
        -:  612:    }
        -:  613:  }
        -:  614:} /* ecma_builtin_json_parse_value */
        -:  615:
        -:  616:static ecma_value_t ecma_builtin_json_internalize_process_property (ecma_object_t *reviver_p,
        -:  617:                                                                    ecma_object_t *object_p,
        -:  618:                                                                    ecma_string_t *prop_name);
        -:  619:
        -:  620:/**
        -:  621: * Abstract operation InternalizeJSONProperty
        -:  622: *
        -:  623: * See also:
        -:  624: *         ECMA-262 v5, 24.3.1.1
        -:  625: *         ECMA-262 v11, 24.5.1.1
        -:  626: *
        -:  627: * @return ecma value
        -:  628: *         Returned value must be freed with ecma_free_value.
        -:  629: */
        -:  630:static ecma_value_t
    #####:  631:ecma_builtin_json_internalize_property (ecma_object_t *reviver_p, /**< reviver function */
        -:  632:                                        ecma_object_t *holder_p, /**< holder object */
        -:  633:                                        ecma_string_t *name_p) /**< property name */
        -:  634:{
    #####:  635:  JERRY_ASSERT (reviver_p);
    #####:  636:  JERRY_ASSERT (holder_p);
    #####:  637:  JERRY_ASSERT (name_p);
        -:  638:
    #####:  639:  ECMA_CHECK_STACK_USAGE ();
        -:  640:
        -:  641:  /* 1. */
    #####:  642:  ecma_value_t value = ecma_op_object_get (holder_p, name_p);
        -:  643:
        -:  644:  /* 2. */
    #####:  645:  if (ECMA_IS_VALUE_ERROR (value))
        -:  646:  {
    #####:  647:    return value;
        -:  648:  }
        -:  649:
        -:  650:  /* 3. */
    #####:  651:  if (ecma_is_value_object (value))
        -:  652:  {
        -:  653:    /* 3.a */
    #####:  654:    ecma_value_t is_array = ecma_is_value_array (value);
        -:  655:
        -:  656:#if JERRY_ESNEXT
    #####:  657:    if (ECMA_IS_VALUE_ERROR (is_array))
        -:  658:    {
    #####:  659:      ecma_free_value (value);
    #####:  660:      return is_array;
        -:  661:    }
        -:  662:#endif /* JERRY_ESNEXT */
        -:  663:
    #####:  664:    ecma_object_t *object_p = ecma_get_object_from_value (value);
        -:  665:
        -:  666:    /* 3.c */
    #####:  667:    if (ecma_is_value_true (is_array))
        -:  668:    {
        -:  669:      /* 3.c.ii */
    #####:  670:      ecma_length_t length;
    #####:  671:      ecma_value_t to_len = ecma_op_object_get_length (object_p, &length);
        -:  672:
        -:  673:      /* 3.c.iii */
        -:  674:#if JERRY_BUILTIN_PROXY
    #####:  675:      if (ECMA_IS_VALUE_ERROR (to_len))
        -:  676:      {
    #####:  677:        ecma_deref_object (object_p);
    #####:  678:        return to_len;
        -:  679:      }
        -:  680:#endif /* JERRY_BUILTIN_PROXY */
    #####:  681:      JERRY_ASSERT (ecma_is_value_empty (to_len));
        -:  682:
        -:  683:      /* 3.c.iv */
    #####:  684:      for (ecma_length_t i = 0; i < length; i++)
        -:  685:      {
    #####:  686:        ecma_string_t *prop_index = ecma_new_ecma_string_from_length (i);
    #####:  687:        ecma_value_t result = ecma_builtin_json_internalize_process_property (reviver_p, object_p, prop_index);
        -:  688:
    #####:  689:        ecma_deref_ecma_string (prop_index);
        -:  690:
    #####:  691:        if (ECMA_IS_VALUE_ERROR (result))
        -:  692:        {
    #####:  693:          ecma_deref_object (object_p);
    #####:  694:          return result;
        -:  695:        }
        -:  696:
    #####:  697:        JERRY_ASSERT (result == ECMA_VALUE_TRUE);
        -:  698:      }
        -:  699:    }
        -:  700:    /* 3.d */
        -:  701:    else
        -:  702:    {
    #####:  703:      ecma_collection_t *props_p =
        -:  704:        ecma_op_object_get_enumerable_property_names (object_p, ECMA_ENUMERABLE_PROPERTY_KEYS);
        -:  705:#if JERRY_ESNEXT
    #####:  706:      if (JERRY_UNLIKELY (props_p == NULL))
        -:  707:      {
    #####:  708:        ecma_deref_object (object_p);
    #####:  709:        return ECMA_VALUE_ERROR;
        -:  710:      }
        -:  711:#else /* !JERRY_ESNEXT */
        -:  712:      JERRY_ASSERT (props_p != NULL);
        -:  713:#endif /* JERRY_ESNEXT */
        -:  714:
    #####:  715:      ecma_value_t *buffer_p = props_p->buffer_p;
        -:  716:
        -:  717:      /* 3.d.iii */
    #####:  718:      for (uint32_t i = 0; i < props_p->item_count; i++)
        -:  719:      {
    #####:  720:        ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
    #####:  721:        ecma_value_t result = ecma_builtin_json_internalize_process_property (reviver_p, object_p, property_name_p);
        -:  722:
    #####:  723:        if (ECMA_IS_VALUE_ERROR (result))
        -:  724:        {
    #####:  725:          ecma_collection_free (props_p);
    #####:  726:          ecma_deref_object (object_p);
    #####:  727:          return result;
        -:  728:        }
        -:  729:
    #####:  730:        JERRY_ASSERT (result == ECMA_VALUE_TRUE);
        -:  731:      }
        -:  732:
    #####:  733:      ecma_collection_free (props_p);
        -:  734:    }
        -:  735:  }
        -:  736:
    #####:  737:  ecma_value_t arguments_list[2];
    #####:  738:  arguments_list[0] = ecma_make_string_value (name_p);
    #####:  739:  arguments_list[1] = value;
        -:  740:
        -:  741:  /* 4. */
    #####:  742:  ecma_value_t ret_value = ecma_op_function_call (reviver_p, ecma_make_object_value (holder_p), arguments_list, 2);
    #####:  743:  ecma_free_value (value);
    #####:  744:  return ret_value;
        -:  745:} /* ecma_builtin_json_internalize_property */
        -:  746:
        -:  747:/**
        -:  748: * Part of the InternalizeJSONProperty abstract method.
        -:  749: *
        -:  750: * See also:
        -:  751: *         ECMA-262 v5, 15.12.2
        -:  752: *         ECMA-262 v11, 24.5.1.1 in step 2
        -:  753: *
        -:  754: * @return ECMA_VALUE_TRUE - if no error occurred.
        -:  755: *         error if one of the operation failed.
        -:  756: */
        -:  757:static ecma_value_t
    #####:  758:ecma_builtin_json_internalize_process_property (ecma_object_t *reviver_p, /**< reviver function */
        -:  759:                                                ecma_object_t *object_p, /**< holder object */
        -:  760:                                                ecma_string_t *prop_name) /**< property name */
        -:  761:{
        -:  762:  /* ES11: 2.b.iii.1 / 2.c.ii.1 */
    #####:  763:  ecma_value_t new_element = ecma_builtin_json_internalize_property (reviver_p, object_p, prop_name);
        -:  764:
    #####:  765:  if (ECMA_IS_VALUE_ERROR (new_element))
        -:  766:  {
    #####:  767:    return new_element;
        -:  768:  }
        -:  769:
        -:  770:  /* ES11: 2.b.iii.2 / 2.c.ii.2 */
    #####:  771:  if (ecma_is_value_undefined (new_element))
        -:  772:  {
        -:  773:    /* ES11: 2.b.iii.2.a / 2.c.ii.2.a */
    #####:  774:    ecma_value_t delete_val = ecma_op_object_delete (object_p, prop_name, false);
        -:  775:
        -:  776:#if JERRY_ESNEXT
    #####:  777:    if (ECMA_IS_VALUE_ERROR (delete_val))
        -:  778:    {
    #####:  779:      return delete_val;
        -:  780:    }
        -:  781:#endif /* JERRY_ESNEXT */
        -:  782:
    #####:  783:    JERRY_ASSERT (ecma_is_value_boolean (delete_val));
        -:  784:  }
        -:  785:  else
        -:  786:  {
        -:  787:    /* ES11: 2.b.iii.3.a / 2.c.ii.3.a */
    #####:  788:    ecma_value_t def_value =
        -:  789:      ecma_builtin_helper_def_prop (object_p, prop_name, new_element, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  790:    ecma_free_value (new_element);
        -:  791:
        -:  792:#if JERRY_ESNEXT
    #####:  793:    if (ECMA_IS_VALUE_ERROR (def_value))
        -:  794:    {
    #####:  795:      return def_value;
        -:  796:    }
        -:  797:#endif /* JERRY_ESNEXT */
        -:  798:
    #####:  799:    JERRY_ASSERT (ecma_is_value_boolean (def_value));
        -:  800:  }
        -:  801:
    #####:  802:  return ECMA_VALUE_TRUE;
        -:  803:} /* ecma_builtin_json_internalize_process_property */
        -:  804:
        -:  805:/**
        -:  806: * Function to set a string token from the given arguments, fills its fields and advances the string pointer.
        -:  807: *
        -:  808: * @return ecma_value_t containing an object or an error massage
        -:  809: *         Returned value must be freed with ecma_free_value.
        -:  810: */
        -:  811:ecma_value_t
    #####:  812:ecma_builtin_json_parse_buffer (const lit_utf8_byte_t *str_start_p, /**< String to parse */
        -:  813:                                lit_utf8_size_t string_size) /**< size of the string */
        -:  814:{
    #####:  815:  ecma_json_token_t token;
    #####:  816:  token.current_p = str_start_p;
    #####:  817:  token.end_p = str_start_p + string_size;
        -:  818:
    #####:  819:  ecma_builtin_json_parse_next_token (&token, true);
    #####:  820:  ecma_value_t result = ecma_builtin_json_parse_value (&token);
        -:  821:
    #####:  822:  if (!ecma_is_value_empty (result))
        -:  823:  {
    #####:  824:    ecma_builtin_json_parse_next_token (&token, false);
    #####:  825:    if (token.type == TOKEN_END)
        -:  826:    {
    #####:  827:      return result;
        -:  828:    }
        -:  829:
    #####:  830:    ecma_free_value (result);
        -:  831:  }
        -:  832:
    #####:  833:  return ecma_raise_syntax_error (ECMA_ERR_INVALID_JSON_FORMAT);
        -:  834:} /* ecma_builtin_json_parse_buffer */
        -:  835:
        -:  836:/**
        -:  837: * The JSON object's 'parse' routine
        -:  838: *
        -:  839: * See also:
        -:  840: *          ECMA-262 v5, 15.12.2
        -:  841: *
        -:  842: * @return ecma value
        -:  843: *         Returned value must be freed with ecma_free_value.
        -:  844: */
        -:  845:static ecma_value_t
    #####:  846:ecma_builtin_json_parse (ecma_value_t arg1, /**< string argument */
        -:  847:                         ecma_value_t arg2) /**< reviver argument */
        -:  848:{
    #####:  849:  ecma_string_t *text_string_p = ecma_op_to_string (arg1);
        -:  850:
    #####:  851:  if (JERRY_UNLIKELY (text_string_p == NULL))
        -:  852:  {
    #####:  853:    return ECMA_VALUE_ERROR;
        -:  854:  }
        -:  855:
    #####:  856:  ECMA_STRING_TO_UTF8_STRING (text_string_p, str_start_p, string_size);
    #####:  857:  ecma_value_t result = ecma_builtin_json_parse_buffer (str_start_p, string_size);
    #####:  858:  ECMA_FINALIZE_UTF8_STRING (str_start_p, string_size);
    #####:  859:  ecma_deref_ecma_string (text_string_p);
        -:  860:
    #####:  861:  if (!ECMA_IS_VALUE_ERROR (result) && ecma_op_is_callable (arg2))
        -:  862:  {
    #####:  863:    ecma_object_t *object_p = ecma_op_create_object_object_noarg ();
        -:  864:
        -:  865:    ecma_property_value_t *prop_value_p;
    #####:  866:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  867:                                                    ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY),
        -:  868:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  869:                                                    NULL);
        -:  870:
    #####:  871:    ecma_named_data_property_assign_value (object_p, prop_value_p, result);
        -:  872:
    #####:  873:    ecma_free_value (result);
    #####:  874:    result = ecma_builtin_json_internalize_property (ecma_get_object_from_value (arg2),
        -:  875:                                                     object_p,
        -:  876:                                                     ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY));
    #####:  877:    ecma_deref_object (object_p);
        -:  878:  }
        -:  879:
    #####:  880:  return result;
        -:  881:} /* ecma_builtin_json_parse */
        -:  882:
        -:  883:/**
        -:  884: * Abstract operation 'QuoteJSONString' defined in 24.3.2.2
        -:  885: */
        -:  886:static void
    #####:  887:ecma_builtin_json_quote (ecma_stringbuilder_t *builder_p, /**< builder for the result */
        -:  888:                         ecma_string_t *string_p) /**< string that should be quoted */
        -:  889:{
    #####:  890:  ECMA_STRING_TO_UTF8_STRING (string_p, string_buff, string_buff_size);
    #####:  891:  const lit_utf8_byte_t *str_p = string_buff;
    #####:  892:  const lit_utf8_byte_t *regular_str_start_p = string_buff;
    #####:  893:  const lit_utf8_byte_t *str_end_p = str_p + string_buff_size;
        -:  894:
    #####:  895:  ecma_stringbuilder_append_byte (builder_p, LIT_CHAR_DOUBLE_QUOTE);
        -:  896:
    #####:  897:  while (str_p < str_end_p)
        -:  898:  {
    #####:  899:    ecma_char_t c = lit_cesu8_read_next (&str_p);
        -:  900:
    #####:  901:    bool should_escape = false;
        -:  902:
        -:  903:#if JERRY_ESNEXT
    #####:  904:    if (lit_is_code_point_utf16_high_surrogate (c))
        -:  905:    {
    #####:  906:      if (str_p < str_end_p)
        -:  907:      {
    #####:  908:        const ecma_char_t next_ch = lit_cesu8_peek_next (str_p);
    #####:  909:        if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  910:        {
    #####:  911:          str_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
    #####:  912:          continue;
        -:  913:        }
    #####:  914:        should_escape = true;
        -:  915:      }
        -:  916:      else
        -:  917:      {
    #####:  918:        should_escape = true;
        -:  919:      }
        -:  920:    }
    #####:  921:    else if (lit_is_code_point_utf16_low_surrogate (c))
        -:  922:    {
    #####:  923:      should_escape = true;
        -:  924:    }
        -:  925:#endif /* JERRY_ESNEXT */
        -:  926:
    #####:  927:    if (c == LIT_CHAR_BACKSLASH || c == LIT_CHAR_DOUBLE_QUOTE)
        -:  928:    {
    #####:  929:      ecma_stringbuilder_append_raw (builder_p,
        -:  930:                                     regular_str_start_p,
    #####:  931:                                     (lit_utf8_size_t) (str_p - regular_str_start_p - 1));
    #####:  932:      regular_str_start_p = str_p;
    #####:  933:      ecma_stringbuilder_append_byte (builder_p, LIT_CHAR_BACKSLASH);
    #####:  934:      ecma_stringbuilder_append_byte (builder_p, (lit_utf8_byte_t) c);
        -:  935:    }
    #####:  936:    else if (c < LIT_CHAR_SP || should_escape)
        -:  937:    {
        -:  938:      /**
        -:  939:       * In ES10 we should escape high or low surrogate characters,
        -:  940:       * so we shouldn't append the unescaped character to the stringbuilder
        -:  941:       */
    #####:  942:      uint8_t offset = should_escape ? LIT_UTF8_MAX_BYTES_IN_CODE_UNIT : 1;
        -:  943:
    #####:  944:      ecma_stringbuilder_append_raw (builder_p,
        -:  945:                                     regular_str_start_p,
    #####:  946:                                     (lit_utf8_size_t) (str_p - regular_str_start_p - offset));
        -:  947:
    #####:  948:      regular_str_start_p = str_p;
        -:  949:
    #####:  950:      switch (c)
        -:  951:      {
    #####:  952:        case LIT_CHAR_BS:
        -:  953:        {
    #####:  954:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\b", 2);
    #####:  955:          break;
        -:  956:        }
    #####:  957:        case LIT_CHAR_FF:
        -:  958:        {
    #####:  959:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\f", 2);
    #####:  960:          break;
        -:  961:        }
    #####:  962:        case LIT_CHAR_LF:
        -:  963:        {
    #####:  964:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\n", 2);
    #####:  965:          break;
        -:  966:        }
    #####:  967:        case LIT_CHAR_CR:
        -:  968:        {
    #####:  969:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\r", 2);
    #####:  970:          break;
        -:  971:        }
    #####:  972:        case LIT_CHAR_TAB:
        -:  973:        {
    #####:  974:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\t", 2);
    #####:  975:          break;
        -:  976:        }
    #####:  977:        default: /* Hexadecimal. */
        -:  978:        {
    #####:  979:          lit_char_unicode_escape (builder_p, c);
    #####:  980:          break;
        -:  981:        }
        -:  982:      }
    #####:  983:    }
        -:  984:  }
        -:  985:
    #####:  986:  ecma_stringbuilder_append_raw (builder_p, regular_str_start_p, (lit_utf8_size_t) (str_end_p - regular_str_start_p));
    #####:  987:  ecma_stringbuilder_append_byte (builder_p, LIT_CHAR_DOUBLE_QUOTE);
        -:  988:
    #####:  989:  ECMA_FINALIZE_UTF8_STRING (string_buff, string_buff_size);
    #####:  990:} /* ecma_builtin_json_quote */
        -:  991:
        -:  992:static ecma_value_t ecma_builtin_json_serialize_property (ecma_json_stringify_context_t *context_p,
        -:  993:                                                          ecma_object_t *holder_p,
        -:  994:                                                          ecma_string_t *key_p);
        -:  995:
        -:  996:/**
        -:  997: * Abstract operation 'SerializeJSONObject' defined in 24.3.2.3
        -:  998: *
        -:  999: * @return ecma value
        -: 1000: *         Returned value must be freed with ecma_free_value.
        -: 1001: */
        -: 1002:static ecma_value_t
    #####: 1003:ecma_builtin_json_serialize_object (ecma_json_stringify_context_t *context_p, /**< context*/
        -: 1004:                                    ecma_object_t *obj_p) /**< the object*/
        -: 1005:{
        -: 1006:  /* 1. */
    #####: 1007:  if (ecma_json_has_object_in_stack (context_p->occurrence_stack_last_p, obj_p))
        -: 1008:  {
    #####: 1009:    return ecma_raise_type_error (ECMA_ERR_THE_STRUCTURE_IS_CYCLICAL);
        -: 1010:  }
        -: 1011:
        -: 1012:  /* 2. */
    #####: 1013:  ecma_json_occurrence_stack_item_t stack_item;
    #####: 1014:  stack_item.next_p = context_p->occurrence_stack_last_p;
    #####: 1015:  stack_item.object_p = obj_p;
    #####: 1016:  context_p->occurrence_stack_last_p = &stack_item;
        -: 1017:
        -: 1018:  /* 3. - 4.*/
    #####: 1019:  const lit_utf8_size_t stepback_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
    #####: 1020:  ecma_stringbuilder_append (&context_p->indent_builder, context_p->gap_str_p);
        -: 1021:
    #####: 1022:  const bool has_gap = !ecma_compare_ecma_string_to_magic_id (context_p->gap_str_p, LIT_MAGIC_STRING__EMPTY);
    #####: 1023:  const lit_utf8_size_t separator_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
        -: 1024:
        -: 1025:  ecma_collection_t *property_keys_p;
        -: 1026:  /* 5. */
    #####: 1027:  if (context_p->property_list_p != NULL)
        -: 1028:  {
    #####: 1029:    property_keys_p = context_p->property_list_p;
        -: 1030:  }
        -: 1031:  /* 6. */
        -: 1032:  else
        -: 1033:  {
    #####: 1034:    property_keys_p = ecma_op_object_get_enumerable_property_names (obj_p, ECMA_ENUMERABLE_PROPERTY_KEYS);
        -: 1035:
        -: 1036:#if JERRY_BUILTIN_PROXY
    #####: 1037:    if (property_keys_p == NULL)
        -: 1038:    {
    #####: 1039:      return ECMA_VALUE_ERROR;
        -: 1040:    }
        -: 1041:#endif /* JERRY_BUILTIN_PROXY */
        -: 1042:  }
        -: 1043:
        -: 1044:  /* 8. */
    #####: 1045:  ecma_value_t *buffer_p = property_keys_p->buffer_p;
        -: 1046:
    #####: 1047:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_LEFT_BRACE);
    #####: 1048:  const lit_utf8_size_t left_brace = ecma_stringbuilder_get_size (&context_p->result_builder);
    #####: 1049:  lit_utf8_size_t last_prop = left_brace;
    #####: 1050:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -: 1051:
    #####: 1052:  for (uint32_t i = 0; i < property_keys_p->item_count; i++)
        -: 1053:  {
    #####: 1054:    if (has_gap)
        -: 1055:    {
    #####: 1056:      ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1057:                                     ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1058:                                     separator_size);
        -: 1059:    }
        -: 1060:
    #####: 1061:    ecma_string_t *key_p = ecma_get_string_from_value (buffer_p[i]);
    #####: 1062:    ecma_builtin_json_quote (&context_p->result_builder, key_p);
    #####: 1063:    ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_COLON);
        -: 1064:
        -: 1065:    /* 8.c.iii */
    #####: 1066:    if (has_gap)
        -: 1067:    {
    #####: 1068:      ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_SP);
        -: 1069:    }
        -: 1070:
    #####: 1071:    result = ecma_builtin_json_serialize_property (context_p, obj_p, key_p);
        -: 1072:
    #####: 1073:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1074:    {
    #####: 1075:      goto cleanup;
        -: 1076:    }
        -: 1077:
        -: 1078:    /* 8.b */
    #####: 1079:    if (!ecma_is_value_undefined (result))
        -: 1080:    {
        -: 1081:      /* ecma_builtin_json_serialize_property already appended the result. */
    #####: 1082:      JERRY_ASSERT (ecma_is_value_empty (result));
        -: 1083:
    #####: 1084:      ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_COMMA);
    #####: 1085:      last_prop = ecma_stringbuilder_get_size (&context_p->result_builder);
        -: 1086:    }
        -: 1087:    else
        -: 1088:    {
        -: 1089:      /* The property should not be appended, we must backtrack. */
    #####: 1090:      ecma_stringbuilder_revert (&context_p->result_builder, last_prop);
        -: 1091:    }
        -: 1092:  }
        -: 1093:
    #####: 1094:  if (last_prop != left_brace)
        -: 1095:  {
        -: 1096:    /* Remove the last comma. */
    #####: 1097:    ecma_stringbuilder_revert (&context_p->result_builder, last_prop - 1);
        -: 1098:
    #####: 1099:    if (has_gap)
        -: 1100:    {
        -: 1101:      /* We appended at least one element, and have a separator, so must append the stepback. */
    #####: 1102:      ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1103:                                     ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1104:                                     stepback_size);
        -: 1105:    }
        -: 1106:  }
        -: 1107:
    #####: 1108:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_RIGHT_BRACE);
    #####: 1109:  result = ECMA_VALUE_EMPTY;
        -: 1110:
        -: 1111:  /* 11. */
    #####: 1112:  context_p->occurrence_stack_last_p = stack_item.next_p;
        -: 1113:
        -: 1114:  /* 12. */
    #####: 1115:  ecma_stringbuilder_revert (&context_p->indent_builder, stepback_size);
        -: 1116:
    #####: 1117:cleanup:
    #####: 1118:  if (context_p->property_list_p == NULL)
        -: 1119:  {
    #####: 1120:    ecma_collection_free (property_keys_p);
        -: 1121:  }
        -: 1122:
    #####: 1123:  return result;
        -: 1124:} /* ecma_builtin_json_serialize_object */
        -: 1125:
        -: 1126:/**
        -: 1127: * Abstract operation 'SerializeJSONArray' defined in 24.3.2.4
        -: 1128: *
        -: 1129: * @return ecma value
        -: 1130: *         Returned value must be freed with ecma_free_value.
        -: 1131: */
        -: 1132:static ecma_value_t
    #####: 1133:ecma_builtin_json_serialize_array (ecma_json_stringify_context_t *context_p, /**< context*/
        -: 1134:                                   ecma_object_t *obj_p) /**< the array object*/
        -: 1135:{
        -: 1136:#ifndef JERRY_NDEBUG
    #####: 1137:  ecma_value_t obj_value = ecma_make_object_value (obj_p);
    #####: 1138:  ecma_value_t is_array = ecma_is_value_array (obj_value);
        -: 1139:
    #####: 1140:  JERRY_ASSERT (ecma_is_value_true (is_array));
        -: 1141:#endif /* !JERRY_NDEBUG */
        -: 1142:
        -: 1143:  /* 1. */
    #####: 1144:  if (ecma_json_has_object_in_stack (context_p->occurrence_stack_last_p, obj_p))
        -: 1145:  {
    #####: 1146:    return ecma_raise_type_error (ECMA_ERR_THE_STRUCTURE_IS_CYCLICAL);
        -: 1147:  }
        -: 1148:
        -: 1149:  /* 2. */
    #####: 1150:  ecma_json_occurrence_stack_item_t stack_item;
    #####: 1151:  stack_item.next_p = context_p->occurrence_stack_last_p;
    #####: 1152:  stack_item.object_p = obj_p;
    #####: 1153:  context_p->occurrence_stack_last_p = &stack_item;
        -: 1154:
        -: 1155:  /* 3. - 4.*/
    #####: 1156:  const lit_utf8_size_t stepback_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
    #####: 1157:  ecma_stringbuilder_append (&context_p->indent_builder, context_p->gap_str_p);
    #####: 1158:  const lit_utf8_size_t separator_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
        -: 1159:
    #####: 1160:  const bool has_gap = !ecma_compare_ecma_string_to_magic_id (context_p->gap_str_p, LIT_MAGIC_STRING__EMPTY);
        -: 1161:
        -: 1162:  /* 6. */
    #####: 1163:  ecma_length_t array_length;
    #####: 1164:  ecma_value_t length_value = ecma_op_object_get_length (obj_p, &array_length);
        -: 1165:
        -: 1166:#if JERRY_BUILTIN_PROXY
    #####: 1167:  if (ECMA_IS_VALUE_ERROR (length_value))
        -: 1168:  {
    #####: 1169:    return length_value;
        -: 1170:  }
        -: 1171:#endif /* JERRY_BUILTIN_PROXY */
    #####: 1172:  JERRY_ASSERT (ecma_is_value_empty (length_value));
        -: 1173:
    #####: 1174:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_LEFT_SQUARE);
        -: 1175:
    #####: 1176:  const lit_utf8_size_t left_square = ecma_stringbuilder_get_size (&context_p->result_builder);
    #####: 1177:  lit_utf8_size_t last_prop = left_square;
        -: 1178:
        -: 1179:  /* 8. - 9. */
    #####: 1180:  for (ecma_length_t index = 0; index < array_length; index++)
        -: 1181:  {
        -: 1182:    /* 9.a */
    #####: 1183:    ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
        -: 1184:
    #####: 1185:    if (has_gap)
        -: 1186:    {
    #####: 1187:      ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1188:                                     ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1189:                                     separator_size);
        -: 1190:    }
        -: 1191:
    #####: 1192:    ecma_value_t result = ecma_builtin_json_serialize_property (context_p, obj_p, index_str_p);
    #####: 1193:    ecma_deref_ecma_string (index_str_p);
        -: 1194:
    #####: 1195:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1196:    {
    #####: 1197:      return result;
        -: 1198:    }
        -: 1199:
    #####: 1200:    if (ecma_is_value_undefined (result))
        -: 1201:    {
        -: 1202:      /* 9.c */
    #####: 1203:      ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_NULL);
        -: 1204:    }
        -: 1205:    else
        -: 1206:    {
    #####: 1207:      JERRY_ASSERT (ecma_is_value_empty (result));
        -: 1208:    }
        -: 1209:
    #####: 1210:    last_prop = ecma_stringbuilder_get_size (&context_p->result_builder);
    #####: 1211:    ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_COMMA);
        -: 1212:  }
        -: 1213:
        -: 1214:  /* Remove the last comma. */
    #####: 1215:  ecma_stringbuilder_revert (&context_p->result_builder, last_prop);
        -: 1216:
        -: 1217:  /* 11.b.iii */
    #####: 1218:  if (last_prop != left_square && has_gap)
        -: 1219:  {
        -: 1220:    /* We appended at least one element, and have a separator, so must append the stepback. */
    #####: 1221:    ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1222:                                   ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1223:                                   stepback_size);
        -: 1224:  }
        -: 1225:
    #####: 1226:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_RIGHT_SQUARE);
        -: 1227:
        -: 1228:  /* 12. */
    #####: 1229:  context_p->occurrence_stack_last_p = stack_item.next_p;
        -: 1230:
        -: 1231:  /* 13. */
    #####: 1232:  ecma_stringbuilder_revert (&context_p->indent_builder, stepback_size);
        -: 1233:
    #####: 1234:  return ECMA_VALUE_EMPTY;
        -: 1235:} /* ecma_builtin_json_serialize_array */
        -: 1236:
        -: 1237:/**
        -: 1238: * Abstract operation 'SerializeJSONProperty' defined in 24.3.2.1
        -: 1239: *
        -: 1240: * @return ecma value
        -: 1241: *         Returned value must be freed with ecma_free_value.
        -: 1242: */
        -: 1243:static ecma_value_t
    #####: 1244:ecma_builtin_json_serialize_property (ecma_json_stringify_context_t *context_p, /**< context*/
        -: 1245:                                      ecma_object_t *holder_p, /**< the object*/
        -: 1246:                                      ecma_string_t *key_p) /**< property key*/
        -: 1247:{
        -: 1248:  /* 1. */
    #####: 1249:  ecma_value_t value = ecma_op_object_get (holder_p, key_p);
        -: 1250:
        -: 1251:  /* 2. */
    #####: 1252:  if (ECMA_IS_VALUE_ERROR (value))
        -: 1253:  {
    #####: 1254:    return value;
        -: 1255:  }
        -: 1256:
        -: 1257:  /* 3. */
    #####: 1258:  if (ecma_is_value_object (value) || ecma_is_value_bigint (value))
        -: 1259:  {
    #####: 1260:    ecma_value_t to_object_value = ecma_op_to_object (value);
        -: 1261:
    #####: 1262:    if (ECMA_IS_VALUE_ERROR (to_object_value))
        -: 1263:    {
    #####: 1264:      ecma_free_value (value);
    #####: 1265:      return to_object_value;
        -: 1266:    }
        -: 1267:
    #####: 1268:    ecma_object_t *value_obj_p = ecma_get_object_from_value (to_object_value);
    #####: 1269:    ecma_value_t to_json =
    #####: 1270:      ecma_op_object_get_with_receiver (value_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_TO_JSON_UL), value);
        -: 1271:
    #####: 1272:    ecma_deref_object (value_obj_p);
        -: 1273:
    #####: 1274:    if (ECMA_IS_VALUE_ERROR (to_json))
        -: 1275:    {
    #####: 1276:      ecma_free_value (value);
    #####: 1277:      return to_json;
        -: 1278:    }
        -: 1279:
        -: 1280:    /* 3.c */
    #####: 1281:    if (ecma_op_is_callable (to_json))
        -: 1282:    {
    #####: 1283:      ecma_value_t key_value = ecma_make_string_value (key_p);
    #####: 1284:      ecma_value_t call_args[] = { key_value };
    #####: 1285:      ecma_object_t *to_json_obj_p = ecma_get_object_from_value (to_json);
        -: 1286:
    #####: 1287:      ecma_value_t result = ecma_op_function_call (to_json_obj_p, value, call_args, 1);
    #####: 1288:      ecma_free_value (value);
        -: 1289:
    #####: 1290:      if (ECMA_IS_VALUE_ERROR (result))
        -: 1291:      {
    #####: 1292:        ecma_deref_object (to_json_obj_p);
    #####: 1293:        return result;
        -: 1294:      }
    #####: 1295:      value = result;
        -: 1296:    }
    #####: 1297:    ecma_free_value (to_json);
        -: 1298:  }
        -: 1299:
        -: 1300:  /* 4. */
    #####: 1301:  if (context_p->replacer_function_p)
        -: 1302:  {
    #####: 1303:    ecma_value_t holder_value = ecma_make_object_value (holder_p);
    #####: 1304:    ecma_value_t key_value = ecma_make_string_value (key_p);
    #####: 1305:    ecma_value_t call_args[] = { key_value, value };
        -: 1306:
    #####: 1307:    ecma_value_t result = ecma_op_function_call (context_p->replacer_function_p, holder_value, call_args, 2);
    #####: 1308:    ecma_free_value (value);
        -: 1309:
    #####: 1310:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1311:    {
    #####: 1312:      return result;
        -: 1313:    }
        -: 1314:
    #####: 1315:    value = result;
        -: 1316:  }
        -: 1317:
        -: 1318:  /* 5. */
    #####: 1319:  if (ecma_is_value_object (value))
        -: 1320:  {
    #####: 1321:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1322:
    #####: 1323:    if (ecma_get_object_base_type (obj_p) == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1324:    {
    #####: 1325:      switch (((ecma_extended_object_t *) obj_p)->u.cls.type)
        -: 1326:      {
        -: 1327:        /* 5.a */
    #####: 1328:        case ECMA_OBJECT_CLASS_NUMBER:
        -: 1329:        {
    #####: 1330:          ecma_number_t num;
    #####: 1331:          value = ecma_op_to_number (value, &num);
    #####: 1332:          ecma_deref_object (obj_p);
        -: 1333:
    #####: 1334:          if (ECMA_IS_VALUE_ERROR (value))
        -: 1335:          {
    #####: 1336:            return value;
        -: 1337:          }
        -: 1338:
    #####: 1339:          value = ecma_make_number_value (num);
    #####: 1340:          break;
        -: 1341:        }
        -: 1342:        /* 5.b */
    #####: 1343:        case ECMA_OBJECT_CLASS_STRING:
        -: 1344:        {
    #####: 1345:          ecma_string_t *str_p = ecma_op_to_string (value);
    #####: 1346:          ecma_deref_object (obj_p);
        -: 1347:
    #####: 1348:          if (JERRY_UNLIKELY (str_p == NULL))
        -: 1349:          {
    #####: 1350:            return ECMA_VALUE_ERROR;
        -: 1351:          }
        -: 1352:
    #####: 1353:          value = ecma_make_string_value (str_p);
    #####: 1354:          break;
        -: 1355:        }
        -: 1356:        /* 5.c */
    #####: 1357:        case ECMA_OBJECT_CLASS_BOOLEAN:
        -: 1358:        {
    #####: 1359:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
    #####: 1360:          value = ext_object_p->u.cls.u3.value;
    #####: 1361:          ecma_deref_object (obj_p);
    #####: 1362:          break;
        -: 1363:        }
        -: 1364:#if JERRY_BUILTIN_BIGINT
        -: 1365:        /* 5.d */
    #####: 1366:        case ECMA_OBJECT_CLASS_BIGINT:
        -: 1367:        {
    #####: 1368:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
    #####: 1369:          value = ecma_copy_value (ext_object_p->u.cls.u3.value);
    #####: 1370:          ecma_deref_object (obj_p);
    #####: 1371:          break;
        -: 1372:        }
        -: 1373:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1374:      }
        -: 1375:    }
        -: 1376:  }
        -: 1377:
        -: 1378:  /* 6. - 8. */
    #####: 1379:  if (ecma_is_value_null (value))
        -: 1380:  {
    #####: 1381:    ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_NULL);
    #####: 1382:    return ECMA_VALUE_EMPTY;
        -: 1383:  }
        -: 1384:
    #####: 1385:  if (ecma_is_value_true (value))
        -: 1386:  {
    #####: 1387:    ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_TRUE);
    #####: 1388:    return ECMA_VALUE_EMPTY;
        -: 1389:  }
        -: 1390:
    #####: 1391:  if (ecma_is_value_false (value))
        -: 1392:  {
    #####: 1393:    ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_FALSE);
    #####: 1394:    return ECMA_VALUE_EMPTY;
        -: 1395:  }
        -: 1396:
        -: 1397:  /* 9. */
    #####: 1398:  if (ecma_is_value_string (value))
        -: 1399:  {
    #####: 1400:    ecma_string_t *value_str_p = ecma_get_string_from_value (value);
        -: 1401:    /* Quote will append the result. */
    #####: 1402:    ecma_builtin_json_quote (&context_p->result_builder, value_str_p);
    #####: 1403:    ecma_deref_ecma_string (value_str_p);
        -: 1404:
    #####: 1405:    return ECMA_VALUE_EMPTY;
        -: 1406:  }
        -: 1407:
        -: 1408:  /* 10. */
    #####: 1409:  if (ecma_is_value_number (value))
        -: 1410:  {
    #####: 1411:    ecma_number_t num_value = ecma_get_number_from_value (value);
        -: 1412:
        -: 1413:    /* 10.a */
    #####: 1414:    if (!ecma_number_is_nan (num_value) && !ecma_number_is_infinity (num_value))
    #####: 1415:    {
    #####: 1416:      ecma_string_t *result_string_p = ecma_op_to_string (value);
    #####: 1417:      JERRY_ASSERT (result_string_p != NULL);
        -: 1418:
    #####: 1419:      ecma_stringbuilder_append (&context_p->result_builder, result_string_p);
    #####: 1420:      ecma_deref_ecma_string (result_string_p);
        -: 1421:    }
        -: 1422:    else
        -: 1423:    {
        -: 1424:      /* 10.b */
    #####: 1425:      ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_NULL);
        -: 1426:    }
        -: 1427:
    #####: 1428:    ecma_free_value (value);
    #####: 1429:    return ECMA_VALUE_EMPTY;
        -: 1430:  }
        -: 1431:
        -: 1432:#if JERRY_BUILTIN_BIGINT
    #####: 1433:  if (ecma_is_value_bigint (value))
        -: 1434:  {
    #####: 1435:    ecma_free_value (value);
    #####: 1436:    return ecma_raise_type_error (ECMA_ERR_BIGINT_SERIALIZED);
        -: 1437:  }
        -: 1438:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1439:
        -: 1440:  /* 11. */
    #####: 1441:  if (ecma_is_value_object (value) && !ecma_op_is_callable (value))
        -: 1442:  {
    #####: 1443:    ecma_value_t is_array = ecma_is_value_array (value);
        -: 1444:
        -: 1445:#if JERRY_BUILTIN_BIGINT
    #####: 1446:    if (ECMA_IS_VALUE_ERROR (is_array))
        -: 1447:    {
    #####: 1448:      ecma_free_value (value);
    #####: 1449:      return is_array;
        -: 1450:    }
        -: 1451:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1452:
    #####: 1453:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1454:
        -: 1455:    ecma_value_t ret_value;
        -: 1456:    /* 10.a */
    #####: 1457:    if (ecma_is_value_true (is_array))
        -: 1458:    {
    #####: 1459:      ret_value = ecma_builtin_json_serialize_array (context_p, obj_p);
        -: 1460:    }
        -: 1461:    /* 10.b */
        -: 1462:    else
        -: 1463:    {
    #####: 1464:      ret_value = ecma_builtin_json_serialize_object (context_p, obj_p);
        -: 1465:    }
        -: 1466:
    #####: 1467:    ecma_deref_object (obj_p);
    #####: 1468:    return ret_value;
        -: 1469:  }
        -: 1470:
        -: 1471:  /* 12. */
    #####: 1472:  ecma_free_value (value);
    #####: 1473:  return ECMA_VALUE_UNDEFINED;
        -: 1474:} /* ecma_builtin_json_serialize_property */
        -: 1475:
        -: 1476:/**
        -: 1477: * Helper function to stringify an object in JSON format representing an ecma_value.
        -: 1478: *
        -: 1479: *  @return ecma_value_t string created from an abject formating by a given context
        -: 1480: *          Returned value must be freed with ecma_free_value.
        -: 1481: *
        -: 1482: */
        -: 1483:static ecma_value_t
    #####: 1484:ecma_builtin_json_str_helper (ecma_json_stringify_context_t *context_p, /**< context argument */
        -: 1485:                              const ecma_value_t arg1) /**< object argument */
        -: 1486:{
    #####: 1487:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####: 1488:  ecma_object_t *obj_wrapper_p = ecma_op_create_object_object_noarg ();
    #####: 1489:  ecma_string_t *empty_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
    #####: 1490:  ecma_value_t put_comp_val =
        -: 1491:    ecma_builtin_helper_def_prop (obj_wrapper_p, empty_str_p, arg1, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 1492:
    #####: 1493:  JERRY_ASSERT (ecma_is_value_true (put_comp_val));
        -: 1494:
    #####: 1495:  context_p->result_builder = ecma_stringbuilder_create ();
        -: 1496:
    #####: 1497:  if (!ecma_compare_ecma_string_to_magic_id (context_p->gap_str_p, LIT_MAGIC_STRING__EMPTY))
        -: 1498:  {
    #####: 1499:    ecma_stringbuilder_append_byte (&context_p->indent_builder, LIT_CHAR_LF);
        -: 1500:  }
        -: 1501:
    #####: 1502:  ret_value = ecma_builtin_json_serialize_property (context_p, obj_wrapper_p, empty_str_p);
    #####: 1503:  ecma_deref_object (obj_wrapper_p);
        -: 1504:
    #####: 1505:  if (ECMA_IS_VALUE_ERROR (ret_value) || ecma_is_value_undefined (ret_value))
        -: 1506:  {
    #####: 1507:    ecma_stringbuilder_destroy (&context_p->result_builder);
    #####: 1508:    return ret_value;
        -: 1509:  }
        -: 1510:
    #####: 1511:  return ecma_make_string_value (ecma_stringbuilder_finalize (&context_p->result_builder));
        -: 1512:} /* ecma_builtin_json_str_helper */
        -: 1513:
        -: 1514:/**
        -: 1515: * Function to create a JSON string from a JS value.
        -: 1516: *
        -: 1517: * Note:
        -: 1518: *      The returned value must be freed with ecma_free_value.
        -: 1519: *
        -: 1520: * @return - ecma_value_t containing a json string.
        -: 1521: *         - Error value in case of any errors.
        -: 1522: */
        -: 1523:ecma_value_t
    #####: 1524:ecma_builtin_json_stringify_no_opts (const ecma_value_t value) /**< value to stringify */
        -: 1525:{
    #####: 1526:  ecma_json_stringify_context_t context;
    #####: 1527:  context.occurrence_stack_last_p = NULL;
    #####: 1528:  context.indent_builder = ecma_stringbuilder_create ();
    #####: 1529:  context.property_list_p = NULL;
    #####: 1530:  context.replacer_function_p = NULL;
    #####: 1531:  context.gap_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 1532:
    #####: 1533:  ecma_value_t ret_value = ecma_builtin_json_str_helper (&context, value);
        -: 1534:
    #####: 1535:  ecma_deref_ecma_string (context.gap_str_p);
    #####: 1536:  ecma_stringbuilder_destroy (&context.indent_builder);
    #####: 1537:  return ret_value;
        -: 1538:} /* ecma_builtin_json_stringify_no_opts */
        -: 1539:
        -: 1540:/**
        -: 1541: * The JSON object's 'stringify' routine
        -: 1542: *
        -: 1543: * See also:
        -: 1544: *          ECMA-262 v5, 15.12.3
        -: 1545: *          ECMA-262 v11, 24.5.2
        -: 1546: *
        -: 1547: * @return ecma value
        -: 1548: *         Returned value must be freed with ecma_free_value.
        -: 1549: */
        -: 1550:static ecma_value_t
    #####: 1551:ecma_builtin_json_stringify (ecma_value_t arg1, /**< value */
        -: 1552:                             ecma_value_t arg2, /**< replacer */
        -: 1553:                             ecma_value_t arg3) /**< space */
        -: 1554:{
    #####: 1555:  ecma_json_stringify_context_t context;
    #####: 1556:  context.replacer_function_p = NULL;
    #####: 1557:  context.property_list_p = NULL;
        -: 1558:
        -: 1559:  /* 4. */
    #####: 1560:  if (ecma_is_value_object (arg2))
        -: 1561:  {
    #####: 1562:    ecma_object_t *obj_p = ecma_get_object_from_value (arg2);
        -: 1563:
        -: 1564:    /* 4.a */
    #####: 1565:    if (ecma_op_is_callable (arg2))
        -: 1566:    {
    #####: 1567:      context.replacer_function_p = obj_p;
        -: 1568:    }
        -: 1569:    /* 4.b */
        -: 1570:    else
        -: 1571:    {
    #####: 1572:      ecma_value_t is_array = ecma_is_value_array (arg2);
        -: 1573:
        -: 1574:#if JERRY_ESNEXT
    #####: 1575:      if (ECMA_IS_VALUE_ERROR (is_array))
        -: 1576:      {
    #####: 1577:        return is_array;
        -: 1578:      }
        -: 1579:#endif /* JERRY_ESNEXT */
        -: 1580:
    #####: 1581:      if (ecma_is_value_true (is_array))
        -: 1582:      {
    #####: 1583:        ecma_length_t array_length;
    #####: 1584:        ecma_value_t to_len = ecma_op_object_get_length (obj_p, &array_length);
        -: 1585:
        -: 1586:#if JERRY_BUILTIN_PROXY
    #####: 1587:        if (ECMA_IS_VALUE_ERROR (to_len))
        -: 1588:        {
    #####: 1589:          return to_len;
        -: 1590:        }
        -: 1591:#endif /* JERRY_BUILTIN_PROXY */
    #####: 1592:        JERRY_ASSERT (ecma_is_value_empty (to_len));
        -: 1593:
    #####: 1594:        context.property_list_p = ecma_new_collection ();
        -: 1595:
    #####: 1596:        uint32_t index = 0;
        -: 1597:
        -: 1598:        /* 4.b.iii.5 */
    #####: 1599:        while (index < array_length)
        -: 1600:        {
    #####: 1601:          ecma_value_t value = ecma_op_object_get_by_index (obj_p, index);
        -: 1602:
    #####: 1603:          if (ECMA_IS_VALUE_ERROR (value))
        -: 1604:          {
    #####: 1605:            ecma_collection_free (context.property_list_p);
    #####: 1606:            return value;
        -: 1607:          }
        -: 1608:
        -: 1609:          /* 4.b.iii.5.c */
    #####: 1610:          ecma_value_t item = ECMA_VALUE_UNDEFINED;
        -: 1611:
        -: 1612:          /* 4.b.iii.5.d */
    #####: 1613:          if (ecma_is_value_string (value))
        -: 1614:          {
    #####: 1615:            ecma_ref_ecma_string (ecma_get_string_from_value (value));
    #####: 1616:            item = value;
        -: 1617:          }
        -: 1618:          /* 4.b.iii.5.e */
    #####: 1619:          else if (ecma_is_value_number (value))
        -: 1620:          {
    #####: 1621:            ecma_string_t *number_str_p = ecma_op_to_string (value);
    #####: 1622:            JERRY_ASSERT (number_str_p != NULL);
    #####: 1623:            item = ecma_make_string_value (number_str_p);
        -: 1624:          }
        -: 1625:          /* 4.b.iii.5.f */
    #####: 1626:          else if (ecma_is_value_object (value))
        -: 1627:          {
    #####: 1628:            ecma_object_t *value_obj_p = ecma_get_object_from_value (value);
        -: 1629:
    #####: 1630:            if (ecma_get_object_base_type (value_obj_p) == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1631:            {
    #####: 1632:              uint8_t class_type = ((ecma_extended_object_t *) value_obj_p)->u.cls.type;
        -: 1633:
    #####: 1634:              if (class_type == ECMA_OBJECT_CLASS_NUMBER || class_type == ECMA_OBJECT_CLASS_STRING)
        -: 1635:              {
    #####: 1636:                ecma_string_t *str_p = ecma_op_to_string (value);
        -: 1637:
    #####: 1638:                if (JERRY_UNLIKELY (str_p == NULL))
        -: 1639:                {
    #####: 1640:                  ecma_collection_free (context.property_list_p);
    #####: 1641:                  ecma_free_value (value);
    #####: 1642:                  return ECMA_VALUE_ERROR;
        -: 1643:                }
        -: 1644:
    #####: 1645:                item = ecma_make_string_value (str_p);
        -: 1646:              }
        -: 1647:            }
        -: 1648:          }
        -: 1649:
    #####: 1650:          ecma_free_value (value);
        -: 1651:
        -: 1652:          /* 4.b.iii.5.g */
    #####: 1653:          if (!ecma_is_value_undefined (item))
        -: 1654:          {
    #####: 1655:            JERRY_ASSERT (ecma_is_value_string (item));
    #####: 1656:            ecma_string_t *string_p = ecma_get_string_from_value (item);
        -: 1657:
    #####: 1658:            if (!ecma_collection_has_string_value (context.property_list_p, string_p))
        -: 1659:            {
    #####: 1660:              ecma_collection_push_back (context.property_list_p, item);
        -: 1661:            }
        -: 1662:            else
        -: 1663:            {
    #####: 1664:              ecma_deref_ecma_string (string_p);
        -: 1665:            }
        -: 1666:          }
        -: 1667:
    #####: 1668:          index++;
        -: 1669:        }
        -: 1670:      }
        -: 1671:    }
        -: 1672:  }
        -: 1673:
    #####: 1674:  ecma_value_t space = ECMA_VALUE_EMPTY;
        -: 1675:
        -: 1676:  /* 5. */
    #####: 1677:  if (ecma_is_value_object (arg3))
        -: 1678:  {
    #####: 1679:    ecma_object_t *obj_p = ecma_get_object_from_value (arg3);
        -: 1680:
    #####: 1681:    if (ecma_get_object_base_type (obj_p) == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1682:    {
    #####: 1683:      uint8_t class_type = ((ecma_extended_object_t *) obj_p)->u.cls.type;
        -: 1684:
        -: 1685:      /* 5.a */
    #####: 1686:      if (class_type == ECMA_OBJECT_CLASS_NUMBER)
        -: 1687:      {
    #####: 1688:        ecma_number_t num;
    #####: 1689:        ecma_value_t value = ecma_op_to_number (arg3, &num);
        -: 1690:
    #####: 1691:        if (ECMA_IS_VALUE_ERROR (value))
        -: 1692:        {
    #####: 1693:          if (context.property_list_p != NULL)
        -: 1694:          {
    #####: 1695:            ecma_collection_free (context.property_list_p);
        -: 1696:          }
    #####: 1697:          return value;
        -: 1698:        }
        -: 1699:
    #####: 1700:        space = ecma_make_number_value (num);
        -: 1701:      }
        -: 1702:      /* 5.b */
    #####: 1703:      else if (class_type == ECMA_OBJECT_CLASS_STRING)
        -: 1704:      {
    #####: 1705:        ecma_string_t *value_str_p = ecma_op_to_string (arg3);
        -: 1706:
    #####: 1707:        if (JERRY_UNLIKELY (value_str_p == NULL))
        -: 1708:        {
    #####: 1709:          if (context.property_list_p != NULL)
        -: 1710:          {
    #####: 1711:            ecma_collection_free (context.property_list_p);
        -: 1712:          }
    #####: 1713:          return ECMA_VALUE_ERROR;
        -: 1714:        }
        -: 1715:
    #####: 1716:        space = ecma_make_string_value (value_str_p);
        -: 1717:      }
        -: 1718:    }
        -: 1719:  }
        -: 1720:
    #####: 1721:  if (space == ECMA_VALUE_EMPTY)
        -: 1722:  {
    #####: 1723:    space = ecma_copy_value (arg3);
        -: 1724:  }
        -: 1725:
        -: 1726:  /* 6. */
    #####: 1727:  if (ecma_is_value_number (space))
        -: 1728:  {
        -: 1729:    /* 6.a */
    #####: 1730:    ecma_number_t num_of_spaces;
    #####: 1731:    ecma_op_to_integer (space, &num_of_spaces);
        -: 1732:
    #####: 1733:    num_of_spaces = JERRY_MIN (10, num_of_spaces);
        -: 1734:
        -: 1735:    /* 6.b */
    #####: 1736:    if (num_of_spaces < 1)
        -: 1737:    {
    #####: 1738:      context.gap_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 1739:    }
        -: 1740:    else
        -: 1741:    {
    #####: 1742:      JMEM_DEFINE_LOCAL_ARRAY (space_buff, num_of_spaces, char);
        -: 1743:
    #####: 1744:      memset (space_buff, LIT_CHAR_SP, (size_t) num_of_spaces);
    #####: 1745:      context.gap_str_p =
    #####: 1746:        ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) space_buff, (lit_utf8_size_t) num_of_spaces);
        -: 1747:
    #####: 1748:      JMEM_FINALIZE_LOCAL_ARRAY (space_buff);
        -: 1749:    }
        -: 1750:  }
        -: 1751:  /* 7. */
    #####: 1752:  else if (ecma_is_value_string (space))
        -: 1753:  {
    #####: 1754:    ecma_string_t *space_str_p = ecma_get_string_from_value (space);
    #####: 1755:    lit_utf8_size_t num_of_chars = ecma_string_get_length (space_str_p);
        -: 1756:
    #####: 1757:    if (num_of_chars < 10)
        -: 1758:    {
    #####: 1759:      ecma_ref_ecma_string (space_str_p);
    #####: 1760:      context.gap_str_p = space_str_p;
        -: 1761:    }
        -: 1762:    else
        -: 1763:    {
    #####: 1764:      context.gap_str_p = ecma_string_substr (space_str_p, 0, 10);
        -: 1765:    }
        -: 1766:  }
        -: 1767:  /* 8. */
        -: 1768:  else
        -: 1769:  {
    #####: 1770:    context.gap_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 1771:  }
        -: 1772:
    #####: 1773:  ecma_free_value (space);
        -: 1774:
        -: 1775:  /* 1., 2., 3. */
    #####: 1776:  context.occurrence_stack_last_p = NULL;
    #####: 1777:  context.indent_builder = ecma_stringbuilder_create ();
        -: 1778:
        -: 1779:  /* 9. */
    #####: 1780:  ecma_value_t ret_value = ecma_builtin_json_str_helper (&context, arg1);
        -: 1781:
    #####: 1782:  ecma_deref_ecma_string (context.gap_str_p);
    #####: 1783:  ecma_stringbuilder_destroy (&context.indent_builder);
        -: 1784:
    #####: 1785:  if (context.property_list_p != NULL)
        -: 1786:  {
    #####: 1787:    ecma_collection_free (context.property_list_p);
        -: 1788:  }
        -: 1789:
    #####: 1790:  return ret_value;
        -: 1791:} /* ecma_builtin_json_stringify */
        -: 1792:
        -: 1793:/**
        -: 1794: * Dispatcher of the built-in's routines
        -: 1795: *
        -: 1796: * @return ecma value
        -: 1797: *         Returned value must be freed with ecma_free_value.
        -: 1798: */
        -: 1799:ecma_value_t
    #####: 1800:ecma_builtin_json_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -: 1801:                                    ecma_value_t this_arg, /**< 'this' argument value */
        -: 1802:                                    const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1803:                                                                            *   passed to routine */
        -: 1804:                                    uint32_t arguments_number) /**< length of arguments' list */
        -: 1805:{
        -: 1806:  JERRY_UNUSED_2 (this_arg, arguments_number);
        -: 1807:
    #####: 1808:  switch (builtin_routine_id)
        -: 1809:  {
    #####: 1810:    case ECMA_BUILTIN_JSON_PARSE:
        -: 1811:    {
    #####: 1812:      return ecma_builtin_json_parse (arguments_list_p[0], arguments_list_p[1]);
        -: 1813:    }
    #####: 1814:    case ECMA_BUILTIN_JSON_STRINGIFY:
        -: 1815:    {
    #####: 1816:      return ecma_builtin_json_stringify (arguments_list_p[0], arguments_list_p[1], arguments_list_p[2]);
        -: 1817:    }
    #####: 1818:    default:
        -: 1819:    {
    #####: 1820:      JERRY_UNREACHABLE ();
        -: 1821:    }
        -: 1822:  }
        -: 1823:} /* ecma_builtin_json_dispatch_routine */
        -: 1824:
        -: 1825:/**
        -: 1826: * @}
        -: 1827: * @}
        -: 1828: * @}
        -: 1829: */
        -: 1830:
        -: 1831:#endif /* JERRY_BUILTIN_JSON */
