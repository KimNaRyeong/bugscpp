        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-date.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:
        -:   27:#include "jcontext.h"
        -:   28:#include "lit-char-helpers.h"
        -:   29:
        -:   30:#if JERRY_BUILTIN_DATE
        -:   31:
        -:   32:#define ECMA_BUILTINS_INTERNAL
        -:   33:#include "ecma-builtins-internal.h"
        -:   34:
        -:   35:/**
        -:   36: * This object has a custom dispatch function.
        -:   37: */
        -:   38:#define BUILTIN_CUSTOM_DISPATCH
        -:   39:
        -:   40:/**
        -:   41: * List of built-in routine identifiers.
        -:   42: */
        -:   43:enum
        -:   44:{
        -:   45:  ECMA_DATE_ROUTINE_START = 0,
        -:   46:  ECMA_DATE_ROUTINE_PARSE,
        -:   47:  ECMA_DATE_ROUTINE_UTC,
        -:   48:  ECMA_DATE_ROUTINE_NOW,
        -:   49:};
        -:   50:
        -:   51:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-date.inc.h"
        -:   52:#define BUILTIN_UNDERSCORED_ID  date
        -:   53:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   54:
        -:   55:/** \addtogroup ecma ECMA
        -:   56: * @{
        -:   57: *
        -:   58: * \addtogroup ecmabuiltins
        -:   59: * @{
        -:   60: *
        -:   61: * \addtogroup date ECMA Date object built-in
        -:   62: * @{
        -:   63: */
        -:   64:
        -:   65:/**
        -:   66: * Encode minimum/maximum limits
        -:   67: *
        -:   68: * See: ecma_date_parse_date_chars
        -:   69: *
        -:   70: * @param min: 8 bits unsigned number
        -:   71: * @param max: 24 bits unsigned number
        -:   72: */
        -:   73:#define ECMA_DATE_LIMIT(min, max) (min << 24 | max)
        -:   74:
        -:   75:/**
        -:   76: * Decode the minimum value from the encoded limit
        -:   77: */
        -:   78:#define ECMA_DATE_LIMIT_MIN(limit) (limit >> 24)
        -:   79:
        -:   80:/**
        -:   81: * Decode the maximum value from the encoded limit
        -:   82: */
        -:   83:#define ECMA_DATE_LIMIT_MAX(limit) (limit & ((1 << 24) - 1))
        -:   84:
        -:   85:/**
        -:   86: * Helper function to try to parse a part of a date string
        -:   87: *
        -:   88: * @return NaN if cannot read from string, ToNumber() otherwise
        -:   89: */
        -:   90:static ecma_number_t
    #####:   91:ecma_date_parse_date_chars (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:   92:                            const lit_utf8_byte_t *str_end_p, /**< pointer to the end of the string */
        -:   93:                            uint32_t num_of_chars, /**< number of characters to read and convert */
        -:   94:                            uint32_t limit) /**< minimum/maximum valid value */
        -:   95:{
    #####:   96:  JERRY_ASSERT (num_of_chars > 0 && num_of_chars <= 6);
        -:   97:
    #####:   98:  if (*str_p + num_of_chars > str_end_p)
        -:   99:  {
    #####:  100:    return ecma_number_make_nan ();
        -:  101:  }
        -:  102:
    #####:  103:  str_end_p = *str_p + num_of_chars;
        -:  104:
    #####:  105:  uint32_t num = 0;
        -:  106:
    #####:  107:  while (num_of_chars--)
        -:  108:  {
    #####:  109:    lit_utf8_byte_t c = **str_p;
    #####:  110:    if (!lit_char_is_decimal_digit (c))
        -:  111:    {
    #####:  112:      return ecma_number_make_nan ();
        -:  113:    }
        -:  114:
    #####:  115:    num = (num * 10) + (uint32_t) ((c - LIT_CHAR_0));
    #####:  116:    (*str_p)++;
        -:  117:  }
        -:  118:
    #####:  119:  if (num >= ECMA_DATE_LIMIT_MIN (limit) && num <= ECMA_DATE_LIMIT_MAX (limit))
        -:  120:  {
    #####:  121:    return (ecma_number_t) num;
        -:  122:  }
        -:  123:
    #####:  124:  return ecma_number_make_nan ();
        -:  125:} /* ecma_date_parse_date_chars */
        -:  126:
        -:  127:/**
        -:  128: * Helper function to try to parse a special chracter (+,-,T,Z,:,.) in a date string
        -:  129: *
        -:  130: * @return true if the first character is same as the expected, false otherwise
        -:  131: */
        -:  132:static bool
    #####:  133:ecma_date_parse_special_char (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  134:                              const lit_utf8_byte_t *str_end_p, /**< pointer to the end of the string */
        -:  135:                              ecma_char_t expected_char) /**< expected character */
        -:  136:{
    #####:  137:  if ((*str_p < str_end_p) && (**str_p == expected_char))
        -:  138:  {
    #####:  139:    (*str_p)++;
    #####:  140:    return true;
        -:  141:  }
        -:  142:
    #####:  143:  return false;
        -:  144:} /* ecma_date_parse_special_char */
        -:  145:
        -:  146:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  147:ecma_date_check_two_chars (const lit_utf8_byte_t *str_p, /**< pointer to the cesu8 string */
        -:  148:                           const lit_utf8_byte_t *str_end_p, /**< pointer to the end of the string */
        -:  149:                           ecma_char_t expected_char1, /**< first expected character */
        -:  150:                           ecma_char_t expected_char2) /**< second expected character */
        -:  151:{
    #####:  152:  return (str_p < str_end_p && (*str_p == expected_char1 || *str_p == expected_char2));
        -:  153:} /* ecma_date_check_two_chars */
        -:  154:
        -:  155:/**
        -:  156: * Helper function to try to parse a 4-5-6 digit year with optional negative sign in a date string
        -:  157: *
        -:  158: * Date.prototype.toString() and Date.prototype.toUTCString() emits year
        -:  159: * in this format and Date.parse() should parse this format too.
        -:  160: *
        -:  161: * @return the parsed year or NaN.
        -:  162: */
        -:  163:static ecma_number_t
    #####:  164:ecma_date_parse_year (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  165:                      const lit_utf8_byte_t *str_end_p) /**< pointer to the end of the string */
        -:  166:{
    #####:  167:  bool is_year_sign_negative = ecma_date_parse_special_char (str_p, str_end_p, LIT_CHAR_MINUS);
    #####:  168:  const lit_utf8_byte_t *str_start_p = *str_p;
    #####:  169:  int32_t parsed_year = 0;
        -:  170:
    #####:  171:  while ((str_start_p - *str_p < 6) && (str_start_p < str_end_p) && lit_char_is_decimal_digit (*str_start_p))
        -:  172:  {
    #####:  173:    parsed_year = 10 * parsed_year + *str_start_p - LIT_CHAR_0;
    #####:  174:    str_start_p++;
        -:  175:  }
        -:  176:
    #####:  177:  if (str_start_p - *str_p >= 4)
        -:  178:  {
    #####:  179:    *str_p = str_start_p;
    #####:  180:    return is_year_sign_negative ? -parsed_year : parsed_year;
        -:  181:  }
        -:  182:
    #####:  183:  return ecma_number_make_nan ();
        -:  184:} /* ecma_date_parse_year */
        -:  185:
        -:  186:/**
        -:  187: * Helper function to try to parse a day name in a date string
        -:  188: * Valid day names: Sun, Mon, Tue, Wed, Thu, Fri, Sat
        -:  189: * See also:
        -:  190: *          ECMA-262 v9, 20.3.4.41.2 Table 46
        -:  191: *
        -:  192: * @return true if the string starts with a valid day name, false otherwise
        -:  193: */
        -:  194:static bool
    #####:  195:ecma_date_parse_day_name (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  196:                          const lit_utf8_byte_t *str_end_p) /**< pointer to the end of the string */
        -:  197:{
    #####:  198:  if (*str_p + 3 < str_end_p)
        -:  199:  {
    #####:  200:    for (uint32_t i = 0; i < 7; i++)
        -:  201:    {
    #####:  202:      if (!memcmp (day_names_p[i], *str_p, 3))
        -:  203:      {
    #####:  204:        (*str_p) += 3;
    #####:  205:        return true;
        -:  206:      }
        -:  207:    }
        -:  208:  }
    #####:  209:  return false;
        -:  210:} /* ecma_date_parse_day_name */
        -:  211:
        -:  212:/**
        -:  213: * Helper function to try to parse a month name in a date string
        -:  214: * Valid month names: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
        -:  215: * See also:
        -:  216: *          ECMA-262 v9, 20.3.4.41.2 Table 47
        -:  217: *
        -:  218: * @return number of the month if the string starts with a valid month name, 0 otherwise
        -:  219: */
        -:  220:static uint32_t
    #####:  221:ecma_date_parse_month_name (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  222:                            const lit_utf8_byte_t *str_end_p) /**< pointer to the end of the string */
        -:  223:{
    #####:  224:  if (*str_p + 3 < str_end_p)
        -:  225:  {
    #####:  226:    for (uint32_t i = 0; i < 12; i++)
        -:  227:    {
    #####:  228:      if (!memcmp (month_names_p[i], *str_p, 3))
        -:  229:      {
    #####:  230:        (*str_p) += 3;
    #####:  231:        return (i + 1);
        -:  232:      }
        -:  233:    }
        -:  234:  }
    #####:  235:  return 0;
        -:  236:} /* ecma_date_parse_month_name */
        -:  237:
        -:  238:/**
        -:  239: * Calculate MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)) for Date constructor and UTC
        -:  240: *
        -:  241: * See also:
        -:  242: *          ECMA-262 v11, 20.4.3.4
        -:  243: *
        -:  244: * @return false - if the operation fails
        -:  245: *         true - otherwise
        -:  246: */
        -:  247:static bool
    #####:  248:ecma_date_construct_helper (const ecma_value_t *args, /**< arguments passed to the Date constructor */
        -:  249:                            uint32_t args_len, /**< number of arguments */
        -:  250:                            ecma_number_t *tv_p) /**< [out] time value */
        -:  251:{
    #####:  252:  ecma_number_t date_nums[7] = {
        -:  253:    ECMA_NUMBER_ZERO, /* year */
        -:  254:    ECMA_NUMBER_ZERO, /* month */
        -:  255:    ECMA_NUMBER_ONE, /* date */
        -:  256:    ECMA_NUMBER_ZERO, /* hours */
        -:  257:    ECMA_NUMBER_ZERO, /* minutes */
        -:  258:    ECMA_NUMBER_ZERO, /* seconds */
        -:  259:    ECMA_NUMBER_ZERO /* miliseconds */
        -:  260:  };
        -:  261:
    #####:  262:  args_len = JERRY_MIN (args_len, sizeof (date_nums) / sizeof (date_nums[0]));
        -:  263:
        -:  264:  /* 1-7. */
    #####:  265:  for (uint32_t i = 0; i < args_len; i++)
        -:  266:  {
    #####:  267:    ecma_value_t status = ecma_op_to_number (args[i], date_nums + i);
        -:  268:
    #####:  269:    if (ECMA_IS_VALUE_ERROR (status))
        -:  270:    {
    #####:  271:      return false;
        -:  272:    }
        -:  273:  }
        -:  274:
        -:  275:  /* 8. */
    #####:  276:  if (!ecma_number_is_nan (date_nums[0]))
        -:  277:  {
        -:  278:    /* 9.a */
    #####:  279:    ecma_number_t yi = ecma_number_trunc (date_nums[0]);
        -:  280:
        -:  281:    /* 9.b */
    #####:  282:    if (yi >= 0 && yi <= 99)
        -:  283:    {
    #####:  284:      date_nums[0] = 1900 + yi;
        -:  285:    }
        -:  286:  }
        -:  287:
        -:  288:  /* 10. */
    #####:  289:  *tv_p = ecma_date_make_date (ecma_date_make_day (date_nums[0], date_nums[1], date_nums[2]),
        -:  290:                               ecma_date_make_time (date_nums[3], date_nums[4], date_nums[5], date_nums[6]));
    #####:  291:  return true;
        -:  292:} /* ecma_date_construct_helper */
        -:  293:
        -:  294:/**
        -:  295: * Helper function used by ecma_builtin_date_parse
        -:  296: *
        -:  297: * See also:
        -:  298: *          ECMA-262 v5, 15.9.4.2  Date.parse (string)
        -:  299: *          ECMA-262 v5, 15.9.1.15 Date Time String Format
        -:  300: *
        -:  301: * @return the parsed date as ecma_number_t or NaN otherwise
        -:  302: */
        -:  303:static ecma_number_t
    #####:  304:ecma_builtin_date_parse_basic (const lit_utf8_byte_t *date_str_curr_p, /**< date string start */
        -:  305:                               const lit_utf8_byte_t *date_str_end_p) /**< date string end */
        -:  306:{
        -:  307:  /* 1. read year */
        -:  308:
    #####:  309:  uint32_t year_digits = 4;
    #####:  310:  uint32_t year_limit = 9999;
        -:  311:
    #####:  312:  bool is_year_sign_negative = false;
        -:  313:
    #####:  314:  if (ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_MINUS, LIT_CHAR_PLUS))
        -:  315:  {
    #####:  316:    is_year_sign_negative = (*date_str_curr_p++ == LIT_CHAR_MINUS);
    #####:  317:    year_digits = 6;
    #####:  318:    year_limit = 999999;
        -:  319:  }
        -:  320:
    #####:  321:  ecma_number_t year =
        -:  322:    ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, year_digits, ECMA_DATE_LIMIT (0, year_limit));
    #####:  323:  if (is_year_sign_negative)
        -:  324:  {
    #####:  325:    year = -year;
        -:  326:  }
        -:  327:
    #####:  328:  if (ecma_number_is_nan (year))
        -:  329:  {
    #####:  330:    return year;
        -:  331:  }
        -:  332:
    #####:  333:  ecma_number_t month = ECMA_NUMBER_ONE;
    #####:  334:  ecma_number_t day = ECMA_NUMBER_ONE;
    #####:  335:  ecma_number_t time = ECMA_NUMBER_ZERO;
        -:  336:
        -:  337:  /* 2. read month if any */
    #####:  338:  if (ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_MINUS, LIT_CHAR_SLASH))
        -:  339:  {
    #####:  340:    lit_utf8_byte_t separator = *date_str_curr_p++;
    #####:  341:    month = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (1, 12));
        -:  342:
        -:  343:    /* 3. read day if any */
    #####:  344:    if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, separator))
        -:  345:    {
    #####:  346:      day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (1, 31));
        -:  347:    }
        -:  348:  }
        -:  349:
    #####:  350:  bool is_utc = true;
        -:  351:  /* 4. read time if any */
    #####:  352:  if (ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_UPPERCASE_T, LIT_CHAR_SP))
        -:  353:  {
    #####:  354:    date_str_curr_p++;
        -:  355:
    #####:  356:    ecma_number_t hours = ECMA_NUMBER_ZERO;
    #####:  357:    ecma_number_t minutes = ECMA_NUMBER_ZERO;
    #####:  358:    ecma_number_t seconds = ECMA_NUMBER_ZERO;
    #####:  359:    ecma_number_t milliseconds = ECMA_NUMBER_ZERO;
        -:  360:
        -:  361:    /* 'HH:mm' must present */
    #####:  362:    if (date_str_end_p - date_str_curr_p < 5)
        -:  363:    {
    #####:  364:      return ecma_number_make_nan ();
        -:  365:    }
        -:  366:
        -:  367:    /* 4.1 read hours and minutes */
    #####:  368:    hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  369:
    #####:  370:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  371:    {
    #####:  372:      return ecma_number_make_nan ();
        -:  373:    }
        -:  374:
    #####:  375:    minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  376:
        -:  377:    /* 4.2 read seconds if any */
    #####:  378:    if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  379:    {
    #####:  380:      seconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  381:
        -:  382:      /* 4.3 read milliseconds if any */
    #####:  383:      if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_DOT))
        -:  384:      {
    #####:  385:        milliseconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 3, ECMA_DATE_LIMIT (0, 999));
        -:  386:      }
        -:  387:    }
        -:  388:
    #####:  389:    if (hours == 24 && (minutes != 0 || seconds != 0 || milliseconds != 0))
        -:  390:    {
    #####:  391:      return ecma_number_make_nan ();
        -:  392:    }
        -:  393:
    #####:  394:    time = ecma_date_make_time (hours, minutes, seconds, milliseconds);
        -:  395:
    #####:  396:    if (ecma_number_is_nan (time))
        -:  397:    {
    #####:  398:      return time;
        -:  399:    }
        -:  400:
        -:  401:    /* 4.4 read timezone if any */
    #####:  402:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_UPPERCASE_Z))
        -:  403:    {
    #####:  404:      if ((date_str_end_p - date_str_curr_p) == 6
    #####:  405:          && (*date_str_curr_p == LIT_CHAR_MINUS || *date_str_curr_p == LIT_CHAR_PLUS))
    #####:  406:      {
    #####:  407:        bool is_timezone_sign_negative = (*date_str_curr_p++ == LIT_CHAR_MINUS);
        -:  408:        /* read hours and minutes */
    #####:  409:        hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  410:
    #####:  411:        if (hours == 24)
        -:  412:        {
    #####:  413:          hours = ECMA_NUMBER_ZERO;
        -:  414:        }
        -:  415:
    #####:  416:        if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  417:        {
    #####:  418:          return ecma_number_make_nan ();
        -:  419:        }
        -:  420:
    #####:  421:        minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
    #####:  422:        ecma_number_t timezone_offset = ecma_date_make_time (hours, minutes, ECMA_NUMBER_ZERO, ECMA_NUMBER_ZERO);
    #####:  423:        time += is_timezone_sign_negative ? timezone_offset : -timezone_offset;
        -:  424:      }
        -:  425:      else
        -:  426:      {
    #####:  427:        is_utc = false;
        -:  428:      }
        -:  429:    }
        -:  430:  }
        -:  431:
    #####:  432:  if (date_str_curr_p < date_str_end_p)
        -:  433:  {
    #####:  434:    return ecma_number_make_nan ();
        -:  435:  }
        -:  436:
    #####:  437:  ecma_number_t date = ecma_date_make_day (year, month - 1, day);
    #####:  438:  ecma_number_t result_date = ecma_date_make_date (date, time);
        -:  439:
    #####:  440:  if (!is_utc)
        -:  441:  {
    #####:  442:    result_date = ecma_date_utc (result_date);
        -:  443:  }
        -:  444:
    #####:  445:  return result_date;
        -:  446:} /* ecma_builtin_date_parse_basic */
        -:  447:
        -:  448:/**
        -:  449: * Helper function used by ecma_builtin_date_parse
        -:  450: *
        -:  451: * See also:
        -:  452: *          ECMA-262 v5, 15.9.4.2  Date.parse (string)
        -:  453: *          ECMA-262 v9, 20.3.4.41 Date.prototype.toString ()
        -:  454: *          ECMA-262 v9, 20.3.4.43 Date.prototype.toUTCString ()
        -:  455: *
        -:  456: * Used by: ecma_builtin_date_parse
        -:  457: *
        -:  458: * @return the parsed date as ecma_number_t or NaN otherwise
        -:  459: */
        -:  460:static ecma_number_t
    #####:  461:ecma_builtin_date_parse_toString_formats (const lit_utf8_byte_t *date_str_curr_p, const lit_utf8_byte_t *date_str_end_p)
        -:  462:{
    #####:  463:  const ecma_number_t nan = ecma_number_make_nan ();
        -:  464:
    #####:  465:  if (!ecma_date_parse_day_name (&date_str_curr_p, date_str_end_p))
        -:  466:  {
    #####:  467:    return nan;
        -:  468:  }
        -:  469:
    #####:  470:  const bool is_toUTCString_format = ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COMMA);
        -:  471:
    #####:  472:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  473:  {
    #####:  474:    return nan;
        -:  475:  }
        -:  476:
    #####:  477:  ecma_number_t month = 0;
    #####:  478:  ecma_number_t day = 0;
    #####:  479:  if (is_toUTCString_format)
        -:  480:  {
    #####:  481:    day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 31));
        -:  482:
    #####:  483:    if (ecma_number_is_nan (day))
        -:  484:    {
    #####:  485:      return nan;
        -:  486:    }
        -:  487:
    #####:  488:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  489:    {
    #####:  490:      return nan;
        -:  491:    }
        -:  492:
    #####:  493:    month = ecma_date_parse_month_name (&date_str_curr_p, date_str_end_p);
        -:  494:
    #####:  495:    if (month == 0)
        -:  496:    {
    #####:  497:      return ecma_number_make_nan ();
        -:  498:    }
        -:  499:  }
        -:  500:  else
        -:  501:  {
    #####:  502:    month = ecma_date_parse_month_name (&date_str_curr_p, date_str_end_p);
        -:  503:
    #####:  504:    if (month == 0)
        -:  505:    {
    #####:  506:      return nan;
        -:  507:    }
        -:  508:
    #####:  509:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  510:    {
    #####:  511:      return nan;
        -:  512:    }
        -:  513:
    #####:  514:    day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 31));
        -:  515:
    #####:  516:    if (ecma_number_is_nan (day))
        -:  517:    {
    #####:  518:      return nan;
        -:  519:    }
        -:  520:  }
        -:  521:
    #####:  522:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  523:  {
    #####:  524:    return nan;
        -:  525:  }
        -:  526:
    #####:  527:  ecma_number_t year = ecma_date_parse_year (&date_str_curr_p, date_str_end_p);
        -:  528:
    #####:  529:  if (ecma_number_is_nan (year))
        -:  530:  {
    #####:  531:    return nan;
        -:  532:  }
        -:  533:
    #####:  534:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  535:  {
    #####:  536:    return nan;
        -:  537:  }
        -:  538:
    #####:  539:  ecma_number_t hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  540:
    #####:  541:  if (ecma_number_is_nan (hours))
        -:  542:  {
    #####:  543:    return nan;
        -:  544:  }
        -:  545:
    #####:  546:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  547:  {
    #####:  548:    return nan;
        -:  549:  }
        -:  550:
    #####:  551:  ecma_number_t minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  552:
    #####:  553:  if (ecma_number_is_nan (minutes))
        -:  554:  {
    #####:  555:    return nan;
        -:  556:  }
        -:  557:
    #####:  558:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  559:  {
    #####:  560:    return nan;
        -:  561:  }
        -:  562:
    #####:  563:  ecma_number_t seconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  564:
    #####:  565:  if (ecma_number_is_nan (seconds))
        -:  566:  {
    #####:  567:    return nan;
        -:  568:  }
        -:  569:
    #####:  570:  if (hours == 24 && (minutes != 0 || seconds != 0))
        -:  571:  {
    #####:  572:    return nan;
        -:  573:  }
        -:  574:
    #####:  575:  const char gmt_p[] = " GMT";
    #####:  576:  if (date_str_end_p - date_str_curr_p < 4 || memcmp (date_str_curr_p, gmt_p, 4) != 0)
        -:  577:  {
    #####:  578:    return nan;
        -:  579:  }
        -:  580:
    #####:  581:  date_str_curr_p += 4;
        -:  582:
    #####:  583:  ecma_number_t time = ecma_date_make_time (hours, minutes, seconds, 0);
        -:  584:
    #####:  585:  if (!is_toUTCString_format)
        -:  586:  {
    #####:  587:    if (!ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_MINUS, LIT_CHAR_PLUS))
        -:  588:    {
    #####:  589:      return nan;
        -:  590:    }
        -:  591:
    #####:  592:    bool is_timezone_sign_negative = (*date_str_curr_p++ == LIT_CHAR_MINUS);
        -:  593:
    #####:  594:    hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  595:
    #####:  596:    if (ecma_number_is_nan (hours))
        -:  597:    {
    #####:  598:      return nan;
        -:  599:    }
        -:  600:
    #####:  601:    if (hours == 24)
        -:  602:    {
    #####:  603:      hours = ECMA_NUMBER_ZERO;
        -:  604:    }
        -:  605:
    #####:  606:    minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  607:
    #####:  608:    if (ecma_number_is_nan (minutes))
        -:  609:    {
    #####:  610:      return nan;
        -:  611:    }
        -:  612:
    #####:  613:    ecma_number_t timezone_offset = ecma_date_make_time (hours, minutes, ECMA_NUMBER_ZERO, ECMA_NUMBER_ZERO);
        -:  614:
    #####:  615:    time += is_timezone_sign_negative ? timezone_offset : -timezone_offset;
        -:  616:  }
        -:  617:
    #####:  618:  if (date_str_curr_p < date_str_end_p)
        -:  619:  {
    #####:  620:    return nan;
        -:  621:  }
        -:  622:
    #####:  623:  ecma_number_t date = ecma_date_make_day (year, month - 1, day);
    #####:  624:  return ecma_date_make_date (date, time);
        -:  625:} /* ecma_builtin_date_parse_toString_formats */
        -:  626:
        -:  627:/**
        -:  628: * The Date object's 'parse' routine
        -:  629: *
        -:  630: * See also:
        -:  631: *          ECMA-262 v5, 15.9.4.2  Date.parse (string)
        -:  632: *          ECMA-262 v5, 15.9.1.15 Date Time String Format
        -:  633: *          ECMA-262 v9, 20.3.4.41 Date.prototype.toString ()
        -:  634: *          ECMA-262 v9, 20.3.4.43 Date.prototype.toUTCString ()
        -:  635: *
        -:  636: * @return parsed time
        -:  637: */
        -:  638:static ecma_number_t
    #####:  639:ecma_builtin_date_parse (ecma_string_t *string_p) /**< string */
        -:  640:{
    #####:  641:  ECMA_STRING_TO_UTF8_STRING (string_p, str_p, str_size);
    #####:  642:  const lit_utf8_byte_t *date_str_curr_p = str_p;
    #####:  643:  const lit_utf8_byte_t *date_str_end_p = str_p + str_size;
        -:  644:
        -:  645:  /* try to parse date string as ISO string - ECMA-262 v5, 15.9.1.15 */
    #####:  646:  ecma_number_t tv = ecma_builtin_date_parse_basic (date_str_curr_p, date_str_end_p);
        -:  647:
    #####:  648:  if (ecma_number_is_nan (tv))
        -:  649:  {
        -:  650:    /* try to parse date string in Date.prototype.toString() or toUTCString() format */
    #####:  651:    tv = ecma_builtin_date_parse_toString_formats (date_str_curr_p, date_str_end_p);
        -:  652:  }
        -:  653:
    #####:  654:  ECMA_FINALIZE_UTF8_STRING (str_p, str_size);
        -:  655:
    #####:  656:  return tv;
        -:  657:} /* ecma_builtin_date_parse */
        -:  658:
        -:  659:/**
        -:  660: * The Date object's 'UTC' routine
        -:  661: *
        -:  662: * See also:
        -:  663: *          ECMA-262 v5, 15.9.4.3
        -:  664: *
        -:  665: * @return ecma value
        -:  666: *         Returned value must be freed with ecma_free_value.
        -:  667: */
        -:  668:static ecma_value_t
    #####:  669:ecma_builtin_date_utc (const ecma_value_t args[], /**< arguments list */
        -:  670:                       uint32_t args_number) /**< number of arguments */
        -:  671:{
        -:  672:#if JERRY_ESNEXT
    #####:  673:  const uint32_t required_args_number = 1;
        -:  674:#else /* !JERRY_ESNEXT */
    #####:  675:  const uint32_t required_args_number = 2;
        -:  676:#endif /* JERRY_ESNEXT */
        -:  677:
    #####:  678:  if (args_number < required_args_number)
        -:  679:  {
    #####:  680:    return ecma_make_nan_value ();
        -:  681:  }
        -:  682:
    #####:  683:  ecma_number_t tv;
        -:  684:
    #####:  685:  if (!ecma_date_construct_helper (args, args_number, &tv))
        -:  686:  {
    #####:  687:    return ECMA_VALUE_ERROR;
        -:  688:  }
        -:  689:
    #####:  690:  return ecma_make_number_value ((ecma_number_t) ecma_date_time_clip (tv));
        -:  691:} /* ecma_builtin_date_utc */
        -:  692:
        -:  693:/**
        -:  694: * Helper method to get the current time
        -:  695: *
        -:  696: * @return ecma_number_t
        -:  697: */
        -:  698:static ecma_number_t
    #####:  699:ecma_builtin_date_now_helper (void)
        -:  700:{
    #####:  701:  return floor (DOUBLE_TO_ECMA_NUMBER_T (jerry_port_get_current_time ()));
        -:  702:} /* ecma_builtin_date_now_helper */
        -:  703:
        -:  704:/**
        -:  705: * Construct a date object with the given [[DateValue]]
        -:  706: *
        -:  707: * Note: New target must be a valid object
        -:  708: *
        -:  709: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  710: *         constructed date object - otherwise
        -:  711: */
        -:  712:static ecma_value_t
    #####:  713:ecma_builtin_date_create (ecma_number_t tv)
        -:  714:{
        -:  715:#if JERRY_ESNEXT
    #####:  716:  JERRY_ASSERT (JERRY_CONTEXT (current_new_target_p) != NULL);
        -:  717:
    #####:  718:  ecma_object_t *prototype_obj_p =
    #####:  719:    ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p), ECMA_BUILTIN_ID_DATE_PROTOTYPE);
        -:  720:
    #####:  721:  if (JERRY_UNLIKELY (prototype_obj_p == NULL))
        -:  722:  {
    #####:  723:    return ECMA_VALUE_ERROR;
        -:  724:  }
        -:  725:
    #####:  726:  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, sizeof (ecma_date_object_t), ECMA_OBJECT_TYPE_CLASS);
    #####:  727:  ecma_deref_object (prototype_obj_p);
        -:  728:
    #####:  729:  ecma_date_object_t *date_object_p = (ecma_date_object_t *) obj_p;
    #####:  730:  date_object_p->header.u.cls.type = ECMA_OBJECT_CLASS_DATE;
    #####:  731:  date_object_p->header.u.cls.u1.date_flags = ECMA_DATE_TZA_NONE;
    #####:  732:  date_object_p->header.u.cls.u3.tza = 0;
    #####:  733:  date_object_p->date_value = tv;
        -:  734:#else /* !JERRY_ESNEXT */
    #####:  735:  ecma_number_t *date_value_p = ecma_alloc_number ();
    #####:  736:  *date_value_p = tv;
        -:  737:
    #####:  738:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_DATE_PROTOTYPE);
    #####:  739:  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  740:
    #####:  741:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
    #####:  742:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_DATE;
    #####:  743:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.date, date_value_p);
        -:  744:#endif /* JERRY_ESNEXT */
        -:  745:
    #####:  746:  return ecma_make_object_value (obj_p);
        -:  747:} /* ecma_builtin_date_create */
        -:  748:
        -:  749:/**
        -:  750: * Handle calling [[Call]] of built-in Date object
        -:  751: *
        -:  752: * See also:
        -:  753: *          ECMA-262 v5, 15.9.2.1
        -:  754: *
        -:  755: * @return ecma value
        -:  756: */
        -:  757:ecma_value_t
    #####:  758:ecma_builtin_date_dispatch_call (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  759:                                 uint32_t arguments_list_len) /**< number of arguments */
        -:  760:{
        -:  761:  JERRY_UNUSED (arguments_list_p);
        -:  762:  JERRY_UNUSED (arguments_list_len);
        -:  763:
    #####:  764:  return ecma_date_value_to_string (ecma_builtin_date_now_helper ());
        -:  765:} /* ecma_builtin_date_dispatch_call */
        -:  766:
        -:  767:/**
        -:  768: * Handle calling [[Construct]] of built-in Date object
        -:  769: *
        -:  770: * See also:
        -:  771: *          ECMA-262 v5, 15.9.3.1
        -:  772: *          ECMA-262 v11, 20.4.2
        -:  773: *
        -:  774: * @return ecma value
        -:  775: */
        -:  776:ecma_value_t
    #####:  777:ecma_builtin_date_dispatch_construct (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  778:                                      uint32_t arguments_list_len) /**< number of arguments */
        -:  779:{
        -:  780:  /* 20.4.2.3 */
    #####:  781:  if (arguments_list_len == 0)
        -:  782:  {
    #####:  783:    return ecma_builtin_date_create (ecma_builtin_date_now_helper ());
        -:  784:  }
        -:  785:
    #####:  786:  ecma_number_t tv;
        -:  787:  /* 20.4.2.2 */
    #####:  788:  if (arguments_list_len == 1)
        -:  789:  {
    #####:  790:    ecma_value_t argument = arguments_list_p[0];
        -:  791:
        -:  792:    /* 4.a */
    #####:  793:    if (ecma_is_value_object (argument)
    #####:  794:        && ecma_object_class_is (ecma_get_object_from_value (argument), ECMA_OBJECT_CLASS_DATE))
        -:  795:    {
        -:  796:#if JERRY_ESNEXT
    #####:  797:      tv = ((ecma_date_object_t *) ecma_get_object_from_value (argument))->date_value;
        -:  798:#else /* !JERRY_ESNEXT */
    #####:  799:      ecma_extended_object_t *arg_ext_object_p = (ecma_extended_object_t *) ecma_get_object_from_value (argument);
    #####:  800:      tv = *ECMA_GET_INTERNAL_VALUE_POINTER (ecma_number_t, arg_ext_object_p->u.cls.u3.date);
        -:  801:#endif /* JERRY_ESNEXT */
        -:  802:
    #####:  803:      return ecma_builtin_date_create (tv);
        -:  804:    }
        -:  805:    /* 4.b */
    #####:  806:    ecma_value_t primitive = ecma_op_to_primitive (argument, ECMA_PREFERRED_TYPE_NO);
        -:  807:
    #####:  808:    if (ECMA_IS_VALUE_ERROR (primitive))
        -:  809:    {
    #####:  810:      return primitive;
        -:  811:    }
        -:  812:
    #####:  813:    if (ecma_is_value_string (primitive))
        -:  814:    {
    #####:  815:      ecma_string_t *prim_str_p = ecma_get_string_from_value (primitive);
    #####:  816:      tv = ecma_builtin_date_parse (prim_str_p);
    #####:  817:      ecma_deref_ecma_string (prim_str_p);
        -:  818:    }
        -:  819:    else
        -:  820:    {
    #####:  821:      ecma_value_t prim_value = ecma_op_to_number (primitive, &tv);
    #####:  822:      ecma_free_value (primitive);
        -:  823:
    #####:  824:      if (ECMA_IS_VALUE_ERROR (prim_value))
        -:  825:      {
    #####:  826:        return prim_value;
        -:  827:      }
        -:  828:    }
        -:  829:  }
        -:  830:  /* 20.4.2.1 */
    #####:  831:  else if (ecma_date_construct_helper (arguments_list_p, arguments_list_len, &tv))
        -:  832:  {
    #####:  833:    tv = ecma_date_utc (tv);
        -:  834:  }
        -:  835:  else
        -:  836:  {
    #####:  837:    return ECMA_VALUE_ERROR;
        -:  838:  }
        -:  839:
    #####:  840:  return ecma_builtin_date_create (ecma_date_time_clip (tv));
        -:  841:} /* ecma_builtin_date_dispatch_construct */
        -:  842:
        -:  843:/**
        -:  844: * Dispatcher of the built-in's routines
        -:  845: *
        -:  846: * @return ecma value
        -:  847: *         Returned value must be freed with ecma_free_value.
        -:  848: */
        -:  849:ecma_value_t
    #####:  850:ecma_builtin_date_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine  identifier */
        -:  851:                                    ecma_value_t this_arg, /**< 'this' argument value */
        -:  852:                                    const ecma_value_t arguments_list_p[], /**< list of arguments passed to routine */
        -:  853:                                    uint32_t arguments_number) /**< length of arguments' list */
        -:  854:{
        -:  855:  JERRY_UNUSED (this_arg);
        -:  856:
    #####:  857:  switch (builtin_routine_id)
        -:  858:  {
    #####:  859:    case ECMA_DATE_ROUTINE_NOW:
        -:  860:    {
    #####:  861:      return ecma_make_number_value (ecma_builtin_date_now_helper ());
        -:  862:    }
    #####:  863:    case ECMA_DATE_ROUTINE_UTC:
        -:  864:    {
    #####:  865:      return ecma_builtin_date_utc (arguments_list_p, arguments_number);
        -:  866:    }
    #####:  867:    case ECMA_DATE_ROUTINE_PARSE:
        -:  868:    {
    #####:  869:      if (arguments_number < 1)
        -:  870:      {
    #####:  871:        return ecma_make_nan_value ();
        -:  872:      }
        -:  873:
    #####:  874:      ecma_string_t *str_p = ecma_op_to_string (arguments_list_p[0]);
        -:  875:
    #####:  876:      if (JERRY_UNLIKELY (str_p == NULL))
        -:  877:      {
    #####:  878:        return ECMA_VALUE_ERROR;
        -:  879:      }
        -:  880:
    #####:  881:      ecma_value_t result = ecma_make_number_value (ecma_date_time_clip (ecma_builtin_date_parse (str_p)));
    #####:  882:      ecma_deref_ecma_string (str_p);
        -:  883:
    #####:  884:      return result;
        -:  885:    }
    #####:  886:    default:
        -:  887:    {
    #####:  888:      JERRY_UNREACHABLE ();
        -:  889:    }
        -:  890:  }
        -:  891:} /* ecma_builtin_date_dispatch_routine */
        -:  892:
        -:  893:/**
        -:  894: * @}
        -:  895: * @}
        -:  896: * @}
        -:  897: */
        -:  898:
        -:  899:#endif /* JERRY_BUILTIN_DATE */
