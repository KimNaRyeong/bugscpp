        -:    0:Source:/home/workspace/jerry-math/pow.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: *
        -:   15: * This file is based on work under the following copyright and permission
        -:   16: * notice:
        -:   17: *
        -:   18: *     Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
        -:   19: *
        -:   20: *     Permission to use, copy, modify, and distribute this
        -:   21: *     software is freely granted, provided that this notice
        -:   22: *     is preserved.
        -:   23: *
        -:   24: *     @(#)e_pow.c 1.5 04/04/22
        -:   25: */
        -:   26:
        -:   27:#include "jerry-math-internal.h"
        -:   28:
        -:   29:/* pow(x,y) return x**y
        -:   30: *
        -:   31: *                    n
        -:   32: * Method:  Let x =  2   * (1+f)
        -:   33: *      1. Compute and return log2(x) in two pieces:
        -:   34: *              log2(x) = w1 + w2,
        -:   35: *         where w1 has 53-24 = 29 bit trailing zeros.
        -:   36: *      2. Perform y*log2(x) = n+y' by simulating muti-precision
        -:   37: *         arithmetic, where |y'|<=0.5.
        -:   38: *      3. Return x**y = 2**n*exp(y'*log2)
        -:   39: *
        -:   40: * Special cases:
        -:   41: *      0.  +1 ** (anything) is 1
        -:   42: *      1.  (anything) ** 0  is 1
        -:   43: *      2.  (anything) ** 1  is itself
        -:   44: *      3.  (anything) ** NAN is NAN
        -:   45: *      4.  NAN ** (anything except 0) is NAN
        -:   46: *      5.  +-(|x| > 1) **  +INF is +INF
        -:   47: *      6.  +-(|x| > 1) **  -INF is +0
        -:   48: *      7.  +-(|x| < 1) **  +INF is +0
        -:   49: *      8.  +-(|x| < 1) **  -INF is +INF
        -:   50: *      9.  -1          ** +-INF is 1
        -:   51: *      10. +0 ** (+anything except 0, NAN)               is +0
        -:   52: *      11. -0 ** (+anything except 0, NAN, odd integer)  is +0
        -:   53: *      12. +0 ** (-anything except 0, NAN)               is +INF
        -:   54: *      13. -0 ** (-anything except 0, NAN, odd integer)  is +INF
        -:   55: *      14. -0 ** (odd integer) = -( +0 ** (odd integer) )
        -:   56: *      15. +INF ** (+anything except 0,NAN) is +INF
        -:   57: *      16. +INF ** (-anything except 0,NAN) is +0
        -:   58: *      17. -INF ** (anything)  = -0 ** (-anything)
        -:   59: *      18. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)
        -:   60: *      19. (-anything except 0 and inf) ** (non-integer) is NAN
        -:   61: *
        -:   62: * Accuracy:
        -:   63: *      pow(x,y) returns x**y nearly rounded. In particular
        -:   64: *                      pow(integer,integer)
        -:   65: *      always returns the correct integer provided it is
        -:   66: *      representable.
        -:   67: *
        -:   68: * Constants:
        -:   69: * The hexadecimal values are the intended ones for the following
        -:   70: * constants. The decimal values may be used, provided that the
        -:   71: * compiler will convert from decimal to binary accurately enough
        -:   72: * to produce the hexadecimal values shown.
        -:   73: */
        -:   74:
        -:   75:static const double bp[] = {
        -:   76:  1.0,
        -:   77:  1.5,
        -:   78:};
        -:   79:static const double dp_h[] = {
        -:   80:  0.0,
        -:   81:  5.84962487220764160156e-01, /* 0x3FE2B803, 0x40000000 */
        -:   82:};
        -:   83:static const double dp_l[] = {
        -:   84:  0.0,
        -:   85:  1.35003920212974897128e-08, /* 0x3E4CFDEB, 0x43CFD006 */
        -:   86:};
        -:   87:
        -:   88:#define zero  0.0
        -:   89:#define one   1.0
        -:   90:#define two   2.0
        -:   91:#define two53 9007199254740992.0 /* 0x43400000, 0x00000000 */
        -:   92:#define huge  1.0e300
        -:   93:#define tiny  1.0e-300
        -:   94:/* poly coefs for (3/2) * (log(x) - 2s - 2/3 * s**3 */
        -:   95:#define L1      5.99999999999994648725e-01 /* 0x3FE33333, 0x33333303 */
        -:   96:#define L2      4.28571428578550184252e-01 /* 0x3FDB6DB6, 0xDB6FABFF */
        -:   97:#define L3      3.33333329818377432918e-01 /* 0x3FD55555, 0x518F264D */
        -:   98:#define L4      2.72728123808534006489e-01 /* 0x3FD17460, 0xA91D4101 */
        -:   99:#define L5      2.30660745775561754067e-01 /* 0x3FCD864A, 0x93C9DB65 */
        -:  100:#define L6      2.06975017800338417784e-01 /* 0x3FCA7E28, 0x4A454EEF */
        -:  101:#define P1      1.66666666666666019037e-01 /* 0x3FC55555, 0x5555553E */
        -:  102:#define P2      -2.77777777770155933842e-03 /* 0xBF66C16C, 0x16BEBD93 */
        -:  103:#define P3      6.61375632143793436117e-05 /* 0x3F11566A, 0xAF25DE2C */
        -:  104:#define P4      -1.65339022054652515390e-06 /* 0xBEBBBD41, 0xC5D26BF1 */
        -:  105:#define P5      4.13813679705723846039e-08 /* 0x3E663769, 0x72BEA4D0 */
        -:  106:#define lg2     6.93147180559945286227e-01 /* 0x3FE62E42, 0xFEFA39EF */
        -:  107:#define lg2_h   6.93147182464599609375e-01 /* 0x3FE62E43, 0x00000000 */
        -:  108:#define lg2_l   -1.90465429995776804525e-09 /* 0xBE205C61, 0x0CA86C39 */
        -:  109:#define ovt     8.0085662595372944372e-0017 /* -(1024-log2(ovfl+.5ulp)) */
        -:  110:#define cp      9.61796693925975554329e-01 /* 0x3FEEC709, 0xDC3A03FD = 2 / (3 ln2) */
        -:  111:#define cp_h    9.61796700954437255859e-01 /* 0x3FEEC709, 0xE0000000 = (float) cp */
        -:  112:#define cp_l    -7.02846165095275826516e-09 /* 0xBE3E2FE0, 0x145B01F5 = tail of cp_h */
        -:  113:#define ivln2   1.44269504088896338700e+00 /* 0x3FF71547, 0x652B82FE = 1 / ln2 */
        -:  114:#define ivln2_h 1.44269502162933349609e+00 /* 0x3FF71547, 0x60000000 = 24b 1 / ln2 */
        -:  115:#define ivln2_l 1.92596299112661746887e-08 /* 0x3E54AE0B, 0xF85DDF44 = 1 / ln2 tail */
        -:  116:
        -:  117:double
    #####:  118:pow (double x, double y)
        -:  119:{
        -:  120:  double_accessor t1, ax, p_h, y1, t, z;
        -:  121:  double z_h, z_l, p_l;
        -:  122:  double t2, r, s, u, v, w;
        -:  123:  int i, j, k, yisint, n;
        -:  124:  int hx, hy, ix, iy;
        -:  125:  unsigned lx, ly;
        -:  126:
    #####:  127:  hx = __HI (x);
    #####:  128:  lx = __LO (x);
    #####:  129:  hy = __HI (y);
    #####:  130:  ly = __LO (y);
    #####:  131:  ix = hx & 0x7fffffff;
    #####:  132:  iy = hy & 0x7fffffff;
        -:  133:
        -:  134:  /* x == one: 1**y = 1 */
    #####:  135:  if (((hx - 0x3ff00000) | lx) == 0)
        -:  136:  {
        -:  137:    return one;
        -:  138:  }
        -:  139:
        -:  140:  /* y == zero: x**0 = 1 */
    #####:  141:  if ((iy | ly) == 0)
        -:  142:  {
        -:  143:    return one;
        -:  144:  }
        -:  145:
        -:  146:  /* +-NaN return x + y */
    #####:  147:  if (ix > 0x7ff00000 || ((ix == 0x7ff00000) && (lx != 0)) || iy > 0x7ff00000 || ((iy == 0x7ff00000) && (ly != 0)))
        -:  148:  {
    #####:  149:    return x + y;
        -:  150:  }
        -:  151:
        -:  152:  /* determine if y is an odd int when x < 0
        -:  153:   * yisint = 0 ... y is not an integer
        -:  154:   * yisint = 1 ... y is an odd int
        -:  155:   * yisint = 2 ... y is an even int
        -:  156:   */
    #####:  157:  yisint = 0;
    #####:  158:  if (hx < 0)
        -:  159:  {
    #####:  160:    if (iy >= 0x43400000) /* even integer y */
        -:  161:    {
        -:  162:      yisint = 2;
        -:  163:    }
    #####:  164:    else if (iy >= 0x3ff00000)
        -:  165:    {
    #####:  166:      k = (iy >> 20) - 0x3ff; /* exponent */
    #####:  167:      if (k > 20)
        -:  168:      {
    #####:  169:        j = ly >> (52 - k);
    #####:  170:        if ((j << (52 - k)) == ly)
        -:  171:        {
    #####:  172:          yisint = 2 - (j & 1);
        -:  173:        }
        -:  174:      }
    #####:  175:      else if (ly == 0)
        -:  176:      {
    #####:  177:        j = iy >> (20 - k);
    #####:  178:        if ((j << (20 - k)) == iy)
        -:  179:        {
    #####:  180:          yisint = 2 - (j & 1);
        -:  181:        }
        -:  182:      }
        -:  183:    }
        -:  184:  }
        -:  185:
        -:  186:  /* special value of y */
    #####:  187:  if (ly == 0)
        -:  188:  {
    #####:  189:    if (iy == 0x7ff00000) /* y is +-inf */
        -:  190:    {
    #####:  191:      if (((ix - 0x3ff00000) | lx) == 0) /* +-1**+-inf is 1 */
        -:  192:      {
        -:  193:        return one;
        -:  194:      }
    #####:  195:      else if (ix >= 0x3ff00000) /* (|x|>1)**+-inf = inf,0 */
        -:  196:      {
    #####:  197:        return (hy >= 0) ? y : zero;
        -:  198:      }
        -:  199:      else /* (|x|<1)**-,+inf = inf,0 */
        -:  200:      {
    #####:  201:        return (hy < 0) ? -y : zero;
        -:  202:      }
        -:  203:    }
    #####:  204:    if (iy == 0x3ff00000) /* y is +-1 */
        -:  205:    {
    #####:  206:      if (hy < 0)
        -:  207:      {
    #####:  208:        return one / x;
        -:  209:      }
        -:  210:      else
        -:  211:      {
        -:  212:        return x;
        -:  213:      }
        -:  214:    }
    #####:  215:    if (hy == 0x40000000) /* y is 2 */
        -:  216:    {
    #####:  217:      return x * x;
        -:  218:    }
    #####:  219:    if (hy == 0x3fe00000) /* y is 0.5 */
        -:  220:    {
    #####:  221:      if (hx >= 0) /* x >= +0 */
        -:  222:      {
    #####:  223:        return sqrt (x);
        -:  224:      }
        -:  225:    }
        -:  226:  }
        -:  227:
    #####:  228:  ax.dbl = fabs (x);
        -:  229:  /* special value of x */
    #####:  230:  if (lx == 0)
        -:  231:  {
    #####:  232:    if (ix == 0x7ff00000 || ix == 0 || ix == 0x3ff00000)
        -:  233:    {
    #####:  234:      z.dbl = ax.dbl; /* x is +-0,+-inf,+-1 */
    #####:  235:      if (hy < 0)
        -:  236:      {
    #####:  237:        z.dbl = one / z.dbl; /* z = (1 / |x|) */
        -:  238:      }
    #####:  239:      if (hx < 0)
        -:  240:      {
    #####:  241:        if (((ix - 0x3ff00000) | yisint) == 0)
        -:  242:        {
    #####:  243:          z.dbl = NAN; /* (-1)**non-int is NaN */
        -:  244:        }
    #####:  245:        else if (yisint == 1)
        -:  246:        {
    #####:  247:          z.dbl = -z.dbl; /* (x<0)**odd = -(|x|**odd) */
        -:  248:        }
        -:  249:      }
    #####:  250:      return z.dbl;
        -:  251:    }
        -:  252:  }
        -:  253:
    #####:  254:  n = (hx < 0) ? 0 : 1;
        -:  255:
        -:  256:  /* (x<0)**(non-int) is NaN */
    #####:  257:  if ((n | yisint) == 0)
        -:  258:  {
    #####:  259:    return NAN;
        -:  260:  }
        -:  261:
    #####:  262:  s = one; /* s (sign of result -ve**odd) = -1 else = 1 */
    #####:  263:  if ((n | (yisint - 1)) == 0)
        -:  264:  {
    #####:  265:    s = -one; /* (-ve)**(odd int) */
        -:  266:  }
        -:  267:
        -:  268:  /* |y| is huge */
    #####:  269:  if (iy > 0x41e00000) /* if |y| > 2**31 */
        -:  270:  {
    #####:  271:    if (iy > 0x43f00000) /* if |y| > 2**64, must o/uflow */
        -:  272:    {
    #####:  273:      if (ix <= 0x3fefffff)
        -:  274:      {
    #####:  275:        return (hy < 0) ? huge * huge : tiny * tiny;
        -:  276:      }
        -:  277:      if (ix >= 0x3ff00000)
        -:  278:      {
    #####:  279:        return (hy > 0) ? huge * huge : tiny * tiny;
        -:  280:      }
        -:  281:    }
        -:  282:    /* over/underflow if x is not close to one */
    #####:  283:    if (ix < 0x3fefffff)
        -:  284:    {
    #####:  285:      return (hy < 0) ? s * huge * huge : s * tiny * tiny;
        -:  286:    }
    #####:  287:    if (ix > 0x3ff00000)
        -:  288:    {
    #####:  289:      return (hy > 0) ? s * huge * huge : s * tiny * tiny;
        -:  290:    }
        -:  291:    /* now |1 - x| is tiny <= 2**-20, suffice to compute
        -:  292:       log(x) by x - x^2 / 2 + x^3 / 3 - x^4 / 4 */
    #####:  293:    t.dbl = ax.dbl - one; /* t has 20 trailing zeros */
    #####:  294:    w = (t.dbl * t.dbl) * (0.5 - t.dbl * (0.3333333333333333333333 - t.dbl * 0.25));
    #####:  295:    u = ivln2_h * t.dbl; /* ivln2_h has 21 sig. bits */
    #####:  296:    v = t.dbl * ivln2_l - w * ivln2;
    #####:  297:    t1.dbl = u + v;
    #####:  298:    t1.as_int.lo = 0;
    #####:  299:    t2 = v - (t1.dbl - u);
        -:  300:  }
        -:  301:  else
        -:  302:  {
        -:  303:    double_accessor s_h, t_h;
        -:  304:    double ss, s2, s_l, t_l;
        -:  305:
    #####:  306:    n = 0;
        -:  307:    /* take care subnormal number */
    #####:  308:    if (ix < 0x00100000)
        -:  309:    {
    #####:  310:      ax.dbl *= two53;
    #####:  311:      n -= 53;
    #####:  312:      ix = ax.as_int.hi;
        -:  313:    }
    #####:  314:    n += ((ix) >> 20) - 0x3ff;
    #####:  315:    j = ix & 0x000fffff;
        -:  316:    /* determine interval */
    #####:  317:    ix = j | 0x3ff00000; /* normalize ix */
    #####:  318:    if (j <= 0x3988E) /* |x| < sqrt(3/2) */
        -:  319:    {
        -:  320:      k = 0;
        -:  321:    }
    #####:  322:    else if (j < 0xBB67A) /* |x| < sqrt(3) */
        -:  323:    {
        -:  324:      k = 1;
        -:  325:    }
        -:  326:    else
        -:  327:    {
    #####:  328:      k = 0;
    #####:  329:      n += 1;
    #####:  330:      ix -= 0x00100000;
        -:  331:    }
    #####:  332:    ax.as_int.hi = ix;
        -:  333:
        -:  334:    /* compute ss = s_h + s_l = (x - 1) / (x + 1) or (x - 1.5) / (x + 1.5) */
    #####:  335:    u = ax.dbl - bp[k]; /* bp[0] = 1.0, bp[1] = 1.5 */
    #####:  336:    v = one / (ax.dbl + bp[k]);
    #####:  337:    ss = u * v;
    #####:  338:    s_h.dbl = ss;
    #####:  339:    s_h.as_int.lo = 0;
        -:  340:    /* t_h = ax + bp[k] High */
    #####:  341:    t_h.dbl = zero;
    #####:  342:    t_h.as_int.hi = ((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18);
    #####:  343:    t_l = ax.dbl - (t_h.dbl - bp[k]);
    #####:  344:    s_l = v * ((u - s_h.dbl * t_h.dbl) - s_h.dbl * t_l);
        -:  345:    /* compute log(ax) */
    #####:  346:    s2 = ss * ss;
    #####:  347:    r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
    #####:  348:    r += s_l * (s_h.dbl + ss);
    #####:  349:    s2 = s_h.dbl * s_h.dbl;
    #####:  350:    t_h.dbl = 3.0 + s2 + r;
    #####:  351:    t_h.as_int.lo = 0;
    #####:  352:    t_l = r - ((t_h.dbl - 3.0) - s2);
        -:  353:    /* u + v = ss * (1 + ...) */
    #####:  354:    u = s_h.dbl * t_h.dbl;
    #####:  355:    v = s_l * t_h.dbl + t_l * ss;
        -:  356:    /* 2 / (3 * log2) * (ss + ...) */
    #####:  357:    p_h.dbl = u + v;
    #####:  358:    p_h.as_int.lo = 0;
    #####:  359:    p_l = v - (p_h.dbl - u);
    #####:  360:    z_h = cp_h * p_h.dbl; /* cp_h + cp_l = 2 / (3 * log2) */
    #####:  361:    z_l = cp_l * p_h.dbl + p_l * cp + dp_l[k];
        -:  362:    /* log2(ax) = (ss + ...) * 2 / (3 * log2) = n + dp_h + z_h + z_l */
    #####:  363:    t.dbl = (double) n;
    #####:  364:    t1.dbl = (((z_h + z_l) + dp_h[k]) + t.dbl);
    #####:  365:    t1.as_int.lo = 0;
    #####:  366:    t2 = z_l - (((t1.dbl - t.dbl) - dp_h[k]) - z_h);
        -:  367:  }
        -:  368:
        -:  369:  /* split up y into y1 + y2 and compute (y1 + y2) * (t1 + t2) */
    #####:  370:  y1.dbl = y;
    #####:  371:  y1.as_int.lo = 0;
    #####:  372:  p_l = (y - y1.dbl) * t1.dbl + y * t2;
    #####:  373:  p_h.dbl = y1.dbl * t1.dbl;
    #####:  374:  z.dbl = p_l + p_h.dbl;
    #####:  375:  j = z.as_int.hi;
    #####:  376:  i = z.as_int.lo;
    #####:  377:  if (j >= 0x40900000) /* z >= 1024 */
        -:  378:  {
    #####:  379:    if (((j - 0x40900000) | i) != 0) /* if z > 1024 */
        -:  380:    {
    #####:  381:      return s * huge * huge; /* overflow */
        -:  382:    }
        -:  383:    else
        -:  384:    {
    #####:  385:      if (p_l + ovt > z.dbl - p_h.dbl)
        -:  386:      {
    #####:  387:        return s * huge * huge; /* overflow */
        -:  388:      }
        -:  389:    }
        -:  390:  }
    #####:  391:  else if ((j & 0x7fffffff) >= 0x4090cc00) /* z <= -1075 */
        -:  392:  {
    #####:  393:    if (((j - 0xc090cc00) | i) != 0) /* z < -1075 */
        -:  394:    {
    #####:  395:      return s * tiny * tiny; /* underflow */
        -:  396:    }
        -:  397:    else
        -:  398:    {
    #####:  399:      if (p_l <= z.dbl - p_h.dbl)
        -:  400:      {
    #####:  401:        return s * tiny * tiny; /* underflow */
        -:  402:      }
        -:  403:    }
        -:  404:  }
        -:  405:  /*
        -:  406:   * compute 2**(p_h + p_l)
        -:  407:   */
    #####:  408:  i = j & 0x7fffffff;
    #####:  409:  k = (i >> 20) - 0x3ff;
    #####:  410:  n = 0;
    #####:  411:  if (i > 0x3fe00000) /* if |z| > 0.5, set n = [z + 0.5] */
        -:  412:  {
    #####:  413:    n = j + (0x00100000 >> (k + 1));
    #####:  414:    k = ((n & 0x7fffffff) >> 20) - 0x3ff; /* new k for n */
    #####:  415:    t.dbl = zero;
    #####:  416:    t.as_int.hi = (n & ~(0x000fffff >> k));
    #####:  417:    n = ((n & 0x000fffff) | 0x00100000) >> (20 - k);
    #####:  418:    if (j < 0)
        -:  419:    {
    #####:  420:      n = -n;
        -:  421:    }
    #####:  422:    p_h.dbl -= t.dbl;
        -:  423:  }
    #####:  424:  t.dbl = p_l + p_h.dbl;
    #####:  425:  t.as_int.lo = 0;
    #####:  426:  u = t.dbl * lg2_h;
    #####:  427:  v = (p_l - (t.dbl - p_h.dbl)) * lg2 + t.dbl * lg2_l;
    #####:  428:  z.dbl = u + v;
    #####:  429:  w = v - (z.dbl - u);
    #####:  430:  t.dbl = z.dbl * z.dbl;
    #####:  431:  t1.dbl = z.dbl - t.dbl * (P1 + t.dbl * (P2 + t.dbl * (P3 + t.dbl * (P4 + t.dbl * P5))));
    #####:  432:  r = (z.dbl * t1.dbl) / (t1.dbl - two) - (w + z.dbl * w);
    #####:  433:  z.dbl = one - (r - z.dbl);
    #####:  434:  j = z.as_int.hi;
    #####:  435:  j += (n << 20);
    #####:  436:  if ((j >> 20) <= 0) /* subnormal output */
        -:  437:  {
    #####:  438:    z.dbl = scalbn (z.dbl, n);
        -:  439:  }
        -:  440:  else
        -:  441:  {
    #####:  442:    z.as_int.hi += (n << 20);
        -:  443:  }
    #####:  444:  return s * z.dbl;
        -:  445:} /* pow */
        -:  446:
        -:  447:#undef zero
        -:  448:#undef one
        -:  449:#undef two
        -:  450:#undef two53
        -:  451:#undef huge
        -:  452:#undef tiny
        -:  453:#undef L1
        -:  454:#undef L2
        -:  455:#undef L3
        -:  456:#undef L4
        -:  457:#undef L5
        -:  458:#undef L6
        -:  459:#undef P1
        -:  460:#undef P2
        -:  461:#undef P3
        -:  462:#undef P4
        -:  463:#undef P5
        -:  464:#undef lg2
        -:  465:#undef lg2_h
        -:  466:#undef lg2_l
        -:  467:#undef ovt
        -:  468:#undef cp
        -:  469:#undef cp_h
        -:  470:#undef cp_l
        -:  471:#undef ivln2
        -:  472:#undef ivln2_h
        -:  473:#undef ivln2_l
