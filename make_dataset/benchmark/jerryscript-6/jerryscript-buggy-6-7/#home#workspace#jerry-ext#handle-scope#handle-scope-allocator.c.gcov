        -:    0:Source:/home/workspace/jerry-ext/handle-scope/handle-scope-allocator.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:#include "handle-scope-internal.h"
        -:   19:#include "jext-common.h"
        -:   20:
        -:   21:static jerryx_handle_scope_t jerryx_handle_scope_root = {
        -:   22:  .prelist_handle_count = 0,
        -:   23:  .handle_ptr = NULL,
        -:   24:};
        -:   25:static jerryx_handle_scope_t *jerryx_handle_scope_current = &jerryx_handle_scope_root;
        -:   26:static jerryx_handle_scope_pool_t jerryx_handle_scope_pool = {
        -:   27:  .count = 0,
        -:   28:  .start = NULL,
        -:   29:};
        -:   30:
        -:   31:#define JERRYX_HANDLE_SCOPE_POOL_PRELIST_LAST jerryx_handle_scope_pool.prelist + JERRYX_SCOPE_PRELIST_SIZE - 1
        -:   32:
        -:   33:#define JERRYX_HANDLE_SCOPE_PRELIST_IDX(scope) (scope - jerryx_handle_scope_pool.prelist)
        -:   34:
        -:   35:/**
        -:   36: * Get current handle scope top of stack.
        -:   37: */
        -:   38:jerryx_handle_scope_t *
    #####:   39:jerryx_handle_scope_get_current (void)
        -:   40:{
    #####:   41:  return jerryx_handle_scope_current;
        -:   42:} /* jerryx_handle_scope_get_current */
        -:   43:
        -:   44:/**
        -:   45: * Get root handle scope.
        -:   46: */
        -:   47:jerryx_handle_scope_t *
    #####:   48:jerryx_handle_scope_get_root (void)
        -:   49:{
    #####:   50:  return &jerryx_handle_scope_root;
        -:   51:} /* jerryx_handle_scope_get_root */
        -:   52:
        -:   53:/**
        -:   54: * Determines if given handle scope is located in pre-allocated list.
        -:   55: *
        -:   56: * @param scope - the one to be determined.
        -:   57: */
        -:   58:static bool
    #####:   59:jerryx_handle_scope_is_in_prelist (jerryx_handle_scope_t *scope)
        -:   60:{
        -:   61:  return (jerryx_handle_scope_pool.prelist <= scope)
    #####:   62:         && (scope <= (jerryx_handle_scope_pool.prelist + JERRYX_SCOPE_PRELIST_SIZE - 1));
        -:   63:} /* jerryx_handle_scope_is_in_prelist */
        -:   64:
        -:   65:/**
        -:   66: * Get the parent of given handle scope.
        -:   67: * If given handle scope is in prelist, the parent must be in prelist too;
        -:   68: * if given is the first item of heap chain list, the parent must be the last one of prelist;
        -:   69: * the parent must be in chain list otherwise.
        -:   70: *
        -:   71: * @param scope - the one to be permformed on.
        -:   72: * @returns - the parent of the given scope.
        -:   73: */
        -:   74:jerryx_handle_scope_t *
    #####:   75:jerryx_handle_scope_get_parent (jerryx_handle_scope_t *scope)
        -:   76:{
    #####:   77:  if (scope == &jerryx_handle_scope_root)
        -:   78:  {
    #####:   79:    return NULL;
        -:   80:  }
    #####:   81:  if (!jerryx_handle_scope_is_in_prelist (scope))
        -:   82:  {
    #####:   83:    jerryx_handle_scope_dynamic_t *dy_scope = (jerryx_handle_scope_dynamic_t *) scope;
    #####:   84:    if (dy_scope == jerryx_handle_scope_pool.start)
        -:   85:    {
    #####:   86:      return JERRYX_HANDLE_SCOPE_POOL_PRELIST_LAST;
        -:   87:    }
    #####:   88:    jerryx_handle_scope_dynamic_t *parent = dy_scope->parent;
    #####:   89:    return (jerryx_handle_scope_t *) parent;
        -:   90:  }
    #####:   91:  if (scope == jerryx_handle_scope_pool.prelist)
        -:   92:  {
    #####:   93:    return &jerryx_handle_scope_root;
        -:   94:  }
    #####:   95:  return jerryx_handle_scope_pool.prelist + JERRYX_HANDLE_SCOPE_PRELIST_IDX (scope) - 1;
        -:   96:} /* jerryx_handle_scope_get_parent */
        -:   97:
        -:   98:/**
        -:   99: * Get the child of given handle scope.
        -:  100: * If the given handle scope is in heap chain list, its child must be in heap chain list too;
        -:  101: * if the given handle scope is the last one of prelist, its child must be the first item of chain list;
        -:  102: * the children are in prelist otherwise.
        -:  103: *
        -:  104: * @param scope - the one to be permformed on.
        -:  105: * @returns the child of the given scope.
        -:  106: */
        -:  107:jerryx_handle_scope_t *
    #####:  108:jerryx_handle_scope_get_child (jerryx_handle_scope_t *scope)
        -:  109:{
    #####:  110:  if (scope == &jerryx_handle_scope_root)
        -:  111:  {
    #####:  112:    if (jerryx_handle_scope_pool.count > 0)
        -:  113:    {
    #####:  114:      return jerryx_handle_scope_pool.prelist;
        -:  115:    }
    #####:  116:    return NULL;
        -:  117:  }
    #####:  118:  if (!jerryx_handle_scope_is_in_prelist (scope))
        -:  119:  {
    #####:  120:    jerryx_handle_scope_dynamic_t *child = ((jerryx_handle_scope_dynamic_t *) scope)->child;
    #####:  121:    return (jerryx_handle_scope_t *) child;
        -:  122:  }
    #####:  123:  if (scope == JERRYX_HANDLE_SCOPE_POOL_PRELIST_LAST)
        -:  124:  {
    #####:  125:    return (jerryx_handle_scope_t *) jerryx_handle_scope_pool.start;
        -:  126:  }
    #####:  127:  ptrdiff_t idx = JERRYX_HANDLE_SCOPE_PRELIST_IDX (scope);
    #####:  128:  if (idx < 0)
        -:  129:  {
    #####:  130:    return NULL;
        -:  131:  }
    #####:  132:  if ((unsigned long) idx >= jerryx_handle_scope_pool.count - 1)
        -:  133:  {
    #####:  134:    return NULL;
        -:  135:  }
    #####:  136:  return jerryx_handle_scope_pool.prelist + idx + 1;
        -:  137:} /* jerryx_handle_scope_get_child */
        -:  138:
        -:  139:/**
        -:  140: * Claims a handle scope either from prelist or allocating a new memory block,
        -:  141: * and increment pool's scope count by 1, and set current scope to the newly claimed one.
        -:  142: * If there are still available spaces in prelist, claims a block in prelist;
        -:  143: * otherwise allocates a new memory block from heap and sets its fields to default values,
        -:  144: * and link it to previously dynamically allocated scope, or link it to pool's start pointer.
        -:  145: *
        -:  146: * @returns the newly claimed handle scope pointer.
        -:  147: */
        -:  148:jerryx_handle_scope_t *
    #####:  149:jerryx_handle_scope_alloc (void)
        -:  150:{
        -:  151:  jerryx_handle_scope_t *scope;
    #####:  152:  if (jerryx_handle_scope_pool.count < JERRYX_SCOPE_PRELIST_SIZE)
        -:  153:  {
    #####:  154:    scope = jerryx_handle_scope_pool.prelist + jerryx_handle_scope_pool.count;
        -:  155:  }
        -:  156:  else
        -:  157:  {
        -:  158:    jerryx_handle_scope_dynamic_t *dy_scope;
    #####:  159:    dy_scope = (jerryx_handle_scope_dynamic_t *) jerry_heap_alloc (sizeof (jerryx_handle_scope_dynamic_t));
    #####:  160:    JERRYX_ASSERT (dy_scope != NULL);
    #####:  161:    dy_scope->child = NULL;
        -:  162:
    #####:  163:    if (jerryx_handle_scope_pool.count != JERRYX_SCOPE_PRELIST_SIZE)
        -:  164:    {
    #####:  165:      jerryx_handle_scope_dynamic_t *dy_current = (jerryx_handle_scope_dynamic_t *) jerryx_handle_scope_current;
    #####:  166:      dy_scope->parent = dy_current;
    #####:  167:      dy_current->child = dy_scope;
        -:  168:    }
        -:  169:    else
        -:  170:    {
    #####:  171:      jerryx_handle_scope_pool.start = dy_scope;
    #####:  172:      dy_scope->parent = NULL;
        -:  173:    }
        -:  174:
    #####:  175:    scope = (jerryx_handle_scope_t *) dy_scope;
        -:  176:  }
        -:  177:
    #####:  178:  scope->prelist_handle_count = 0;
    #####:  179:  scope->escaped = false;
    #####:  180:  scope->handle_ptr = NULL;
        -:  181:
    #####:  182:  jerryx_handle_scope_current = scope;
    #####:  183:  ++jerryx_handle_scope_pool.count;
    #####:  184:  return (jerryx_handle_scope_t *) scope;
        -:  185:} /* jerryx_handle_scope_alloc */
        -:  186:
        -:  187:/**
        -:  188: * Deannounce a previously claimed handle scope, return it to pool
        -:  189: * or free the allocated memory block.
        -:  190: *
        -:  191: * @param scope - the one to be freed.
        -:  192: */
        -:  193:void
    #####:  194:jerryx_handle_scope_free (jerryx_handle_scope_t *scope)
        -:  195:{
    #####:  196:  if (scope == &jerryx_handle_scope_root)
        -:  197:  {
    #####:  198:    return;
        -:  199:  }
        -:  200:
    #####:  201:  --jerryx_handle_scope_pool.count;
    #####:  202:  if (scope == jerryx_handle_scope_current)
        -:  203:  {
    #####:  204:    jerryx_handle_scope_current = jerryx_handle_scope_get_parent (scope);
        -:  205:  }
        -:  206:
    #####:  207:  if (!jerryx_handle_scope_is_in_prelist (scope))
        -:  208:  {
    #####:  209:    jerryx_handle_scope_dynamic_t *dy_scope = (jerryx_handle_scope_dynamic_t *) scope;
    #####:  210:    if (dy_scope == jerryx_handle_scope_pool.start)
        -:  211:    {
    #####:  212:      jerryx_handle_scope_pool.start = dy_scope->child;
        -:  213:    }
    #####:  214:    else if (dy_scope->parent != NULL)
        -:  215:    {
    #####:  216:      dy_scope->parent->child = dy_scope->child;
        -:  217:    }
    #####:  218:    jerry_heap_free (dy_scope, sizeof (jerryx_handle_scope_dynamic_t));
    #####:  219:    return;
        -:  220:  }
        -:  221:  /**
        -:  222:   * Nothing to do with scopes in prelist
        -:  223:   */
        -:  224:} /* jerryx_handle_scope_free */
