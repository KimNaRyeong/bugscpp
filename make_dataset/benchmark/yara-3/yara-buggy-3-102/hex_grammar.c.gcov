        -:    0:Source:hex_grammar.c
        -:    0:Graph:/home/workspace/libyara/hex_grammar.gcno
        -:    0:Data:/home/workspace/libyara/hex_grammar.gcda
        -:    0:Runs:8
        -:    1:/* A Bison parser, made by GNU Bison 3.5.1.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
        -:    6:   Inc.
        -:    7:
        -:    8:   This program is free software: you can redistribute it and/or modify
        -:    9:   it under the terms of the GNU General Public License as published by
        -:   10:   the Free Software Foundation, either version 3 of the License, or
        -:   11:   (at your option) any later version.
        -:   12:
        -:   13:   This program is distributed in the hope that it will be useful,
        -:   14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:   GNU General Public License for more details.
        -:   17:
        -:   18:   You should have received a copy of the GNU General Public License
        -:   19:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   20:
        -:   21:/* As a special exception, you may create a larger work that contains
        -:   22:   part or all of the Bison parser skeleton and distribute that work
        -:   23:   under terms of your choice, so long as that work isn't itself a
        -:   24:   parser generator using the skeleton or a modified version thereof
        -:   25:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   26:   the parser skeleton itself, you may (at your option) remove this
        -:   27:   special exception, which will cause the skeleton and the resulting
        -:   28:   Bison output files to be licensed under the GNU General Public
        -:   29:   License without this special exception.
        -:   30:
        -:   31:   This special exception was added by the Free Software Foundation in
        -:   32:   version 2.2 of Bison.  */
        -:   33:
        -:   34:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   35:   simplifying the original so-called "semantic" parser.  */
        -:   36:
        -:   37:/* All symbols defined below should begin with yy or YY, to avoid
        -:   38:   infringing on user name space.  This should be done even for local
        -:   39:   variables, as they might otherwise be expanded by user macros.
        -:   40:   There are some unavoidable exceptions within include files to
        -:   41:   define necessary library symbols; they are noted "INFRINGES ON
        -:   42:   USER NAME SPACE" below.  */
        -:   43:
        -:   44:/* Undocumented macros, especially those whose name start with YY_,
        -:   45:   are private implementation details.  Do not rely on them.  */
        -:   46:
        -:   47:/* Identify Bison output.  */
        -:   48:#define YYBISON 1
        -:   49:
        -:   50:/* Bison version.  */
        -:   51:#define YYBISON_VERSION "3.5.1"
        -:   52:
        -:   53:/* Skeleton name.  */
        -:   54:#define YYSKELETON_NAME "yacc.c"
        -:   55:
        -:   56:/* Pure parsers.  */
        -:   57:#define YYPURE 1
        -:   58:
        -:   59:/* Push parsers.  */
        -:   60:#define YYPUSH 0
        -:   61:
        -:   62:/* Pull parsers.  */
        -:   63:#define YYPULL 1
        -:   64:
        -:   65:
        -:   66:/* Substitute the variable and function names.  */
        -:   67:#define yyparse         hex_yyparse
        -:   68:#define yylex           hex_yylex
        -:   69:#define yyerror         hex_yyerror
        -:   70:#define yydebug         hex_yydebug
        -:   71:#define yynerrs         hex_yynerrs
        -:   72:
        -:   73:/* First part of user prologue.  */
        -:   74:#line 30 "hex_grammar.y"
        -:   75:
        -:   76:
        -:   77:#include <string.h>
        -:   78:#include <limits.h>
        -:   79:
        -:   80:#include <yara/integers.h>
        -:   81:#include <yara/utils.h>
        -:   82:#include <yara/hex_lexer.h>
        -:   83:#include <yara/limits.h>
        -:   84:#include <yara/mem.h>
        -:   85:#include <yara/error.h>
        -:   86:
        -:   87:
        -:   88:#define STR_EXPAND(tok) #tok
        -:   89:#define STR(tok) STR_EXPAND(tok)
        -:   90:
        -:   91:#define YYERROR_VERBOSE
        -:   92:
        -:   93:#define YYMALLOC yr_malloc
        -:   94:#define YYFREE yr_free
        -:   95:
        -:   96:#define mark_as_not_fast_regexp() \
        -:   97:    ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP
        -:   98:
        -:   99:#define fail_if(x, error) \
        -:  100:    if (x) \
        -:  101:    { \
        -:  102:      lex_env->last_error = error; \
        -:  103:      YYABORT; \
        -:  104:    } \
        -:  105:
        -:  106:#define destroy_node_if(x, node) \
        -:  107:    if (x) \
        -:  108:    { \
        -:  109:      yr_re_node_destroy(node); \
        -:  110:    } \
        -:  111:
        -:  112:
        -:  113:#line 114 "hex_grammar.c"
        -:  114:
        -:  115:# ifndef YY_CAST
        -:  116:#  ifdef __cplusplus
        -:  117:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  118:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  119:#  else
        -:  120:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  121:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  122:#  endif
        -:  123:# endif
        -:  124:# ifndef YY_NULLPTR
        -:  125:#  if defined __cplusplus
        -:  126:#   if 201103L <= __cplusplus
        -:  127:#    define YY_NULLPTR nullptr
        -:  128:#   else
        -:  129:#    define YY_NULLPTR 0
        -:  130:#   endif
        -:  131:#  else
        -:  132:#   define YY_NULLPTR ((void*)0)
        -:  133:#  endif
        -:  134:# endif
        -:  135:
        -:  136:/* Enabling verbose error messages.  */
        -:  137:#ifdef YYERROR_VERBOSE
        -:  138:# undef YYERROR_VERBOSE
        -:  139:# define YYERROR_VERBOSE 1
        -:  140:#else
        -:  141:# define YYERROR_VERBOSE 0
        -:  142:#endif
        -:  143:
        -:  144:/* Use api.header.include to #include this header
        -:  145:   instead of duplicating it here.  */
        -:  146:#ifndef YY_HEX_YY_HEX_GRAMMAR_H_INCLUDED
        -:  147:# define YY_HEX_YY_HEX_GRAMMAR_H_INCLUDED
        -:  148:/* Debug traces.  */
        -:  149:#ifndef YYDEBUG
        -:  150:# define YYDEBUG 0
        -:  151:#endif
        -:  152:#if YYDEBUG
        -:  153:extern int hex_yydebug;
        -:  154:#endif
        -:  155:
        -:  156:/* Token type.  */
        -:  157:#ifndef YYTOKENTYPE
        -:  158:# define YYTOKENTYPE
        -:  159:  enum yytokentype
        -:  160:  {
        -:  161:    _BYTE_ = 258,
        -:  162:    _MASKED_BYTE_ = 259,
        -:  163:    _NUMBER_ = 260
        -:  164:  };
        -:  165:#endif
        -:  166:/* Tokens.  */
        -:  167:#define _BYTE_ 258
        -:  168:#define _MASKED_BYTE_ 259
        -:  169:#define _NUMBER_ 260
        -:  170:
        -:  171:/* Value type.  */
        -:  172:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  173:union YYSTYPE
        -:  174:{
        -:  175:#line 78 "hex_grammar.y"
        -:  176:
        -:  177:  int64_t integer;
        -:  178:  RE_NODE *re_node;
        -:  179:
        -:  180:#line 181 "hex_grammar.c"
        -:  181:
        -:  182:};
        -:  183:typedef union YYSTYPE YYSTYPE;
        -:  184:# define YYSTYPE_IS_TRIVIAL 1
        -:  185:# define YYSTYPE_IS_DECLARED 1
        -:  186:#endif
        -:  187:
        -:  188:
        -:  189:
        -:  190:int hex_yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env);
        -:  191:
        -:  192:#endif /* !YY_HEX_YY_HEX_GRAMMAR_H_INCLUDED  */
        -:  193:
        -:  194:
        -:  195:
        -:  196:#ifdef short
        -:  197:# undef short
        -:  198:#endif
        -:  199:
        -:  200:/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
        -:  201:   <limits.h> and (if available) <stdint.h> are included
        -:  202:   so that the code can choose integer types of a good width.  */
        -:  203:
        -:  204:#ifndef __PTRDIFF_MAX__
        -:  205:# include <limits.h> /* INFRINGES ON USER NAME SPACE */
        -:  206:# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  207:#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
        -:  208:#  define YY_STDINT_H
        -:  209:# endif
        -:  210:#endif
        -:  211:
        -:  212:/* Narrow types that promote to a signed type and that can represent a
        -:  213:   signed or unsigned integer of at least N bits.  In tables they can
        -:  214:   save space and decrease cache pressure.  Promoting to a signed type
        -:  215:   helps avoid bugs in integer arithmetic.  */
        -:  216:
        -:  217:#ifdef __INT_LEAST8_MAX__
        -:  218:typedef __INT_LEAST8_TYPE__ yytype_int8;
        -:  219:#elif defined YY_STDINT_H
        -:  220:typedef int_least8_t yytype_int8;
        -:  221:#else
        -:  222:typedef signed char yytype_int8;
        -:  223:#endif
        -:  224:
        -:  225:#ifdef __INT_LEAST16_MAX__
        -:  226:typedef __INT_LEAST16_TYPE__ yytype_int16;
        -:  227:#elif defined YY_STDINT_H
        -:  228:typedef int_least16_t yytype_int16;
        -:  229:#else
        -:  230:typedef short yytype_int16;
        -:  231:#endif
        -:  232:
        -:  233:#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
        -:  234:typedef __UINT_LEAST8_TYPE__ yytype_uint8;
        -:  235:#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
        -:  236:       && UINT_LEAST8_MAX <= INT_MAX)
        -:  237:typedef uint_least8_t yytype_uint8;
        -:  238:#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
        -:  239:typedef unsigned char yytype_uint8;
        -:  240:#else
        -:  241:typedef short yytype_uint8;
        -:  242:#endif
        -:  243:
        -:  244:#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
        -:  245:typedef __UINT_LEAST16_TYPE__ yytype_uint16;
        -:  246:#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
        -:  247:       && UINT_LEAST16_MAX <= INT_MAX)
        -:  248:typedef uint_least16_t yytype_uint16;
        -:  249:#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
        -:  250:typedef unsigned short yytype_uint16;
        -:  251:#else
        -:  252:typedef int yytype_uint16;
        -:  253:#endif
        -:  254:
        -:  255:#ifndef YYPTRDIFF_T
        -:  256:# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
        -:  257:#  define YYPTRDIFF_T __PTRDIFF_TYPE__
        -:  258:#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
        -:  259:# elif defined PTRDIFF_MAX
        -:  260:#  ifndef ptrdiff_t
        -:  261:#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  262:#  endif
        -:  263:#  define YYPTRDIFF_T ptrdiff_t
        -:  264:#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
        -:  265:# else
        -:  266:#  define YYPTRDIFF_T long
        -:  267:#  define YYPTRDIFF_MAXIMUM LONG_MAX
        -:  268:# endif
        -:  269:#endif
        -:  270:
        -:  271:#ifndef YYSIZE_T
        -:  272:# ifdef __SIZE_TYPE__
        -:  273:#  define YYSIZE_T __SIZE_TYPE__
        -:  274:# elif defined size_t
        -:  275:#  define YYSIZE_T size_t
        -:  276:# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  277:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  278:#  define YYSIZE_T size_t
        -:  279:# else
        -:  280:#  define YYSIZE_T unsigned
        -:  281:# endif
        -:  282:#endif
        -:  283:
        -:  284:#define YYSIZE_MAXIMUM                                  \
        -:  285:  YY_CAST (YYPTRDIFF_T,                                 \
        -:  286:           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
        -:  287:            ? YYPTRDIFF_MAXIMUM                         \
        -:  288:            : YY_CAST (YYSIZE_T, -1)))
        -:  289:
        -:  290:#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
        -:  291:
        -:  292:/* Stored state numbers (used for stacks). */
        -:  293:typedef yytype_int8 yy_state_t;
        -:  294:
        -:  295:/* State numbers in computations.  */
        -:  296:typedef int yy_state_fast_t;
        -:  297:
        -:  298:#ifndef YY_
        -:  299:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  300:#  if ENABLE_NLS
        -:  301:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  302:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  303:#  endif
        -:  304:# endif
        -:  305:# ifndef YY_
        -:  306:#  define YY_(Msgid) Msgid
        -:  307:# endif
        -:  308:#endif
        -:  309:
        -:  310:#ifndef YY_ATTRIBUTE_PURE
        -:  311:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  312:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  313:# else
        -:  314:#  define YY_ATTRIBUTE_PURE
        -:  315:# endif
        -:  316:#endif
        -:  317:
        -:  318:#ifndef YY_ATTRIBUTE_UNUSED
        -:  319:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  320:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  321:# else
        -:  322:#  define YY_ATTRIBUTE_UNUSED
        -:  323:# endif
        -:  324:#endif
        -:  325:
        -:  326:/* Suppress unused-variable warnings by "using" E.  */
        -:  327:#if ! defined lint || defined __GNUC__
        -:  328:# define YYUSE(E) ((void) (E))
        -:  329:#else
        -:  330:# define YYUSE(E) /* empty */
        -:  331:#endif
        -:  332:
        -:  333:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  334:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  335:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  336:    _Pragma ("GCC diagnostic push")                                     \
        -:  337:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  338:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  339:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  340:    _Pragma ("GCC diagnostic pop")
        -:  341:#else
        -:  342:# define YY_INITIAL_VALUE(Value) Value
        -:  343:#endif
        -:  344:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  345:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  346:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  347:#endif
        -:  348:#ifndef YY_INITIAL_VALUE
        -:  349:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  350:#endif
        -:  351:
        -:  352:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  353:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  354:    _Pragma ("GCC diagnostic push")                            \
        -:  355:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  356:# define YY_IGNORE_USELESS_CAST_END            \
        -:  357:    _Pragma ("GCC diagnostic pop")
        -:  358:#endif
        -:  359:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  360:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  361:# define YY_IGNORE_USELESS_CAST_END
        -:  362:#endif
        -:  363:
        -:  364:
        -:  365:#define YY_ASSERT(E) ((void) (0 && (E)))
        -:  366:
        -:  367:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  368:
        -:  369:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  370:
        -:  371:# ifdef YYSTACK_USE_ALLOCA
        -:  372:#  if YYSTACK_USE_ALLOCA
        -:  373:#   ifdef __GNUC__
        -:  374:#    define YYSTACK_ALLOC __builtin_alloca
        -:  375:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  376:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  377:#   elif defined _AIX
        -:  378:#    define YYSTACK_ALLOC __alloca
        -:  379:#   elif defined _MSC_VER
        -:  380:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  381:#    define alloca _alloca
        -:  382:#   else
        -:  383:#    define YYSTACK_ALLOC alloca
        -:  384:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  385:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  386:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  387:#     ifndef EXIT_SUCCESS
        -:  388:#      define EXIT_SUCCESS 0
        -:  389:#     endif
        -:  390:#    endif
        -:  391:#   endif
        -:  392:#  endif
        -:  393:# endif
        -:  394:
        -:  395:# ifdef YYSTACK_ALLOC
        -:  396:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  397:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  398:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  399:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  400:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  401:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  402:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  403:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  404:#  endif
        -:  405:# else
        -:  406:#  define YYSTACK_ALLOC YYMALLOC
        -:  407:#  define YYSTACK_FREE YYFREE
        -:  408:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  409:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  410:#  endif
        -:  411:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  412:       && ! ((defined YYMALLOC || defined malloc) \
        -:  413:             && (defined YYFREE || defined free)))
        -:  414:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  415:#   ifndef EXIT_SUCCESS
        -:  416:#    define EXIT_SUCCESS 0
        -:  417:#   endif
        -:  418:#  endif
        -:  419:#  ifndef YYMALLOC
        -:  420:#   define YYMALLOC malloc
        -:  421:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  422:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  423:#   endif
        -:  424:#  endif
        -:  425:#  ifndef YYFREE
        -:  426:#   define YYFREE free
        -:  427:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  428:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  429:#   endif
        -:  430:#  endif
        -:  431:# endif
        -:  432:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  433:
        -:  434:
        -:  435:#if (! defined yyoverflow \
        -:  436:     && (! defined __cplusplus \
        -:  437:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  438:
        -:  439:/* A type that is properly aligned for any stack member.  */
        -:  440:union yyalloc
        -:  441:{
        -:  442:  yy_state_t yyss_alloc;
        -:  443:  YYSTYPE yyvs_alloc;
        -:  444:};
        -:  445:
        -:  446:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  447:# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
        -:  448:
        -:  449:/* The size of an array large to enough to hold all stacks, each with
        -:  450:   N elements.  */
        -:  451:# define YYSTACK_BYTES(N) \
        -:  452:     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
        -:  453:      + YYSTACK_GAP_MAXIMUM)
        -:  454:
        -:  455:# define YYCOPY_NEEDED 1
        -:  456:
        -:  457:/* Relocate STACK from its old location to the new one.  The
        -:  458:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  459:   elements in the stack, and YYPTR gives the new location of the
        -:  460:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  461:   stack.  */
        -:  462:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  463:    do                                                                  \
        -:  464:      {                                                                 \
        -:  465:        YYPTRDIFF_T yynewbytes;                                         \
        -:  466:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  467:        Stack = &yyptr->Stack_alloc;                                    \
        -:  468:        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  469:        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
        -:  470:      }                                                                 \
        -:  471:    while (0)
        -:  472:
        -:  473:#endif
        -:  474:
        -:  475:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  476:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  477:   not overlap.  */
        -:  478:# ifndef YYCOPY
        -:  479:#  if defined __GNUC__ && 1 < __GNUC__
        -:  480:#   define YYCOPY(Dst, Src, Count) \
        -:  481:      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
        -:  482:#  else
        -:  483:#   define YYCOPY(Dst, Src, Count)              \
        -:  484:      do                                        \
        -:  485:        {                                       \
        -:  486:          YYPTRDIFF_T yyi;                      \
        -:  487:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  488:            (Dst)[yyi] = (Src)[yyi];            \
        -:  489:        }                                       \
        -:  490:      while (0)
        -:  491:#  endif
        -:  492:# endif
        -:  493:#endif /* !YYCOPY_NEEDED */
        -:  494:
        -:  495:/* YYFINAL -- State number of the termination state.  */
        -:  496:#define YYFINAL  9
        -:  497:/* YYLAST -- Last index in YYTABLE.  */
        -:  498:#define YYLAST   30
        -:  499:
        -:  500:/* YYNTOKENS -- Number of terminals.  */
        -:  501:#define YYNTOKENS  14
        -:  502:/* YYNNTS -- Number of nonterminals.  */
        -:  503:#define YYNNTS  10
        -:  504:/* YYNRULES -- Number of rules.  */
        -:  505:#define YYNRULES  20
        -:  506:/* YYNSTATES -- Number of states.  */
        -:  507:#define YYNSTATES  32
        -:  508:
        -:  509:#define YYUNDEFTOK  2
        -:  510:#define YYMAXUTOK   260
        -:  511:
        -:  512:
        -:  513:/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
        -:  514:   as returned by yylex, with out-of-bounds checking.  */
        -:  515:#define YYTRANSLATE(YYX)                                                \
        -:  516:  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  517:
        -:  518:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  519:   as returned by yylex.  */
        -:  520:static const yytype_int8 yytranslate[] =
        -:  521:{
        -:  522:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  523:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  524:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  525:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  526:       8,     9,     2,     2,     2,    12,     2,     2,     2,     2,
        -:  527:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  528:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  529:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  530:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  531:       2,    10,     2,    11,     2,     2,     2,     2,     2,     2,
        -:  532:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  533:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  534:       2,     2,     2,     6,    13,     7,     2,     2,     2,     2,
        -:  535:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  536:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  537:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  538:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  539:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  540:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  541:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  542:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  543:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  544:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  545:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  546:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  547:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  548:       5
        -:  549:};
        -:  550:
        -:  551:#if YYDEBUG
        -:  552:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  553:static const yytype_int16 yyrline[] =
        -:  554:{
        -:  555:       0,   105,   105,   114,   118,   130,   141,   150,   159,   163,
        -:  556:     172,   177,   176,   189,   212,   244,   266,   286,   290,   307,
        -:  557:     316
        -:  558:};
        -:  559:#endif
        -:  560:
        -:  561:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  562:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  563:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  564:static const char *const yytname[] =
        -:  565:{
        -:  566:  "$end", "error", "$undefined", "_BYTE_", "_MASKED_BYTE_", "_NUMBER_",
        -:  567:  "'{'", "'}'", "'('", "')'", "'['", "']'", "'-'", "'|'", "$accept",
        -:  568:  "hex_string", "tokens", "token_sequence", "token_or_range", "token",
        -:  569:  "$@1", "range", "alternatives", "byte", YY_NULLPTR
        -:  570:};
        -:  571:#endif
        -:  572:
        -:  573:# ifdef YYPRINT
        -:  574:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  575:   (internal) symbol number NUM (which must be that of a token).  */
        -:  576:static const yytype_int16 yytoknum[] =
        -:  577:{
        -:  578:       0,   256,   257,   258,   259,   260,   123,   125,    40,    41,
        -:  579:      91,    93,    45,   124
        -:  580:};
        -:  581:# endif
        -:  582:
        -:  583:#define YYPACT_NINF (-11)
        -:  584:
        -:  585:#define yypact_value_is_default(Yyn) \
        -:  586:  ((Yyn) == YYPACT_NINF)
        -:  587:
        -:  588:#define YYTABLE_NINF (-6)
        -:  589:
        -:  590:#define yytable_value_is_error(Yyn) \
        -:  591:  0
        -:  592:
        -:  593:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  594:     STATE-NUM.  */
        -:  595:static const yytype_int8 yypact[] =
        -:  596:{
        -:  597:      20,    14,    27,   -11,   -11,   -11,    21,    -2,   -11,   -11,
        -:  598:      14,   -11,    -1,    -2,   -11,    -4,   -11,   -11,    10,    13,
        -:  599:       9,   -11,     3,   -11,    14,   -11,     2,   -11,   -11,    18,
        -:  600:     -11,   -11
        -:  601:};
        -:  602:
        -:  603:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  604:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  605:     means the default is an error.  */
        -:  606:static const yytype_int8 yydefact[] =
        -:  607:{
        -:  608:       0,     0,     0,    19,    20,    11,     0,     3,    10,     1,
        -:  609:       0,     2,     0,     0,     6,     8,     9,    17,     0,     0,
        -:  610:       0,     7,     8,    12,     0,    13,     0,    16,    18,     0,
        -:  611:      15,    14
        -:  612:};
        -:  613:
        -:  614:  /* YYPGOTO[NTERM-NUM].  */
        -:  615:static const yytype_int8 yypgoto[] =
        -:  616:{
        -:  617:     -11,   -11,   -10,   -11,    17,     8,   -11,   -11,   -11,   -11
        -:  618:};
        -:  619:
        -:  620:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  621:static const yytype_int8 yydefgoto[] =
        -:  622:{
        -:  623:      -1,     2,     6,    13,    14,     7,    10,    16,    18,     8
        -:  624:};
        -:  625:
        -:  626:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  627:     positive, shift that token.  If negative, reduce the rule whose
        -:  628:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  629:static const yytype_int8 yytable[] =
        -:  630:{
        -:  631:      17,     3,     4,    -4,    19,    -4,     5,    29,    12,    -4,
        -:  632:      -5,    20,    -5,    30,    28,    15,    -5,     3,     4,    23,
        -:  633:      27,    22,     5,    24,    25,    26,     1,     9,    11,    31,
        -:  634:      21
        -:  635:};
        -:  636:
        -:  637:static const yytype_int8 yycheck[] =
        -:  638:{
        -:  639:      10,     3,     4,     7,     5,     9,     8,     5,    10,    13,
        -:  640:       7,    12,     9,    11,    24,     7,    13,     3,     4,     9,
        -:  641:      11,    13,     8,    13,    11,    12,     6,     0,     7,    11,
        -:  642:      13
        -:  643:};
        -:  644:
        -:  645:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  646:     symbol of state STATE-NUM.  */
        -:  647:static const yytype_int8 yystos[] =
        -:  648:{
        -:  649:       0,     6,    15,     3,     4,     8,    16,    19,    23,     0,
        -:  650:      20,     7,    10,    17,    18,    19,    21,    16,    22,     5,
        -:  651:      12,    18,    19,     9,    13,    11,    12,    11,    16,     5,
        -:  652:      11,    11
        -:  653:};
        -:  654:
        -:  655:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  656:static const yytype_int8 yyr1[] =
        -:  657:{
        -:  658:       0,    14,    15,    16,    16,    16,    17,    17,    18,    18,
        -:  659:      19,    20,    19,    21,    21,    21,    21,    22,    22,    23,
        -:  660:      23
        -:  661:};
        -:  662:
        -:  663:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  664:static const yytype_int8 yyr2[] =
        -:  665:{
        -:  666:       0,     2,     3,     1,     2,     3,     1,     2,     1,     1,
        -:  667:       1,     0,     4,     3,     5,     4,     3,     1,     3,     1,
        -:  668:       1
        -:  669:};
        -:  670:
        -:  671:
        -:  672:#define yyerrok         (yyerrstatus = 0)
        -:  673:#define yyclearin       (yychar = YYEMPTY)
        -:  674:#define YYEMPTY         (-2)
        -:  675:#define YYEOF           0
        -:  676:
        -:  677:#define YYACCEPT        goto yyacceptlab
        -:  678:#define YYABORT         goto yyabortlab
        -:  679:#define YYERROR         goto yyerrorlab
        -:  680:
        -:  681:
        -:  682:#define YYRECOVERING()  (!!yyerrstatus)
        -:  683:
        -:  684:#define YYBACKUP(Token, Value)                                    \
        -:  685:  do                                                              \
        -:  686:    if (yychar == YYEMPTY)                                        \
        -:  687:      {                                                           \
        -:  688:        yychar = (Token);                                         \
        -:  689:        yylval = (Value);                                         \
        -:  690:        YYPOPSTACK (yylen);                                       \
        -:  691:        yystate = *yyssp;                                         \
        -:  692:        goto yybackup;                                            \
        -:  693:      }                                                           \
        -:  694:    else                                                          \
        -:  695:      {                                                           \
        -:  696:        yyerror (yyscanner, lex_env, YY_("syntax error: cannot back up")); \
        -:  697:        YYERROR;                                                  \
        -:  698:      }                                                           \
        -:  699:  while (0)
        -:  700:
        -:  701:/* Error token number */
        -:  702:#define YYTERROR        1
        -:  703:#define YYERRCODE       256
        -:  704:
        -:  705:
        -:  706:
        -:  707:/* Enable debugging if requested.  */
        -:  708:#if YYDEBUG
        -:  709:
        -:  710:# ifndef YYFPRINTF
        -:  711:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -:  712:#  define YYFPRINTF fprintf
        -:  713:# endif
        -:  714:
        -:  715:# define YYDPRINTF(Args)                        \
        -:  716:do {                                            \
        -:  717:  if (yydebug)                                  \
        -:  718:    YYFPRINTF Args;                             \
        -:  719:} while (0)
        -:  720:
        -:  721:/* This macro is provided for backward compatibility. */
        -:  722:#ifndef YY_LOCATION_PRINT
        -:  723:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -:  724:#endif
        -:  725:
        -:  726:
        -:  727:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -:  728:do {                                                                      \
        -:  729:  if (yydebug)                                                            \
        -:  730:    {                                                                     \
        -:  731:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -:  732:      yy_symbol_print (stderr,                                            \
        -:  733:                  Type, Value, yyscanner, lex_env); \
        -:  734:      YYFPRINTF (stderr, "\n");                                           \
        -:  735:    }                                                                     \
        -:  736:} while (0)
        -:  737:
        -:  738:
        -:  739:/*-----------------------------------.
        -:  740:| Print this symbol's value on YYO.  |
        -:  741:`-----------------------------------*/
        -:  742:
        -:  743:static void
        -:  744:yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -:  745:{
        -:  746:  FILE *yyoutput = yyo;
        -:  747:  YYUSE (yyoutput);
        -:  748:  YYUSE (yyscanner);
        -:  749:  YYUSE (lex_env);
        -:  750:  if (!yyvaluep)
        -:  751:    return;
        -:  752:# ifdef YYPRINT
        -:  753:  if (yytype < YYNTOKENS)
        -:  754:    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
        -:  755:# endif
        -:  756:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  757:  YYUSE (yytype);
        -:  758:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  759:}
        -:  760:
        -:  761:
        -:  762:/*---------------------------.
        -:  763:| Print this symbol on YYO.  |
        -:  764:`---------------------------*/
        -:  765:
        -:  766:static void
        -:  767:yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -:  768:{
        -:  769:  YYFPRINTF (yyo, "%s %s (",
        -:  770:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -:  771:
        -:  772:  yy_symbol_value_print (yyo, yytype, yyvaluep, yyscanner, lex_env);
        -:  773:  YYFPRINTF (yyo, ")");
        -:  774:}
        -:  775:
        -:  776:/*------------------------------------------------------------------.
        -:  777:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -:  778:| TOP (included).                                                   |
        -:  779:`------------------------------------------------------------------*/
        -:  780:
        -:  781:static void
        -:  782:yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
        -:  783:{
        -:  784:  YYFPRINTF (stderr, "Stack now");
        -:  785:  for (; yybottom <= yytop; yybottom++)
        -:  786:    {
        -:  787:      int yybot = *yybottom;
        -:  788:      YYFPRINTF (stderr, " %d", yybot);
        -:  789:    }
        -:  790:  YYFPRINTF (stderr, "\n");
        -:  791:}
        -:  792:
        -:  793:# define YY_STACK_PRINT(Bottom, Top)                            \
        -:  794:do {                                                            \
        -:  795:  if (yydebug)                                                  \
        -:  796:    yy_stack_print ((Bottom), (Top));                           \
        -:  797:} while (0)
        -:  798:
        -:  799:
        -:  800:/*------------------------------------------------.
        -:  801:| Report that the YYRULE is going to be reduced.  |
        -:  802:`------------------------------------------------*/
        -:  803:
        -:  804:static void
        -:  805:yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -:  806:{
        -:  807:  int yylno = yyrline[yyrule];
        -:  808:  int yynrhs = yyr2[yyrule];
        -:  809:  int yyi;
        -:  810:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
        -:  811:             yyrule - 1, yylno);
        -:  812:  /* The symbols being reduced.  */
        -:  813:  for (yyi = 0; yyi < yynrhs; yyi++)
        -:  814:    {
        -:  815:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -:  816:      yy_symbol_print (stderr,
        -:  817:                       yystos[+yyssp[yyi + 1 - yynrhs]],
        -:  818:                       &yyvsp[(yyi + 1) - (yynrhs)]
        -:  819:                                              , yyscanner, lex_env);
        -:  820:      YYFPRINTF (stderr, "\n");
        -:  821:    }
        -:  822:}
        -:  823:
        -:  824:# define YY_REDUCE_PRINT(Rule)          \
        -:  825:do {                                    \
        -:  826:  if (yydebug)                          \
        -:  827:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, lex_env); \
        -:  828:} while (0)
        -:  829:
        -:  830:/* Nonzero means print parse trace.  It is left uninitialized so that
        -:  831:   multiple parsers can coexist.  */
        -:  832:int yydebug;
        -:  833:#else /* !YYDEBUG */
        -:  834:# define YYDPRINTF(Args)
        -:  835:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -:  836:# define YY_STACK_PRINT(Bottom, Top)
        -:  837:# define YY_REDUCE_PRINT(Rule)
        -:  838:#endif /* !YYDEBUG */
        -:  839:
        -:  840:
        -:  841:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -:  842:#ifndef YYINITDEPTH
        -:  843:# define YYINITDEPTH 200
        -:  844:#endif
        -:  845:
        -:  846:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -:  847:   if the built-in stack extension method is used).
        -:  848:
        -:  849:   Do not make this value too large; the results are undefined if
        -:  850:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -:  851:   evaluated with infinite-precision integer arithmetic.  */
        -:  852:
        -:  853:#ifndef YYMAXDEPTH
        -:  854:# define YYMAXDEPTH 10000
        -:  855:#endif
        -:  856:
        -:  857:
        -:  858:#if YYERROR_VERBOSE
        -:  859:
        -:  860:# ifndef yystrlen
        -:  861:#  if defined __GLIBC__ && defined _STRING_H
        -:  862:#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
        -:  863:#  else
        -:  864:/* Return the length of YYSTR.  */
        -:  865:static YYPTRDIFF_T
        -:  866:yystrlen (const char *yystr)
        -:  867:{
        -:  868:  YYPTRDIFF_T yylen;
        -:  869:  for (yylen = 0; yystr[yylen]; yylen++)
        -:  870:    continue;
        -:  871:  return yylen;
        -:  872:}
        -:  873:#  endif
        -:  874:# endif
        -:  875:
        -:  876:# ifndef yystpcpy
        -:  877:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -:  878:#   define yystpcpy stpcpy
        -:  879:#  else
        -:  880:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -:  881:   YYDEST.  */
        -:  882:static char *
    #####:  883:yystpcpy (char *yydest, const char *yysrc)
        -:  884:{
    #####:  885:  char *yyd = yydest;
    #####:  886:  const char *yys = yysrc;
        -:  887:
    #####:  888:  while ((*yyd++ = *yys++) != '\0')
    #####:  889:    continue;
        -:  890:
    #####:  891:  return yyd - 1;
        -:  892:}
        -:  893:#  endif
        -:  894:# endif
        -:  895:
        -:  896:# ifndef yytnamerr
        -:  897:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -:  898:   quotes and backslashes, so that it's suitable for yyerror.  The
        -:  899:   heuristic is that double-quoting is unnecessary unless the string
        -:  900:   contains an apostrophe, a comma, or backslash (other than
        -:  901:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -:  902:   null, do not copy; instead, return the length of what the result
        -:  903:   would have been.  */
        -:  904:static YYPTRDIFF_T
    #####:  905:yytnamerr (char *yyres, const char *yystr)
        -:  906:{
    #####:  907:  if (*yystr == '"')
        -:  908:    {
    #####:  909:      YYPTRDIFF_T yyn = 0;
    #####:  910:      char const *yyp = yystr;
        -:  911:
        -:  912:      for (;;)
    #####:  913:        switch (*++yyp)
        -:  914:          {
    #####:  915:          case '\'':
        -:  916:          case ',':
    #####:  917:            goto do_not_strip_quotes;
        -:  918:
    #####:  919:          case '\\':
    #####:  920:            if (*++yyp != '\\')
    #####:  921:              goto do_not_strip_quotes;
        -:  922:            else
    #####:  923:              goto append;
        -:  924:
    #####:  925:          append:
        -:  926:          default:
    #####:  927:            if (yyres)
    #####:  928:              yyres[yyn] = *yyp;
    #####:  929:            yyn++;
    #####:  930:            break;
        -:  931:
    #####:  932:          case '"':
    #####:  933:            if (yyres)
    #####:  934:              yyres[yyn] = '\0';
    #####:  935:            return yyn;
        -:  936:          }
    #####:  937:    do_not_strip_quotes: ;
        -:  938:    }
        -:  939:
    #####:  940:  if (yyres)
    #####:  941:    return yystpcpy (yyres, yystr) - yyres;
        -:  942:  else
    #####:  943:    return yystrlen (yystr);
        -:  944:}
        -:  945:# endif
        -:  946:
        -:  947:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -:  948:   about the unexpected token YYTOKEN for the state stack whose top is
        -:  949:   YYSSP.
        -:  950:
        -:  951:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -:  952:   not large enough to hold the message.  In that case, also set
        -:  953:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -:  954:   required number of bytes is too large to store.  */
        -:  955:static int
    #####:  956:yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
        -:  957:                yy_state_t *yyssp, int yytoken)
        -:  958:{
        -:  959:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -:  960:  /* Internationalized format string. */
    #####:  961:  const char *yyformat = YY_NULLPTR;
        -:  962:  /* Arguments of yyformat: reported tokens (one for the "unexpected",
        -:  963:     one per "expected"). */
        -:  964:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -:  965:  /* Actual size of YYARG. */
    #####:  966:  int yycount = 0;
        -:  967:  /* Cumulated lengths of YYARG.  */
    #####:  968:  YYPTRDIFF_T yysize = 0;
        -:  969:
        -:  970:  /* There are many possibilities here to consider:
        -:  971:     - If this state is a consistent state with a default action, then
        -:  972:       the only way this function was invoked is if the default action
        -:  973:       is an error action.  In that case, don't check for expected
        -:  974:       tokens because there are none.
        -:  975:     - The only way there can be no lookahead present (in yychar) is if
        -:  976:       this state is a consistent state with a default action.  Thus,
        -:  977:       detecting the absence of a lookahead is sufficient to determine
        -:  978:       that there is no unexpected or expected token to report.  In that
        -:  979:       case, just report a simple "syntax error".
        -:  980:     - Don't assume there isn't a lookahead just because this state is a
        -:  981:       consistent state with a default action.  There might have been a
        -:  982:       previous inconsistent state, consistent state with a non-default
        -:  983:       action, or user semantic action that manipulated yychar.
        -:  984:     - Of course, the expected token list depends on states to have
        -:  985:       correct lookahead information, and it depends on the parser not
        -:  986:       to perform extra reductions after fetching a lookahead from the
        -:  987:       scanner and before detecting a syntax error.  Thus, state merging
        -:  988:       (from LALR or IELR) and default reductions corrupt the expected
        -:  989:       token list.  However, the list is correct for canonical LR with
        -:  990:       one exception: it will still contain any token that will not be
        -:  991:       accepted due to an error action in a later state.
        -:  992:  */
    #####:  993:  if (yytoken != YYEMPTY)
        -:  994:    {
    #####:  995:      int yyn = yypact[+*yyssp];
    #####:  996:      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
    #####:  997:      yysize = yysize0;
    #####:  998:      yyarg[yycount++] = yytname[yytoken];
    #####:  999:      if (!yypact_value_is_default (yyn))
        -: 1000:        {
        -: 1001:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1002:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1003:             this state because they are default actions.  */
    #####: 1004:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1005:          /* Stay within bounds of both yycheck and yytname.  */
    #####: 1006:          int yychecklim = YYLAST - yyn + 1;
    #####: 1007:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1008:          int yyx;
        -: 1009:
    #####: 1010:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
    #####: 1011:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
    #####: 1012:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1013:              {
    #####: 1014:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1015:                  {
    #####: 1016:                    yycount = 1;
    #####: 1017:                    yysize = yysize0;
    #####: 1018:                    break;
        -: 1019:                  }
    #####: 1020:                yyarg[yycount++] = yytname[yyx];
        -: 1021:                {
    #####: 1022:                  YYPTRDIFF_T yysize1
    #####: 1023:                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
    #####: 1024:                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1025:                    yysize = yysize1;
        -: 1026:                  else
    #####: 1027:                    return 2;
        -: 1028:                }
        -: 1029:              }
        -: 1030:        }
        -: 1031:    }
        -: 1032:
    #####: 1033:  switch (yycount)
        -: 1034:    {
        -: 1035:# define YYCASE_(N, S)                      \
        -: 1036:      case N:                               \
        -: 1037:        yyformat = S;                       \
        -: 1038:      break
    #####: 1039:    default: /* Avoid compiler warnings. */
    #####: 1040:      YYCASE_(0, YY_("syntax error"));
    #####: 1041:      YYCASE_(1, YY_("syntax error, unexpected %s"));
    #####: 1042:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1043:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1044:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1045:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1046:# undef YYCASE_
        -: 1047:    }
        -: 1048:
        -: 1049:  {
        -: 1050:    /* Don't count the "%s"s in the final size, but reserve room for
        -: 1051:       the terminator.  */
    #####: 1052:    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
    #####: 1053:    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1054:      yysize = yysize1;
        -: 1055:    else
    #####: 1056:      return 2;
        -: 1057:  }
        -: 1058:
    #####: 1059:  if (*yymsg_alloc < yysize)
        -: 1060:    {
    #####: 1061:      *yymsg_alloc = 2 * yysize;
    #####: 1062:      if (! (yysize <= *yymsg_alloc
        -: 1063:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1064:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1065:      return 1;
        -: 1066:    }
        -: 1067:
        -: 1068:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1069:     Don't have undefined behavior even if the translation
        -: 1070:     produced a string with the wrong number of "%s"s.  */
        -: 1071:  {
    #####: 1072:    char *yyp = *yymsg;
    #####: 1073:    int yyi = 0;
    #####: 1074:    while ((*yyp = *yyformat) != '\0')
    #####: 1075:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1076:        {
    #####: 1077:          yyp += yytnamerr (yyp, yyarg[yyi++]);
    #####: 1078:          yyformat += 2;
        -: 1079:        }
        -: 1080:      else
        -: 1081:        {
    #####: 1082:          ++yyp;
    #####: 1083:          ++yyformat;
        -: 1084:        }
        -: 1085:  }
    #####: 1086:  return 0;
        -: 1087:}
        -: 1088:#endif /* YYERROR_VERBOSE */
        -: 1089:
        -: 1090:/*-----------------------------------------------.
        -: 1091:| Release the memory associated to this symbol.  |
        -: 1092:`-----------------------------------------------*/
        -: 1093:
        -: 1094:static void
        2: 1095:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -: 1096:{
        -: 1097:  YYUSE (yyvaluep);
        -: 1098:  YYUSE (yyscanner);
        -: 1099:  YYUSE (lex_env);
        2: 1100:  if (!yymsg)
    #####: 1101:    yymsg = "Deleting";
        -: 1102:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1103:
        -: 1104:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        2: 1105:  switch (yytype)
        -: 1106:    {
    #####: 1107:    case 16: /* tokens  */
        -: 1108:#line 94 "hex_grammar.y"
        -: 1109:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1110:#line 1111 "hex_grammar.c"
    #####: 1111:        break;
        -: 1112:
    #####: 1113:    case 17: /* token_sequence  */
        -: 1114:#line 95 "hex_grammar.y"
        -: 1115:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1116:#line 1117 "hex_grammar.c"
    #####: 1117:        break;
        -: 1118:
    #####: 1119:    case 18: /* token_or_range  */
        -: 1120:#line 96 "hex_grammar.y"
        -: 1121:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1122:#line 1123 "hex_grammar.c"
    #####: 1123:        break;
        -: 1124:
    #####: 1125:    case 19: /* token  */
        -: 1126:#line 97 "hex_grammar.y"
        -: 1127:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1128:#line 1129 "hex_grammar.c"
    #####: 1129:        break;
        -: 1130:
    #####: 1131:    case 21: /* range  */
        -: 1132:#line 100 "hex_grammar.y"
        -: 1133:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1134:#line 1135 "hex_grammar.c"
    #####: 1135:        break;
        -: 1136:
    #####: 1137:    case 22: /* alternatives  */
        -: 1138:#line 99 "hex_grammar.y"
        -: 1139:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1140:#line 1141 "hex_grammar.c"
    #####: 1141:        break;
        -: 1142:
    #####: 1143:    case 23: /* byte  */
        -: 1144:#line 98 "hex_grammar.y"
        -: 1145:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1146:#line 1147 "hex_grammar.c"
    #####: 1147:        break;
        -: 1148:
        2: 1149:      default:
        2: 1150:        break;
        -: 1151:    }
        -: 1152:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        2: 1153:}
        -: 1154:
        -: 1155:
        -: 1156:
        -: 1157:
        -: 1158:/*----------.
        -: 1159:| yyparse.  |
        -: 1160:`----------*/
        -: 1161:
        -: 1162:int
        1: 1163:yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -: 1164:{
        -: 1165:/* The lookahead symbol.  */
        -: 1166:int yychar;
        -: 1167:
        -: 1168:
        -: 1169:/* The semantic value of the lookahead symbol.  */
        -: 1170:/* Default value used for initialization, for pacifying older GCCs
        -: 1171:   or non-GCC compilers.  */
        -: 1172:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1173:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1174:
        -: 1175:    /* Number of syntax errors so far.  */
        -: 1176:    int yynerrs;
        -: 1177:
        -: 1178:    yy_state_fast_t yystate;
        -: 1179:    /* Number of tokens to shift before error messages enabled.  */
        -: 1180:    int yyerrstatus;
        -: 1181:
        -: 1182:    /* The stacks and their tools:
        -: 1183:       'yyss': related to states.
        -: 1184:       'yyvs': related to semantic values.
        -: 1185:
        -: 1186:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1187:       to reallocate them elsewhere.  */
        -: 1188:
        -: 1189:    /* The state stack.  */
        -: 1190:    yy_state_t yyssa[YYINITDEPTH];
        -: 1191:    yy_state_t *yyss;
        -: 1192:    yy_state_t *yyssp;
        -: 1193:
        -: 1194:    /* The semantic value stack.  */
        -: 1195:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1196:    YYSTYPE *yyvs;
        -: 1197:    YYSTYPE *yyvsp;
        -: 1198:
        -: 1199:    YYPTRDIFF_T yystacksize;
        -: 1200:
        -: 1201:  int yyn;
        -: 1202:  int yyresult;
        -: 1203:  /* Lookahead token as an internal (translated) token number.  */
        1: 1204:  int yytoken = 0;
        -: 1205:  /* The variables used to return semantic value and location from the
        -: 1206:     action routines.  */
        -: 1207:  YYSTYPE yyval;
        -: 1208:
        -: 1209:#if YYERROR_VERBOSE
        -: 1210:  /* Buffer for error messages, and its allocated size.  */
        -: 1211:  char yymsgbuf[128];
        1: 1212:  char *yymsg = yymsgbuf;
        1: 1213:  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
        -: 1214:#endif
        -: 1215:
        -: 1216:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1217:
        -: 1218:  /* The number of symbols on the RHS of the reduced rule.
        -: 1219:     Keep to zero when no symbol should be popped.  */
        1: 1220:  int yylen = 0;
        -: 1221:
        1: 1222:  yyssp = yyss = yyssa;
        1: 1223:  yyvsp = yyvs = yyvsa;
        1: 1224:  yystacksize = YYINITDEPTH;
        -: 1225:
        -: 1226:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1227:
        1: 1228:  yystate = 0;
        1: 1229:  yyerrstatus = 0;
        1: 1230:  yynerrs = 0;
        1: 1231:  yychar = YYEMPTY; /* Cause a token to be read.  */
        1: 1232:  goto yysetstate;
        -: 1233:
        -: 1234:
        -: 1235:/*------------------------------------------------------------.
        -: 1236:| yynewstate -- push a new state, which is found in yystate.  |
        -: 1237:`------------------------------------------------------------*/
       36: 1238:yynewstate:
        -: 1239:  /* In all cases, when you get here, the value and location stacks
        -: 1240:     have just been pushed.  So pushing a state here evens the stacks.  */
       36: 1241:  yyssp++;
        -: 1242:
        -: 1243:
        -: 1244:/*--------------------------------------------------------------------.
        -: 1245:| yysetstate -- set current state (the top of the stack) to yystate.  |
        -: 1246:`--------------------------------------------------------------------*/
       37: 1247:yysetstate:
        -: 1248:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1249:  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
        -: 1250:  YY_IGNORE_USELESS_CAST_BEGIN
       37: 1251:  *yyssp = YY_CAST (yy_state_t, yystate);
        -: 1252:  YY_IGNORE_USELESS_CAST_END
        -: 1253:
       37: 1254:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1255:#if !defined yyoverflow && !defined YYSTACK_RELOCATE
        -: 1256:    goto yyexhaustedlab;
        -: 1257:#else
        -: 1258:    {
        -: 1259:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1260:      YYPTRDIFF_T yysize = yyssp - yyss + 1;
        -: 1261:
        -: 1262:# if defined yyoverflow
        -: 1263:      {
        -: 1264:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1265:           these so that the &'s don't force the real ones into
        -: 1266:           memory.  */
        -: 1267:        yy_state_t *yyss1 = yyss;
        -: 1268:        YYSTYPE *yyvs1 = yyvs;
        -: 1269:
        -: 1270:        /* Each stack pointer address is followed by the size of the
        -: 1271:           data in use in that stack, in bytes.  This used to be a
        -: 1272:           conditional around just the two extra args, but that might
        -: 1273:           be undefined if yyoverflow is a macro.  */
        -: 1274:        yyoverflow (YY_("memory exhausted"),
        -: 1275:                    &yyss1, yysize * YYSIZEOF (*yyssp),
        -: 1276:                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
        -: 1277:                    &yystacksize);
        -: 1278:        yyss = yyss1;
        -: 1279:        yyvs = yyvs1;
        -: 1280:      }
        -: 1281:# else /* defined YYSTACK_RELOCATE */
        -: 1282:      /* Extend the stack our own way.  */
    #####: 1283:      if (YYMAXDEPTH <= yystacksize)
    #####: 1284:        goto yyexhaustedlab;
    #####: 1285:      yystacksize *= 2;
    #####: 1286:      if (YYMAXDEPTH < yystacksize)
    #####: 1287:        yystacksize = YYMAXDEPTH;
        -: 1288:
        -: 1289:      {
    #####: 1290:        yy_state_t *yyss1 = yyss;
        -: 1291:        union yyalloc *yyptr =
    #####: 1292:          YY_CAST (union yyalloc *,
        -: 1293:                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
    #####: 1294:        if (! yyptr)
    #####: 1295:          goto yyexhaustedlab;
    #####: 1296:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1297:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1298:# undef YYSTACK_RELOCATE
    #####: 1299:        if (yyss1 != yyssa)
    #####: 1300:          YYSTACK_FREE (yyss1);
        -: 1301:      }
        -: 1302:# endif
        -: 1303:
    #####: 1304:      yyssp = yyss + yysize - 1;
    #####: 1305:      yyvsp = yyvs + yysize - 1;
        -: 1306:
        -: 1307:      YY_IGNORE_USELESS_CAST_BEGIN
        -: 1308:      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
        -: 1309:                  YY_CAST (long, yystacksize)));
        -: 1310:      YY_IGNORE_USELESS_CAST_END
        -: 1311:
    #####: 1312:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1313:        YYABORT;
        -: 1314:    }
        -: 1315:#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
        -: 1316:
       37: 1317:  if (yystate == YYFINAL)
        1: 1318:    YYACCEPT;
        -: 1319:
       36: 1320:  goto yybackup;
        -: 1321:
        -: 1322:
        -: 1323:/*-----------.
        -: 1324:| yybackup.  |
        -: 1325:`-----------*/
       36: 1326:yybackup:
        -: 1327:  /* Do appropriate processing given the current state.  Read a
        -: 1328:     lookahead token if we need one and don't already have one.  */
        -: 1329:
        -: 1330:  /* First try to decide what to do without reference to lookahead token.  */
       36: 1331:  yyn = yypact[yystate];
       36: 1332:  if (yypact_value_is_default (yyn))
       20: 1333:    goto yydefault;
        -: 1334:
        -: 1335:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1336:
        -: 1337:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
       16: 1338:  if (yychar == YYEMPTY)
        -: 1339:    {
        -: 1340:      YYDPRINTF ((stderr, "Reading a token: "));
       10: 1341:      yychar = yylex (&yylval, yyscanner, lex_env);
        -: 1342:    }
        -: 1343:
       16: 1344:  if (yychar <= YYEOF)
        -: 1345:    {
        1: 1346:      yychar = yytoken = YYEOF;
        -: 1347:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1348:    }
        -: 1349:  else
        -: 1350:    {
      15*: 1351:      yytoken = YYTRANSLATE (yychar);
        -: 1352:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1353:    }
        -: 1354:
        -: 1355:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1356:     detect an error, take that action.  */
       16: 1357:  yyn += yytoken;
       16: 1358:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
        5: 1359:    goto yydefault;
       11: 1360:  yyn = yytable[yyn];
       11: 1361:  if (yyn <= 0)
        -: 1362:    {
        -: 1363:      if (yytable_value_is_error (yyn))
        -: 1364:        goto yyerrlab;
        1: 1365:      yyn = -yyn;
        1: 1366:      goto yyreduce;
        -: 1367:    }
        -: 1368:
        -: 1369:  /* Count tokens shifted since error; after three, turn off error
        -: 1370:     status.  */
       10: 1371:  if (yyerrstatus)
    #####: 1372:    yyerrstatus--;
        -: 1373:
        -: 1374:  /* Shift the lookahead token.  */
        -: 1375:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
       10: 1376:  yystate = yyn;
        -: 1377:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
       10: 1378:  *++yyvsp = yylval;
        -: 1379:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1380:
        -: 1381:  /* Discard the shifted token.  */
       10: 1382:  yychar = YYEMPTY;
       10: 1383:  goto yynewstate;
        -: 1384:
        -: 1385:
        -: 1386:/*-----------------------------------------------------------.
        -: 1387:| yydefault -- do the default action for the current state.  |
        -: 1388:`-----------------------------------------------------------*/
       25: 1389:yydefault:
       25: 1390:  yyn = yydefact[yystate];
       25: 1391:  if (yyn == 0)
    #####: 1392:    goto yyerrlab;
       25: 1393:  goto yyreduce;
        -: 1394:
        -: 1395:
        -: 1396:/*-----------------------------.
        -: 1397:| yyreduce -- do a reduction.  |
        -: 1398:`-----------------------------*/
       26: 1399:yyreduce:
        -: 1400:  /* yyn is the number of a rule to reduce with.  */
       26: 1401:  yylen = yyr2[yyn];
        -: 1402:
        -: 1403:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1404:     '$$ = $1'.
        -: 1405:
        -: 1406:     Otherwise, the following line sets YYVAL to garbage.
        -: 1407:     This behavior is undocumented and Bison
        -: 1408:     users should not rely upon it.  Assigning to YYVAL
        -: 1409:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1410:     GCC warning that YYVAL may be used uninitialized.  */
       26: 1411:  yyval = yyvsp[1-yylen];
        -: 1412:
        -: 1413:
        -: 1414:  YY_REDUCE_PRINT (yyn);
       26: 1415:  switch (yyn)
        -: 1416:    {
        1: 1417:  case 2:
        -: 1418:#line 106 "hex_grammar.y"
        -: 1419:      {
        -: 1420:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1421:        re_ast->root_node = (yyvsp[-1].re_node);
        -: 1422:      }
        -: 1423:#line 1424 "hex_grammar.c"
        1: 1424:    break;
        -: 1425:
    #####: 1426:  case 3:
        -: 1427:#line 115 "hex_grammar.y"
        -: 1428:      {
        -: 1429:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1430:      }
        -: 1431:#line 1432 "hex_grammar.c"
    #####: 1432:    break;
        -: 1433:
    #####: 1434:  case 4:
        -: 1435:#line 119 "hex_grammar.y"
        -: 1436:      {
        -: 1437:        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);
        -: 1438:
        -: 1439:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1440:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1441:
        -: 1442:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1443:
        -: 1444:        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));
        -: 1445:        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));
        -: 1446:      }
        -: 1447:#line 1448 "hex_grammar.c"
    #####: 1448:    break;
        -: 1449:
        1: 1450:  case 5:
        -: 1451:#line 131 "hex_grammar.y"
        -: 1452:      {
        -: 1453:        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));
        -: 1454:        yr_re_node_prepend_child((yyvsp[-1].re_node), (yyvsp[-2].re_node));
        -: 1455:
        -: 1456:        (yyval.re_node) = (yyvsp[-1].re_node);
        -: 1457:      }
        -: 1458:#line 1459 "hex_grammar.c"
        1: 1459:    break;
        -: 1460:
        1: 1461:  case 6:
        -: 1462:#line 142 "hex_grammar.y"
        -: 1463:      {
        -: 1464:        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);
        -: 1465:
        -: 1466:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1467:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1468:
        -: 1469:        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));
        -: 1470:      }
        -: 1471:#line 1472 "hex_grammar.c"
        1: 1472:    break;
        -: 1473:
        4: 1474:  case 7:
        -: 1475:#line 151 "hex_grammar.y"
        -: 1476:      {
        -: 1477:        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));
        -: 1478:        (yyval.re_node) = (yyvsp[-1].re_node);
        -: 1479:      }
        -: 1480:#line 1481 "hex_grammar.c"
        4: 1481:    break;
        -: 1482:
        5: 1483:  case 8:
        -: 1484:#line 160 "hex_grammar.y"
        -: 1485:      {
        -: 1486:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1487:      }
        -: 1488:#line 1489 "hex_grammar.c"
        5: 1489:    break;
        -: 1490:
    #####: 1491:  case 9:
        -: 1492:#line 164 "hex_grammar.y"
        -: 1493:      {
        -: 1494:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1495:        (yyval.re_node)->greedy = false;
        -: 1496:      }
        -: 1497:#line 1498 "hex_grammar.c"
    #####: 1498:    break;
        -: 1499:
        7: 1500:  case 10:
        -: 1501:#line 173 "hex_grammar.y"
        -: 1502:      {
        -: 1503:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1504:      }
        -: 1505:#line 1506 "hex_grammar.c"
        7: 1506:    break;
        -: 1507:
    #####: 1508:  case 11:
        -: 1509:#line 177 "hex_grammar.y"
        -: 1510:      {
        -: 1511:        lex_env->inside_or++;
        -: 1512:      }
        -: 1513:#line 1514 "hex_grammar.c"
    #####: 1514:    break;
        -: 1515:
    #####: 1516:  case 12:
        -: 1517:#line 181 "hex_grammar.y"
        -: 1518:      {
        -: 1519:        (yyval.re_node) = (yyvsp[-1].re_node);
        -: 1520:        lex_env->inside_or--;
        -: 1521:      }
        -: 1522:#line 1523 "hex_grammar.c"
    #####: 1523:    break;
        -: 1524:
    #####: 1525:  case 13:
        -: 1526:#line 190 "hex_grammar.y"
        -: 1527:      {
        -: 1528:        if ((yyvsp[-1].integer) <= 0)
        -: 1529:        {
        -: 1530:          yyerror(yyscanner, lex_env, "invalid jump length");
        -: 1531:          YYABORT;
        -: 1532:        }
        -: 1533:
        -: 1534:        if (lex_env->inside_or && (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD)
        -: 1535:        {
        -: 1536:          yyerror(yyscanner, lex_env, "jumps over "
        -: 1537:              STR(YR_STRING_CHAINING_THRESHOLD)
        -: 1538:              " now allowed inside alternation (|)");
        -: 1539:          YYABORT;
        -: 1540:        }
        -: 1541:
        -: 1542:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1543:
        -: 1544:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1545:
        -: 1546:        (yyval.re_node)->start = (int) (yyvsp[-1].integer);
        -: 1547:        (yyval.re_node)->end = (int) (yyvsp[-1].integer);
        -: 1548:      }
        -: 1549:#line 1550 "hex_grammar.c"
    #####: 1550:    break;
        -: 1551:
    #####: 1552:  case 14:
        -: 1553:#line 213 "hex_grammar.y"
        -: 1554:      {
        -: 1555:        if (lex_env->inside_or &&
        -: 1556:            ((yyvsp[-3].integer) > YR_STRING_CHAINING_THRESHOLD ||
        -: 1557:             (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD) )
        -: 1558:        {
        -: 1559:          yyerror(yyscanner, lex_env, "jumps over "
        -: 1560:              STR(YR_STRING_CHAINING_THRESHOLD)
        -: 1561:              " now allowed inside alternation (|)");
        -: 1562:
        -: 1563:          YYABORT;
        -: 1564:        }
        -: 1565:
        -: 1566:        if ((yyvsp[-3].integer) < 0 || (yyvsp[-1].integer) < 0)
        -: 1567:        {
        -: 1568:          yyerror(yyscanner, lex_env, "invalid negative jump length");
        -: 1569:          YYABORT;
        -: 1570:        }
        -: 1571:
        -: 1572:        if ((yyvsp[-3].integer) > (yyvsp[-1].integer))
        -: 1573:        {
        -: 1574:          yyerror(yyscanner, lex_env, "invalid jump range");
        -: 1575:          YYABORT;
        -: 1576:        }
        -: 1577:
        -: 1578:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1579:
        -: 1580:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1581:
        -: 1582:        (yyval.re_node)->start = (int) (yyvsp[-3].integer);
        -: 1583:        (yyval.re_node)->end = (int) (yyvsp[-1].integer);
        -: 1584:      }
        -: 1585:#line 1586 "hex_grammar.c"
    #####: 1586:    break;
        -: 1587:
    #####: 1588:  case 15:
        -: 1589:#line 245 "hex_grammar.y"
        -: 1590:      {
        -: 1591:        if (lex_env->inside_or)
        -: 1592:        {
        -: 1593:          yyerror(yyscanner, lex_env,
        -: 1594:              "unbounded jumps not allowed inside alternation (|)");
        -: 1595:          YYABORT;
        -: 1596:        }
        -: 1597:
        -: 1598:        if ((yyvsp[-2].integer) < 0)
        -: 1599:        {
        -: 1600:          yyerror(yyscanner, lex_env, "invalid negative jump length");
        -: 1601:          YYABORT;
        -: 1602:        }
        -: 1603:
        -: 1604:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1605:
        -: 1606:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1607:
        -: 1608:        (yyval.re_node)->start = (int) (yyvsp[-2].integer);
        -: 1609:        (yyval.re_node)->end = INT_MAX;
        -: 1610:      }
        -: 1611:#line 1612 "hex_grammar.c"
    #####: 1612:    break;
        -: 1613:
    #####: 1614:  case 16:
        -: 1615:#line 267 "hex_grammar.y"
        -: 1616:      {
        -: 1617:        if (lex_env->inside_or)
        -: 1618:        {
        -: 1619:          yyerror(yyscanner, lex_env,
        -: 1620:              "unbounded jumps not allowed inside alternation (|)");
        -: 1621:          YYABORT;
        -: 1622:        }
        -: 1623:
        -: 1624:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);
        -: 1625:
        -: 1626:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1627:
        -: 1628:        (yyval.re_node)->start = 0;
        -: 1629:        (yyval.re_node)->end = INT_MAX;
        -: 1630:      }
        -: 1631:#line 1632 "hex_grammar.c"
    #####: 1632:    break;
        -: 1633:
    #####: 1634:  case 17:
        -: 1635:#line 287 "hex_grammar.y"
        -: 1636:      {
        -: 1637:          (yyval.re_node) = (yyvsp[0].re_node);
        -: 1638:      }
        -: 1639:#line 1640 "hex_grammar.c"
    #####: 1640:    break;
        -: 1641:
    #####: 1642:  case 18:
        -: 1643:#line 291 "hex_grammar.y"
        -: 1644:      {
        -: 1645:        mark_as_not_fast_regexp();
        -: 1646:
        -: 1647:        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);
        -: 1648:
        -: 1649:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1650:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1651:
        -: 1652:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1653:
        -: 1654:        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));
        -: 1655:        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));
        -: 1656:      }
        -: 1657:#line 1658 "hex_grammar.c"
    #####: 1658:    break;
        -: 1659:
        5: 1660:  case 19:
        -: 1661:#line 308 "hex_grammar.y"
        -: 1662:      {
        -: 1663:        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL);
        -: 1664:
        -: 1665:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1666:
        -: 1667:        (yyval.re_node)->value = (int) (yyvsp[0].integer);
        -: 1668:        (yyval.re_node)->mask = 0xFF;
        -: 1669:      }
        -: 1670:#line 1671 "hex_grammar.c"
        5: 1671:    break;
        -: 1672:
        2: 1673:  case 20:
        -: 1674:#line 317 "hex_grammar.y"
        -: 1675:      {
        -: 1676:        uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);
        -: 1677:
        -: 1678:        if (mask == 0x00)
        -: 1679:        {
        -: 1680:          (yyval.re_node) = yr_re_node_create(RE_NODE_ANY);
        -: 1681:
        -: 1682:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1683:
        -: 1684:          (yyval.re_node)->value = 0x00;
        -: 1685:          (yyval.re_node)->mask = 0x00;
        -: 1686:        }
        -: 1687:        else
        -: 1688:        {
        -: 1689:          (yyval.re_node) = yr_re_node_create(RE_NODE_MASKED_LITERAL);
        -: 1690:
        -: 1691:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1692:
        -: 1693:          (yyval.re_node)->value = (yyvsp[0].integer) & 0xFF;
        -: 1694:          (yyval.re_node)->mask = mask;
        -: 1695:        }
        -: 1696:      }
        -: 1697:#line 1698 "hex_grammar.c"
        2: 1698:    break;
        -: 1699:
        -: 1700:
        -: 1701:#line 1702 "hex_grammar.c"
        -: 1702:
    #####: 1703:      default: break;
        -: 1704:    }
        -: 1705:  /* User semantic actions sometimes alter yychar, and that requires
        -: 1706:     that yytoken be updated with the new translation.  We take the
        -: 1707:     approach of translating immediately before every use of yytoken.
        -: 1708:     One alternative is translating here after every semantic action,
        -: 1709:     but that translation would be missed if the semantic action invokes
        -: 1710:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 1711:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 1712:     incorrect destructor might then be invoked immediately.  In the
        -: 1713:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 1714:     to an incorrect destructor call or verbose syntax error message
        -: 1715:     before the lookahead is translated.  */
        -: 1716:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 1717:
       26: 1718:  YYPOPSTACK (yylen);
       26: 1719:  yylen = 0;
        -: 1720:  YY_STACK_PRINT (yyss, yyssp);
        -: 1721:
       26: 1722:  *++yyvsp = yyval;
        -: 1723:
        -: 1724:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 1725:     that goes to, based on the state we popped back to and the rule
        -: 1726:     number reduced by.  */
        -: 1727:  {
       26: 1728:    const int yylhs = yyr1[yyn] - YYNTOKENS;
       26: 1729:    const int yyi = yypgoto[yylhs] + *yyssp;
       17: 1730:    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
       10: 1731:               ? yytable[yyi]
       43: 1732:               : yydefgoto[yylhs]);
        -: 1733:  }
        -: 1734:
       26: 1735:  goto yynewstate;
        -: 1736:
        -: 1737:
        -: 1738:/*--------------------------------------.
        -: 1739:| yyerrlab -- here on detecting error.  |
        -: 1740:`--------------------------------------*/
    #####: 1741:yyerrlab:
        -: 1742:  /* Make sure we have latest lookahead translation.  See comments at
        -: 1743:     user semantic actions for why this is necessary.  */
    #####: 1744:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 1745:
        -: 1746:  /* If not already recovering from an error, report this error.  */
    #####: 1747:  if (!yyerrstatus)
        -: 1748:    {
    #####: 1749:      ++yynerrs;
        -: 1750:#if ! YYERROR_VERBOSE
        -: 1751:      yyerror (yyscanner, lex_env, YY_("syntax error"));
        -: 1752:#else
        -: 1753:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 1754:                                        yyssp, yytoken)
        -: 1755:      {
    #####: 1756:        char const *yymsgp = YY_("syntax error");
        -: 1757:        int yysyntax_error_status;
    #####: 1758:        yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1759:        if (yysyntax_error_status == 0)
    #####: 1760:          yymsgp = yymsg;
    #####: 1761:        else if (yysyntax_error_status == 1)
        -: 1762:          {
    #####: 1763:            if (yymsg != yymsgbuf)
    #####: 1764:              YYSTACK_FREE (yymsg);
    #####: 1765:            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
    #####: 1766:            if (!yymsg)
        -: 1767:              {
    #####: 1768:                yymsg = yymsgbuf;
    #####: 1769:                yymsg_alloc = sizeof yymsgbuf;
    #####: 1770:                yysyntax_error_status = 2;
        -: 1771:              }
        -: 1772:            else
        -: 1773:              {
    #####: 1774:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1775:                yymsgp = yymsg;
        -: 1776:              }
        -: 1777:          }
    #####: 1778:        yyerror (yyscanner, lex_env, yymsgp);
    #####: 1779:        if (yysyntax_error_status == 2)
    #####: 1780:          goto yyexhaustedlab;
        -: 1781:      }
        -: 1782:# undef YYSYNTAX_ERROR
        -: 1783:#endif
        -: 1784:    }
        -: 1785:
        -: 1786:
        -: 1787:
    #####: 1788:  if (yyerrstatus == 3)
        -: 1789:    {
        -: 1790:      /* If just tried and failed to reuse lookahead token after an
        -: 1791:         error, discard it.  */
        -: 1792:
    #####: 1793:      if (yychar <= YYEOF)
        -: 1794:        {
        -: 1795:          /* Return failure if at end of input.  */
    #####: 1796:          if (yychar == YYEOF)
    #####: 1797:            YYABORT;
        -: 1798:        }
        -: 1799:      else
        -: 1800:        {
    #####: 1801:          yydestruct ("Error: discarding",
        -: 1802:                      yytoken, &yylval, yyscanner, lex_env);
    #####: 1803:          yychar = YYEMPTY;
        -: 1804:        }
        -: 1805:    }
        -: 1806:
        -: 1807:  /* Else will try to reuse lookahead token after shifting the error
        -: 1808:     token.  */
    #####: 1809:  goto yyerrlab1;
        -: 1810:
        -: 1811:
        -: 1812:/*---------------------------------------------------.
        -: 1813:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 1814:`---------------------------------------------------*/
        -: 1815:yyerrorlab:
        -: 1816:  /* Pacify compilers when the user code never invokes YYERROR and the
        -: 1817:     label yyerrorlab therefore never appears in user code.  */
        -: 1818:  if (0)
        -: 1819:    YYERROR;
        -: 1820:
        -: 1821:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 1822:     this YYERROR.  */
        -: 1823:  YYPOPSTACK (yylen);
        -: 1824:  yylen = 0;
        -: 1825:  YY_STACK_PRINT (yyss, yyssp);
        -: 1826:  yystate = *yyssp;
        -: 1827:  goto yyerrlab1;
        -: 1828:
        -: 1829:
        -: 1830:/*-------------------------------------------------------------.
        -: 1831:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 1832:`-------------------------------------------------------------*/
    #####: 1833:yyerrlab1:
    #####: 1834:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 1835:
        -: 1836:  for (;;)
        -: 1837:    {
    #####: 1838:      yyn = yypact[yystate];
    #####: 1839:      if (!yypact_value_is_default (yyn))
        -: 1840:        {
    #####: 1841:          yyn += YYTERROR;
    #####: 1842:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 1843:            {
    #####: 1844:              yyn = yytable[yyn];
    #####: 1845:              if (0 < yyn)
    #####: 1846:                break;
        -: 1847:            }
        -: 1848:        }
        -: 1849:
        -: 1850:      /* Pop the current state because it cannot handle the error token.  */
    #####: 1851:      if (yyssp == yyss)
    #####: 1852:        YYABORT;
        -: 1853:
        -: 1854:
    #####: 1855:      yydestruct ("Error: popping",
    #####: 1856:                  yystos[yystate], yyvsp, yyscanner, lex_env);
    #####: 1857:      YYPOPSTACK (1);
    #####: 1858:      yystate = *yyssp;
        -: 1859:      YY_STACK_PRINT (yyss, yyssp);
        -: 1860:    }
        -: 1861:
        -: 1862:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1863:  *++yyvsp = yylval;
        -: 1864:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1865:
        -: 1866:
        -: 1867:  /* Shift the error token.  */
        -: 1868:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 1869:
    #####: 1870:  yystate = yyn;
    #####: 1871:  goto yynewstate;
        -: 1872:
        -: 1873:
        -: 1874:/*-------------------------------------.
        -: 1875:| yyacceptlab -- YYACCEPT comes here.  |
        -: 1876:`-------------------------------------*/
        1: 1877:yyacceptlab:
        1: 1878:  yyresult = 0;
        1: 1879:  goto yyreturn;
        -: 1880:
        -: 1881:
        -: 1882:/*-----------------------------------.
        -: 1883:| yyabortlab -- YYABORT comes here.  |
        -: 1884:`-----------------------------------*/
    #####: 1885:yyabortlab:
    #####: 1886:  yyresult = 1;
    #####: 1887:  goto yyreturn;
        -: 1888:
        -: 1889:
        -: 1890:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 1891:/*-------------------------------------------------.
        -: 1892:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 1893:`-------------------------------------------------*/
    #####: 1894:yyexhaustedlab:
    #####: 1895:  yyerror (yyscanner, lex_env, YY_("memory exhausted"));
    #####: 1896:  yyresult = 2;
        -: 1897:  /* Fall through.  */
        -: 1898:#endif
        -: 1899:
        -: 1900:
        -: 1901:/*-----------------------------------------------------.
        -: 1902:| yyreturn -- parsing is finished, return the result.  |
        -: 1903:`-----------------------------------------------------*/
        1: 1904:yyreturn:
        1: 1905:  if (yychar != YYEMPTY)
        -: 1906:    {
        -: 1907:      /* Make sure we have latest lookahead translation.  See comments at
        -: 1908:         user semantic actions for why this is necessary.  */
    #####: 1909:      yytoken = YYTRANSLATE (yychar);
    #####: 1910:      yydestruct ("Cleanup: discarding lookahead",
        -: 1911:                  yytoken, &yylval, yyscanner, lex_env);
        -: 1912:    }
        -: 1913:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 1914:     this YYABORT or YYACCEPT.  */
        1: 1915:  YYPOPSTACK (yylen);
        -: 1916:  YY_STACK_PRINT (yyss, yyssp);
        3: 1917:  while (yyssp != yyss)
        -: 1918:    {
        2: 1919:      yydestruct ("Cleanup: popping",
        2: 1920:                  yystos[+*yyssp], yyvsp, yyscanner, lex_env);
        2: 1921:      YYPOPSTACK (1);
        -: 1922:    }
        -: 1923:#ifndef yyoverflow
        1: 1924:  if (yyss != yyssa)
    #####: 1925:    YYSTACK_FREE (yyss);
        -: 1926:#endif
        -: 1927:#if YYERROR_VERBOSE
        1: 1928:  if (yymsg != yymsgbuf)
    #####: 1929:    YYSTACK_FREE (yymsg);
        -: 1930:#endif
        1: 1931:  return yyresult;
        -: 1932:}
        -: 1933:#line 341 "hex_grammar.y"
