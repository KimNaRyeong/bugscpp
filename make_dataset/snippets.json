[
    {
        "begin_line": 8,
        "end_line": 51,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc.cc",
        "func_name": "main",
        "snippet": "int main(void) {\n    // (2) Make a parser\n    parser parser(R\"(\n        # Grammar for Calculator...\n        Additive    <- Multitive '+' Additive / Multitive\n        Multitive   <- Primary '*' Multitive / Primary\n        Primary     <- '(' Additive ')' / Number\n        Number      <- < [0-9]+ >\n        %whitespace <- [ \\t]*\n    )\");\n\n    assert(static_cast<bool>(parser) == true);\n\n    // (3) Setup actions\n    parser[\"Additive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:  // \"Multitive '+' Additive\"\n            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);\n        default: // \"Multitive\"\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser[\"Multitive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:  // \"Primary '*' Multitive\"\n            return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);\n        default: // \"Primary\"\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser[\"Number\"] = [](const SemanticValues& sv) {\n        return stoi(sv.token(), nullptr, 10);\n    };\n\n    // (4) Parse\n    parser.enable_packrat_parsing(); // Enable packrat parsing.\n\n    int val;\n    parser.parse(\" (1 + 2) * 3 \", val);\n\n    assert(val == 9);\n}\n"
    },
    {
        "begin_line": 22,
        "end_line": 29,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc.cc",
        "func_name": "__anon6a64aa3d0102",
        "snippet": "    parser[\"Additive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:  // \"Multitive '+' Additive\"\n            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);\n        default: // \"Multitive\"\n            return any_cast<int>(sv[0]);\n        }\n    };\n"
    },
    {
        "begin_line": 31,
        "end_line": 38,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc.cc",
        "func_name": "__anon6a64aa3d0202",
        "snippet": "    parser[\"Multitive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:  // \"Primary '*' Multitive\"\n            return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);\n        default: // \"Primary\"\n            return any_cast<int>(sv[0]);\n        }\n    };\n"
    },
    {
        "begin_line": 40,
        "end_line": 42,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc.cc",
        "func_name": "__anon6a64aa3d0302",
        "snippet": "    parser[\"Number\"] = [](const SemanticValues& sv) {\n        return stoi(sv.token(), nullptr, 10);\n    };\n"
    },
    {
        "begin_line": 24,
        "end_line": 63,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc2.cc",
        "func_name": "main",
        "snippet": "int main(int argc, const char** argv)\n{\n    if (argc < 2 || std::string(\"--help\") == argv[1]) {\n        std::cout << \"usage: calc [formula]\" << std::endl;\n        return 1;\n    }\n\n    auto reduce = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            auto ope = any_cast<char>(sv[i]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n\n    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n\n    EXPRESSION      <= seq(TERM, zom(seq(TERM_OPERATOR, TERM))),         reduce;\n    TERM            <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR))),   reduce;\n    FACTOR          <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));\n    TERM_OPERATOR   <= cls(\"+-\"),                                        [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n    FACTOR_OPERATOR <= cls(\"*/\"),                                        [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n    NUMBER          <= oom(cls(\"0-9\")),                                  [](const SemanticValues& sv) { return atol(sv.c_str()); };\n\n    auto expr = argv[1];\n    long val = 0;\n    if (EXPRESSION.parse_and_get_value(expr, val).ret) {\n        std::cout << expr << \" = \" << val << std::endl;\n        return 0;\n    }\n\n    return -1;\n}\n"
    },
    {
        "begin_line": 31,
        "end_line": 44,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc2.cc",
        "func_name": "__anonb6fb424f0102",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            auto ope = any_cast<char>(sv[i]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n"
    },
    {
        "begin_line": 51,
        "end_line": 51,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc2.cc",
        "func_name": "__anonb6fb424f0202",
        "snippet": "    TERM_OPERATOR   <= cls(\"+-\"),                                        [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n"
    },
    {
        "begin_line": 52,
        "end_line": 52,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc2.cc",
        "func_name": "__anonb6fb424f0302",
        "snippet": "    FACTOR_OPERATOR <= cls(\"*/\"),                                        [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n"
    },
    {
        "begin_line": 53,
        "end_line": 53,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc2.cc",
        "func_name": "__anonb6fb424f0402",
        "snippet": "    NUMBER          <= oom(cls(\"0-9\")),                                  [](const SemanticValues& sv) { return atol(sv.c_str()); };\n"
    },
    {
        "begin_line": 14,
        "end_line": 67,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc3.cc",
        "func_name": "main",
        "snippet": "int main(int argc, const char** argv)\n{\n    if (argc < 2 || std::string(\"--help\") == argv[1]) {\n        std::cout << \"usage: calc3 [formula]\" << std::endl;\n        return 1;\n    }\n\n    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            for (auto i = 1u; i < nodes.size(); i += 2) {\n                auto num = eval(*nodes[i + 1]);\n                auto ope = nodes[i]->token[0];\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n\n    parser parser(R\"(\n        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' EXPRESSION ')'\n\n        TERM_OPERATOR    <-  < [-+] >\n        FACTOR_OPERATOR  <-  < [/*] >\n        NUMBER           <-  < [0-9]+ >\n\n        %whitespace      <-  [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    auto expr = argv[1];\n    std::shared_ptr<Ast> ast;\n    if (parser.parse(expr, ast)) {\n        ast = AstOptimizer(true).optimize(ast);\n        std::cout << ast_to_s(ast);\n        std::cout << expr << \" = \" << eval(*ast) << std::endl;\n        return 0;\n    }\n\n    std::cout << \"syntax error...\" << std::endl;\n\n    return -1;\n}\n"
    },
    {
        "begin_line": 21,
        "end_line": 39,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc3.cc",
        "func_name": "__anonb6fbceb00102",
        "snippet": "    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            for (auto i = 1u; i < nodes.size(); i += 2) {\n                auto num = eval(*nodes[i + 1]);\n                auto ope = nodes[i]->token[0];\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n"
    },
    {
        "begin_line": 8,
        "end_line": 42,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc4.cc",
        "func_name": "main",
        "snippet": "int main(void) {\n    parser parser(R\"(\n        EXPRESSION  <- ATOM (OPERATOR ATOM)* {\n                         precedence\n                           L - +\n                           L / *\n                       }\n        ATOM        <- NUMBER / '(' EXPRESSION ')'\n        OPERATOR    <- < [-+/*] >\n        NUMBER      <- < '-'? [0-9]+ >\n        %whitespace <- [ \\t\\r\\n]*\n    )\");\n\n    parser[\"EXPRESSION\"] = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        if (sv.size() > 1) {\n            auto ope = any_cast<char>(sv[1]);\n            auto num = any_cast<long>(sv[2]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n    parser[\"OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };\n    parser[\"NUMBER\"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };\n\n    long val;\n    parser.parse(\" -1 + (1 + 2) * 3 - -1\", val);\n\n    assert(val == 9);\n}\n"
    },
    {
        "begin_line": 21,
        "end_line": 34,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc4.cc",
        "func_name": "__anonb6fc5b110102",
        "snippet": "    parser[\"EXPRESSION\"] = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        if (sv.size() > 1) {\n            auto ope = any_cast<char>(sv[1]);\n            auto num = any_cast<long>(sv[2]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n"
    },
    {
        "begin_line": 35,
        "end_line": 35,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc4.cc",
        "func_name": "__anonb6fc5b110202",
        "snippet": "    parser[\"OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 36,
        "end_line": 36,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc4.cc",
        "func_name": "__anonb6fc5b110302",
        "snippet": "    parser[\"NUMBER\"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };\n"
    },
    {
        "begin_line": 14,
        "end_line": 67,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc5.cc",
        "func_name": "main",
        "snippet": "int main(int argc, const char** argv)\n{\n    if (argc < 2 || std::string(\"--help\") == argv[1]) {\n        std::cout << \"usage: calc5 [formula]\" << std::endl;\n        return 1;\n    }\n\n    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            if (nodes.size() > 1) {\n                auto ope = nodes[1]->token[0];\n                auto num = eval(*nodes[2]);\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n\n    parser parser(R\"(\n        EXPRESSION  <- ATOM (OPERATOR ATOM)* {\n                         precedence\n                           L - +\n                           L / *\n                       }\n        ATOM        <- NUMBER / '(' EXPRESSION ')'\n        OPERATOR    <- < [-+/*] >\n        NUMBER      <- < '-'? [0-9]+ >\n        %whitespace <- [ \\t\\r\\n]*\n    )\");\n\n    parser.enable_ast();\n\n    auto expr = argv[1];\n    std::shared_ptr<Ast> ast;\n    if (parser.parse(expr, ast)) {\n        ast = AstOptimizer(true).optimize(ast);\n        std::cout << ast_to_s(ast);\n        std::cout << expr << \" = \" << eval(*ast) << std::endl;\n        return 0;\n    }\n\n    std::cout << \"syntax error...\" << std::endl;\n\n    return -1;\n}\n"
    },
    {
        "begin_line": 21,
        "end_line": 39,
        "file_name": "./proj/cpp_peglib/buggy-1/example/calc5.cc",
        "func_name": "__anonb6fce7720102",
        "snippet": "    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            if (nodes.size() > 1) {\n                auto ope = nodes[1]->token[0];\n                auto num = eval(*nodes[2]);\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n"
    },
    {
        "begin_line": 14,
        "end_line": 23,
        "file_name": "./proj/cpp_peglib/buggy-1/lint/peglint.cc",
        "func_name": "read_file",
        "snippet": "inline bool read_file(const char *path, vector<char> &buff) {\n  ifstream ifs(path, ios::in | ios::binary);\n  if (ifs.fail()) { return false; }\n\n  buff.resize(static_cast<unsigned int>(ifs.seekg(0, ios::end).tellg()));\n  if (!buff.empty()) {\n    ifs.seekg(0, ios::beg).read(&buff[0], static_cast<streamsize>(buff.size()));\n  }\n  return true;\n}\n"
    },
    {
        "begin_line": 25,
        "end_line": 33,
        "file_name": "./proj/cpp_peglib/buggy-1/lint/peglint.cc",
        "func_name": "split",
        "snippet": "inline vector<string> split(const string &s, char delim) {\n  vector<string> elems;\n  stringstream ss(s);\n  string elem;\n  while (getline(ss, elem, delim)) {\n    elems.push_back(elem);\n  }\n  return elems;\n}\n"
    },
    {
        "begin_line": 35,
        "end_line": 188,
        "file_name": "./proj/cpp_peglib/buggy-1/lint/peglint.cc",
        "func_name": "main",
        "snippet": "int main(int argc, const char **argv) {\n  auto opt_ast = false;\n  auto opt_optimize = false;\n  auto opt_mode = true;\n  vector<string> opt_rules;\n  auto opt_help = false;\n  auto opt_source = false;\n  vector<char> source;\n  auto opt_trace = false;\n  vector<const char *> path_list;\n\n  auto argi = 1;\n  while (argi < argc) {\n    auto arg = argv[argi++];\n    if (string(\"--help\") == arg) {\n      opt_help = true;\n    } else if (string(\"--ast\") == arg) {\n      opt_ast = true;\n    } else if (string(\"--opt\") == arg || string(\"--opt-all\") == arg) {\n      opt_optimize = true;\n      opt_mode = true;\n    } else if (string(\"--opt-only\") == arg) {\n      opt_optimize = true;\n      opt_mode = false;\n    } else if (string(\"--opt-rules\") == arg) {\n      if (argi < argc) {\n        std::string s = argv[argi++];\n        opt_rules = split(s, ',');\n      }\n    } else if (string(\"--source\") == arg) {\n      opt_source = true;\n      if (argi < argc) {\n        std::string text = argv[argi++];\n        source.assign(text.begin(), text.end());\n      }\n    } else if (string(\"--trace\") == arg) {\n      opt_trace = true;\n    } else {\n      path_list.push_back(arg);\n    }\n  }\n\n  if (path_list.empty() || opt_help) {\n    cerr << \"usage: grammar_file_path [source_file_path]\" << endl\n         << endl\n         << \"  options:\" << endl\n         << \"    --source: source text\" << endl\n         << \"    --ast: show AST tree\" << endl\n         << \"    --opt, --opt-all: optimaze all AST nodes except nodes \"\n            \"selected with \"\n            \"--opt-rules\"\n         << endl\n         << \"    --opt-only: optimaze only AST nodes selected with --opt-rules\"\n         << endl\n         << \"    --opt-rules rules: CSV definition rules to adjust AST \"\n            \"optimazation\"\n         << endl\n         << \"    --trace: show trace messages\" << endl;\n    return 1;\n  }\n\n  // Check PEG grammar\n  auto syntax_path = path_list[0];\n\n  vector<char> syntax;\n  if (!read_file(syntax_path, syntax)) {\n    cerr << \"can't open the grammar file.\" << endl;\n    return -1;\n  }\n\n  peg::parser parser;\n\n  parser.log = [&](size_t ln, size_t col, const string &msg) {\n    cerr << syntax_path << \":\" << ln << \":\" << col << \": \" << msg << endl;\n  };\n\n  if (!parser.load_grammar(syntax.data(), syntax.size())) { return -1; }\n\n  if (path_list.size() < 2 && !opt_source) { return 0; }\n\n  // Check source\n  std::string source_path = \"[commandline]\";\n  if (path_list.size() >= 2) {\n    if (!read_file(path_list[1], source)) {\n      cerr << \"can't open the code file.\" << endl;\n      return -1;\n    }\n    source_path = path_list[1];\n  }\n\n  parser.log = [&](size_t ln, size_t col, const string &msg) {\n    cerr << source_path << \":\" << ln << \":\" << col << \": \" << msg << endl;\n  };\n\n  if (opt_trace) {\n    size_t prev_pos = 0;\n    parser.enable_trace(\n        [&](const char *name, const char *s, size_t /*n*/,\n            const peg::SemanticValues & /*sv*/, const peg::Context &c,\n            const peg::any & /*dt*/) {\n          auto pos = static_cast<size_t>(s - c.s);\n          auto backtrack = (pos < prev_pos ? \"*\" : \"\");\n          string indent;\n          auto level = c.trace_ids.size() - 1;\n          while (level--) {\n            indent += \"\u2502\";\n          }\n          std::cout << \"E \" << pos << backtrack << \"\\t\" << indent << \"\u250c\" << name\n                    << \" #\" << c.trace_ids.back() << std::endl;\n          prev_pos = static_cast<size_t>(pos);\n        },\n        [&](const char *name, const char *s, size_t /*n*/,\n            const peg::SemanticValues &sv, const peg::Context &c,\n            const peg::any & /*dt*/, size_t len) {\n          auto pos = static_cast<size_t>(s - c.s);\n          if (len != static_cast<size_t>(-1)) { pos += len; }\n          string indent;\n          auto level = c.trace_ids.size() - 1;\n          while (level--) {\n            indent += \"\u2502\";\n          }\n          auto ret = len != static_cast<size_t>(-1) ? \"\u2514o \" : \"\u2514x \";\n          std::stringstream choice;\n          if (sv.choice_count() > 0) {\n            choice << \" \" << sv.choice() << \"/\" << sv.choice_count();\n          }\n          std::string token;\n          if (!sv.tokens.empty()) {\n            const auto &tok = sv.tokens[0];\n            token += \" '\" + std::string(tok.first, tok.second) + \"'\";\n          }\n          std::cout << \"L \" << pos << \"\\t\" << indent << ret << name << \" #\"\n                    << c.trace_ids.back() << choice.str() << token << std::endl;\n        });\n  }\n\n  if (opt_ast) {\n    parser.enable_ast();\n\n    std::shared_ptr<peg::Ast> ast;\n    if (!parser.parse_n(source.data(), source.size(), ast)) { return -1; }\n\n    if (opt_optimize) {\n      ast = peg::AstOptimizer(opt_mode, opt_rules).optimize(ast);\n    }\n\n    std::cout << peg::ast_to_s(ast);\n\n  } else {\n    if (!parser.parse_n(source.data(), source.size())) { return -1; }\n  }\n\n  return 0;\n}\n"
    },
    {
        "begin_line": 107,
        "end_line": 109,
        "file_name": "./proj/cpp_peglib/buggy-1/lint/peglint.cc",
        "func_name": "__anon70ba0ec80102",
        "snippet": "  parser.log = [&](size_t ln, size_t col, const string &msg) {\n    cerr << syntax_path << \":\" << ln << \":\" << col << \": \" << msg << endl;\n  };\n"
    },
    {
        "begin_line": 125,
        "end_line": 127,
        "file_name": "./proj/cpp_peglib/buggy-1/lint/peglint.cc",
        "func_name": "__anon70ba0ec80202",
        "snippet": "  parser.log = [&](size_t ln, size_t col, const string &msg) {\n    cerr << source_path << \":\" << ln << \":\" << col << \": \" << msg << endl;\n  };\n"
    },
    {
        "begin_line": 134,
        "end_line": 145,
        "file_name": "./proj/cpp_peglib/buggy-1/lint/peglint.cc",
        "func_name": "__anon70ba0ec80302",
        "snippet": "            const peg::any & /*dt*/) {\n          auto pos = static_cast<size_t>(s - c.s);\n          auto backtrack = (pos < prev_pos ? \"*\" : \"\");\n          string indent;\n          auto level = c.trace_ids.size() - 1;\n          while (level--) {\n            indent += \"\u2502\";\n          }\n          std::cout << \"E \" << pos << backtrack << \"\\t\" << indent << \"\u250c\" << name\n                    << \" #\" << c.trace_ids.back() << std::endl;\n          prev_pos = static_cast<size_t>(pos);\n        },\n"
    },
    {
        "begin_line": 148,
        "end_line": 168,
        "file_name": "./proj/cpp_peglib/buggy-1/lint/peglint.cc",
        "func_name": "__anon70ba0ec80402",
        "snippet": "            const peg::any & /*dt*/, size_t len) {\n          auto pos = static_cast<size_t>(s - c.s);\n          if (len != static_cast<size_t>(-1)) { pos += len; }\n          string indent;\n          auto level = c.trace_ids.size() - 1;\n          while (level--) {\n            indent += \"\u2502\";\n          }\n          auto ret = len != static_cast<size_t>(-1) ? \"\u2514o \" : \"\u2514x \";\n          std::stringstream choice;\n          if (sv.choice_count() > 0) {\n            choice << \" \" << sv.choice() << \"/\" << sv.choice_count();\n          }\n          std::string token;\n          if (!sv.tokens.empty()) {\n            const auto &tok = sv.tokens[0];\n            token += \" '\" + std::string(tok.first, tok.second) + \"'\";\n          }\n          std::cout << \"L \" << pos << \"\\t\" << indent << ret << name << \" #\"\n                    << c.trace_ids.back() << choice.str() << token << std::endl;\n        });\n"
    },
    {
        "begin_line": 9,
        "end_line": 9,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "CPPPEGLIB_PEGLIB_H",
        "snippet": "#define CPPPEGLIB_PEGLIB_H\n"
    },
    {
        "begin_line": 13,
        "end_line": 13,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEGLIB_USE_STD_ANY",
        "snippet": "#define PEGLIB_USE_STD_ANY _MSVC_LANG >= 201703L\n"
    },
    {
        "begin_line": 15,
        "end_line": 15,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEGLIB_USE_STD_ANY",
        "snippet": "#define PEGLIB_USE_STD_ANY __cplusplus >= 201703L\n"
    },
    {
        "begin_line": 47,
        "end_line": 4008,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "peg",
        "snippet": "namespace peg {\n\n/*-----------------------------------------------------------------------------\n *  any\n *---------------------------------------------------------------------------*/\n\n#if PEGLIB_USE_STD_ANY\nusing any = std::any;\n\n// Define a function alias to std::any_cast using perfect forwarding\ntemplate <typename T, typename... Args>\nauto any_cast(Args &&... args)\n    -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {\n  return std::any_cast<T>(std::forward<Args>(args)...);\n}\n#else\nclass any {\npublic:\n  any() = default;\n\n  any(const any &rhs) : content_(rhs.clone()) {}\n\n  any(any &&rhs) : content_(rhs.content_) { rhs.content_ = nullptr; }\n\n  template <typename T> any(const T &value) : content_(new holder<T>(value)) {}\n\n  any &operator=(const any &rhs) {\n    if (this != &rhs) {\n      if (content_) { delete content_; }\n      content_ = rhs.clone();\n    }\n    return *this;\n  }\n\n  any &operator=(any &&rhs) {\n    if (this != &rhs) {\n      if (content_) { delete content_; }\n      content_ = rhs.content_;\n      rhs.content_ = nullptr;\n    }\n    return *this;\n  }\n\n  ~any() { delete content_; }\n\n  bool has_value() const { return content_ != nullptr; }\n\n  template <typename T> friend T &any_cast(any &val);\n\n  template <typename T> friend const T &any_cast(const any &val);\n\nprivate:\n  struct placeholder {\n    virtual ~placeholder() {}\n    virtual placeholder *clone() const = 0;\n  };\n\n  template <typename T> struct holder : placeholder {\n    holder(const T &value) : value_(value) {}\n    placeholder *clone() const override { return new holder(value_); }\n    T value_;\n  };\n\n  placeholder *clone() const { return content_ ? content_->clone() : nullptr; }\n\n  placeholder *content_ = nullptr;\n};\n\ntemplate <typename T> T &any_cast(any &val) {\n  if (!val.content_) { throw std::bad_cast(); }\n  auto p = dynamic_cast<any::holder<T> *>(val.content_);\n  assert(p);\n  if (!p) { throw std::bad_cast(); }\n  return p->value_;\n}\n\ntemplate <> inline any &any_cast<any>(any &val) { return val; }\n\ntemplate <typename T> const T &any_cast(const any &val) {\n  assert(val.content_);\n  auto p = dynamic_cast<any::holder<T> *>(val.content_);\n  assert(p);\n  if (!p) { throw std::bad_cast(); }\n  return p->value_;\n}\n\ntemplate <> inline const any &any_cast<any>(const any &val) { return val; }\n#endif\n\n/*-----------------------------------------------------------------------------\n *  scope_exit\n *---------------------------------------------------------------------------*/\n\n// This is based on\n// \"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189\".\n\ntemplate <typename EF> struct scope_exit {\n  explicit scope_exit(EF &&f)\n      : exit_function(std::move(f)), execute_on_destruction{true} {}\n\n  scope_exit(scope_exit &&rhs)\n      : exit_function(std::move(rhs.exit_function)),\n        execute_on_destruction{rhs.execute_on_destruction} {\n    rhs.release();\n  }\n\n  ~scope_exit() {\n    if (execute_on_destruction) { this->exit_function(); }\n  }\n\n  void release() { this->execute_on_destruction = false; }\n\nprivate:\n  scope_exit(const scope_exit &) = delete;\n  void operator=(const scope_exit &) = delete;\n  scope_exit &operator=(scope_exit &&) = delete;\n\n  EF exit_function;\n  bool execute_on_destruction;\n};\n\ntemplate <typename EF>\nauto make_scope_exit(EF &&exit_function) -> scope_exit<EF> {\n  return scope_exit<typename std::remove_reference<EF>::type>(\n      std::forward<EF>(exit_function));\n}\n\n/*-----------------------------------------------------------------------------\n *  UTF8 functions\n *---------------------------------------------------------------------------*/\n\ninline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}\n\ninline size_t encode_codepoint(char32_t cp, char *buff) {\n  if (cp < 0x0080) {\n    buff[0] = static_cast<char>(cp & 0x7F);\n    return 1;\n  } else if (cp < 0x0800) {\n    buff[0] = static_cast<char>(0xC0 | ((cp >> 6) & 0x1F));\n    buff[1] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 2;\n  } else if (cp < 0xD800) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0xE000) {\n    // D800 - DFFF is invalid...\n    return 0;\n  } else if (cp < 0x10000) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0x110000) {\n    buff[0] = static_cast<char>(0xF0 | ((cp >> 18) & 0x7));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 12) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[3] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 4;\n  }\n  return 0;\n}\n\ninline std::string encode_codepoint(char32_t cp) {\n  char buff[4];\n  auto l = encode_codepoint(cp, buff);\n  return std::string(buff, l);\n}\n\ninline bool decode_codepoint(const char *s8, size_t l, size_t &bytes,\n                             char32_t &cp) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      bytes = 1;\n      cp = b;\n      return true;\n    } else if ((b & 0xE0) == 0xC0) {\n      if (l >= 2) {\n        bytes = 2;\n        cp = ((static_cast<char32_t>(s8[0] & 0x1F)) << 6) |\n             (static_cast<char32_t>(s8[1] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF0) == 0xE0) {\n      if (l >= 3) {\n        bytes = 3;\n        cp = ((static_cast<char32_t>(s8[0] & 0x0F)) << 12) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[2] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF8) == 0xF0) {\n      if (l >= 4) {\n        bytes = 4;\n        cp = ((static_cast<char32_t>(s8[0] & 0x07)) << 18) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 12) |\n             ((static_cast<char32_t>(s8[2] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[3] & 0x3F));\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\ninline size_t decode_codepoint(const char *s8, size_t l, char32_t &out) {\n  size_t bytes;\n  if (decode_codepoint(s8, l, bytes, out)) { return bytes; }\n  return 0;\n}\n\ninline char32_t decode_codepoint(const char *s8, size_t l) {\n  char32_t out = 0;\n  decode_codepoint(s8, l, out);\n  return out;\n}\n\ninline std::u32string decode(const char *s8, size_t l) {\n  std::u32string out;\n  size_t i = 0;\n  while (i < l) {\n    auto beg = i++;\n    while (i < l && (s8[i] & 0xc0) == 0x80) {\n      i++;\n    }\n    out += decode_codepoint(&s8[beg], (i - beg));\n  }\n  return out;\n}\n\n/*-----------------------------------------------------------------------------\n *  resolve_escape_sequence\n *---------------------------------------------------------------------------*/\n\ninline bool is_hex(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  } else if ('a' <= c && c <= 'f') {\n    v = c - 'a' + 10;\n    return true;\n  } else if ('A' <= c && c <= 'F') {\n    v = c - 'A' + 10;\n    return true;\n  }\n  return false;\n}\n\ninline bool is_digit(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  }\n  return false;\n}\n\ninline std::pair<int, size_t> parse_hex_number(const char *s, size_t n,\n                                               size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_hex(s[i], val)) {\n    ret = static_cast<int>(ret * 16 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n\ninline std::pair<int, size_t> parse_octal_number(const char *s, size_t n,\n                                                 size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_digit(s[i], val)) {\n    ret = static_cast<int>(ret * 8 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n\ninline std::string resolve_escape_sequence(const char *s, size_t n) {\n  std::string r;\n  r.reserve(n);\n\n  size_t i = 0;\n  while (i < n) {\n    auto ch = s[i];\n    if (ch == '\\\\') {\n      i++;\n      if (i == n) { throw std::runtime_error(\"Invalid escape sequence...\"); }\n      switch (s[i]) {\n      case 'n':\n        r += '\\n';\n        i++;\n        break;\n      case 'r':\n        r += '\\r';\n        i++;\n        break;\n      case 't':\n        r += '\\t';\n        i++;\n        break;\n      case '\\'':\n        r += '\\'';\n        i++;\n        break;\n      case '\"':\n        r += '\"';\n        i++;\n        break;\n      case '[':\n        r += '[';\n        i++;\n        break;\n      case ']':\n        r += ']';\n        i++;\n        break;\n      case '\\\\':\n        r += '\\\\';\n        i++;\n        break;\n      case 'x':\n      case 'u': {\n        char32_t cp;\n        std::tie(cp, i) = parse_hex_number(s, n, i + 1);\n        r += encode_codepoint(cp);\n        break;\n      }\n      default: {\n        char32_t cp;\n        std::tie(cp, i) = parse_octal_number(s, n, i);\n        r += encode_codepoint(cp);\n        break;\n      }\n      }\n    } else {\n      r += ch;\n      i++;\n    }\n  }\n  return r;\n}\n\n/*-----------------------------------------------------------------------------\n *  Trie\n *---------------------------------------------------------------------------*/\n\nclass Trie {\npublic:\n  Trie() = default;\n  Trie(const Trie &) = default;\n\n  Trie(const std::vector<std::string> &items) {\n    for (const auto &item : items) {\n      for (size_t len = 1; len <= item.size(); len++) {\n        auto last = len == item.size();\n        std::string s(item.c_str(), len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          dic_.emplace(s, Info{last, last});\n        } else if (last) {\n          it->second.match = true;\n        } else {\n          it->second.done = false;\n        }\n      }\n    }\n  }\n\n  size_t match(const char *text, size_t text_len) const {\n    size_t match_len = 0;\n    {\n      auto done = false;\n      size_t len = 1;\n      while (!done && len <= text_len) {\n        std::string s(text, len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          done = true;\n        } else {\n          if (it->second.match) { match_len = len; }\n          if (it->second.done) { done = true; }\n        }\n        len += 1;\n      }\n    }\n    return match_len;\n  }\n\nprivate:\n  struct Info {\n    bool done;\n    bool match;\n  };\n  std::unordered_map<std::string, Info> dic_;\n};\n\n/*-----------------------------------------------------------------------------\n *  PEG\n *---------------------------------------------------------------------------*/\n\n/*\n * Line information utility function\n */\ninline std::pair<size_t, size_t> line_info(const char *start, const char *cur) {\n  auto p = start;\n  auto col_ptr = p;\n  auto no = 1;\n\n  while (p < cur) {\n    if (*p == '\\n') {\n      no++;\n      col_ptr = p + 1;\n    }\n    p++;\n  }\n\n  auto col = p - col_ptr + 1;\n\n  return std::make_pair(no, col);\n}\n\n/*\n * String tag\n */\ninline constexpr unsigned int str2tag(const char *str, unsigned int h = 0) {\n  return (*str == '\\0')\n             ? h\n             : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));\n}\n\nnamespace udl {\n\ninline constexpr unsigned int operator\"\" _(const char *s, size_t) {\n  return str2tag(s);\n}\n\n} // namespace udl\n\n/*\n * Semantic values\n */\nstruct SemanticValues : protected std::vector<any> {\n  // Input text\n  const char *path = nullptr;\n  const char *ss = nullptr;\n  const std::vector<size_t> *source_line_index = nullptr;\n\n  // Matched string\n  const char *c_str() const { return s_; }\n  size_t length() const { return n_; }\n\n  std::string str() const { return std::string(s_, n_); }\n\n  // Definition name\n  const std::string &name() const { return name_; }\n\n  std::vector<unsigned int> tags;\n\n  // Line number and column at which the matched string is\n  std::pair<size_t, size_t> line_info() const {\n    const auto &idx = *source_line_index;\n\n    auto cur = static_cast<size_t>(std::distance(ss, s_));\n    auto it = std::lower_bound(\n        idx.begin(), idx.end(), cur,\n        [](size_t element, size_t value) { return element < value; });\n\n    auto id = static_cast<size_t>(std::distance(idx.begin(), it));\n    auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);\n    return std::make_pair(id + 1, off + 1);\n  }\n\n  // Choice count\n  size_t choice_count() const { return choice_count_; }\n\n  // Choice number (0 based index)\n  size_t choice() const { return choice_; }\n\n  // Tokens\n  std::vector<std::pair<const char *, size_t>> tokens;\n\n  std::string token(size_t id = 0) const {\n    if (!tokens.empty()) {\n      assert(id < tokens.size());\n      const auto &tok = tokens[id];\n      return std::string(tok.first, tok.second);\n    }\n    return std::string(s_, n_);\n  }\n\n  // Transform the semantic value vector to another vector\n  template <typename T>\n  std::vector<T> transform(size_t beg = 0,\n                           size_t end = static_cast<size_t>(-1)) const {\n    std::vector<T> r;\n    end = (std::min)(end, size());\n    for (size_t i = beg; i < end; i++) {\n      r.emplace_back(any_cast<T>((*this)[i]));\n    }\n    return r;\n  }\n\n  using std::vector<any>::iterator;\n  using std::vector<any>::const_iterator;\n  using std::vector<any>::size;\n  using std::vector<any>::empty;\n  using std::vector<any>::assign;\n  using std::vector<any>::begin;\n  using std::vector<any>::end;\n  using std::vector<any>::rbegin;\n  using std::vector<any>::rend;\n  using std::vector<any>::operator[];\n  using std::vector<any>::at;\n  using std::vector<any>::resize;\n  using std::vector<any>::front;\n  using std::vector<any>::back;\n  using std::vector<any>::push_back;\n  using std::vector<any>::pop_back;\n  using std::vector<any>::insert;\n  using std::vector<any>::erase;\n  using std::vector<any>::clear;\n  using std::vector<any>::swap;\n  using std::vector<any>::emplace;\n  using std::vector<any>::emplace_back;\n\nprivate:\n  friend class Context;\n  friend class Sequence;\n  friend class PrioritizedChoice;\n  friend class Holder;\n  friend class PrecedenceClimbing;\n\n  const char *s_ = nullptr;\n  size_t n_ = 0;\n  size_t choice_count_ = 0;\n  size_t choice_ = 0;\n  std::string name_;\n};\n\n/*\n * Semantic action\n */\ntemplate <typename R, typename F,\n          typename std::enable_if<std::is_void<R>::value,\n                                  std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  fn(std::forward<Args>(args)...);\n  return any();\n}\n\ntemplate <typename R, typename F,\n          typename std::enable_if<\n              std::is_same<typename std::remove_cv<R>::type, any>::value,\n              std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  return fn(std::forward<Args>(args)...);\n}\n\ntemplate <typename R, typename F,\n          typename std::enable_if<\n              !std::is_void<R>::value &&\n                  !std::is_same<typename std::remove_cv<R>::type, any>::value,\n              std::nullptr_t>::type = nullptr,\n          typename... Args>\nany call(F fn, Args &&... args) {\n  return any(fn(std::forward<Args>(args)...));\n}\n\nclass Action {\npublic:\n  Action() = default;\n  Action(const Action &rhs) = default;\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, fn)) {}\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F /*fn*/) {}\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, &F::operator());\n  }\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, fn);\n  }\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F /*fn*/) {}\n\n  Action &operator=(const Action &rhs) = default;\n\n  operator bool() const { return bool(fn_); }\n\n  any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }\n\nprivate:\n  template <typename R> struct TypeAdaptor_sv {\n    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv {\n    TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(const SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_sv_dt {\n    TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(SemanticValues &sv, any &dt)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv_dt {\n    TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(const SemanticValues &sv, any &dt)> fn_;\n  };\n\n  typedef std::function<any(SemanticValues &sv, any &dt)> Fty;\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv) const) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv) const) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  Fty fn_;\n};\n\n/*\n * Semantic predicate\n */\n// Note: 'parse_error' exception class should be be used in sematic action\n// handlers to reject the rule.\nstruct parse_error {\n  parse_error() = default;\n  parse_error(const char *s) : s_(s) {}\n  const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }\n\nprivate:\n  std::string s_;\n};\n\n/*\n * Result\n */\ninline bool success(size_t len) { return len != static_cast<size_t>(-1); }\n\ninline bool fail(size_t len) { return len == static_cast<size_t>(-1); }\n\n/*\n * Context\n */\nclass Context;\nclass Ope;\nclass Definition;\n\ntypedef std::function<void(const char *name, const char *s, size_t n,\n                           const SemanticValues &sv, const Context &c,\n                           const any &dt)>\n    TracerEnter;\n\ntypedef std::function<void(const char *name, const char *s, size_t n,\n                           const SemanticValues &sv, const Context &c,\n                           const any &dt, size_t)>\n    TracerLeave;\n\nclass Context {\npublic:\n  const char *path;\n  const char *s;\n  const size_t l;\n  std::vector<size_t> source_line_index;\n\n  const char *error_pos = nullptr;\n  const char *message_pos = nullptr;\n  std::string message; // TODO: should be `int`.\n\n  std::vector<std::shared_ptr<SemanticValues>> value_stack;\n  size_t value_stack_size = 0;\n\n  std::vector<Definition *> rule_stack;\n  std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;\n\n  bool in_token = false;\n\n  std::shared_ptr<Ope> whitespaceOpe;\n  bool in_whitespace = false;\n\n  std::shared_ptr<Ope> wordOpe;\n\n  std::vector<std::map<std::string, std::string>> capture_scope_stack;\n  size_t capture_scope_stack_size = 0;\n\n  const size_t def_count;\n  const bool enablePackratParsing;\n  std::vector<bool> cache_registered;\n  std::vector<bool> cache_success;\n\n  std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;\n\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n\n  Context(const char *a_path, const char *a_s, size_t a_l, size_t a_def_count,\n          std::shared_ptr<Ope> a_whitespaceOpe, std::shared_ptr<Ope> a_wordOpe,\n          bool a_enablePackratParsing, TracerEnter a_tracer_enter,\n          TracerLeave a_tracer_leave)\n      : path(a_path), s(a_s), l(a_l), whitespaceOpe(a_whitespaceOpe),\n        wordOpe(a_wordOpe), def_count(a_def_count),\n        enablePackratParsing(a_enablePackratParsing),\n        cache_registered(enablePackratParsing ? def_count * (l + 1) : 0),\n        cache_success(enablePackratParsing ? def_count * (l + 1) : 0),\n        tracer_enter(a_tracer_enter), tracer_leave(a_tracer_leave) {\n\n    for (size_t pos = 0; pos < l; pos++) {\n      if (s[pos] == '\\n') { source_line_index.push_back(pos); }\n    }\n    source_line_index.push_back(l);\n\n    args_stack.resize(1);\n\n    push_capture_scope();\n  }\n\n  ~Context() { assert(!value_stack_size); }\n\n  Context(const Context &) = delete;\n  Context(Context &&) = delete;\n  Context operator=(const Context &) = delete;\n\n  template <typename T>\n  void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {\n    if (!enablePackratParsing) {\n      fn(val);\n      return;\n    }\n\n    auto col = a_s - s;\n    auto idx = def_count * static_cast<size_t>(col) + def_id;\n\n    if (cache_registered[idx]) {\n      if (cache_success[idx]) {\n        auto key = std::make_pair(col, def_id);\n        std::tie(len, val) = cache_values[key];\n        return;\n      } else {\n        len = static_cast<size_t>(-1);\n        return;\n      }\n    } else {\n      fn(val);\n      cache_registered[idx] = true;\n      cache_success[idx] = success(len);\n      if (success(len)) {\n        auto key = std::make_pair(col, def_id);\n        cache_values[key] = std::make_pair(len, val);\n      }\n      return;\n    }\n  }\n\n  SemanticValues &push() {\n    assert(value_stack_size <= value_stack.size());\n    if (value_stack_size == value_stack.size()) {\n      value_stack.emplace_back(std::make_shared<SemanticValues>());\n    } else {\n      auto &sv = *value_stack[value_stack_size];\n      if (!sv.empty()) {\n        sv.clear();\n        if (!sv.tags.empty()) { sv.tags.clear(); }\n      }\n      sv.s_ = nullptr;\n      sv.n_ = 0;\n      sv.choice_count_ = 0;\n      sv.choice_ = 0;\n      if (!sv.tokens.empty()) { sv.tokens.clear(); }\n    }\n\n    auto &sv = *value_stack[value_stack_size++];\n    sv.path = path;\n    sv.ss = s;\n    sv.source_line_index = &source_line_index;\n    return sv;\n  }\n\n  void pop() { value_stack_size--; }\n\n  void push_args(std::vector<std::shared_ptr<Ope>> &&args) {\n    args_stack.emplace_back(args);\n  }\n\n  void pop_args() { args_stack.pop_back(); }\n\n  const std::vector<std::shared_ptr<Ope>> &top_args() const {\n    return args_stack[args_stack.size() - 1];\n  }\n\n  void push_capture_scope() {\n    assert(capture_scope_stack_size <= capture_scope_stack.size());\n    if (capture_scope_stack_size == capture_scope_stack.size()) {\n      capture_scope_stack.emplace_back(std::map<std::string, std::string>());\n    } else {\n      auto &cs = capture_scope_stack[capture_scope_stack_size];\n      if (!cs.empty()) { cs.clear(); }\n    }\n    capture_scope_stack_size++;\n  }\n\n  void pop_capture_scope() { capture_scope_stack_size--; }\n\n  void shift_capture_values() {\n    assert(capture_scope_stack.size() >= 2);\n    auto curr = &capture_scope_stack[capture_scope_stack_size - 1];\n    auto prev = curr - 1;\n    for (const auto &kv : *curr) {\n      (*prev)[kv.first] = kv.second;\n    }\n  }\n\n  void set_error_pos(const char *a_s) {\n    if (error_pos < a_s) error_pos = a_s;\n  }\n\n  void trace_enter(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt) const;\n  void trace_leave(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt, size_t len) const;\n  bool is_traceable(const Ope &ope) const;\n\n  mutable size_t next_trace_id = 0;\n  mutable std::list<size_t> trace_ids;\n};\n\n/*\n * Parser operators\n */\nclass Ope {\npublic:\n  struct Visitor;\n\n  virtual ~Ope() {}\n  size_t parse(const char *s, size_t n, SemanticValues &sv, Context &c,\n               any &dt) const;\n  virtual size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt) const = 0;\n  virtual void accept(Visitor &v) = 0;\n};\n\nclass Sequence : public Ope {\npublic:\n  template <typename... Args>\n  Sequence(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}\n  Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto &chldsv = c.push();\n    auto pop_se = make_scope_exit([&]() { c.pop(); });\n    size_t i = 0;\n    for (const auto &ope : opes_) {\n      const auto &rule = *ope;\n      auto len = rule.parse(s + i, n - i, chldsv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n    if (!chldsv.empty()) {\n      for (size_t j = 0; j < chldsv.size(); j++) {\n        sv.emplace_back(std::move(chldsv[j]));\n      }\n    }\n    if (!chldsv.tags.empty()) {\n      for (size_t j = 0; j < chldsv.tags.size(); j++) {\n        sv.tags.emplace_back(std::move(chldsv.tags[j]));\n      }\n    }\n    sv.s_ = chldsv.c_str();\n    sv.n_ = chldsv.length();\n    if (!chldsv.tokens.empty()) {\n      for (size_t j = 0; j < chldsv.tokens.size(); j++) {\n        sv.tokens.emplace_back(std::move(chldsv.tokens[j]));\n      }\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n\nclass PrioritizedChoice : public Ope {\npublic:\n  template <typename... Args>\n  PrioritizedChoice(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)\n      : opes_(opes) {}\n  PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t id = 0;\n    for (const auto &ope : opes_) {\n      auto &chldsv = c.push();\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() {\n        c.pop();\n        c.pop_capture_scope();\n      });\n      auto len = ope->parse(s, n, chldsv, c, dt);\n      if (success(len)) {\n        if (!chldsv.empty()) {\n          for (size_t i = 0; i < chldsv.size(); i++) {\n            sv.emplace_back(std::move(chldsv[i]));\n          }\n        }\n        if (!chldsv.tags.empty()) {\n          for (size_t i = 0; i < chldsv.tags.size(); i++) {\n            sv.tags.emplace_back(std::move(chldsv.tags[i]));\n          }\n        }\n        sv.s_ = chldsv.c_str();\n        sv.n_ = chldsv.length();\n        sv.choice_count_ = opes_.size();\n        sv.choice_ = id;\n        if (!chldsv.tokens.empty()) {\n          for (size_t i = 0; i < chldsv.tokens.size(); i++) {\n            sv.tokens.emplace_back(std::move(chldsv.tokens[i]));\n          }\n        }\n\n        c.shift_capture_values();\n        return len;\n      }\n      id++;\n    }\n    return static_cast<size_t>(-1);\n  }\n\n  void accept(Visitor &v) override;\n\n  size_t size() const { return opes_.size(); }\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n\nclass Repetition : public Ope {\npublic:\n  Repetition(const std::shared_ptr<Ope> &ope, size_t min, size_t max)\n      : ope_(ope), min_(min), max_(max) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t count = 0;\n    size_t i = 0;\n    while (count < min_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        return static_cast<size_t>(-1);\n      }\n      i += len;\n      count++;\n    }\n\n    auto save_error_pos = c.error_pos;\n    while (n - i > 0 && count < max_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      auto save_sv_size = sv.size();\n      auto save_tok_size = sv.tokens.size();\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        if (sv.size() != save_sv_size) {\n          sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));\n          sv.tags.erase(sv.tags.begin() +\n                        static_cast<std::ptrdiff_t>(save_sv_size));\n        }\n        if (sv.tokens.size() != save_tok_size) {\n          sv.tokens.erase(sv.tokens.begin() +\n                          static_cast<std::ptrdiff_t>(save_tok_size));\n        }\n        c.error_pos = save_error_pos;\n        break;\n      }\n      i += len;\n      count++;\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  bool is_zom() const {\n    return min_ == 0 && max_ == std::numeric_limits<size_t>::max();\n  }\n\n  static std::shared_ptr<Repetition> zom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> oom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 1,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> opt(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0, 1);\n  }\n\n  std::shared_ptr<Ope> ope_;\n  size_t min_;\n  size_t max_;\n};\n\nclass AndPredicate : public Ope {\npublic:\n  AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      return 0;\n    } else {\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass NotPredicate : public Ope {\npublic:\n  NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto save_error_pos = c.error_pos;\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    auto len = ope_->parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    } else {\n      c.error_pos = save_error_pos;\n      return 0;\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Dictionary : public Ope, public std::enable_shared_from_this<Dictionary> {\npublic:\n  Dictionary(const std::vector<std::string> &v) : trie_(v) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  Trie trie_;\n};\n\nclass LiteralString : public Ope,\n                      public std::enable_shared_from_this<LiteralString> {\npublic:\n  LiteralString(std::string &&s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n\n  LiteralString(const std::string &s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string lit_;\n  bool ignore_case_;\n  mutable std::once_flag init_is_word_;\n  mutable bool is_word_;\n};\n\nclass CharacterClass : public Ope,\n                       public std::enable_shared_from_this<CharacterClass> {\npublic:\n  CharacterClass(const std::string &s, bool negated) : negated_(negated) {\n    auto chars = decode(s.c_str(), s.length());\n    auto i = 0u;\n    while (i < chars.size()) {\n      if (i + 2 < chars.size() && chars[i + 1] == '-') {\n        auto cp1 = chars[i];\n        auto cp2 = chars[i + 2];\n        ranges_.emplace_back(std::make_pair(cp1, cp2));\n        i += 3;\n      } else {\n        auto cp = chars[i];\n        ranges_.emplace_back(std::make_pair(cp, cp));\n        i += 1;\n      }\n    }\n    assert(!ranges_.empty());\n  }\n\n  CharacterClass(const std::vector<std::pair<char32_t, char32_t>> &ranges,\n                 bool negated)\n      : ranges_(ranges), negated_(negated) {\n    assert(!ranges_.empty());\n  }\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n\n    char32_t cp = 0;\n    auto len = decode_codepoint(s, n, cp);\n\n    for (const auto &range : ranges_) {\n      if (range.first <= cp && cp <= range.second) {\n        if (negated_) {\n          c.set_error_pos(s);\n          return static_cast<size_t>(-1);\n        } else {\n          return len;\n        }\n      }\n    }\n\n    if (negated_) {\n      return len;\n    } else {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::pair<char32_t, char32_t>> ranges_;\n  bool negated_;\n};\n\nclass Character : public Ope, public std::enable_shared_from_this<Character> {\npublic:\n  Character(char ch) : ch_(ch) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1 || s[0] != ch_) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return 1;\n  }\n\n  void accept(Visitor &v) override;\n\n  char ch_;\n};\n\nclass AnyCharacter : public Ope,\n                     public std::enable_shared_from_this<AnyCharacter> {\npublic:\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    auto len = codepoint_length(s, n);\n    if (len < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n};\n\nclass CaptureScope : public Ope {\npublic:\n  CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Capture : public Ope {\npublic:\n  typedef std::function<void(const char *s, size_t n, Context &c)> MatchAction;\n\n  Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)\n      : ope_(ope), match_action_(ma) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    if (success(len) && match_action_) { match_action_(s, len, c); }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n  MatchAction match_action_;\n};\n\nclass TokenBoundary : public Ope {\npublic:\n  TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass Ignore : public Ope {\npublic:\n  Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    const auto &rule = *ope_;\n    auto &chldsv = c.push();\n    auto se = make_scope_exit([&]() { c.pop(); });\n    return rule.parse(s, n, chldsv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\ntypedef std::function<size_t(const char *s, size_t n, SemanticValues &sv,\n                             any &dt)>\n    Parser;\n\nclass User : public Ope {\npublic:\n  User(Parser fn) : fn_(fn) {}\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                    Context & /*c*/, any &dt) const override {\n    assert(fn_);\n    return fn_(s, n, sv, dt);\n  }\n  void accept(Visitor &v) override;\n  std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n      fn_;\n};\n\nclass WeakHolder : public Ope {\npublic:\n  WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto ope = weak_.lock();\n    assert(ope);\n    const auto &rule = *ope;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::weak_ptr<Ope> weak_;\n};\n\nclass Holder : public Ope {\npublic:\n  Holder(Definition *outer) : outer_(outer) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  any reduce(SemanticValues &sv, any &dt) const;\n\n  const char *trace_name() const;\n\n  std::shared_ptr<Ope> ope_;\n  Definition *outer_;\n  mutable std::string trace_name_;\n\n  friend class Definition;\n};\n\ntypedef std::unordered_map<std::string, Definition> Grammar;\n\nclass Reference : public Ope, public std::enable_shared_from_this<Reference> {\npublic:\n  Reference(const Grammar &grammar, const std::string &name, const char *s,\n            bool is_macro, const std::vector<std::shared_ptr<Ope>> &args)\n      : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),\n        rule_(nullptr), iarg_(0) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> get_core_operator() const;\n\n  const Grammar &grammar_;\n  const std::string name_;\n  const char *s_;\n\n  const bool is_macro_;\n  const std::vector<std::shared_ptr<Ope>> args_;\n\n  Definition *rule_;\n  size_t iarg_;\n};\n\nclass Whitespace : public Ope {\npublic:\n  Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    if (c.in_whitespace) { return 0; }\n    c.in_whitespace = true;\n    auto se = make_scope_exit([&]() { c.in_whitespace = false; });\n    const auto &rule = *ope_;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n\nclass BackReference : public Ope {\npublic:\n  BackReference(const std::string &name) : name_(name) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string name_;\n};\n\nclass PrecedenceClimbing : public Ope {\npublic:\n  using BinOpeInfo = std::map<std::string, std::pair<size_t, char>>;\n\n  PrecedenceClimbing(const std::shared_ptr<Ope> &atom,\n                     const std::shared_ptr<Ope> &binop, const BinOpeInfo &info,\n                     const Definition &rule)\n      : atom_(atom), binop_(binop), info_(info), rule_(rule) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    return parse_expression(s, n, sv, c, dt, 0);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> atom_;\n  std::shared_ptr<Ope> binop_;\n  BinOpeInfo info_;\n  const Definition &rule_;\n\nprivate:\n  size_t parse_expression(const char *s, size_t n, SemanticValues &sv,\n                          Context &c, any &dt, size_t min_prec) const;\n\n  Definition &get_reference_for_binop(Context &c) const;\n};\n\n/*\n * Factories\n */\ntemplate <typename... Args> std::shared_ptr<Ope> seq(Args &&... args) {\n  return std::make_shared<Sequence>(static_cast<std::shared_ptr<Ope>>(args)...);\n}\n\ntemplate <typename... Args> std::shared_ptr<Ope> cho(Args &&... args) {\n  return std::make_shared<PrioritizedChoice>(\n      static_cast<std::shared_ptr<Ope>>(args)...);\n}\n\ninline std::shared_ptr<Ope> zom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::zom(ope);\n}\n\ninline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::oom(ope);\n}\n\ninline std::shared_ptr<Ope> opt(const std::shared_ptr<Ope> &ope) {\n  return Repetition::opt(ope);\n}\n\ninline std::shared_ptr<Ope> rep(const std::shared_ptr<Ope> &ope, size_t min,\n                                size_t max) {\n  return std::make_shared<Repetition>(ope, min, max);\n}\n\ninline std::shared_ptr<Ope> apd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<AndPredicate>(ope);\n}\n\ninline std::shared_ptr<Ope> npd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<NotPredicate>(ope);\n}\n\ninline std::shared_ptr<Ope> dic(const std::vector<std::string> &v) {\n  return std::make_shared<Dictionary>(v);\n}\n\ninline std::shared_ptr<Ope> lit(std::string &&s) {\n  return std::make_shared<LiteralString>(s, false);\n}\n\ninline std::shared_ptr<Ope> liti(std::string &&s) {\n  return std::make_shared<LiteralString>(s, true);\n}\n\ninline std::shared_ptr<Ope> cls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, false);\n}\n\ninline std::shared_ptr<Ope>\ncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, false);\n}\n\ninline std::shared_ptr<Ope> ncls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, true);\n}\n\ninline std::shared_ptr<Ope>\nncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, true);\n}\n\ninline std::shared_ptr<Ope> chr(char dt) {\n  return std::make_shared<Character>(dt);\n}\n\ninline std::shared_ptr<Ope> dot() { return std::make_shared<AnyCharacter>(); }\n\ninline std::shared_ptr<Ope> csc(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<CaptureScope>(ope);\n}\n\ninline std::shared_ptr<Ope> cap(const std::shared_ptr<Ope> &ope,\n                                Capture::MatchAction ma) {\n  return std::make_shared<Capture>(ope, ma);\n}\n\ninline std::shared_ptr<Ope> tok(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<TokenBoundary>(ope);\n}\n\ninline std::shared_ptr<Ope> ign(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Ignore>(ope);\n}\n\ninline std::shared_ptr<Ope>\nusr(std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n        fn) {\n  return std::make_shared<User>(fn);\n}\n\ninline std::shared_ptr<Ope> ref(const Grammar &grammar, const std::string &name,\n                                const char *s, bool is_macro,\n                                const std::vector<std::shared_ptr<Ope>> &args) {\n  return std::make_shared<Reference>(grammar, name, s, is_macro, args);\n}\n\ninline std::shared_ptr<Ope> wsp(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));\n}\n\ninline std::shared_ptr<Ope> bkr(const std::string &name) {\n  return std::make_shared<BackReference>(name);\n}\n\ninline std::shared_ptr<Ope> pre(const std::shared_ptr<Ope> &atom,\n                                const std::shared_ptr<Ope> &binop,\n                                const PrecedenceClimbing::BinOpeInfo &info,\n                                const Definition &rule) {\n  return std::make_shared<PrecedenceClimbing>(atom, binop, info, rule);\n}\n\n/*\n * Visitor\n */\nstruct Ope::Visitor {\n  virtual ~Visitor() {}\n  virtual void visit(Sequence & /*ope*/) {}\n  virtual void visit(PrioritizedChoice & /*ope*/) {}\n  virtual void visit(Repetition & /*ope*/) {}\n  virtual void visit(AndPredicate & /*ope*/) {}\n  virtual void visit(NotPredicate & /*ope*/) {}\n  virtual void visit(Dictionary & /*ope*/) {}\n  virtual void visit(LiteralString & /*ope*/) {}\n  virtual void visit(CharacterClass & /*ope*/) {}\n  virtual void visit(Character & /*ope*/) {}\n  virtual void visit(AnyCharacter & /*ope*/) {}\n  virtual void visit(CaptureScope & /*ope*/) {}\n  virtual void visit(Capture & /*ope*/) {}\n  virtual void visit(TokenBoundary & /*ope*/) {}\n  virtual void visit(Ignore & /*ope*/) {}\n  virtual void visit(User & /*ope*/) {}\n  virtual void visit(WeakHolder & /*ope*/) {}\n  virtual void visit(Holder & /*ope*/) {}\n  virtual void visit(Reference & /*ope*/) {}\n  virtual void visit(Whitespace & /*ope*/) {}\n  virtual void visit(BackReference & /*ope*/) {}\n  virtual void visit(PrecedenceClimbing & /*ope*/) {}\n};\n\nstruct IsReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n  void visit(Reference & /*ope*/) override { is_reference = true; }\n  bool is_reference = false;\n};\n\nstruct TraceOpeName : public Ope::Visitor {\n  void visit(Sequence & /*ope*/) override { name = \"Sequence\"; }\n  void visit(PrioritizedChoice & /*ope*/) override {\n    name = \"PrioritizedChoice\";\n  }\n  void visit(Repetition & /*ope*/) override { name = \"Repetition\"; }\n  void visit(AndPredicate & /*ope*/) override { name = \"AndPredicate\"; }\n  void visit(NotPredicate & /*ope*/) override { name = \"NotPredicate\"; }\n  void visit(Dictionary & /*ope*/) override { name = \"Dictionary\"; }\n  void visit(LiteralString & /*ope*/) override { name = \"LiteralString\"; }\n  void visit(CharacterClass & /*ope*/) override { name = \"CharacterClass\"; }\n  void visit(Character & /*ope*/) override { name = \"Character\"; }\n  void visit(AnyCharacter & /*ope*/) override { name = \"AnyCharacter\"; }\n  void visit(CaptureScope & /*ope*/) override { name = \"CaptureScope\"; }\n  void visit(Capture & /*ope*/) override { name = \"Capture\"; }\n  void visit(TokenBoundary & /*ope*/) override { name = \"TokenBoundary\"; }\n  void visit(Ignore & /*ope*/) override { name = \"Ignore\"; }\n  void visit(User & /*ope*/) override { name = \"User\"; }\n  void visit(WeakHolder & /*ope*/) override { name = \"WeakHolder\"; }\n  void visit(Holder &ope) override { name = ope.trace_name(); }\n  void visit(Reference & /*ope*/) override { name = \"Reference\"; }\n  void visit(Whitespace & /*ope*/) override { name = \"Whitespace\"; }\n  void visit(BackReference & /*ope*/) override { name = \"BackReference\"; }\n  void visit(PrecedenceClimbing & /*ope*/) override {\n    name = \"PrecedenceClimbing\";\n  }\n\n  const char *name = nullptr;\n};\n\nstruct AssignIDToDefinition : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override;\n\n  std::unordered_map<void *, size_t> ids;\n};\n\nstruct IsLiteralToken : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      if (!IsLiteralToken::check(*op)) { return; }\n    }\n    result_ = true;\n  }\n\n  void visit(Dictionary & /*ope*/) override { result_ = true; }\n  void visit(LiteralString & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsLiteralToken vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n\nstruct TokenChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  static bool is_token(Ope &ope) {\n    if (IsLiteralToken::check(ope)) { return true; }\n\n    TokenChecker vis;\n    ope.accept(vis);\n    return vis.has_token_boundary_ || !vis.has_rule_;\n  }\n\nprivate:\n  bool has_token_boundary_ = false;\n  bool has_rule_ = false;\n};\n\nstruct DetectLeftRecursion : public Ope::Visitor {\n  DetectLeftRecursion(const std::string &name) : name_(name) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (done_) {\n        break;\n      } else if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    done_ = ope.min_ > 0;\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(Dictionary & /*ope*/) override { done_ = true; }\n  void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }\n  void visit(CharacterClass & /*ope*/) override { done_ = true; }\n  void visit(Character & /*ope*/) override { done_ = true; }\n  void visit(AnyCharacter & /*ope*/) override { done_ = true; }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(User & /*ope*/) override { done_ = true; }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(BackReference & /*ope*/) override { done_ = true; }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  const char *error_s = nullptr;\n\nprivate:\n  std::string name_;\n  std::set<std::string> refs_;\n  bool done_ = false;\n};\n\nstruct HasEmptyElement : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)\n      : refs_(refs) {}\n\n  void visit(Sequence &ope) override {\n    bool save_is_empty = false;\n    const char *save_error_s = nullptr;\n    std::string save_error_name;\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (!is_empty) { return; }\n      save_is_empty = is_empty;\n      save_error_s = error_s;\n      save_error_name = error_name;\n      is_empty = false;\n      error_name.clear();\n    }\n    is_empty = save_is_empty;\n    error_s = save_error_s;\n    error_name = save_error_name;\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (is_empty) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.min_ == 0) {\n      set_error();\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate & /*ope*/) override { set_error(); }\n  void visit(NotPredicate & /*ope*/) override { set_error(); }\n  void visit(LiteralString &ope) override {\n    if (ope.lit_.empty()) { set_error(); }\n  }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool is_empty = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  void set_error() {\n    is_empty = true;\n    error_s = refs_.back().first;\n    error_name = refs_.back().second;\n  }\n  std::list<std::pair<const char *, std::string>> &refs_;\n};\n\nstruct DetectInfiniteLoop : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  DetectInfiniteLoop(const char *s, const std::string &name) {\n    refs_.emplace_back(s, name);\n  }\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.max_ == std::numeric_limits<size_t>::max()) {\n      HasEmptyElement vis(refs_);\n      ope.ope_->accept(vis);\n      if (vis.is_empty) {\n        has_error = true;\n        error_s = vis.error_s;\n        error_name = vis.error_name;\n      }\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool has_error = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  std::list<std::pair<const char *, std::string>> refs_;\n};\n\nstruct ReferenceChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  ReferenceChecker(const Grammar &grammar,\n                   const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  std::unordered_map<std::string, const char *> error_s;\n  std::unordered_map<std::string, std::string> error_message;\n\nprivate:\n  const Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n\nstruct LinkReferences : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  LinkReferences(Grammar &grammar, const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\nprivate:\n  Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n\nstruct FindReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  FindReference(const std::vector<std::shared_ptr<Ope>> &args,\n                const std::vector<std::string> &params)\n      : args_(args), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<Sequence>(opes);\n  }\n  void visit(PrioritizedChoice &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<PrioritizedChoice>(opes);\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = rep(found_ope, ope.min_, ope.max_);\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = apd(found_ope);\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = npd(found_ope);\n  }\n  void visit(Dictionary &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(LiteralString &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(CharacterClass &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(Character &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(AnyCharacter &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(CaptureScope &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n  void visit(Capture &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = cap(found_ope, ope.match_action_);\n  }\n  void visit(TokenBoundary &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = tok(found_ope);\n  }\n  void visit(Ignore &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = ign(found_ope);\n  }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = wsp(found_ope);\n  }\n  void visit(PrecedenceClimbing &ope) override {\n    ope.atom_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n\n  std::shared_ptr<Ope> found_ope;\n\nprivate:\n  const std::vector<std::shared_ptr<Ope>> &args_;\n  const std::vector<std::string> &params_;\n};\n\nstruct IsPrioritizedChoice : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsPrioritizedChoice vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n\n/*\n * Keywords\n */\nstatic const char *WHITESPACE_DEFINITION_NAME = \"%whitespace\";\nstatic const char *WORD_DEFINITION_NAME = \"%word\";\n\n/*\n * Definition\n */\nclass Definition {\npublic:\n  struct Result {\n    bool ret;\n    size_t len;\n    const char *error_pos;\n    const char *message_pos;\n    const std::string message;\n  };\n\n  Definition() : holder_(std::make_shared<Holder>(this)) {}\n\n  Definition(const Definition &rhs) : name(rhs.name), holder_(rhs.holder_) {\n    holder_->outer_ = this;\n  }\n\n  Definition(const std::shared_ptr<Ope> &ope)\n      : holder_(std::make_shared<Holder>(this)) {\n    *this <= ope;\n  }\n\n  operator std::shared_ptr<Ope>() {\n    return std::make_shared<WeakHolder>(holder_);\n  }\n\n  Definition &operator<=(const std::shared_ptr<Ope> &ope) {\n    holder_->ope_ = ope;\n    return *this;\n  }\n\n  Result parse(const char *s, size_t n, const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, path);\n  }\n\n  Result parse(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    SemanticValues sv;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, dt, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, val, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, any &dt, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, dt, val, path);\n  }\n\n  Action operator=(Action a) {\n    action = a;\n    return a;\n  }\n\n  template <typename T> Definition &operator,(T fn) {\n    operator=(fn);\n    return *this;\n  }\n\n  Definition &operator~() {\n    ignoreSemanticValue = true;\n    return *this;\n  }\n\n  void accept(Ope::Visitor &v) { holder_->accept(v); }\n\n  std::shared_ptr<Ope> get_core_operator() const { return holder_->ope_; }\n\n  bool is_token() const {\n    std::call_once(is_token_init_, [this]() {\n      is_token_ = TokenChecker::is_token(*get_core_operator());\n    });\n    return is_token_;\n  }\n\n  std::string name;\n  const char *s_ = nullptr;\n\n  size_t id = 0;\n  Action action;\n  std::function<void(const char *s, size_t n, any &dt)> enter;\n  std::function<void(const char *s, size_t n, size_t matchlen, any &value,\n                     any &dt)>\n      leave;\n  std::function<std::string()> error_message;\n  bool ignoreSemanticValue = false;\n  std::shared_ptr<Ope> whitespaceOpe;\n  std::shared_ptr<Ope> wordOpe;\n  bool enablePackratParsing = false;\n  bool is_macro = false;\n  std::vector<std::string> params;\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n  bool disable_action = false;\n\nprivate:\n  friend class Reference;\n  friend class ParserGenerator;\n\n  Definition &operator=(const Definition &rhs);\n  Definition &operator=(Definition &&rhs);\n\n  void initialize_definition_ids() const {\n    std::call_once(definition_ids_init_, [&]() {\n      AssignIDToDefinition vis;\n      holder_->accept(vis);\n      if (whitespaceOpe) { whitespaceOpe->accept(vis); }\n      if (wordOpe) { wordOpe->accept(vis); }\n      definition_ids_.swap(vis.ids);\n    });\n  }\n\n  Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,\n                    const char *path) const {\n    initialize_definition_ids();\n\n    std::shared_ptr<Ope> ope = holder_;\n    if (whitespaceOpe) { ope = std::make_shared<Sequence>(whitespaceOpe, ope); }\n\n    Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,\n                enablePackratParsing, tracer_enter, tracer_leave);\n\n    auto len = ope->parse(s, n, sv, cxt, dt);\n    return Result{success(len), len, cxt.error_pos, cxt.message_pos,\n                  cxt.message};\n  }\n\n  std::shared_ptr<Holder> holder_;\n  mutable std::once_flag is_token_init_;\n  mutable bool is_token_ = false;\n  mutable std::once_flag assign_id_to_definition_init_;\n  mutable std::once_flag definition_ids_init_;\n  mutable std::unordered_map<void *, size_t> definition_ids_;\n};\n\n/*\n * Implementations\n */\n\ninline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt, const std::string &lit,\n                            std::once_flag &init_is_word, bool &is_word,\n                            bool ignore_case) {\n  size_t i = 0;\n  for (; i < lit.size(); i++) {\n    if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i]))\n                               : (s[i] != lit[i]))) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  // Word check\n  static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr,\n                         nullptr);\n  static SemanticValues dummy_sv;\n  static any dummy_dt;\n\n  std::call_once(init_is_word, [&]() {\n    if (c.wordOpe) {\n      auto len =\n          c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);\n      is_word = success(len);\n    }\n  });\n\n  if (is_word) {\n    NotPredicate ope(c.wordOpe);\n    auto len = ope.parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);\n    if (fail(len)) { return static_cast<size_t>(-1); }\n    i += len;\n  }\n\n  // Skip whiltespace\n  if (!c.in_token) {\n    if (c.whitespaceOpe) {\n      auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n  }\n\n  return i;\n}\n\ninline void Context::trace_enter(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt) const {\n  trace_ids.push_back(next_trace_id++);\n  tracer_enter(name, a_s, n, sv, *this, dt);\n}\n\ninline void Context::trace_leave(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt,\n                                 size_t len) const {\n  tracer_leave(name, a_s, n, sv, *this, dt, len);\n  trace_ids.pop_back();\n}\n\ninline bool Context::is_traceable(const Ope &ope) const {\n  if (tracer_enter && tracer_leave) {\n    IsReference vis;\n    const_cast<Ope &>(ope).accept(vis);\n    return !vis.is_reference;\n  }\n  return false;\n}\n\ninline size_t Ope::parse(const char *s, size_t n, SemanticValues &sv,\n                         Context &c, any &dt) const {\n  if (c.is_traceable(*this)) {\n    TraceOpeName vis;\n    const_cast<Ope &>(*this).accept(vis);\n    c.trace_enter(vis.name, s, n, sv, dt);\n    auto len = parse_core(s, n, sv, c, dt);\n    c.trace_leave(vis.name, s, n, sv, dt, len);\n    return len;\n  }\n  return parse_core(s, n, sv, c, dt);\n}\n\ninline size_t Dictionary::parse_core(const char *s, size_t n,\n                                     SemanticValues & /*sv*/, Context &c,\n                                     any & /*dt*/) const {\n  auto len = trie_.match(s, n);\n  if (len > 0) { return len; }\n  c.set_error_pos(s);\n  return static_cast<size_t>(-1);\n}\n\ninline size_t LiteralString::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_,\n                       ignore_case_);\n}\n\ninline size_t TokenBoundary::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  c.in_token = true;\n  auto se = make_scope_exit([&]() { c.in_token = false; });\n  auto len = ope_->parse(s, n, sv, c, dt);\n  if (success(len)) {\n    sv.tokens.emplace_back(std::make_pair(s, len));\n\n    if (c.whitespaceOpe) {\n      auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);\n      if (fail(l)) { return static_cast<size_t>(-1); }\n      len += l;\n    }\n  }\n  return len;\n}\n\ninline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                 Context &c, any &dt) const {\n  if (!ope_) {\n    throw std::logic_error(\"Uninitialized definition ope was used...\");\n  }\n\n  // Macro reference\n  if (outer_->is_macro) {\n    c.rule_stack.push_back(outer_);\n    auto len = ope_->parse(s, n, sv, c, dt);\n    c.rule_stack.pop_back();\n    return len;\n  }\n\n  size_t len;\n  any val;\n\n  c.packrat(s, outer_->id, len, val, [&](any &a_val) {\n    if (outer_->enter) { outer_->enter(s, n, dt); }\n\n    auto se2 = make_scope_exit([&]() {\n      c.pop();\n\n      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }\n    });\n\n    auto &chldsv = c.push();\n\n    c.rule_stack.push_back(outer_);\n    len = ope_->parse(s, n, chldsv, c, dt);\n    c.rule_stack.pop_back();\n\n    // Invoke action\n    if (success(len)) {\n      chldsv.s_ = s;\n      chldsv.n_ = len;\n      chldsv.name_ = outer_->name;\n\n      if (!IsPrioritizedChoice::check(*ope_)) {\n        chldsv.choice_count_ = 0;\n        chldsv.choice_ = 0;\n      }\n\n      try {\n        a_val = reduce(chldsv, dt);\n      } catch (const parse_error &e) {\n        if (e.what()) {\n          if (c.message_pos < s) {\n            c.message_pos = s;\n            c.message = e.what();\n          }\n        }\n        len = static_cast<size_t>(-1);\n      }\n    }\n  });\n\n  if (success(len)) {\n    if (!outer_->ignoreSemanticValue) {\n      sv.emplace_back(std::move(val));\n      sv.tags.emplace_back(str2tag(outer_->name.c_str()));\n    }\n  } else {\n    if (outer_->error_message) {\n      if (c.message_pos < s) {\n        c.message_pos = s;\n        c.message = outer_->error_message();\n      }\n    }\n  }\n\n  return len;\n}\n\ninline any Holder::reduce(SemanticValues &sv, any &dt) const {\n  if (outer_->action && !outer_->disable_action) {\n    return outer_->action(sv, dt);\n  } else if (sv.empty()) {\n    return any();\n  } else {\n    return std::move(sv.front());\n  }\n}\n\ninline const char *Holder::trace_name() const {\n  if (trace_name_.empty()) { trace_name_ = \"[\" + outer_->name + \"]\"; }\n  return trace_name_.c_str();\n}\n\ninline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                    Context &c, any &dt) const {\n  if (rule_) {\n    // Reference rule\n    if (rule_->is_macro) {\n      // Macro\n      FindReference vis(c.top_args(), c.rule_stack.back()->params);\n\n      // Collect arguments\n      std::vector<std::shared_ptr<Ope>> args;\n      for (auto arg : args_) {\n        arg->accept(vis);\n        args.emplace_back(std::move(vis.found_ope));\n      }\n\n      c.push_args(std::move(args));\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    } else {\n      // Definition\n      c.push_args(std::vector<std::shared_ptr<Ope>>());\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    }\n  } else {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    return args[iarg_]->parse(s, n, sv, c, dt);\n  }\n}\n\ninline std::shared_ptr<Ope> Reference::get_core_operator() const {\n  return rule_->holder_;\n}\n\ninline size_t BackReference::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  auto size = static_cast<int>(c.capture_scope_stack_size);\n  for (auto i = size - 1; i >= 0; i--) {\n    auto index = static_cast<size_t>(i);\n    const auto &cs = c.capture_scope_stack[index];\n    if (cs.find(name_) != cs.end()) {\n      const auto &lit = cs.at(name_);\n      std::once_flag init_is_word;\n      auto is_word = false;\n      return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);\n    }\n  }\n  throw std::runtime_error(\"Invalid back reference...\");\n}\n\ninline Definition &\nPrecedenceClimbing::get_reference_for_binop(Context &c) const {\n  if (rule_.is_macro) {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    auto iarg = dynamic_cast<Reference &>(*binop_).iarg_;\n    auto arg = args[iarg];\n    return *dynamic_cast<Reference &>(*arg).rule_;\n  }\n\n  return *dynamic_cast<Reference &>(*binop_).rule_;\n}\n\ninline size_t PrecedenceClimbing::parse_expression(const char *s, size_t n,\n                                                   SemanticValues &sv,\n                                                   Context &c, any &dt,\n                                                   size_t min_prec) const {\n  auto len = atom_->parse(s, n, sv, c, dt);\n  if (fail(len)) { return len; }\n\n  std::string tok;\n  auto &rule = get_reference_for_binop(c);\n  auto action = rule.action;\n\n  rule.action = [&](SemanticValues &sv2, any &dt2) -> any {\n    tok = sv2.token();\n    if (action) {\n      return action(sv2, dt2);\n    } else if (!sv2.empty()) {\n      return sv2[0];\n    }\n    return any();\n  };\n  auto action_se = make_scope_exit([&]() { rule.action = action; });\n\n  auto save_error_pos = c.error_pos;\n\n  auto i = len;\n  while (i < n) {\n    std::vector<any> save_values(sv.begin(), sv.end());\n    auto save_tokens = sv.tokens;\n\n    auto chv = c.push();\n    auto chl = binop_->parse(s + i, n - i, chv, c, dt);\n    c.pop();\n\n    if (fail(chl)) {\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    auto it = info_.find(tok);\n    if (it == info_.end()) { break; }\n\n    auto level = std::get<0>(it->second);\n    auto assoc = std::get<1>(it->second);\n\n    if (level < min_prec) { break; }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    auto next_min_prec = level;\n    if (assoc == 'L') { next_min_prec = level + 1; }\n\n    chv = c.push();\n    chl = parse_expression(s + i, n - i, chv, c, dt, next_min_prec);\n    c.pop();\n\n    if (fail(chl)) {\n      sv.assign(save_values.begin(), save_values.end());\n      sv.tokens = save_tokens;\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    any val;\n    if (rule_.action) {\n      sv.s_ = s;\n      sv.n_ = i;\n      val = rule_.action(sv, dt);\n    } else if (!sv.empty()) {\n      val = sv[0];\n    }\n    sv.clear();\n    sv.emplace_back(std::move(val));\n  }\n\n  return i;\n}\n\ninline void Sequence::accept(Visitor &v) { v.visit(*this); }\ninline void PrioritizedChoice::accept(Visitor &v) { v.visit(*this); }\ninline void Repetition::accept(Visitor &v) { v.visit(*this); }\ninline void AndPredicate::accept(Visitor &v) { v.visit(*this); }\ninline void NotPredicate::accept(Visitor &v) { v.visit(*this); }\ninline void Dictionary::accept(Visitor &v) { v.visit(*this); }\ninline void LiteralString::accept(Visitor &v) { v.visit(*this); }\ninline void CharacterClass::accept(Visitor &v) { v.visit(*this); }\ninline void Character::accept(Visitor &v) { v.visit(*this); }\ninline void AnyCharacter::accept(Visitor &v) { v.visit(*this); }\ninline void CaptureScope::accept(Visitor &v) { v.visit(*this); }\ninline void Capture::accept(Visitor &v) { v.visit(*this); }\ninline void TokenBoundary::accept(Visitor &v) { v.visit(*this); }\ninline void Ignore::accept(Visitor &v) { v.visit(*this); }\ninline void User::accept(Visitor &v) { v.visit(*this); }\ninline void WeakHolder::accept(Visitor &v) { v.visit(*this); }\ninline void Holder::accept(Visitor &v) { v.visit(*this); }\ninline void Reference::accept(Visitor &v) { v.visit(*this); }\ninline void Whitespace::accept(Visitor &v) { v.visit(*this); }\ninline void BackReference::accept(Visitor &v) { v.visit(*this); }\ninline void PrecedenceClimbing::accept(Visitor &v) { v.visit(*this); }\n\ninline void AssignIDToDefinition::visit(Holder &ope) {\n  auto p = static_cast<void *>(ope.outer_);\n  if (ids.count(p)) { return; }\n  auto id = ids.size();\n  ids[p] = id;\n  ope.outer_->id = id;\n  ope.ope_->accept(*this);\n}\n\ninline void AssignIDToDefinition::visit(Reference &ope) {\n  if (ope.rule_) {\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n    ope.rule_->accept(*this);\n  }\n}\n\ninline void AssignIDToDefinition::visit(PrecedenceClimbing &ope) {\n  ope.atom_->accept(*this);\n  ope.binop_->accept(*this);\n}\n\ninline void TokenChecker::visit(WeakHolder & /*ope*/) { has_rule_ = true; }\n\ninline void TokenChecker::visit(Reference &ope) {\n  if (ope.is_macro_) {\n    ope.rule_->accept(*this);\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n  } else {\n    has_rule_ = true;\n  }\n}\n\ninline void DetectLeftRecursion::visit(Reference &ope) {\n  if (ope.name_ == name_) {\n    error_s = ope.s_;\n  } else if (!refs_.count(ope.name_)) {\n    refs_.insert(ope.name_);\n    if (ope.rule_) {\n      ope.rule_->accept(*this);\n      if (done_ == false) { return; }\n    }\n  }\n  done_ = true;\n}\n\ninline void HasEmptyElement::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n\ninline void DetectInfiniteLoop::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n\ninline void ReferenceChecker::visit(Reference &ope) {\n  auto it = std::find(params_.begin(), params_.end(), ope.name_);\n  if (it != params_.end()) { return; }\n\n  if (!grammar_.count(ope.name_)) {\n    error_s[ope.name_] = ope.s_;\n    error_message[ope.name_] = \"'\" + ope.name_ + \"' is not defined.\";\n  } else {\n    const auto &rule = grammar_.at(ope.name_);\n    if (rule.is_macro) {\n      if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {\n        error_s[ope.name_] = ope.s_;\n        error_message[ope.name_] = \"incorrect number of arguments.\";\n      }\n    } else if (ope.is_macro_) {\n      error_s[ope.name_] = ope.s_;\n      error_message[ope.name_] = \"'\" + ope.name_ + \"' is not macro.\";\n    }\n  }\n}\n\ninline void LinkReferences::visit(Reference &ope) {\n  // Check if the reference is a macro parameter\n  auto found_param = false;\n  for (size_t i = 0; i < params_.size(); i++) {\n    const auto &param = params_[i];\n    if (param == ope.name_) {\n      ope.iarg_ = i;\n      found_param = true;\n      break;\n    }\n  }\n\n  // Check if the reference is a definition rule\n  if (!found_param && grammar_.count(ope.name_)) {\n    auto &rule = grammar_.at(ope.name_);\n    ope.rule_ = &rule;\n  }\n\n  for (auto arg : ope.args_) {\n    arg->accept(*this);\n  }\n}\n\ninline void FindReference::visit(Reference &ope) {\n  for (size_t i = 0; i < args_.size(); i++) {\n    const auto &name = params_[i];\n    if (name == ope.name_) {\n      found_ope = args_[i];\n      return;\n    }\n  }\n  found_ope = ope.shared_from_this();\n}\n\n/*-----------------------------------------------------------------------------\n *  PEG parser generator\n *---------------------------------------------------------------------------*/\n\ntypedef std::unordered_map<std::string, std::shared_ptr<Ope>> Rules;\ntypedef std::function<void(size_t, size_t, const std::string &)> Log;\n\nclass ParserGenerator {\npublic:\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    return get_instance().perform_core(s, n, rules, start, log);\n  }\n\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        std::string &start, Log log) {\n    Rules dummy;\n    return parse(s, n, dummy, start, log);\n  }\n\n  // For debuging purpose\n  static Grammar &grammar() { return get_instance().g; }\n\nprivate:\n  static ParserGenerator &get_instance() {\n    static ParserGenerator instance;\n    return instance;\n  }\n\n  ParserGenerator() {\n    make_grammar();\n    setup_actions();\n  }\n\n  struct Instruction {\n    std::string type;\n    any data;\n  };\n\n  struct Data {\n    std::shared_ptr<Grammar> grammar;\n    std::string start;\n    const char *start_pos = nullptr;\n    std::vector<std::pair<std::string, const char *>> duplicates;\n    std::map<std::string, Instruction> instructions;\n\n    Data() : grammar(std::make_shared<Grammar>()) {}\n  };\n\n  void make_grammar() {\n    // Setup PEG syntax parser\n    g[\"Grammar\"] <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);\n    g[\"Definition\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Parameters\"], g[\"LEFTARROW\"],\n                g[\"Expression\"], opt(g[\"Instruction\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"],\n                opt(g[\"Instruction\"])));\n    g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));\n    g[\"Sequence\"] <= zom(g[\"Prefix\"]);\n    g[\"Prefix\"] <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);\n    g[\"Suffix\"] <= seq(g[\"Primary\"], opt(g[\"Loop\"]));\n    g[\"Loop\"] <= cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"], g[\"Repetition\"]);\n    g[\"Primary\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Arguments\"],\n                npd(g[\"LEFTARROW\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"],\n                npd(seq(opt(g[\"Parameters\"]), g[\"LEFTARROW\"]))),\n            seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),\n            seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),\n            seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),\n            seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]), g[\"BackRef\"],\n            g[\"LiteralI\"], g[\"Dictionary\"], g[\"Literal\"], g[\"NegatedClass\"],\n            g[\"Class\"], g[\"DOT\"]);\n\n    g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);\n    g[\"IdentCont\"] <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));\n\n    const static std::vector<std::pair<char32_t, char32_t>> range = {\n        {0x0080, 0xFFFF}};\n    g[\"IdentStart\"] <= cho(cls(\"a-zA-Z_%\"), cls(range));\n\n    g[\"IdentRest\"] <= cho(g[\"IdentStart\"], cls(\"0-9\"));\n\n    g[\"Dictionary\"] <= seq(g[\"LiteralD\"], oom(seq(g[\"PIPE\"], g[\"LiteralD\"])));\n\n    auto lit_ope = cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))),\n                           cls(\"'\"), g[\"Spacing\"]),\n                       seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))),\n                           cls(\"\\\"\"), g[\"Spacing\"]));\n    g[\"Literal\"] <= lit_ope;\n    g[\"LiteralD\"] <= lit_ope;\n\n    g[\"LiteralI\"] <=\n        cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"),\n                g[\"Spacing\"]),\n            seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"),\n                g[\"Spacing\"]));\n\n    // NOTE: The original Brian Ford's paper uses 'zom' instead of 'oom'.\n    g[\"Class\"] <= seq(chr('['), npd(chr('^')),\n                      tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                      g[\"Spacing\"]);\n    g[\"NegatedClass\"] <= seq(lit(\"[^\"),\n                             tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                             g[\"Spacing\"]);\n\n    g[\"Range\"] <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);\n    g[\"Char\"] <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\^\")),\n                     seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),\n                     seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),\n                     seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),\n                     seq(lit(\"\\\\u\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"),\n                         cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\")),\n                     seq(npd(chr('\\\\')), dot()));\n\n    g[\"Repetition\"] <=\n        seq(g[\"BeginBlacket\"], g[\"RepetitionRange\"], g[\"EndBlacket\"]);\n    g[\"RepetitionRange\"] <= cho(seq(g[\"Number\"], g[\"COMMA\"], g[\"Number\"]),\n                                seq(g[\"Number\"], g[\"COMMA\"]), g[\"Number\"],\n                                seq(g[\"COMMA\"], g[\"Number\"]));\n    g[\"Number\"] <= seq(oom(cls(\"0-9\")), g[\"Spacing\"]);\n\n    g[\"LEFTARROW\"] <=\n        seq(cho(lit(\"<-\"), lit(reinterpret_cast<const char *>(u8\"\u2190\"))),\n            g[\"Spacing\"]);\n    ~g[\"SLASH\"] <= seq(chr('/'), g[\"Spacing\"]);\n    ~g[\"PIPE\"] <= seq(chr('|'), g[\"Spacing\"]);\n    g[\"AND\"] <= seq(chr('&'), g[\"Spacing\"]);\n    g[\"NOT\"] <= seq(chr('!'), g[\"Spacing\"]);\n    g[\"QUESTION\"] <= seq(chr('?'), g[\"Spacing\"]);\n    g[\"STAR\"] <= seq(chr('*'), g[\"Spacing\"]);\n    g[\"PLUS\"] <= seq(chr('+'), g[\"Spacing\"]);\n    ~g[\"OPEN\"] <= seq(chr('('), g[\"Spacing\"]);\n    ~g[\"CLOSE\"] <= seq(chr(')'), g[\"Spacing\"]);\n    g[\"DOT\"] <= seq(chr('.'), g[\"Spacing\"]);\n\n    ~g[\"Spacing\"] <= zom(cho(g[\"Space\"], g[\"Comment\"]));\n    g[\"Comment\"] <=\n        seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);\n    g[\"Space\"] <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);\n    g[\"EndOfLine\"] <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));\n    g[\"EndOfFile\"] <= npd(dot());\n\n    ~g[\"BeginTok\"] <= seq(chr('<'), g[\"Spacing\"]);\n    ~g[\"EndTok\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    ~g[\"BeginCapScope\"] <= seq(chr('$'), chr('('), g[\"Spacing\"]);\n    ~g[\"EndCapScope\"] <= seq(chr(')'), g[\"Spacing\"]);\n\n    g[\"BeginCap\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), chr('<'), g[\"Spacing\"]);\n    ~g[\"EndCap\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    g[\"BackRef\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), g[\"Spacing\"]);\n\n    g[\"IGNORE\"] <= chr('~');\n\n    g[\"Ignore\"] <= opt(g[\"IGNORE\"]);\n    g[\"Parameters\"] <= seq(g[\"OPEN\"], g[\"Identifier\"],\n                           zom(seq(g[\"COMMA\"], g[\"Identifier\"])), g[\"CLOSE\"]);\n    g[\"Arguments\"] <= seq(g[\"OPEN\"], g[\"Expression\"],\n                          zom(seq(g[\"COMMA\"], g[\"Expression\"])), g[\"CLOSE\"]);\n    ~g[\"COMMA\"] <= seq(chr(','), g[\"Spacing\"]);\n\n    // Instruction grammars\n    g[\"Instruction\"] <=\n        seq(g[\"BeginBlacket\"], cho(g[\"PrecedenceClimbing\"]), g[\"EndBlacket\"]);\n\n    ~g[\"SpacesZom\"] <= zom(g[\"Space\"]);\n    ~g[\"SpacesOom\"] <= oom(g[\"Space\"]);\n    ~g[\"BeginBlacket\"] <= seq(chr('{'), g[\"Spacing\"]);\n    ~g[\"EndBlacket\"] <= seq(chr('}'), g[\"Spacing\"]);\n\n    // PrecedenceClimbing instruction\n    g[\"PrecedenceClimbing\"] <=\n        seq(lit(\"precedence\"), g[\"SpacesZom\"], g[\"PrecedenceInfo\"],\n            zom(seq(g[\"SpacesOom\"], g[\"PrecedenceInfo\"])), g[\"SpacesZom\"]);\n    g[\"PrecedenceInfo\"] <=\n        seq(g[\"PrecedenceAssoc\"],\n            oom(seq(ign(g[\"SpacesOom\"]), g[\"PrecedenceOpe\"])));\n    g[\"PrecedenceOpe\"] <=\n        tok(oom(\n            seq(npd(cho(g[\"PrecedenceAssoc\"], g[\"Space\"], chr('}'))), dot())));\n    g[\"PrecedenceAssoc\"] <= cls(\"LR\");\n\n    // Set definition names\n    for (auto &x : g) {\n      x.second.name = x.first;\n    }\n  }\n\n  void setup_actions() {\n    g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      auto is_macro = sv.choice() == 0;\n      auto ignore = any_cast<bool>(sv[0]);\n      auto name = any_cast<std::string>(sv[1]);\n\n      std::vector<std::string> params;\n      std::shared_ptr<Ope> ope;\n      if (is_macro) {\n        params = any_cast<std::vector<std::string>>(sv[2]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[4]);\n        if (sv.size() == 6) {\n          data.instructions[name] = any_cast<Instruction>(sv[5]);\n        }\n      } else {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[3]);\n        if (sv.size() == 5) {\n          data.instructions[name] = any_cast<Instruction>(sv[4]);\n        }\n      }\n\n      auto &grammar = *data.grammar;\n      if (!grammar.count(name)) {\n        auto &rule = grammar[name];\n        rule <= ope;\n        rule.name = name;\n        rule.s_ = sv.c_str();\n        rule.ignoreSemanticValue = ignore;\n        rule.is_macro = is_macro;\n        rule.params = params;\n\n        if (data.start.empty()) {\n          data.start = name;\n          data.start_pos = sv.c_str();\n        }\n      } else {\n        data.duplicates.emplace_back(name, sv.c_str());\n      }\n    };\n\n    g[\"Expression\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (auto i = 0u; i < sv.size(); i++) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));\n        }\n        const std::shared_ptr<Ope> ope =\n            std::make_shared<PrioritizedChoice>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Sequence\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (const auto &x : sv) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));\n        }\n        const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Prefix\"] = [&](const SemanticValues &sv) {\n      std::shared_ptr<Ope> ope;\n      if (sv.size() == 1) {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        assert(sv.size() == 2);\n        auto tok = any_cast<char>(sv[0]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        if (tok == '&') {\n          ope = apd(ope);\n        } else { // '!'\n          ope = npd(ope);\n        }\n      }\n      return ope;\n    };\n\n    struct Loop {\n      enum class Type { opt = 0, zom, oom, rep };\n      Type type;\n      std::pair<size_t, size_t> range;\n    };\n\n    g[\"Suffix\"] = [&](const SemanticValues &sv) {\n      auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      if (sv.size() == 1) {\n        return ope;\n      } else {\n        assert(sv.size() == 2);\n        auto loop = any_cast<Loop>(sv[1]);\n        switch (loop.type) {\n        case Loop::Type::opt: return opt(ope);\n        case Loop::Type::zom: return zom(ope);\n        case Loop::Type::oom: return oom(ope);\n        default: // Regex-like repetition\n          return rep(ope, loop.range.first, loop.range.second);\n        }\n      }\n    };\n\n    g[\"Loop\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: // Option\n        return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};\n      case 1: // Zero or More\n        return Loop{Loop::Type::zom, std::pair<size_t, size_t>()};\n      case 2: // One or More\n        return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};\n      default: // Regex-like repetition\n        return Loop{Loop::Type::rep,\n                    any_cast<std::pair<size_t, size_t>>(sv[0])};\n      }\n    };\n\n    g[\"RepetitionRange\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: { // Number COMMA Number\n        auto min = any_cast<size_t>(sv[0]);\n        auto max = any_cast<size_t>(sv[1]);\n        return std::make_pair(min, max);\n      }\n      case 1: // Number COMMA\n        return std::make_pair(any_cast<size_t>(sv[0]),\n                              std::numeric_limits<size_t>::max());\n      case 2: { // Number\n        auto n = any_cast<size_t>(sv[0]);\n        return std::make_pair(n, n);\n      }\n      default: // COMMA Number\n        return std::make_pair(std::numeric_limits<size_t>::min(),\n                              any_cast<size_t>(sv[0]));\n      }\n    };\n    g[\"Number\"] = [&](const SemanticValues &sv) {\n      std::stringstream ss(sv.str());\n      size_t n;\n      ss >> n;\n      return n;\n    };\n\n    g[\"Primary\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      switch (sv.choice()) {\n      case 0:   // Macro Reference\n      case 1: { // Reference\n        auto is_macro = sv.choice() == 0;\n        auto ignore = any_cast<bool>(sv[0]);\n        const auto &ident = any_cast<std::string>(sv[1]);\n\n        std::vector<std::shared_ptr<Ope>> args;\n        if (is_macro) {\n          args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);\n        }\n\n        std::shared_ptr<Ope> ope =\n            ref(*data.grammar, ident, sv.c_str(), is_macro, args);\n\n        if (ignore) {\n          return ign(ope);\n        } else {\n          return ope;\n        }\n      }\n      case 2: { // (Expression)\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      case 3: { // TokenBoundary\n        return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 4: { // CaptureScope\n        return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 5: { // Capture\n        const auto &name = any_cast<std::string>(sv[0]);\n        auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {\n          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];\n          cs[name] = std::string(a_s, a_n);\n        });\n      }\n      default: {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      }\n    };\n\n    g[\"IdentCont\"] = [](const SemanticValues &sv) {\n      return std::string(sv.c_str(), sv.length());\n    };\n\n    g[\"Dictionary\"] = [](const SemanticValues &sv) {\n      auto items = sv.transform<std::string>();\n      return dic(items);\n    };\n\n    g[\"Literal\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return lit(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralI\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return liti(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralD\"] = [](const SemanticValues &sv) {\n      auto &tok = sv.tokens.front();\n      return resolve_escape_sequence(tok.first, tok.second);\n    };\n\n    g[\"Class\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return cls(ranges);\n    };\n    g[\"NegatedClass\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return ncls(ranges);\n    };\n    g[\"Range\"] = [](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: {\n        auto s1 = any_cast<std::string>(sv[0]);\n        auto s2 = any_cast<std::string>(sv[1]);\n        auto cp1 = decode_codepoint(s1.c_str(), s1.length());\n        auto cp2 = decode_codepoint(s2.c_str(), s2.length());\n        return std::make_pair(cp1, cp2);\n      }\n      case 1: {\n        auto s = any_cast<std::string>(sv[0]);\n        auto cp = decode_codepoint(s.c_str(), s.length());\n        return std::make_pair(cp, cp);\n      }\n      }\n      return std::make_pair<char32_t, char32_t>(0, 0);\n    };\n    g[\"Char\"] = [](const SemanticValues &sv) {\n      return resolve_escape_sequence(sv.c_str(), sv.length());\n    };\n\n    g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n\n    g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };\n\n    g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };\n\n    g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };\n\n    g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };\n\n    g[\"Parameters\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n\n    g[\"Arguments\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::shared_ptr<Ope>>();\n    };\n\n    g[\"PrecedenceClimbing\"] = [](const SemanticValues &sv) {\n      PrecedenceClimbing::BinOpeInfo binOpeInfo;\n      size_t level = 1;\n      for (auto v : sv) {\n        auto tokens = any_cast<std::vector<std::string>>(v);\n        auto assoc = tokens[0][0];\n        for (size_t i = 1; i < tokens.size(); i++) {\n          const auto &tok = tokens[i];\n          binOpeInfo[tok] = std::make_pair(level, assoc);\n        }\n        level++;\n      }\n      Instruction instruction;\n      instruction.type = \"precedence\";\n      instruction.data = binOpeInfo;\n      return instruction;\n    };\n    g[\"PrecedenceInfo\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n    g[\"PrecedenceOpe\"] = [](const SemanticValues &sv) { return sv.token(); };\n    g[\"PrecedenceAssoc\"] = [](const SemanticValues &sv) { return sv.token(); };\n  }\n\n  bool apply_precedence_instruction(Definition &rule,\n                                    const PrecedenceClimbing::BinOpeInfo &info,\n                                    const char *s, Log log) {\n    try {\n      auto &seq = dynamic_cast<Sequence &>(*rule.get_core_operator());\n      auto atom = seq.opes_[0];\n      auto &rep = dynamic_cast<Repetition &>(*seq.opes_[1]);\n      auto &seq1 = dynamic_cast<Sequence &>(*rep.ope_);\n      auto binop = seq1.opes_[0];\n      auto atom1 = seq1.opes_[1];\n\n      auto atom_name = dynamic_cast<Reference &>(*atom).name_;\n      auto binop_name = dynamic_cast<Reference &>(*binop).name_;\n      auto atom1_name = dynamic_cast<Reference &>(*atom1).name_;\n\n      if (!rep.is_zom() || atom_name != atom1_name || atom_name == binop_name) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"'precedence' instruction cannt be applied to '\" + rule.name +\n                  \"'.\");\n        }\n        return false;\n      }\n\n      rule.holder_->ope_ = pre(atom, binop, info, rule);\n      rule.disable_action = true;\n    } catch (...) {\n      if (log) {\n        auto line = line_info(s, rule.s_);\n        log(line.first, line.second,\n            \"'precedence' instruction cannt be applied to '\" + rule.name +\n                \"'.\");\n      }\n      return false;\n    }\n    return true;\n  }\n\n  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check if the start rule has ignore operator\n    {\n      auto &rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");\n        }\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }\n\n  Grammar g;\n};\n\n/*-----------------------------------------------------------------------------\n *  AST\n *---------------------------------------------------------------------------*/\n\ntemplate <typename Annotation> struct AstBase : public Annotation {\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name,\n          const std::vector<std::shared_ptr<AstBase>> &a_nodes,\n          size_t a_position = 0, size_t a_length = 0, size_t a_choice_count = 0,\n          size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(false),\n        nodes(a_nodes) {}\n\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name, const std::string &a_token, size_t a_position = 0,\n          size_t a_length = 0, size_t a_choice_count = 0, size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(true),\n        token(a_token) {}\n\n  AstBase(const AstBase &ast, const char *a_original_name,\n          size_t a_position = 0, size_t a_length = 0,\n          size_t a_original_choice_count = 0, size_t a_original_choise = 0)\n      : path(ast.path), line(ast.line), column(ast.column), name(ast.name),\n        position(a_position), length(a_length), choice_count(ast.choice_count),\n        choice(ast.choice), original_name(a_original_name),\n        original_choice_count(a_original_choice_count),\n        original_choice(a_original_choise), tag(ast.tag),\n        original_tag(str2tag(a_original_name)), is_token(ast.is_token),\n        token(ast.token), nodes(ast.nodes), parent(ast.parent) {}\n\n  const std::string path;\n  const size_t line = 1;\n  const size_t column = 1;\n\n  const std::string name;\n  size_t position;\n  size_t length;\n  const size_t choice_count;\n  const size_t choice;\n  const std::string original_name;\n  const size_t original_choice_count;\n  const size_t original_choice;\n  const unsigned int tag;\n  const unsigned int original_tag;\n\n  const bool is_token;\n  const std::string token;\n\n  std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;\n  std::weak_ptr<AstBase<Annotation>> parent;\n};\n\ntemplate <typename T>\nvoid ast_to_s_core(const std::shared_ptr<T> &ptr, std::string &s, int level,\n                   std::function<std::string(const T &ast, int level)> fn) {\n  const auto &ast = *ptr;\n  for (auto i = 0; i < level; i++) {\n    s += \"  \";\n  }\n  auto name = ast.original_name;\n  if (ast.original_choice_count > 0) {\n    name += \"/\" + std::to_string(ast.original_choice);\n  }\n  if (ast.name != ast.original_name) { name += \"[\" + ast.name + \"]\"; }\n  if (ast.is_token) {\n    s += \"- \" + name + \" (\" + ast.token + \")\\n\";\n  } else {\n    s += \"+ \" + name + \"\\n\";\n  }\n  if (fn) { s += fn(ast, level + 1); }\n  for (auto node : ast.nodes) {\n    ast_to_s_core(node, s, level + 1, fn);\n  }\n}\n\ntemplate <typename T>\nstd::string\nast_to_s(const std::shared_ptr<T> &ptr,\n         std::function<std::string(const T &ast, int level)> fn = nullptr) {\n  std::string s;\n  ast_to_s_core(ptr, s, 0, fn);\n  return s;\n}\n\nstruct AstOptimizer {\n  AstOptimizer(bool mode, const std::vector<std::string> &rules = {})\n      : mode_(mode), rules_(rules) {}\n\n  template <typename T>\n  std::shared_ptr<T> optimize(std::shared_ptr<T> original,\n                              std::shared_ptr<T> parent = nullptr) {\n    auto found =\n        std::find(rules_.begin(), rules_.end(), original->name) != rules_.end();\n    bool opt = mode_ ? !found : found;\n\n    if (opt && original->nodes.size() == 1) {\n      auto child = optimize(original->nodes[0], parent);\n      return std::make_shared<T>(*child, original->name.c_str(),\n                                 original->choice_count, original->position,\n                                 original->length, original->choice);\n    }\n\n    auto ast = std::make_shared<T>(*original);\n    ast->parent = parent;\n    ast->nodes.clear();\n    for (auto node : original->nodes) {\n      auto child = optimize(node, ast);\n      ast->nodes.push_back(child);\n    }\n    return ast;\n  }\n\nprivate:\n  const bool mode_;\n  const std::vector<std::string> rules_;\n};\n\nstruct EmptyType {};\ntypedef AstBase<EmptyType> Ast;\n\ntemplate <typename T = Ast> void add_ast_action(Definition &rule) {\n  rule.action = [&](const SemanticValues &sv) {\n    auto line = sv.line_info();\n\n    if (rule.is_token()) {\n      return std::make_shared<T>(sv.path, line.first, line.second,\n                                 rule.name.c_str(), sv.token(),\n                                 std::distance(sv.ss, sv.c_str()), sv.length(),\n                                 sv.choice_count(), sv.choice());\n    }\n\n    auto ast = std::make_shared<T>(\n        sv.path, line.first, line.second, rule.name.c_str(),\n        sv.transform<std::shared_ptr<T>>(), std::distance(sv.ss, sv.c_str()),\n        sv.length(), sv.choice_count(), sv.choice());\n\n    for (auto node : ast->nodes) {\n      node->parent = ast;\n    }\n    return ast;\n  };\n}\n\n#define PEG_EXPAND(...) __VA_ARGS__\n#define PEG_CONCAT(a, b) a##b\n#define PEG_CONCAT2(a, b) PEG_CONCAT(a, b)\n\n#define PEG_PICK(                                                              \\\n    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, \\\n    a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, \\\n    a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, \\\n    a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, \\\n    a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, \\\n    a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, \\\n    a92, a93, a94, a95, a96, a97, a98, a99, a100, ...)                         \\\n  a100\n\n#define PEG_COUNT(...)                                                         \\\n  PEG_EXPAND(PEG_PICK(                                                         \\\n      __VA_ARGS__, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87,    \\\n      86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69,  \\\n      68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,  \\\n      50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,  \\\n      32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,  \\\n      14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))\n\n#define PEG_DEF_1(r)                                                           \\\n  peg::Definition r;                                                           \\\n  r.name = #r;                                                                 \\\n  peg::add_ast_action(r);\n\n#define PEG_DEF_2(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_1(__VA_ARGS__))\n#define PEG_DEF_3(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_2(__VA_ARGS__))\n#define PEG_DEF_4(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_3(__VA_ARGS__))\n#define PEG_DEF_5(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_4(__VA_ARGS__))\n#define PEG_DEF_6(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_5(__VA_ARGS__))\n#define PEG_DEF_7(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_6(__VA_ARGS__))\n#define PEG_DEF_8(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_7(__VA_ARGS__))\n#define PEG_DEF_9(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_8(__VA_ARGS__))\n#define PEG_DEF_10(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_9(__VA_ARGS__))\n#define PEG_DEF_11(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_10(__VA_ARGS__))\n#define PEG_DEF_12(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_11(__VA_ARGS__))\n#define PEG_DEF_13(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_12(__VA_ARGS__))\n#define PEG_DEF_14(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_13(__VA_ARGS__))\n#define PEG_DEF_15(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_14(__VA_ARGS__))\n#define PEG_DEF_16(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_15(__VA_ARGS__))\n#define PEG_DEF_17(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_16(__VA_ARGS__))\n#define PEG_DEF_18(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_17(__VA_ARGS__))\n#define PEG_DEF_19(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_18(__VA_ARGS__))\n#define PEG_DEF_20(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_19(__VA_ARGS__))\n#define PEG_DEF_21(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_20(__VA_ARGS__))\n#define PEG_DEF_22(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_21(__VA_ARGS__))\n#define PEG_DEF_23(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_22(__VA_ARGS__))\n#define PEG_DEF_24(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_23(__VA_ARGS__))\n#define PEG_DEF_25(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_24(__VA_ARGS__))\n#define PEG_DEF_26(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_25(__VA_ARGS__))\n#define PEG_DEF_27(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_26(__VA_ARGS__))\n#define PEG_DEF_28(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_27(__VA_ARGS__))\n#define PEG_DEF_29(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_28(__VA_ARGS__))\n#define PEG_DEF_30(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_29(__VA_ARGS__))\n#define PEG_DEF_31(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_30(__VA_ARGS__))\n#define PEG_DEF_32(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_31(__VA_ARGS__))\n#define PEG_DEF_33(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_32(__VA_ARGS__))\n#define PEG_DEF_34(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_33(__VA_ARGS__))\n#define PEG_DEF_35(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_34(__VA_ARGS__))\n#define PEG_DEF_36(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_35(__VA_ARGS__))\n#define PEG_DEF_37(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_36(__VA_ARGS__))\n#define PEG_DEF_38(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_37(__VA_ARGS__))\n#define PEG_DEF_39(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_38(__VA_ARGS__))\n#define PEG_DEF_40(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_39(__VA_ARGS__))\n#define PEG_DEF_41(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_40(__VA_ARGS__))\n#define PEG_DEF_42(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_41(__VA_ARGS__))\n#define PEG_DEF_43(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_42(__VA_ARGS__))\n#define PEG_DEF_44(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_43(__VA_ARGS__))\n#define PEG_DEF_45(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_44(__VA_ARGS__))\n#define PEG_DEF_46(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_45(__VA_ARGS__))\n#define PEG_DEF_47(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_46(__VA_ARGS__))\n#define PEG_DEF_48(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_47(__VA_ARGS__))\n#define PEG_DEF_49(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_48(__VA_ARGS__))\n#define PEG_DEF_50(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_49(__VA_ARGS__))\n#define PEG_DEF_51(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_50(__VA_ARGS__))\n#define PEG_DEF_52(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_51(__VA_ARGS__))\n#define PEG_DEF_53(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_52(__VA_ARGS__))\n#define PEG_DEF_54(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_53(__VA_ARGS__))\n#define PEG_DEF_55(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_54(__VA_ARGS__))\n#define PEG_DEF_56(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_55(__VA_ARGS__))\n#define PEG_DEF_57(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_56(__VA_ARGS__))\n#define PEG_DEF_58(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_57(__VA_ARGS__))\n#define PEG_DEF_59(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_58(__VA_ARGS__))\n#define PEG_DEF_60(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_59(__VA_ARGS__))\n#define PEG_DEF_61(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_60(__VA_ARGS__))\n#define PEG_DEF_62(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_61(__VA_ARGS__))\n#define PEG_DEF_63(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_62(__VA_ARGS__))\n#define PEG_DEF_64(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_63(__VA_ARGS__))\n#define PEG_DEF_65(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_64(__VA_ARGS__))\n#define PEG_DEF_66(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_65(__VA_ARGS__))\n#define PEG_DEF_67(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_66(__VA_ARGS__))\n#define PEG_DEF_68(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_67(__VA_ARGS__))\n#define PEG_DEF_69(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_68(__VA_ARGS__))\n#define PEG_DEF_70(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_69(__VA_ARGS__))\n#define PEG_DEF_71(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_70(__VA_ARGS__))\n#define PEG_DEF_72(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_71(__VA_ARGS__))\n#define PEG_DEF_73(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_72(__VA_ARGS__))\n#define PEG_DEF_74(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_73(__VA_ARGS__))\n#define PEG_DEF_75(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_74(__VA_ARGS__))\n#define PEG_DEF_76(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_75(__VA_ARGS__))\n#define PEG_DEF_77(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_76(__VA_ARGS__))\n#define PEG_DEF_78(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_77(__VA_ARGS__))\n#define PEG_DEF_79(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_78(__VA_ARGS__))\n#define PEG_DEF_80(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_79(__VA_ARGS__))\n#define PEG_DEF_81(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_80(__VA_ARGS__))\n#define PEG_DEF_82(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_81(__VA_ARGS__))\n#define PEG_DEF_83(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_82(__VA_ARGS__))\n#define PEG_DEF_84(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_83(__VA_ARGS__))\n#define PEG_DEF_85(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_84(__VA_ARGS__))\n#define PEG_DEF_86(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_85(__VA_ARGS__))\n#define PEG_DEF_87(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_86(__VA_ARGS__))\n#define PEG_DEF_88(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_87(__VA_ARGS__))\n#define PEG_DEF_89(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_88(__VA_ARGS__))\n#define PEG_DEF_90(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_89(__VA_ARGS__))\n#define PEG_DEF_91(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_90(__VA_ARGS__))\n#define PEG_DEF_92(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_91(__VA_ARGS__))\n#define PEG_DEF_93(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_92(__VA_ARGS__))\n#define PEG_DEF_94(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_93(__VA_ARGS__))\n#define PEG_DEF_95(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_94(__VA_ARGS__))\n#define PEG_DEF_96(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_95(__VA_ARGS__))\n#define PEG_DEF_97(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_96(__VA_ARGS__))\n#define PEG_DEF_98(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_97(__VA_ARGS__))\n#define PEG_DEF_99(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_98(__VA_ARGS__))\n#define PEG_DEF_100(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_99(__VA_ARGS__))\n\n#define AST_DEFINITIONS(...)                                                   \\\n  PEG_EXPAND(PEG_CONCAT2(PEG_DEF_, PEG_COUNT(__VA_ARGS__))(__VA_ARGS__))\n\n/*-----------------------------------------------------------------------------\n *  parser\n *---------------------------------------------------------------------------*/\n\nclass parser {\npublic:\n  parser() = default;\n\n  parser(const char *s, size_t n, const Rules &rules) {\n    load_grammar(s, n, rules);\n  }\n\n  parser(const char *s, const Rules &rules) : parser(s, strlen(s), rules) {}\n\n  parser(const char *s, size_t n) : parser(s, n, Rules()) {}\n\n  parser(const char *s) : parser(s, strlen(s), Rules()) {}\n\n  operator bool() { return grammar_ != nullptr; }\n\n  bool load_grammar(const char *s, size_t n, const Rules &rules) {\n    grammar_ = ParserGenerator::parse(s, n, rules, start_, log);\n    return grammar_ != nullptr;\n  }\n\n  bool load_grammar(const char *s, size_t n) {\n    return load_grammar(s, n, Rules());\n  }\n\n  bool load_grammar(const char *s, const Rules &rules) {\n    auto n = strlen(s);\n    return load_grammar(s, n, rules);\n  }\n\n  bool load_grammar(const char *s) {\n    auto n = strlen(s);\n    return load_grammar(s, n);\n  }\n\n  bool parse_n(const char *s, size_t n, const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, path);\n  }\n\n  bool parse_n(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, dt, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, T &val, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, val, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, any &dt, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, dt, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, any &dt, T &val,\n             const char * /*path*/ = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, val);\n  }\n\n  Definition &operator[](const char *s) { return (*grammar_)[s]; }\n\n  const Definition &operator[](const char *s) const { return (*grammar_)[s]; }\n\n  std::vector<std::string> get_rule_names() {\n    std::vector<std::string> rules;\n    rules.reserve(grammar_->size());\n    for (auto const &r : *grammar_) {\n      rules.emplace_back(r.first);\n    }\n    return rules;\n  }\n\n  void enable_packrat_parsing() {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.enablePackratParsing = true;\n    }\n  }\n\n  template <typename T = Ast> parser &enable_ast() {\n    for (auto &x : *grammar_) {\n      auto &rule = x.second;\n      if (!rule.action) { add_ast_action<T>(rule); }\n    }\n    return *this;\n  }\n\n  void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.tracer_enter = tracer_enter;\n      rule.tracer_leave = tracer_leave;\n    }\n  }\n\n  Log log;\n\nprivate:\n  void output_log(const char *s, size_t n, const Definition::Result &r) const {\n    if (log) {\n      if (!r.ret) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      } else if (r.len != n) {\n        auto line = line_info(s, s + r.len);\n        log(line.first, line.second, \"syntax error\");\n      }\n    }\n  }\n\n  std::shared_ptr<Grammar> grammar_;\n  std::string start_;\n};\n\n} // namespace peg\n"
    },
    {
        "begin_line": 58,
        "end_line": 61,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "any_cast",
        "snippet": "auto any_cast(Args &&... args)\n    -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {\n  return std::any_cast<T>(std::forward<Args>(args)...);\n}\n"
    },
    {
        "begin_line": 143,
        "end_line": 166,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "scope_exit",
        "snippet": "template <typename EF> struct scope_exit {\n  explicit scope_exit(EF &&f)\n      : exit_function(std::move(f)), execute_on_destruction{true} {}\n\n  scope_exit(scope_exit &&rhs)\n      : exit_function(std::move(rhs.exit_function)),\n        execute_on_destruction{rhs.execute_on_destruction} {\n    rhs.release();\n  }\n\n  ~scope_exit() {\n    if (execute_on_destruction) { this->exit_function(); }\n  }\n\n  void release() { this->execute_on_destruction = false; }\n\nprivate:\n  scope_exit(const scope_exit &) = delete;\n  void operator=(const scope_exit &) = delete;\n  scope_exit &operator=(scope_exit &&) = delete;\n\n  EF exit_function;\n  bool execute_on_destruction;\n};\n"
    },
    {
        "begin_line": 144,
        "end_line": 145,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "scope_exit",
        "snippet": "  explicit scope_exit(EF &&f)\n      : exit_function(std::move(f)), execute_on_destruction{true} {}\n"
    },
    {
        "begin_line": 147,
        "end_line": 151,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "scope_exit",
        "snippet": "  scope_exit(scope_exit &&rhs)\n      : exit_function(std::move(rhs.exit_function)),\n        execute_on_destruction{rhs.execute_on_destruction} {\n    rhs.release();\n  }\n"
    },
    {
        "begin_line": 153,
        "end_line": 155,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "~scope_exit",
        "snippet": "  ~scope_exit() {\n    if (execute_on_destruction) { this->exit_function(); }\n  }\n"
    },
    {
        "begin_line": 157,
        "end_line": 157,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "release",
        "snippet": "  void release() { this->execute_on_destruction = false; }\n"
    },
    {
        "begin_line": 164,
        "end_line": 164,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "exit_function",
        "snippet": "  EF exit_function;\n"
    },
    {
        "begin_line": 165,
        "end_line": 165,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "execute_on_destruction",
        "snippet": "  bool execute_on_destruction;\n"
    },
    {
        "begin_line": 169,
        "end_line": 172,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_scope_exit",
        "snippet": "auto make_scope_exit(EF &&exit_function) -> scope_exit<EF> {\n  return scope_exit<typename std::remove_reference<EF>::type>(\n      std::forward<EF>(exit_function));\n}\n"
    },
    {
        "begin_line": 178,
        "end_line": 192,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "codepoint_length",
        "snippet": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}\n"
    },
    {
        "begin_line": 194,
        "end_line": 223,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "encode_codepoint",
        "snippet": "inline size_t encode_codepoint(char32_t cp, char *buff) {\n  if (cp < 0x0080) {\n    buff[0] = static_cast<char>(cp & 0x7F);\n    return 1;\n  } else if (cp < 0x0800) {\n    buff[0] = static_cast<char>(0xC0 | ((cp >> 6) & 0x1F));\n    buff[1] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 2;\n  } else if (cp < 0xD800) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0xE000) {\n    // D800 - DFFF is invalid...\n    return 0;\n  } else if (cp < 0x10000) {\n    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 3;\n  } else if (cp < 0x110000) {\n    buff[0] = static_cast<char>(0xF0 | ((cp >> 18) & 0x7));\n    buff[1] = static_cast<char>(0x80 | ((cp >> 12) & 0x3F));\n    buff[2] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));\n    buff[3] = static_cast<char>(0x80 | (cp & 0x3F));\n    return 4;\n  }\n  return 0;\n}\n"
    },
    {
        "begin_line": 225,
        "end_line": 229,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "encode_codepoint",
        "snippet": "inline std::string encode_codepoint(char32_t cp) {\n  char buff[4];\n  auto l = encode_codepoint(cp, buff);\n  return std::string(buff, l);\n}\n"
    },
    {
        "begin_line": 231,
        "end_line": 266,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "decode_codepoint",
        "snippet": "inline bool decode_codepoint(const char *s8, size_t l, size_t &bytes,\n                             char32_t &cp) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      bytes = 1;\n      cp = b;\n      return true;\n    } else if ((b & 0xE0) == 0xC0) {\n      if (l >= 2) {\n        bytes = 2;\n        cp = ((static_cast<char32_t>(s8[0] & 0x1F)) << 6) |\n             (static_cast<char32_t>(s8[1] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF0) == 0xE0) {\n      if (l >= 3) {\n        bytes = 3;\n        cp = ((static_cast<char32_t>(s8[0] & 0x0F)) << 12) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[2] & 0x3F));\n        return true;\n      }\n    } else if ((b & 0xF8) == 0xF0) {\n      if (l >= 4) {\n        bytes = 4;\n        cp = ((static_cast<char32_t>(s8[0] & 0x07)) << 18) |\n             ((static_cast<char32_t>(s8[1] & 0x3F)) << 12) |\n             ((static_cast<char32_t>(s8[2] & 0x3F)) << 6) |\n             (static_cast<char32_t>(s8[3] & 0x3F));\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"
    },
    {
        "begin_line": 268,
        "end_line": 272,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "decode_codepoint",
        "snippet": "inline size_t decode_codepoint(const char *s8, size_t l, char32_t &out) {\n  size_t bytes;\n  if (decode_codepoint(s8, l, bytes, out)) { return bytes; }\n  return 0;\n}\n"
    },
    {
        "begin_line": 274,
        "end_line": 278,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "decode_codepoint",
        "snippet": "inline char32_t decode_codepoint(const char *s8, size_t l) {\n  char32_t out = 0;\n  decode_codepoint(s8, l, out);\n  return out;\n}\n"
    },
    {
        "begin_line": 280,
        "end_line": 291,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "decode",
        "snippet": "inline std::u32string decode(const char *s8, size_t l) {\n  std::u32string out;\n  size_t i = 0;\n  while (i < l) {\n    auto beg = i++;\n    while (i < l && (s8[i] & 0xc0) == 0x80) {\n      i++;\n    }\n    out += decode_codepoint(&s8[beg], (i - beg));\n  }\n  return out;\n}\n"
    },
    {
        "begin_line": 297,
        "end_line": 309,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_hex",
        "snippet": "inline bool is_hex(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  } else if ('a' <= c && c <= 'f') {\n    v = c - 'a' + 10;\n    return true;\n  } else if ('A' <= c && c <= 'F') {\n    v = c - 'A' + 10;\n    return true;\n  }\n  return false;\n}\n"
    },
    {
        "begin_line": 311,
        "end_line": 317,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_digit",
        "snippet": "inline bool is_digit(char c, int &v) {\n  if ('0' <= c && c <= '9') {\n    v = c - '0';\n    return true;\n  }\n  return false;\n}\n"
    },
    {
        "begin_line": 319,
        "end_line": 328,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_hex_number",
        "snippet": "inline std::pair<int, size_t> parse_hex_number(const char *s, size_t n,\n                                               size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_hex(s[i], val)) {\n    ret = static_cast<int>(ret * 16 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n"
    },
    {
        "begin_line": 330,
        "end_line": 339,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_octal_number",
        "snippet": "inline std::pair<int, size_t> parse_octal_number(const char *s, size_t n,\n                                                 size_t i) {\n  int ret = 0;\n  int val;\n  while (i < n && is_digit(s[i], val)) {\n    ret = static_cast<int>(ret * 8 + val);\n    i++;\n  }\n  return std::make_pair(ret, i);\n}\n"
    },
    {
        "begin_line": 341,
        "end_line": 404,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "resolve_escape_sequence",
        "snippet": "inline std::string resolve_escape_sequence(const char *s, size_t n) {\n  std::string r;\n  r.reserve(n);\n\n  size_t i = 0;\n  while (i < n) {\n    auto ch = s[i];\n    if (ch == '\\\\') {\n      i++;\n      if (i == n) { throw std::runtime_error(\"Invalid escape sequence...\"); }\n      switch (s[i]) {\n      case 'n':\n        r += '\\n';\n        i++;\n        break;\n      case 'r':\n        r += '\\r';\n        i++;\n        break;\n      case 't':\n        r += '\\t';\n        i++;\n        break;\n      case '\\'':\n        r += '\\'';\n        i++;\n        break;\n      case '\"':\n        r += '\"';\n        i++;\n        break;\n      case '[':\n        r += '[';\n        i++;\n        break;\n      case ']':\n        r += ']';\n        i++;\n        break;\n      case '\\\\':\n        r += '\\\\';\n        i++;\n        break;\n      case 'x':\n      case 'u': {\n        char32_t cp;\n        std::tie(cp, i) = parse_hex_number(s, n, i + 1);\n        r += encode_codepoint(cp);\n        break;\n      }\n      default: {\n        char32_t cp;\n        std::tie(cp, i) = parse_octal_number(s, n, i);\n        r += encode_codepoint(cp);\n        break;\n      }\n      }\n    } else {\n      r += ch;\n      i++;\n    }\n  }\n  return r;\n}\n"
    },
    {
        "begin_line": 410,
        "end_line": 458,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Trie",
        "snippet": "class Trie {\npublic:\n  Trie() = default;\n  Trie(const Trie &) = default;\n\n  Trie(const std::vector<std::string> &items) {\n    for (const auto &item : items) {\n      for (size_t len = 1; len <= item.size(); len++) {\n        auto last = len == item.size();\n        std::string s(item.c_str(), len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          dic_.emplace(s, Info{last, last});\n        } else if (last) {\n          it->second.match = true;\n        } else {\n          it->second.done = false;\n        }\n      }\n    }\n  }\n\n  size_t match(const char *text, size_t text_len) const {\n    size_t match_len = 0;\n    {\n      auto done = false;\n      size_t len = 1;\n      while (!done && len <= text_len) {\n        std::string s(text, len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          done = true;\n        } else {\n          if (it->second.match) { match_len = len; }\n          if (it->second.done) { done = true; }\n        }\n        len += 1;\n      }\n    }\n    return match_len;\n  }\n\nprivate:\n  struct Info {\n    bool done;\n    bool match;\n  };\n  std::unordered_map<std::string, Info> dic_;\n};\n"
    },
    {
        "begin_line": 415,
        "end_line": 430,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Trie",
        "snippet": "  Trie(const std::vector<std::string> &items) {\n    for (const auto &item : items) {\n      for (size_t len = 1; len <= item.size(); len++) {\n        auto last = len == item.size();\n        std::string s(item.c_str(), len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          dic_.emplace(s, Info{last, last});\n        } else if (last) {\n          it->second.match = true;\n        } else {\n          it->second.done = false;\n        }\n      }\n    }\n  }\n"
    },
    {
        "begin_line": 432,
        "end_line": 450,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "match",
        "snippet": "  size_t match(const char *text, size_t text_len) const {\n    size_t match_len = 0;\n    {\n      auto done = false;\n      size_t len = 1;\n      while (!done && len <= text_len) {\n        std::string s(text, len);\n        auto it = dic_.find(s);\n        if (it == dic_.end()) {\n          done = true;\n        } else {\n          if (it->second.match) { match_len = len; }\n          if (it->second.done) { done = true; }\n        }\n        len += 1;\n      }\n    }\n    return match_len;\n  }\n"
    },
    {
        "begin_line": 453,
        "end_line": 456,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Info",
        "snippet": "  struct Info {\n    bool done;\n    bool match;\n  };\n"
    },
    {
        "begin_line": 454,
        "end_line": 454,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "done",
        "snippet": "    bool done;\n"
    },
    {
        "begin_line": 455,
        "end_line": 455,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "match",
        "snippet": "    bool match;\n"
    },
    {
        "begin_line": 457,
        "end_line": 457,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "dic_",
        "snippet": "  std::unordered_map<std::string, Info> dic_;\n"
    },
    {
        "begin_line": 467,
        "end_line": 483,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "line_info",
        "snippet": "inline std::pair<size_t, size_t> line_info(const char *start, const char *cur) {\n  auto p = start;\n  auto col_ptr = p;\n  auto no = 1;\n\n  while (p < cur) {\n    if (*p == '\\n') {\n      no++;\n      col_ptr = p + 1;\n    }\n    p++;\n  }\n\n  auto col = p - col_ptr + 1;\n\n  return std::make_pair(no, col);\n}\n"
    },
    {
        "begin_line": 488,
        "end_line": 492,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "str2tag",
        "snippet": "inline constexpr unsigned int str2tag(const char *str, unsigned int h = 0) {\n  return (*str == '\\0')\n             ? h\n             : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));\n}\n"
    },
    {
        "begin_line": 494,
        "end_line": 500,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "udl",
        "snippet": "namespace udl {\n\ninline constexpr unsigned int operator\"\" _(const char *s, size_t) {\n  return str2tag(s);\n}\n\n} // namespace udl\n"
    },
    {
        "begin_line": 496,
        "end_line": 498,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator \"\"_",
        "snippet": "inline constexpr unsigned int operator\"\" _(const char *s, size_t) {\n  return str2tag(s);\n}\n"
    },
    {
        "begin_line": 505,
        "end_line": 601,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "SemanticValues",
        "snippet": "struct SemanticValues : protected std::vector<any> {\n  // Input text\n  const char *path = nullptr;\n  const char *ss = nullptr;\n  const std::vector<size_t> *source_line_index = nullptr;\n\n  // Matched string\n  const char *c_str() const { return s_; }\n  size_t length() const { return n_; }\n\n  std::string str() const { return std::string(s_, n_); }\n\n  // Definition name\n  const std::string &name() const { return name_; }\n\n  std::vector<unsigned int> tags;\n\n  // Line number and column at which the matched string is\n  std::pair<size_t, size_t> line_info() const {\n    const auto &idx = *source_line_index;\n\n    auto cur = static_cast<size_t>(std::distance(ss, s_));\n    auto it = std::lower_bound(\n        idx.begin(), idx.end(), cur,\n        [](size_t element, size_t value) { return element < value; });\n\n    auto id = static_cast<size_t>(std::distance(idx.begin(), it));\n    auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);\n    return std::make_pair(id + 1, off + 1);\n  }\n\n  // Choice count\n  size_t choice_count() const { return choice_count_; }\n\n  // Choice number (0 based index)\n  size_t choice() const { return choice_; }\n\n  // Tokens\n  std::vector<std::pair<const char *, size_t>> tokens;\n\n  std::string token(size_t id = 0) const {\n    if (!tokens.empty()) {\n      assert(id < tokens.size());\n      const auto &tok = tokens[id];\n      return std::string(tok.first, tok.second);\n    }\n    return std::string(s_, n_);\n  }\n\n  // Transform the semantic value vector to another vector\n  template <typename T>\n  std::vector<T> transform(size_t beg = 0,\n                           size_t end = static_cast<size_t>(-1)) const {\n    std::vector<T> r;\n    end = (std::min)(end, size());\n    for (size_t i = beg; i < end; i++) {\n      r.emplace_back(any_cast<T>((*this)[i]));\n    }\n    return r;\n  }\n\n  using std::vector<any>::iterator;\n  using std::vector<any>::const_iterator;\n  using std::vector<any>::size;\n  using std::vector<any>::empty;\n  using std::vector<any>::assign;\n  using std::vector<any>::begin;\n  using std::vector<any>::end;\n  using std::vector<any>::rbegin;\n  using std::vector<any>::rend;\n  using std::vector<any>::operator[];\n  using std::vector<any>::at;\n  using std::vector<any>::resize;\n  using std::vector<any>::front;\n  using std::vector<any>::back;\n  using std::vector<any>::push_back;\n  using std::vector<any>::pop_back;\n  using std::vector<any>::insert;\n  using std::vector<any>::erase;\n  using std::vector<any>::clear;\n  using std::vector<any>::swap;\n  using std::vector<any>::emplace;\n  using std::vector<any>::emplace_back;\n\nprivate:\n  friend class Context;\n  friend class Sequence;\n  friend class PrioritizedChoice;\n  friend class Holder;\n  friend class PrecedenceClimbing;\n\n  const char *s_ = nullptr;\n  size_t n_ = 0;\n  size_t choice_count_ = 0;\n  size_t choice_ = 0;\n  std::string name_;\n};\n"
    },
    {
        "begin_line": 507,
        "end_line": 507,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "path",
        "snippet": "  const char *path = nullptr;\n"
    },
    {
        "begin_line": 508,
        "end_line": 508,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ss",
        "snippet": "  const char *ss = nullptr;\n"
    },
    {
        "begin_line": 509,
        "end_line": 509,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "source_line_index",
        "snippet": "  const std::vector<size_t> *source_line_index = nullptr;\n"
    },
    {
        "begin_line": 512,
        "end_line": 512,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "c_str",
        "snippet": "  const char *c_str() const { return s_; }\n"
    },
    {
        "begin_line": 513,
        "end_line": 513,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "length",
        "snippet": "  size_t length() const { return n_; }\n"
    },
    {
        "begin_line": 515,
        "end_line": 515,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "str",
        "snippet": "  std::string str() const { return std::string(s_, n_); }\n"
    },
    {
        "begin_line": 518,
        "end_line": 518,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name",
        "snippet": "  const std::string &name() const { return name_; }\n"
    },
    {
        "begin_line": 520,
        "end_line": 520,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tags",
        "snippet": "  std::vector<unsigned int> tags;\n"
    },
    {
        "begin_line": 523,
        "end_line": 534,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "line_info",
        "snippet": "  std::pair<size_t, size_t> line_info() const {\n    const auto &idx = *source_line_index;\n\n    auto cur = static_cast<size_t>(std::distance(ss, s_));\n    auto it = std::lower_bound(\n        idx.begin(), idx.end(), cur,\n        [](size_t element, size_t value) { return element < value; });\n\n    auto id = static_cast<size_t>(std::distance(idx.begin(), it));\n    auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);\n    return std::make_pair(id + 1, off + 1);\n  }\n"
    },
    {
        "begin_line": 529,
        "end_line": 529,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240102",
        "snippet": "        [](size_t element, size_t value) { return element < value; });\n"
    },
    {
        "begin_line": 537,
        "end_line": 537,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "choice_count",
        "snippet": "  size_t choice_count() const { return choice_count_; }\n"
    },
    {
        "begin_line": 540,
        "end_line": 540,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "choice",
        "snippet": "  size_t choice() const { return choice_; }\n"
    },
    {
        "begin_line": 543,
        "end_line": 543,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tokens",
        "snippet": "  std::vector<std::pair<const char *, size_t>> tokens;\n"
    },
    {
        "begin_line": 545,
        "end_line": 552,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "token",
        "snippet": "  std::string token(size_t id = 0) const {\n    if (!tokens.empty()) {\n      assert(id < tokens.size());\n      const auto &tok = tokens[id];\n      return std::string(tok.first, tok.second);\n    }\n    return std::string(s_, n_);\n  }\n"
    },
    {
        "begin_line": 556,
        "end_line": 564,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "transform",
        "snippet": "  std::vector<T> transform(size_t beg = 0,\n                           size_t end = static_cast<size_t>(-1)) const {\n    std::vector<T> r;\n    end = (std::min)(end, size());\n    for (size_t i = beg; i < end; i++) {\n      r.emplace_back(any_cast<T>((*this)[i]));\n    }\n    return r;\n  }\n"
    },
    {
        "begin_line": 596,
        "end_line": 596,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "s_",
        "snippet": "  const char *s_ = nullptr;\n"
    },
    {
        "begin_line": 597,
        "end_line": 597,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "n_",
        "snippet": "  size_t n_ = 0;\n"
    },
    {
        "begin_line": 598,
        "end_line": 598,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "choice_count_",
        "snippet": "  size_t choice_count_ = 0;\n"
    },
    {
        "begin_line": 599,
        "end_line": 599,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "choice_",
        "snippet": "  size_t choice_ = 0;\n"
    },
    {
        "begin_line": 600,
        "end_line": 600,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name_",
        "snippet": "  std::string name_;\n"
    },
    {
        "begin_line": 610,
        "end_line": 613,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "call",
        "snippet": "any call(F fn, Args &&... args) {\n  fn(std::forward<Args>(args)...);\n  return any();\n}\n"
    },
    {
        "begin_line": 620,
        "end_line": 622,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "call",
        "snippet": "any call(F fn, Args &&... args) {\n  return fn(std::forward<Args>(args)...);\n}\n"
    },
    {
        "begin_line": 630,
        "end_line": 632,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "call",
        "snippet": "any call(F fn, Args &&... args) {\n  return any(fn(std::forward<Args>(args)...));\n}\n"
    },
    {
        "begin_line": 634,
        "end_line": 773,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Action",
        "snippet": "class Action {\npublic:\n  Action() = default;\n  Action(const Action &rhs) = default;\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  Action(F fn) : fn_(make_adaptor(fn, fn)) {}\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  Action(F /*fn*/) {}\n\n  template <typename F,\n            typename std::enable_if<!std::is_pointer<F>::value &&\n                                        !std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, &F::operator());\n  }\n\n  template <typename F, typename std::enable_if<std::is_pointer<F>::value,\n                                                std::nullptr_t>::type = nullptr>\n  void operator=(F fn) {\n    fn_ = make_adaptor(fn, fn);\n  }\n\n  template <typename F,\n            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,\n                                    std::nullptr_t>::type = nullptr>\n  void operator=(F /*fn*/) {}\n\n  Action &operator=(const Action &rhs) = default;\n\n  operator bool() const { return bool(fn_); }\n\n  any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }\n\nprivate:\n  template <typename R> struct TypeAdaptor_sv {\n    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv {\n    TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(const SemanticValues &sv)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_sv_dt {\n    TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(SemanticValues &sv, any &dt)> fn_;\n  };\n\n  template <typename R> struct TypeAdaptor_csv_dt {\n    TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(const SemanticValues &sv, any &dt)> fn_;\n  };\n\n  typedef std::function<any(SemanticValues &sv, any &dt)> Fty;\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv) const) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv) const) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n\n  template <typename F, typename R>\n  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n\n  Fty fn_;\n};\n"
    },
    {
        "begin_line": 643,
        "end_line": 643,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Action",
        "snippet": "  Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}\n"
    },
    {
        "begin_line": 647,
        "end_line": 647,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Action",
        "snippet": "  Action(F fn) : fn_(make_adaptor(fn, fn)) {}\n"
    },
    {
        "begin_line": 652,
        "end_line": 652,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Action",
        "snippet": "  Action(F /*fn*/) {}\n"
    },
    {
        "begin_line": 658,
        "end_line": 660,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator =",
        "snippet": "  void operator=(F fn) {\n    fn_ = make_adaptor(fn, &F::operator());\n  }\n"
    },
    {
        "begin_line": 664,
        "end_line": 666,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator =",
        "snippet": "  void operator=(F fn) {\n    fn_ = make_adaptor(fn, fn);\n  }\n"
    },
    {
        "begin_line": 671,
        "end_line": 671,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator =",
        "snippet": "  void operator=(F /*fn*/) {}\n"
    },
    {
        "begin_line": 675,
        "end_line": 675,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator bool",
        "snippet": "  operator bool() const { return bool(fn_); }\n"
    },
    {
        "begin_line": 677,
        "end_line": 677,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator ()",
        "snippet": "  any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }\n"
    },
    {
        "begin_line": 680,
        "end_line": 686,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_sv",
        "snippet": "  template <typename R> struct TypeAdaptor_sv {\n    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(SemanticValues &sv)> fn_;\n  };\n"
    },
    {
        "begin_line": 681,
        "end_line": 681,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_sv",
        "snippet": "    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}\n"
    },
    {
        "begin_line": 682,
        "end_line": 684,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator ()",
        "snippet": "    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n"
    },
    {
        "begin_line": 685,
        "end_line": 685,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "fn_",
        "snippet": "    std::function<R(SemanticValues &sv)> fn_;\n"
    },
    {
        "begin_line": 688,
        "end_line": 694,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_csv",
        "snippet": "  template <typename R> struct TypeAdaptor_csv {\n    TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}\n    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n    std::function<R(const SemanticValues &sv)> fn_;\n  };\n"
    },
    {
        "begin_line": 689,
        "end_line": 689,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_csv",
        "snippet": "    TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}\n"
    },
    {
        "begin_line": 690,
        "end_line": 692,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator ()",
        "snippet": "    any operator()(SemanticValues &sv, any & /*dt*/) {\n      return call<R>(fn_, sv);\n    }\n"
    },
    {
        "begin_line": 693,
        "end_line": 693,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "fn_",
        "snippet": "    std::function<R(const SemanticValues &sv)> fn_;\n"
    },
    {
        "begin_line": 696,
        "end_line": 701,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_sv_dt",
        "snippet": "  template <typename R> struct TypeAdaptor_sv_dt {\n    TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(SemanticValues &sv, any &dt)> fn_;\n  };\n"
    },
    {
        "begin_line": 697,
        "end_line": 698,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_sv_dt",
        "snippet": "    TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n"
    },
    {
        "begin_line": 699,
        "end_line": 699,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator ()",
        "snippet": "    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n"
    },
    {
        "begin_line": 700,
        "end_line": 700,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "fn_",
        "snippet": "    std::function<R(SemanticValues &sv, any &dt)> fn_;\n"
    },
    {
        "begin_line": 703,
        "end_line": 708,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_csv_dt",
        "snippet": "  template <typename R> struct TypeAdaptor_csv_dt {\n    TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n    std::function<R(const SemanticValues &sv, any &dt)> fn_;\n  };\n"
    },
    {
        "begin_line": 704,
        "end_line": 705,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TypeAdaptor_csv_dt",
        "snippet": "    TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)\n        : fn_(fn) {}\n"
    },
    {
        "begin_line": 706,
        "end_line": 706,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator ()",
        "snippet": "    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }\n"
    },
    {
        "begin_line": 707,
        "end_line": 707,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "fn_",
        "snippet": "    std::function<R(const SemanticValues &sv, any &dt)> fn_;\n"
    },
    {
        "begin_line": 713,
        "end_line": 715,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv) const) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n"
    },
    {
        "begin_line": 718,
        "end_line": 720,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv) const) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n"
    },
    {
        "begin_line": 723,
        "end_line": 725,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n"
    },
    {
        "begin_line": 728,
        "end_line": 730,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n"
    },
    {
        "begin_line": 733,
        "end_line": 735,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (*)(SemanticValues &sv)) {\n    return TypeAdaptor_sv<R>(fn);\n  }\n"
    },
    {
        "begin_line": 738,
        "end_line": 740,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv)) {\n    return TypeAdaptor_csv<R>(fn);\n  }\n"
    },
    {
        "begin_line": 743,
        "end_line": 745,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n"
    },
    {
        "begin_line": 748,
        "end_line": 750,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt) const) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n"
    },
    {
        "begin_line": 753,
        "end_line": 755,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n"
    },
    {
        "begin_line": 758,
        "end_line": 760,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n"
    },
    {
        "begin_line": 763,
        "end_line": 765,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_sv_dt<R>(fn);\n  }\n"
    },
    {
        "begin_line": 768,
        "end_line": 770,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_adaptor",
        "snippet": "  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv, any &dt)) {\n    return TypeAdaptor_csv_dt<R>(fn);\n  }\n"
    },
    {
        "begin_line": 772,
        "end_line": 772,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "fn_",
        "snippet": "  Fty fn_;\n"
    },
    {
        "begin_line": 780,
        "end_line": 787,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_error",
        "snippet": "struct parse_error {\n  parse_error() = default;\n  parse_error(const char *s) : s_(s) {}\n  const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }\n\nprivate:\n  std::string s_;\n};\n"
    },
    {
        "begin_line": 782,
        "end_line": 782,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_error",
        "snippet": "  parse_error(const char *s) : s_(s) {}\n"
    },
    {
        "begin_line": 783,
        "end_line": 783,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "what",
        "snippet": "  const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }\n"
    },
    {
        "begin_line": 786,
        "end_line": 786,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "s_",
        "snippet": "  std::string s_;\n"
    },
    {
        "begin_line": 792,
        "end_line": 792,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "success",
        "snippet": "inline bool success(size_t len) { return len != static_cast<size_t>(-1); }\n"
    },
    {
        "begin_line": 794,
        "end_line": 794,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "fail",
        "snippet": "inline bool fail(size_t len) { return len == static_cast<size_t>(-1); }\n"
    },
    {
        "begin_line": 813,
        "end_line": 978,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Context",
        "snippet": "class Context {\npublic:\n  const char *path;\n  const char *s;\n  const size_t l;\n  std::vector<size_t> source_line_index;\n\n  const char *error_pos = nullptr;\n  const char *message_pos = nullptr;\n  std::string message; // TODO: should be `int`.\n\n  std::vector<std::shared_ptr<SemanticValues>> value_stack;\n  size_t value_stack_size = 0;\n\n  std::vector<Definition *> rule_stack;\n  std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;\n\n  bool in_token = false;\n\n  std::shared_ptr<Ope> whitespaceOpe;\n  bool in_whitespace = false;\n\n  std::shared_ptr<Ope> wordOpe;\n\n  std::vector<std::map<std::string, std::string>> capture_scope_stack;\n  size_t capture_scope_stack_size = 0;\n\n  const size_t def_count;\n  const bool enablePackratParsing;\n  std::vector<bool> cache_registered;\n  std::vector<bool> cache_success;\n\n  std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;\n\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n\n  Context(const char *a_path, const char *a_s, size_t a_l, size_t a_def_count,\n          std::shared_ptr<Ope> a_whitespaceOpe, std::shared_ptr<Ope> a_wordOpe,\n          bool a_enablePackratParsing, TracerEnter a_tracer_enter,\n          TracerLeave a_tracer_leave)\n      : path(a_path), s(a_s), l(a_l), whitespaceOpe(a_whitespaceOpe),\n        wordOpe(a_wordOpe), def_count(a_def_count),\n        enablePackratParsing(a_enablePackratParsing),\n        cache_registered(enablePackratParsing ? def_count * (l + 1) : 0),\n        cache_success(enablePackratParsing ? def_count * (l + 1) : 0),\n        tracer_enter(a_tracer_enter), tracer_leave(a_tracer_leave) {\n\n    for (size_t pos = 0; pos < l; pos++) {\n      if (s[pos] == '\\n') { source_line_index.push_back(pos); }\n    }\n    source_line_index.push_back(l);\n\n    args_stack.resize(1);\n\n    push_capture_scope();\n  }\n\n  ~Context() { assert(!value_stack_size); }\n\n  Context(const Context &) = delete;\n  Context(Context &&) = delete;\n  Context operator=(const Context &) = delete;\n\n  template <typename T>\n  void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {\n    if (!enablePackratParsing) {\n      fn(val);\n      return;\n    }\n\n    auto col = a_s - s;\n    auto idx = def_count * static_cast<size_t>(col) + def_id;\n\n    if (cache_registered[idx]) {\n      if (cache_success[idx]) {\n        auto key = std::make_pair(col, def_id);\n        std::tie(len, val) = cache_values[key];\n        return;\n      } else {\n        len = static_cast<size_t>(-1);\n        return;\n      }\n    } else {\n      fn(val);\n      cache_registered[idx] = true;\n      cache_success[idx] = success(len);\n      if (success(len)) {\n        auto key = std::make_pair(col, def_id);\n        cache_values[key] = std::make_pair(len, val);\n      }\n      return;\n    }\n  }\n\n  SemanticValues &push() {\n    assert(value_stack_size <= value_stack.size());\n    if (value_stack_size == value_stack.size()) {\n      value_stack.emplace_back(std::make_shared<SemanticValues>());\n    } else {\n      auto &sv = *value_stack[value_stack_size];\n      if (!sv.empty()) {\n        sv.clear();\n        if (!sv.tags.empty()) { sv.tags.clear(); }\n      }\n      sv.s_ = nullptr;\n      sv.n_ = 0;\n      sv.choice_count_ = 0;\n      sv.choice_ = 0;\n      if (!sv.tokens.empty()) { sv.tokens.clear(); }\n    }\n\n    auto &sv = *value_stack[value_stack_size++];\n    sv.path = path;\n    sv.ss = s;\n    sv.source_line_index = &source_line_index;\n    return sv;\n  }\n\n  void pop() { value_stack_size--; }\n\n  void push_args(std::vector<std::shared_ptr<Ope>> &&args) {\n    args_stack.emplace_back(args);\n  }\n\n  void pop_args() { args_stack.pop_back(); }\n\n  const std::vector<std::shared_ptr<Ope>> &top_args() const {\n    return args_stack[args_stack.size() - 1];\n  }\n\n  void push_capture_scope() {\n    assert(capture_scope_stack_size <= capture_scope_stack.size());\n    if (capture_scope_stack_size == capture_scope_stack.size()) {\n      capture_scope_stack.emplace_back(std::map<std::string, std::string>());\n    } else {\n      auto &cs = capture_scope_stack[capture_scope_stack_size];\n      if (!cs.empty()) { cs.clear(); }\n    }\n    capture_scope_stack_size++;\n  }\n\n  void pop_capture_scope() { capture_scope_stack_size--; }\n\n  void shift_capture_values() {\n    assert(capture_scope_stack.size() >= 2);\n    auto curr = &capture_scope_stack[capture_scope_stack_size - 1];\n    auto prev = curr - 1;\n    for (const auto &kv : *curr) {\n      (*prev)[kv.first] = kv.second;\n    }\n  }\n\n  void set_error_pos(const char *a_s) {\n    if (error_pos < a_s) error_pos = a_s;\n  }\n\n  void trace_enter(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt) const;\n  void trace_leave(const char *name, const char *a_s, size_t n,\n                   SemanticValues &sv, any &dt, size_t len) const;\n  bool is_traceable(const Ope &ope) const;\n\n  mutable size_t next_trace_id = 0;\n  mutable std::list<size_t> trace_ids;\n};\n"
    },
    {
        "begin_line": 815,
        "end_line": 815,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "path",
        "snippet": "  const char *path;\n"
    },
    {
        "begin_line": 816,
        "end_line": 816,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "s",
        "snippet": "  const char *s;\n"
    },
    {
        "begin_line": 817,
        "end_line": 817,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "l",
        "snippet": "  const size_t l;\n"
    },
    {
        "begin_line": 818,
        "end_line": 818,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "source_line_index",
        "snippet": "  std::vector<size_t> source_line_index;\n"
    },
    {
        "begin_line": 820,
        "end_line": 820,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_pos",
        "snippet": "  const char *error_pos = nullptr;\n"
    },
    {
        "begin_line": 821,
        "end_line": 821,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "message_pos",
        "snippet": "  const char *message_pos = nullptr;\n"
    },
    {
        "begin_line": 822,
        "end_line": 822,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "message",
        "snippet": "  std::string message; // TODO: should be `int`.\n"
    },
    {
        "begin_line": 824,
        "end_line": 824,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "value_stack",
        "snippet": "  std::vector<std::shared_ptr<SemanticValues>> value_stack;\n"
    },
    {
        "begin_line": 825,
        "end_line": 825,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "value_stack_size",
        "snippet": "  size_t value_stack_size = 0;\n"
    },
    {
        "begin_line": 827,
        "end_line": 827,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "rule_stack",
        "snippet": "  std::vector<Definition *> rule_stack;\n"
    },
    {
        "begin_line": 828,
        "end_line": 828,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "args_stack",
        "snippet": "  std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;\n"
    },
    {
        "begin_line": 830,
        "end_line": 830,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "in_token",
        "snippet": "  bool in_token = false;\n"
    },
    {
        "begin_line": 832,
        "end_line": 832,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "whitespaceOpe",
        "snippet": "  std::shared_ptr<Ope> whitespaceOpe;\n"
    },
    {
        "begin_line": 833,
        "end_line": 833,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "in_whitespace",
        "snippet": "  bool in_whitespace = false;\n"
    },
    {
        "begin_line": 835,
        "end_line": 835,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "wordOpe",
        "snippet": "  std::shared_ptr<Ope> wordOpe;\n"
    },
    {
        "begin_line": 837,
        "end_line": 837,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "capture_scope_stack",
        "snippet": "  std::vector<std::map<std::string, std::string>> capture_scope_stack;\n"
    },
    {
        "begin_line": 838,
        "end_line": 838,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "capture_scope_stack_size",
        "snippet": "  size_t capture_scope_stack_size = 0;\n"
    },
    {
        "begin_line": 840,
        "end_line": 840,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "def_count",
        "snippet": "  const size_t def_count;\n"
    },
    {
        "begin_line": 841,
        "end_line": 841,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "enablePackratParsing",
        "snippet": "  const bool enablePackratParsing;\n"
    },
    {
        "begin_line": 842,
        "end_line": 842,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "cache_registered",
        "snippet": "  std::vector<bool> cache_registered;\n"
    },
    {
        "begin_line": 843,
        "end_line": 843,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "cache_success",
        "snippet": "  std::vector<bool> cache_success;\n"
    },
    {
        "begin_line": 845,
        "end_line": 845,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "cache_values",
        "snippet": "  std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;\n"
    },
    {
        "begin_line": 847,
        "end_line": 847,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tracer_enter",
        "snippet": "  TracerEnter tracer_enter;\n"
    },
    {
        "begin_line": 848,
        "end_line": 848,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tracer_leave",
        "snippet": "  TracerLeave tracer_leave;\n"
    },
    {
        "begin_line": 850,
        "end_line": 869,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Context",
        "snippet": "  Context(const char *a_path, const char *a_s, size_t a_l, size_t a_def_count,\n          std::shared_ptr<Ope> a_whitespaceOpe, std::shared_ptr<Ope> a_wordOpe,\n          bool a_enablePackratParsing, TracerEnter a_tracer_enter,\n          TracerLeave a_tracer_leave)\n      : path(a_path), s(a_s), l(a_l), whitespaceOpe(a_whitespaceOpe),\n        wordOpe(a_wordOpe), def_count(a_def_count),\n        enablePackratParsing(a_enablePackratParsing),\n        cache_registered(enablePackratParsing ? def_count * (l + 1) : 0),\n        cache_success(enablePackratParsing ? def_count * (l + 1) : 0),\n        tracer_enter(a_tracer_enter), tracer_leave(a_tracer_leave) {\n\n    for (size_t pos = 0; pos < l; pos++) {\n      if (s[pos] == '\\n') { source_line_index.push_back(pos); }\n    }\n    source_line_index.push_back(l);\n\n    args_stack.resize(1);\n\n    push_capture_scope();\n  }\n"
    },
    {
        "begin_line": 871,
        "end_line": 871,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "~Context",
        "snippet": "  ~Context() { assert(!value_stack_size); }\n"
    },
    {
        "begin_line": 878,
        "end_line": 906,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "packrat",
        "snippet": "  void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {\n    if (!enablePackratParsing) {\n      fn(val);\n      return;\n    }\n\n    auto col = a_s - s;\n    auto idx = def_count * static_cast<size_t>(col) + def_id;\n\n    if (cache_registered[idx]) {\n      if (cache_success[idx]) {\n        auto key = std::make_pair(col, def_id);\n        std::tie(len, val) = cache_values[key];\n        return;\n      } else {\n        len = static_cast<size_t>(-1);\n        return;\n      }\n    } else {\n      fn(val);\n      cache_registered[idx] = true;\n      cache_success[idx] = success(len);\n      if (success(len)) {\n        auto key = std::make_pair(col, def_id);\n        cache_values[key] = std::make_pair(len, val);\n      }\n      return;\n    }\n  }\n"
    },
    {
        "begin_line": 908,
        "end_line": 930,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "push",
        "snippet": "  SemanticValues &push() {\n    assert(value_stack_size <= value_stack.size());\n    if (value_stack_size == value_stack.size()) {\n      value_stack.emplace_back(std::make_shared<SemanticValues>());\n    } else {\n      auto &sv = *value_stack[value_stack_size];\n      if (!sv.empty()) {\n        sv.clear();\n        if (!sv.tags.empty()) { sv.tags.clear(); }\n      }\n      sv.s_ = nullptr;\n      sv.n_ = 0;\n      sv.choice_count_ = 0;\n      sv.choice_ = 0;\n      if (!sv.tokens.empty()) { sv.tokens.clear(); }\n    }\n\n    auto &sv = *value_stack[value_stack_size++];\n    sv.path = path;\n    sv.ss = s;\n    sv.source_line_index = &source_line_index;\n    return sv;\n  }\n"
    },
    {
        "begin_line": 932,
        "end_line": 932,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "pop",
        "snippet": "  void pop() { value_stack_size--; }\n"
    },
    {
        "begin_line": 934,
        "end_line": 936,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "push_args",
        "snippet": "  void push_args(std::vector<std::shared_ptr<Ope>> &&args) {\n    args_stack.emplace_back(args);\n  }\n"
    },
    {
        "begin_line": 938,
        "end_line": 938,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "pop_args",
        "snippet": "  void pop_args() { args_stack.pop_back(); }\n"
    },
    {
        "begin_line": 940,
        "end_line": 942,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "top_args",
        "snippet": "  const std::vector<std::shared_ptr<Ope>> &top_args() const {\n    return args_stack[args_stack.size() - 1];\n  }\n"
    },
    {
        "begin_line": 944,
        "end_line": 953,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "push_capture_scope",
        "snippet": "  void push_capture_scope() {\n    assert(capture_scope_stack_size <= capture_scope_stack.size());\n    if (capture_scope_stack_size == capture_scope_stack.size()) {\n      capture_scope_stack.emplace_back(std::map<std::string, std::string>());\n    } else {\n      auto &cs = capture_scope_stack[capture_scope_stack_size];\n      if (!cs.empty()) { cs.clear(); }\n    }\n    capture_scope_stack_size++;\n  }\n"
    },
    {
        "begin_line": 955,
        "end_line": 955,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "pop_capture_scope",
        "snippet": "  void pop_capture_scope() { capture_scope_stack_size--; }\n"
    },
    {
        "begin_line": 957,
        "end_line": 964,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "shift_capture_values",
        "snippet": "  void shift_capture_values() {\n    assert(capture_scope_stack.size() >= 2);\n    auto curr = &capture_scope_stack[capture_scope_stack_size - 1];\n    auto prev = curr - 1;\n    for (const auto &kv : *curr) {\n      (*prev)[kv.first] = kv.second;\n    }\n  }\n"
    },
    {
        "begin_line": 966,
        "end_line": 968,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "set_error_pos",
        "snippet": "  void set_error_pos(const char *a_s) {\n    if (error_pos < a_s) error_pos = a_s;\n  }\n"
    },
    {
        "begin_line": 976,
        "end_line": 976,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "next_trace_id",
        "snippet": "  mutable size_t next_trace_id = 0;\n"
    },
    {
        "begin_line": 977,
        "end_line": 977,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "trace_ids",
        "snippet": "  mutable std::list<size_t> trace_ids;\n"
    },
    {
        "begin_line": 983,
        "end_line": 993,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Ope",
        "snippet": "class Ope {\npublic:\n  struct Visitor;\n\n  virtual ~Ope() {}\n  size_t parse(const char *s, size_t n, SemanticValues &sv, Context &c,\n               any &dt) const;\n  virtual size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt) const = 0;\n  virtual void accept(Visitor &v) = 0;\n};\n"
    },
    {
        "begin_line": 987,
        "end_line": 987,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "~Ope",
        "snippet": "  virtual ~Ope() {}\n"
    },
    {
        "begin_line": 995,
        "end_line": 1037,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Sequence",
        "snippet": "class Sequence : public Ope {\npublic:\n  template <typename... Args>\n  Sequence(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}\n  Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto &chldsv = c.push();\n    auto pop_se = make_scope_exit([&]() { c.pop(); });\n    size_t i = 0;\n    for (const auto &ope : opes_) {\n      const auto &rule = *ope;\n      auto len = rule.parse(s + i, n - i, chldsv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n    if (!chldsv.empty()) {\n      for (size_t j = 0; j < chldsv.size(); j++) {\n        sv.emplace_back(std::move(chldsv[j]));\n      }\n    }\n    if (!chldsv.tags.empty()) {\n      for (size_t j = 0; j < chldsv.tags.size(); j++) {\n        sv.tags.emplace_back(std::move(chldsv.tags[j]));\n      }\n    }\n    sv.s_ = chldsv.c_str();\n    sv.n_ = chldsv.length();\n    if (!chldsv.tokens.empty()) {\n      for (size_t j = 0; j < chldsv.tokens.size(); j++) {\n        sv.tokens.emplace_back(std::move(chldsv.tokens[j]));\n      }\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n"
    },
    {
        "begin_line": 998,
        "end_line": 999,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Sequence",
        "snippet": "  Sequence(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n"
    },
    {
        "begin_line": 1000,
        "end_line": 1000,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Sequence",
        "snippet": "  Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}\n"
    },
    {
        "begin_line": 1001,
        "end_line": 1001,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Sequence",
        "snippet": "  Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n"
    },
    {
        "begin_line": 1003,
        "end_line": 1032,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto &chldsv = c.push();\n    auto pop_se = make_scope_exit([&]() { c.pop(); });\n    size_t i = 0;\n    for (const auto &ope : opes_) {\n      const auto &rule = *ope;\n      auto len = rule.parse(s + i, n - i, chldsv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n    if (!chldsv.empty()) {\n      for (size_t j = 0; j < chldsv.size(); j++) {\n        sv.emplace_back(std::move(chldsv[j]));\n      }\n    }\n    if (!chldsv.tags.empty()) {\n      for (size_t j = 0; j < chldsv.tags.size(); j++) {\n        sv.tags.emplace_back(std::move(chldsv.tags[j]));\n      }\n    }\n    sv.s_ = chldsv.c_str();\n    sv.n_ = chldsv.length();\n    if (!chldsv.tokens.empty()) {\n      for (size_t j = 0; j < chldsv.tokens.size(); j++) {\n        sv.tokens.emplace_back(std::move(chldsv.tokens[j]));\n      }\n    }\n    return i;\n  }\n"
    },
    {
        "begin_line": 1006,
        "end_line": 1006,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240202",
        "snippet": "    auto pop_se = make_scope_exit([&]() { c.pop(); });\n"
    },
    {
        "begin_line": 1036,
        "end_line": 1036,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "opes_",
        "snippet": "  std::vector<std::shared_ptr<Ope>> opes_;\n"
    },
    {
        "begin_line": 1039,
        "end_line": 1093,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PrioritizedChoice",
        "snippet": "class PrioritizedChoice : public Ope {\npublic:\n  template <typename... Args>\n  PrioritizedChoice(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n  PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)\n      : opes_(opes) {}\n  PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t id = 0;\n    for (const auto &ope : opes_) {\n      auto &chldsv = c.push();\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() {\n        c.pop();\n        c.pop_capture_scope();\n      });\n      auto len = ope->parse(s, n, chldsv, c, dt);\n      if (success(len)) {\n        if (!chldsv.empty()) {\n          for (size_t i = 0; i < chldsv.size(); i++) {\n            sv.emplace_back(std::move(chldsv[i]));\n          }\n        }\n        if (!chldsv.tags.empty()) {\n          for (size_t i = 0; i < chldsv.tags.size(); i++) {\n            sv.tags.emplace_back(std::move(chldsv.tags[i]));\n          }\n        }\n        sv.s_ = chldsv.c_str();\n        sv.n_ = chldsv.length();\n        sv.choice_count_ = opes_.size();\n        sv.choice_ = id;\n        if (!chldsv.tokens.empty()) {\n          for (size_t i = 0; i < chldsv.tokens.size(); i++) {\n            sv.tokens.emplace_back(std::move(chldsv.tokens[i]));\n          }\n        }\n\n        c.shift_capture_values();\n        return len;\n      }\n      id++;\n    }\n    return static_cast<size_t>(-1);\n  }\n\n  void accept(Visitor &v) override;\n\n  size_t size() const { return opes_.size(); }\n\n  std::vector<std::shared_ptr<Ope>> opes_;\n};\n"
    },
    {
        "begin_line": 1042,
        "end_line": 1043,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PrioritizedChoice",
        "snippet": "  PrioritizedChoice(const Args &... args)\n      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}\n"
    },
    {
        "begin_line": 1044,
        "end_line": 1045,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PrioritizedChoice",
        "snippet": "  PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)\n      : opes_(opes) {}\n"
    },
    {
        "begin_line": 1046,
        "end_line": 1046,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PrioritizedChoice",
        "snippet": "  PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}\n"
    },
    {
        "begin_line": 1048,
        "end_line": 1086,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t id = 0;\n    for (const auto &ope : opes_) {\n      auto &chldsv = c.push();\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() {\n        c.pop();\n        c.pop_capture_scope();\n      });\n      auto len = ope->parse(s, n, chldsv, c, dt);\n      if (success(len)) {\n        if (!chldsv.empty()) {\n          for (size_t i = 0; i < chldsv.size(); i++) {\n            sv.emplace_back(std::move(chldsv[i]));\n          }\n        }\n        if (!chldsv.tags.empty()) {\n          for (size_t i = 0; i < chldsv.tags.size(); i++) {\n            sv.tags.emplace_back(std::move(chldsv.tags[i]));\n          }\n        }\n        sv.s_ = chldsv.c_str();\n        sv.n_ = chldsv.length();\n        sv.choice_count_ = opes_.size();\n        sv.choice_ = id;\n        if (!chldsv.tokens.empty()) {\n          for (size_t i = 0; i < chldsv.tokens.size(); i++) {\n            sv.tokens.emplace_back(std::move(chldsv.tokens[i]));\n          }\n        }\n\n        c.shift_capture_values();\n        return len;\n      }\n      id++;\n    }\n    return static_cast<size_t>(-1);\n  }\n"
    },
    {
        "begin_line": 1054,
        "end_line": 1057,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240302",
        "snippet": "      auto se = make_scope_exit([&]() {\n        c.pop();\n        c.pop_capture_scope();\n      });\n"
    },
    {
        "begin_line": 1090,
        "end_line": 1090,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "size",
        "snippet": "  size_t size() const { return opes_.size(); }\n"
    },
    {
        "begin_line": 1092,
        "end_line": 1092,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "opes_",
        "snippet": "  std::vector<std::shared_ptr<Ope>> opes_;\n"
    },
    {
        "begin_line": 1095,
        "end_line": 1170,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Repetition",
        "snippet": "class Repetition : public Ope {\npublic:\n  Repetition(const std::shared_ptr<Ope> &ope, size_t min, size_t max)\n      : ope_(ope), min_(min), max_(max) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t count = 0;\n    size_t i = 0;\n    while (count < min_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        return static_cast<size_t>(-1);\n      }\n      i += len;\n      count++;\n    }\n\n    auto save_error_pos = c.error_pos;\n    while (n - i > 0 && count < max_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      auto save_sv_size = sv.size();\n      auto save_tok_size = sv.tokens.size();\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        if (sv.size() != save_sv_size) {\n          sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));\n          sv.tags.erase(sv.tags.begin() +\n                        static_cast<std::ptrdiff_t>(save_sv_size));\n        }\n        if (sv.tokens.size() != save_tok_size) {\n          sv.tokens.erase(sv.tokens.begin() +\n                          static_cast<std::ptrdiff_t>(save_tok_size));\n        }\n        c.error_pos = save_error_pos;\n        break;\n      }\n      i += len;\n      count++;\n    }\n    return i;\n  }\n\n  void accept(Visitor &v) override;\n\n  bool is_zom() const {\n    return min_ == 0 && max_ == std::numeric_limits<size_t>::max();\n  }\n\n  static std::shared_ptr<Repetition> zom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> oom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 1,\n                                        std::numeric_limits<size_t>::max());\n  }\n\n  static std::shared_ptr<Repetition> opt(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0, 1);\n  }\n\n  std::shared_ptr<Ope> ope_;\n  size_t min_;\n  size_t max_;\n};\n"
    },
    {
        "begin_line": 1097,
        "end_line": 1098,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Repetition",
        "snippet": "  Repetition(const std::shared_ptr<Ope> &ope, size_t min, size_t max)\n      : ope_(ope), min_(min), max_(max) {}\n"
    },
    {
        "begin_line": 1100,
        "end_line": 1145,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    size_t count = 0;\n    size_t i = 0;\n    while (count < min_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        return static_cast<size_t>(-1);\n      }\n      i += len;\n      count++;\n    }\n\n    auto save_error_pos = c.error_pos;\n    while (n - i > 0 && count < max_) {\n      c.push_capture_scope();\n      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n      auto save_sv_size = sv.size();\n      auto save_tok_size = sv.tokens.size();\n      const auto &rule = *ope_;\n      auto len = rule.parse(s + i, n - i, sv, c, dt);\n      if (success(len)) {\n        c.shift_capture_values();\n      } else {\n        if (sv.size() != save_sv_size) {\n          sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));\n          sv.tags.erase(sv.tags.begin() +\n                        static_cast<std::ptrdiff_t>(save_sv_size));\n        }\n        if (sv.tokens.size() != save_tok_size) {\n          sv.tokens.erase(sv.tokens.begin() +\n                          static_cast<std::ptrdiff_t>(save_tok_size));\n        }\n        c.error_pos = save_error_pos;\n        break;\n      }\n      i += len;\n      count++;\n    }\n    return i;\n  }\n"
    },
    {
        "begin_line": 1106,
        "end_line": 1106,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240402",
        "snippet": "      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n"
    },
    {
        "begin_line": 1121,
        "end_line": 1121,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240502",
        "snippet": "      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n"
    },
    {
        "begin_line": 1149,
        "end_line": 1151,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_zom",
        "snippet": "  bool is_zom() const {\n    return min_ == 0 && max_ == std::numeric_limits<size_t>::max();\n  }\n"
    },
    {
        "begin_line": 1153,
        "end_line": 1156,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "zom",
        "snippet": "  static std::shared_ptr<Repetition> zom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0,\n                                        std::numeric_limits<size_t>::max());\n  }\n"
    },
    {
        "begin_line": 1158,
        "end_line": 1161,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "oom",
        "snippet": "  static std::shared_ptr<Repetition> oom(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 1,\n                                        std::numeric_limits<size_t>::max());\n  }\n"
    },
    {
        "begin_line": 1163,
        "end_line": 1165,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "opt",
        "snippet": "  static std::shared_ptr<Repetition> opt(const std::shared_ptr<Ope> &ope) {\n    return std::make_shared<Repetition>(ope, 0, 1);\n  }\n"
    },
    {
        "begin_line": 1167,
        "end_line": 1167,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1168,
        "end_line": 1168,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "min_",
        "snippet": "  size_t min_;\n"
    },
    {
        "begin_line": 1169,
        "end_line": 1169,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "max_",
        "snippet": "  size_t max_;\n"
    },
    {
        "begin_line": 1172,
        "end_line": 1196,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AndPredicate",
        "snippet": "class AndPredicate : public Ope {\npublic:\n  AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      return 0;\n    } else {\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n"
    },
    {
        "begin_line": 1174,
        "end_line": 1174,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AndPredicate",
        "snippet": "  AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n"
    },
    {
        "begin_line": 1176,
        "end_line": 1191,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      return 0;\n    } else {\n      return static_cast<size_t>(-1);\n    }\n  }\n"
    },
    {
        "begin_line": 1180,
        "end_line": 1183,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240602",
        "snippet": "    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n"
    },
    {
        "begin_line": 1195,
        "end_line": 1195,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1198,
        "end_line": 1224,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "NotPredicate",
        "snippet": "class NotPredicate : public Ope {\npublic:\n  NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto save_error_pos = c.error_pos;\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    auto len = ope_->parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    } else {\n      c.error_pos = save_error_pos;\n      return 0;\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n"
    },
    {
        "begin_line": 1200,
        "end_line": 1200,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "NotPredicate",
        "snippet": "  NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n"
    },
    {
        "begin_line": 1202,
        "end_line": 1219,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    auto save_error_pos = c.error_pos;\n    auto &chldsv = c.push();\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n    auto len = ope_->parse(s, n, chldsv, c, dt);\n    if (success(len)) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    } else {\n      c.error_pos = save_error_pos;\n      return 0;\n    }\n  }\n"
    },
    {
        "begin_line": 1207,
        "end_line": 1210,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240702",
        "snippet": "    auto se = make_scope_exit([&]() {\n      c.pop();\n      c.pop_capture_scope();\n    });\n"
    },
    {
        "begin_line": 1223,
        "end_line": 1223,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1226,
        "end_line": 1236,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Dictionary",
        "snippet": "class Dictionary : public Ope, public std::enable_shared_from_this<Dictionary> {\npublic:\n  Dictionary(const std::vector<std::string> &v) : trie_(v) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  Trie trie_;\n};\n"
    },
    {
        "begin_line": 1228,
        "end_line": 1228,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Dictionary",
        "snippet": "  Dictionary(const std::vector<std::string> &v) : trie_(v) {}\n"
    },
    {
        "begin_line": 1235,
        "end_line": 1235,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "trie_",
        "snippet": "  Trie trie_;\n"
    },
    {
        "begin_line": 1238,
        "end_line": 1256,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "LiteralString",
        "snippet": "class LiteralString : public Ope,\n                      public std::enable_shared_from_this<LiteralString> {\npublic:\n  LiteralString(std::string &&s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n\n  LiteralString(const std::string &s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string lit_;\n  bool ignore_case_;\n  mutable std::once_flag init_is_word_;\n  mutable bool is_word_;\n};\n"
    },
    {
        "begin_line": 1241,
        "end_line": 1242,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "LiteralString",
        "snippet": "  LiteralString(std::string &&s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n"
    },
    {
        "begin_line": 1244,
        "end_line": 1245,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "LiteralString",
        "snippet": "  LiteralString(const std::string &s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}\n"
    },
    {
        "begin_line": 1252,
        "end_line": 1252,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "lit_",
        "snippet": "  std::string lit_;\n"
    },
    {
        "begin_line": 1253,
        "end_line": 1253,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ignore_case_",
        "snippet": "  bool ignore_case_;\n"
    },
    {
        "begin_line": 1254,
        "end_line": 1254,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "init_is_word_",
        "snippet": "  mutable std::once_flag init_is_word_;\n"
    },
    {
        "begin_line": 1255,
        "end_line": 1255,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_word_",
        "snippet": "  mutable bool is_word_;\n"
    },
    {
        "begin_line": 1258,
        "end_line": 1318,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "CharacterClass",
        "snippet": "class CharacterClass : public Ope,\n                       public std::enable_shared_from_this<CharacterClass> {\npublic:\n  CharacterClass(const std::string &s, bool negated) : negated_(negated) {\n    auto chars = decode(s.c_str(), s.length());\n    auto i = 0u;\n    while (i < chars.size()) {\n      if (i + 2 < chars.size() && chars[i + 1] == '-') {\n        auto cp1 = chars[i];\n        auto cp2 = chars[i + 2];\n        ranges_.emplace_back(std::make_pair(cp1, cp2));\n        i += 3;\n      } else {\n        auto cp = chars[i];\n        ranges_.emplace_back(std::make_pair(cp, cp));\n        i += 1;\n      }\n    }\n    assert(!ranges_.empty());\n  }\n\n  CharacterClass(const std::vector<std::pair<char32_t, char32_t>> &ranges,\n                 bool negated)\n      : ranges_(ranges), negated_(negated) {\n    assert(!ranges_.empty());\n  }\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n\n    char32_t cp = 0;\n    auto len = decode_codepoint(s, n, cp);\n\n    for (const auto &range : ranges_) {\n      if (range.first <= cp && cp <= range.second) {\n        if (negated_) {\n          c.set_error_pos(s);\n          return static_cast<size_t>(-1);\n        } else {\n          return len;\n        }\n      }\n    }\n\n    if (negated_) {\n      return len;\n    } else {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  void accept(Visitor &v) override;\n\n  std::vector<std::pair<char32_t, char32_t>> ranges_;\n  bool negated_;\n};\n"
    },
    {
        "begin_line": 1261,
        "end_line": 1277,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "CharacterClass",
        "snippet": "  CharacterClass(const std::string &s, bool negated) : negated_(negated) {\n    auto chars = decode(s.c_str(), s.length());\n    auto i = 0u;\n    while (i < chars.size()) {\n      if (i + 2 < chars.size() && chars[i + 1] == '-') {\n        auto cp1 = chars[i];\n        auto cp2 = chars[i + 2];\n        ranges_.emplace_back(std::make_pair(cp1, cp2));\n        i += 3;\n      } else {\n        auto cp = chars[i];\n        ranges_.emplace_back(std::make_pair(cp, cp));\n        i += 1;\n      }\n    }\n    assert(!ranges_.empty());\n  }\n"
    },
    {
        "begin_line": 1279,
        "end_line": 1283,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "CharacterClass",
        "snippet": "  CharacterClass(const std::vector<std::pair<char32_t, char32_t>> &ranges,\n                 bool negated)\n      : ranges_(ranges), negated_(negated) {\n    assert(!ranges_.empty());\n  }\n"
    },
    {
        "begin_line": 1285,
        "end_line": 1312,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n\n    char32_t cp = 0;\n    auto len = decode_codepoint(s, n, cp);\n\n    for (const auto &range : ranges_) {\n      if (range.first <= cp && cp <= range.second) {\n        if (negated_) {\n          c.set_error_pos(s);\n          return static_cast<size_t>(-1);\n        } else {\n          return len;\n        }\n      }\n    }\n\n    if (negated_) {\n      return len;\n    } else {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n"
    },
    {
        "begin_line": 1316,
        "end_line": 1316,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ranges_",
        "snippet": "  std::vector<std::pair<char32_t, char32_t>> ranges_;\n"
    },
    {
        "begin_line": 1317,
        "end_line": 1317,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "negated_",
        "snippet": "  bool negated_;\n"
    },
    {
        "begin_line": 1320,
        "end_line": 1336,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Character",
        "snippet": "class Character : public Ope, public std::enable_shared_from_this<Character> {\npublic:\n  Character(char ch) : ch_(ch) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1 || s[0] != ch_) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return 1;\n  }\n\n  void accept(Visitor &v) override;\n\n  char ch_;\n};\n"
    },
    {
        "begin_line": 1322,
        "end_line": 1322,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Character",
        "snippet": "  Character(char ch) : ch_(ch) {}\n"
    },
    {
        "begin_line": 1324,
        "end_line": 1331,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    if (n < 1 || s[0] != ch_) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return 1;\n  }\n"
    },
    {
        "begin_line": 1335,
        "end_line": 1335,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ch_",
        "snippet": "  char ch_;\n"
    },
    {
        "begin_line": 1338,
        "end_line": 1352,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AnyCharacter",
        "snippet": "class AnyCharacter : public Ope,\n                     public std::enable_shared_from_this<AnyCharacter> {\npublic:\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    auto len = codepoint_length(s, n);\n    if (len < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n};\n"
    },
    {
        "begin_line": 1341,
        "end_line": 1349,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any & /*dt*/) const override {\n    auto len = codepoint_length(s, n);\n    if (len < 1) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n    return len;\n  }\n"
    },
    {
        "begin_line": 1354,
        "end_line": 1370,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "CaptureScope",
        "snippet": "class CaptureScope : public Ope {\npublic:\n  CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n"
    },
    {
        "begin_line": 1356,
        "end_line": 1356,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "CaptureScope",
        "snippet": "  CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n"
    },
    {
        "begin_line": 1358,
        "end_line": 1365,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    c.push_capture_scope();\n    auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    return len;\n  }\n"
    },
    {
        "begin_line": 1361,
        "end_line": 1361,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240802",
        "snippet": "    auto se = make_scope_exit([&]() { c.pop_capture_scope(); });\n"
    },
    {
        "begin_line": 1369,
        "end_line": 1369,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1372,
        "end_line": 1391,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Capture",
        "snippet": "class Capture : public Ope {\npublic:\n  typedef std::function<void(const char *s, size_t n, Context &c)> MatchAction;\n\n  Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)\n      : ope_(ope), match_action_(ma) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    if (success(len) && match_action_) { match_action_(s, len, c); }\n    return len;\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n  MatchAction match_action_;\n};\n"
    },
    {
        "begin_line": 1376,
        "end_line": 1377,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Capture",
        "snippet": "  Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)\n      : ope_(ope), match_action_(ma) {}\n"
    },
    {
        "begin_line": 1379,
        "end_line": 1385,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    const auto &rule = *ope_;\n    auto len = rule.parse(s, n, sv, c, dt);\n    if (success(len) && match_action_) { match_action_(s, len, c); }\n    return len;\n  }\n"
    },
    {
        "begin_line": 1389,
        "end_line": 1389,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1390,
        "end_line": 1390,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "match_action_",
        "snippet": "  MatchAction match_action_;\n"
    },
    {
        "begin_line": 1393,
        "end_line": 1403,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TokenBoundary",
        "snippet": "class TokenBoundary : public Ope {\npublic:\n  TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n"
    },
    {
        "begin_line": 1395,
        "end_line": 1395,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TokenBoundary",
        "snippet": "  TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n"
    },
    {
        "begin_line": 1402,
        "end_line": 1402,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1405,
        "end_line": 1420,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Ignore",
        "snippet": "class Ignore : public Ope {\npublic:\n  Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    const auto &rule = *ope_;\n    auto &chldsv = c.push();\n    auto se = make_scope_exit([&]() { c.pop(); });\n    return rule.parse(s, n, chldsv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n"
    },
    {
        "begin_line": 1407,
        "end_line": 1407,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Ignore",
        "snippet": "  Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n"
    },
    {
        "begin_line": 1409,
        "end_line": 1415,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,\n                    Context &c, any &dt) const override {\n    const auto &rule = *ope_;\n    auto &chldsv = c.push();\n    auto se = make_scope_exit([&]() { c.pop(); });\n    return rule.parse(s, n, chldsv, c, dt);\n  }\n"
    },
    {
        "begin_line": 1413,
        "end_line": 1413,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240902",
        "snippet": "    auto se = make_scope_exit([&]() { c.pop(); });\n"
    },
    {
        "begin_line": 1419,
        "end_line": 1419,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1426,
        "end_line": 1437,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "User",
        "snippet": "class User : public Ope {\npublic:\n  User(Parser fn) : fn_(fn) {}\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                    Context & /*c*/, any &dt) const override {\n    assert(fn_);\n    return fn_(s, n, sv, dt);\n  }\n  void accept(Visitor &v) override;\n  std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n      fn_;\n};\n"
    },
    {
        "begin_line": 1428,
        "end_line": 1428,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "User",
        "snippet": "  User(Parser fn) : fn_(fn) {}\n"
    },
    {
        "begin_line": 1429,
        "end_line": 1433,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv,\n                    Context & /*c*/, any &dt) const override {\n    assert(fn_);\n    return fn_(s, n, sv, dt);\n  }\n"
    },
    {
        "begin_line": 1436,
        "end_line": 1436,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "fn_",
        "snippet": "      fn_;\n"
    },
    {
        "begin_line": 1439,
        "end_line": 1454,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "WeakHolder",
        "snippet": "class WeakHolder : public Ope {\npublic:\n  WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto ope = weak_.lock();\n    assert(ope);\n    const auto &rule = *ope;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::weak_ptr<Ope> weak_;\n};\n"
    },
    {
        "begin_line": 1441,
        "end_line": 1441,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "WeakHolder",
        "snippet": "  WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}\n"
    },
    {
        "begin_line": 1443,
        "end_line": 1449,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    auto ope = weak_.lock();\n    assert(ope);\n    const auto &rule = *ope;\n    return rule.parse(s, n, sv, c, dt);\n  }\n"
    },
    {
        "begin_line": 1453,
        "end_line": 1453,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "weak_",
        "snippet": "  std::weak_ptr<Ope> weak_;\n"
    },
    {
        "begin_line": 1456,
        "end_line": 1474,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Holder",
        "snippet": "class Holder : public Ope {\npublic:\n  Holder(Definition *outer) : outer_(outer) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  any reduce(SemanticValues &sv, any &dt) const;\n\n  const char *trace_name() const;\n\n  std::shared_ptr<Ope> ope_;\n  Definition *outer_;\n  mutable std::string trace_name_;\n\n  friend class Definition;\n};\n"
    },
    {
        "begin_line": 1458,
        "end_line": 1458,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Holder",
        "snippet": "  Holder(Definition *outer) : outer_(outer) {}\n"
    },
    {
        "begin_line": 1469,
        "end_line": 1469,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1470,
        "end_line": 1470,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "outer_",
        "snippet": "  Definition *outer_;\n"
    },
    {
        "begin_line": 1471,
        "end_line": 1471,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "trace_name_",
        "snippet": "  mutable std::string trace_name_;\n"
    },
    {
        "begin_line": 1478,
        "end_line": 1501,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Reference",
        "snippet": "class Reference : public Ope, public std::enable_shared_from_this<Reference> {\npublic:\n  Reference(const Grammar &grammar, const std::string &name, const char *s,\n            bool is_macro, const std::vector<std::shared_ptr<Ope>> &args)\n      : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),\n        rule_(nullptr), iarg_(0) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> get_core_operator() const;\n\n  const Grammar &grammar_;\n  const std::string name_;\n  const char *s_;\n\n  const bool is_macro_;\n  const std::vector<std::shared_ptr<Ope>> args_;\n\n  Definition *rule_;\n  size_t iarg_;\n};\n"
    },
    {
        "begin_line": 1480,
        "end_line": 1483,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Reference",
        "snippet": "  Reference(const Grammar &grammar, const std::string &name, const char *s,\n            bool is_macro, const std::vector<std::shared_ptr<Ope>> &args)\n      : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),\n        rule_(nullptr), iarg_(0) {}\n"
    },
    {
        "begin_line": 1492,
        "end_line": 1492,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "grammar_",
        "snippet": "  const Grammar &grammar_;\n"
    },
    {
        "begin_line": 1493,
        "end_line": 1493,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name_",
        "snippet": "  const std::string name_;\n"
    },
    {
        "begin_line": 1494,
        "end_line": 1494,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "s_",
        "snippet": "  const char *s_;\n"
    },
    {
        "begin_line": 1496,
        "end_line": 1496,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_macro_",
        "snippet": "  const bool is_macro_;\n"
    },
    {
        "begin_line": 1497,
        "end_line": 1497,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "args_",
        "snippet": "  const std::vector<std::shared_ptr<Ope>> args_;\n"
    },
    {
        "begin_line": 1499,
        "end_line": 1499,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "rule_",
        "snippet": "  Definition *rule_;\n"
    },
    {
        "begin_line": 1500,
        "end_line": 1500,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "iarg_",
        "snippet": "  size_t iarg_;\n"
    },
    {
        "begin_line": 1503,
        "end_line": 1519,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Whitespace",
        "snippet": "class Whitespace : public Ope {\npublic:\n  Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    if (c.in_whitespace) { return 0; }\n    c.in_whitespace = true;\n    auto se = make_scope_exit([&]() { c.in_whitespace = false; });\n    const auto &rule = *ope_;\n    return rule.parse(s, n, sv, c, dt);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> ope_;\n};\n"
    },
    {
        "begin_line": 1505,
        "end_line": 1505,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Whitespace",
        "snippet": "  Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}\n"
    },
    {
        "begin_line": 1507,
        "end_line": 1514,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    if (c.in_whitespace) { return 0; }\n    c.in_whitespace = true;\n    auto se = make_scope_exit([&]() { c.in_whitespace = false; });\n    const auto &rule = *ope_;\n    return rule.parse(s, n, sv, c, dt);\n  }\n"
    },
    {
        "begin_line": 1511,
        "end_line": 1511,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240a02",
        "snippet": "    auto se = make_scope_exit([&]() { c.in_whitespace = false; });\n"
    },
    {
        "begin_line": 1518,
        "end_line": 1518,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ope_",
        "snippet": "  std::shared_ptr<Ope> ope_;\n"
    },
    {
        "begin_line": 1521,
        "end_line": 1531,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "BackReference",
        "snippet": "class BackReference : public Ope {\npublic:\n  BackReference(const std::string &name) : name_(name) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override;\n\n  void accept(Visitor &v) override;\n\n  std::string name_;\n};\n"
    },
    {
        "begin_line": 1523,
        "end_line": 1523,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "BackReference",
        "snippet": "  BackReference(const std::string &name) : name_(name) {}\n"
    },
    {
        "begin_line": 1530,
        "end_line": 1530,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name_",
        "snippet": "  std::string name_;\n"
    },
    {
        "begin_line": 1533,
        "end_line": 1559,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PrecedenceClimbing",
        "snippet": "class PrecedenceClimbing : public Ope {\npublic:\n  using BinOpeInfo = std::map<std::string, std::pair<size_t, char>>;\n\n  PrecedenceClimbing(const std::shared_ptr<Ope> &atom,\n                     const std::shared_ptr<Ope> &binop, const BinOpeInfo &info,\n                     const Definition &rule)\n      : atom_(atom), binop_(binop), info_(info), rule_(rule) {}\n\n  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    return parse_expression(s, n, sv, c, dt, 0);\n  }\n\n  void accept(Visitor &v) override;\n\n  std::shared_ptr<Ope> atom_;\n  std::shared_ptr<Ope> binop_;\n  BinOpeInfo info_;\n  const Definition &rule_;\n\nprivate:\n  size_t parse_expression(const char *s, size_t n, SemanticValues &sv,\n                          Context &c, any &dt, size_t min_prec) const;\n\n  Definition &get_reference_for_binop(Context &c) const;\n};\n"
    },
    {
        "begin_line": 1537,
        "end_line": 1540,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PrecedenceClimbing",
        "snippet": "  PrecedenceClimbing(const std::shared_ptr<Ope> &atom,\n                     const std::shared_ptr<Ope> &binop, const BinOpeInfo &info,\n                     const Definition &rule)\n      : atom_(atom), binop_(binop), info_(info), rule_(rule) {}\n"
    },
    {
        "begin_line": 1542,
        "end_line": 1545,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,\n                    any &dt) const override {\n    return parse_expression(s, n, sv, c, dt, 0);\n  }\n"
    },
    {
        "begin_line": 1549,
        "end_line": 1549,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "atom_",
        "snippet": "  std::shared_ptr<Ope> atom_;\n"
    },
    {
        "begin_line": 1550,
        "end_line": 1550,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "binop_",
        "snippet": "  std::shared_ptr<Ope> binop_;\n"
    },
    {
        "begin_line": 1551,
        "end_line": 1551,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "info_",
        "snippet": "  BinOpeInfo info_;\n"
    },
    {
        "begin_line": 1552,
        "end_line": 1552,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "rule_",
        "snippet": "  const Definition &rule_;\n"
    },
    {
        "begin_line": 1564,
        "end_line": 1566,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "seq",
        "snippet": "template <typename... Args> std::shared_ptr<Ope> seq(Args &&... args) {\n  return std::make_shared<Sequence>(static_cast<std::shared_ptr<Ope>>(args)...);\n}\n"
    },
    {
        "begin_line": 1568,
        "end_line": 1571,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "cho",
        "snippet": "template <typename... Args> std::shared_ptr<Ope> cho(Args &&... args) {\n  return std::make_shared<PrioritizedChoice>(\n      static_cast<std::shared_ptr<Ope>>(args)...);\n}\n"
    },
    {
        "begin_line": 1573,
        "end_line": 1575,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "zom",
        "snippet": "inline std::shared_ptr<Ope> zom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::zom(ope);\n}\n"
    },
    {
        "begin_line": 1577,
        "end_line": 1579,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "oom",
        "snippet": "inline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope> &ope) {\n  return Repetition::oom(ope);\n}\n"
    },
    {
        "begin_line": 1581,
        "end_line": 1583,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "opt",
        "snippet": "inline std::shared_ptr<Ope> opt(const std::shared_ptr<Ope> &ope) {\n  return Repetition::opt(ope);\n}\n"
    },
    {
        "begin_line": 1585,
        "end_line": 1588,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "rep",
        "snippet": "inline std::shared_ptr<Ope> rep(const std::shared_ptr<Ope> &ope, size_t min,\n                                size_t max) {\n  return std::make_shared<Repetition>(ope, min, max);\n}\n"
    },
    {
        "begin_line": 1590,
        "end_line": 1592,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "apd",
        "snippet": "inline std::shared_ptr<Ope> apd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<AndPredicate>(ope);\n}\n"
    },
    {
        "begin_line": 1594,
        "end_line": 1596,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "npd",
        "snippet": "inline std::shared_ptr<Ope> npd(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<NotPredicate>(ope);\n}\n"
    },
    {
        "begin_line": 1598,
        "end_line": 1600,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "dic",
        "snippet": "inline std::shared_ptr<Ope> dic(const std::vector<std::string> &v) {\n  return std::make_shared<Dictionary>(v);\n}\n"
    },
    {
        "begin_line": 1602,
        "end_line": 1604,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "lit",
        "snippet": "inline std::shared_ptr<Ope> lit(std::string &&s) {\n  return std::make_shared<LiteralString>(s, false);\n}\n"
    },
    {
        "begin_line": 1606,
        "end_line": 1608,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "liti",
        "snippet": "inline std::shared_ptr<Ope> liti(std::string &&s) {\n  return std::make_shared<LiteralString>(s, true);\n}\n"
    },
    {
        "begin_line": 1610,
        "end_line": 1612,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "cls",
        "snippet": "inline std::shared_ptr<Ope> cls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, false);\n}\n"
    },
    {
        "begin_line": 1615,
        "end_line": 1617,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "cls",
        "snippet": "cls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, false);\n}\n"
    },
    {
        "begin_line": 1619,
        "end_line": 1621,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ncls",
        "snippet": "inline std::shared_ptr<Ope> ncls(const std::string &s) {\n  return std::make_shared<CharacterClass>(s, true);\n}\n"
    },
    {
        "begin_line": 1624,
        "end_line": 1626,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ncls",
        "snippet": "ncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {\n  return std::make_shared<CharacterClass>(ranges, true);\n}\n"
    },
    {
        "begin_line": 1628,
        "end_line": 1630,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "chr",
        "snippet": "inline std::shared_ptr<Ope> chr(char dt) {\n  return std::make_shared<Character>(dt);\n}\n"
    },
    {
        "begin_line": 1632,
        "end_line": 1632,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "dot",
        "snippet": "inline std::shared_ptr<Ope> dot() { return std::make_shared<AnyCharacter>(); }\n"
    },
    {
        "begin_line": 1634,
        "end_line": 1636,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "csc",
        "snippet": "inline std::shared_ptr<Ope> csc(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<CaptureScope>(ope);\n}\n"
    },
    {
        "begin_line": 1638,
        "end_line": 1641,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "cap",
        "snippet": "inline std::shared_ptr<Ope> cap(const std::shared_ptr<Ope> &ope,\n                                Capture::MatchAction ma) {\n  return std::make_shared<Capture>(ope, ma);\n}\n"
    },
    {
        "begin_line": 1643,
        "end_line": 1645,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tok",
        "snippet": "inline std::shared_ptr<Ope> tok(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<TokenBoundary>(ope);\n}\n"
    },
    {
        "begin_line": 1647,
        "end_line": 1649,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ign",
        "snippet": "inline std::shared_ptr<Ope> ign(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Ignore>(ope);\n}\n"
    },
    {
        "begin_line": 1652,
        "end_line": 1655,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "usr",
        "snippet": "usr(std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>\n        fn) {\n  return std::make_shared<User>(fn);\n}\n"
    },
    {
        "begin_line": 1657,
        "end_line": 1661,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ref",
        "snippet": "inline std::shared_ptr<Ope> ref(const Grammar &grammar, const std::string &name,\n                                const char *s, bool is_macro,\n                                const std::vector<std::shared_ptr<Ope>> &args) {\n  return std::make_shared<Reference>(grammar, name, s, is_macro, args);\n}\n"
    },
    {
        "begin_line": 1663,
        "end_line": 1665,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "wsp",
        "snippet": "inline std::shared_ptr<Ope> wsp(const std::shared_ptr<Ope> &ope) {\n  return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));\n}\n"
    },
    {
        "begin_line": 1667,
        "end_line": 1669,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "bkr",
        "snippet": "inline std::shared_ptr<Ope> bkr(const std::string &name) {\n  return std::make_shared<BackReference>(name);\n}\n"
    },
    {
        "begin_line": 1671,
        "end_line": 1676,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "pre",
        "snippet": "inline std::shared_ptr<Ope> pre(const std::shared_ptr<Ope> &atom,\n                                const std::shared_ptr<Ope> &binop,\n                                const PrecedenceClimbing::BinOpeInfo &info,\n                                const Definition &rule) {\n  return std::make_shared<PrecedenceClimbing>(atom, binop, info, rule);\n}\n"
    },
    {
        "begin_line": 1681,
        "end_line": 1704,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Visitor",
        "snippet": "struct Ope::Visitor {\n  virtual ~Visitor() {}\n  virtual void visit(Sequence & /*ope*/) {}\n  virtual void visit(PrioritizedChoice & /*ope*/) {}\n  virtual void visit(Repetition & /*ope*/) {}\n  virtual void visit(AndPredicate & /*ope*/) {}\n  virtual void visit(NotPredicate & /*ope*/) {}\n  virtual void visit(Dictionary & /*ope*/) {}\n  virtual void visit(LiteralString & /*ope*/) {}\n  virtual void visit(CharacterClass & /*ope*/) {}\n  virtual void visit(Character & /*ope*/) {}\n  virtual void visit(AnyCharacter & /*ope*/) {}\n  virtual void visit(CaptureScope & /*ope*/) {}\n  virtual void visit(Capture & /*ope*/) {}\n  virtual void visit(TokenBoundary & /*ope*/) {}\n  virtual void visit(Ignore & /*ope*/) {}\n  virtual void visit(User & /*ope*/) {}\n  virtual void visit(WeakHolder & /*ope*/) {}\n  virtual void visit(Holder & /*ope*/) {}\n  virtual void visit(Reference & /*ope*/) {}\n  virtual void visit(Whitespace & /*ope*/) {}\n  virtual void visit(BackReference & /*ope*/) {}\n  virtual void visit(PrecedenceClimbing & /*ope*/) {}\n};\n"
    },
    {
        "begin_line": 1682,
        "end_line": 1682,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "~Visitor",
        "snippet": "  virtual ~Visitor() {}\n"
    },
    {
        "begin_line": 1683,
        "end_line": 1683,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Sequence & /*ope*/) {}\n"
    },
    {
        "begin_line": 1684,
        "end_line": 1684,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(PrioritizedChoice & /*ope*/) {}\n"
    },
    {
        "begin_line": 1685,
        "end_line": 1685,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Repetition & /*ope*/) {}\n"
    },
    {
        "begin_line": 1686,
        "end_line": 1686,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(AndPredicate & /*ope*/) {}\n"
    },
    {
        "begin_line": 1687,
        "end_line": 1687,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(NotPredicate & /*ope*/) {}\n"
    },
    {
        "begin_line": 1688,
        "end_line": 1688,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Dictionary & /*ope*/) {}\n"
    },
    {
        "begin_line": 1689,
        "end_line": 1689,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(LiteralString & /*ope*/) {}\n"
    },
    {
        "begin_line": 1690,
        "end_line": 1690,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(CharacterClass & /*ope*/) {}\n"
    },
    {
        "begin_line": 1691,
        "end_line": 1691,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Character & /*ope*/) {}\n"
    },
    {
        "begin_line": 1692,
        "end_line": 1692,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(AnyCharacter & /*ope*/) {}\n"
    },
    {
        "begin_line": 1693,
        "end_line": 1693,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(CaptureScope & /*ope*/) {}\n"
    },
    {
        "begin_line": 1694,
        "end_line": 1694,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Capture & /*ope*/) {}\n"
    },
    {
        "begin_line": 1695,
        "end_line": 1695,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(TokenBoundary & /*ope*/) {}\n"
    },
    {
        "begin_line": 1696,
        "end_line": 1696,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Ignore & /*ope*/) {}\n"
    },
    {
        "begin_line": 1697,
        "end_line": 1697,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(User & /*ope*/) {}\n"
    },
    {
        "begin_line": 1698,
        "end_line": 1698,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(WeakHolder & /*ope*/) {}\n"
    },
    {
        "begin_line": 1699,
        "end_line": 1699,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Holder & /*ope*/) {}\n"
    },
    {
        "begin_line": 1700,
        "end_line": 1700,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Reference & /*ope*/) {}\n"
    },
    {
        "begin_line": 1701,
        "end_line": 1701,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(Whitespace & /*ope*/) {}\n"
    },
    {
        "begin_line": 1702,
        "end_line": 1702,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(BackReference & /*ope*/) {}\n"
    },
    {
        "begin_line": 1703,
        "end_line": 1703,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  virtual void visit(PrecedenceClimbing & /*ope*/) {}\n"
    },
    {
        "begin_line": 1706,
        "end_line": 1710,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "IsReference",
        "snippet": "struct IsReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n  void visit(Reference & /*ope*/) override { is_reference = true; }\n  bool is_reference = false;\n};\n"
    },
    {
        "begin_line": 1708,
        "end_line": 1708,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Reference & /*ope*/) override { is_reference = true; }\n"
    },
    {
        "begin_line": 1709,
        "end_line": 1709,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_reference",
        "snippet": "  bool is_reference = false;\n"
    },
    {
        "begin_line": 1712,
        "end_line": 1740,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TraceOpeName",
        "snippet": "struct TraceOpeName : public Ope::Visitor {\n  void visit(Sequence & /*ope*/) override { name = \"Sequence\"; }\n  void visit(PrioritizedChoice & /*ope*/) override {\n    name = \"PrioritizedChoice\";\n  }\n  void visit(Repetition & /*ope*/) override { name = \"Repetition\"; }\n  void visit(AndPredicate & /*ope*/) override { name = \"AndPredicate\"; }\n  void visit(NotPredicate & /*ope*/) override { name = \"NotPredicate\"; }\n  void visit(Dictionary & /*ope*/) override { name = \"Dictionary\"; }\n  void visit(LiteralString & /*ope*/) override { name = \"LiteralString\"; }\n  void visit(CharacterClass & /*ope*/) override { name = \"CharacterClass\"; }\n  void visit(Character & /*ope*/) override { name = \"Character\"; }\n  void visit(AnyCharacter & /*ope*/) override { name = \"AnyCharacter\"; }\n  void visit(CaptureScope & /*ope*/) override { name = \"CaptureScope\"; }\n  void visit(Capture & /*ope*/) override { name = \"Capture\"; }\n  void visit(TokenBoundary & /*ope*/) override { name = \"TokenBoundary\"; }\n  void visit(Ignore & /*ope*/) override { name = \"Ignore\"; }\n  void visit(User & /*ope*/) override { name = \"User\"; }\n  void visit(WeakHolder & /*ope*/) override { name = \"WeakHolder\"; }\n  void visit(Holder &ope) override { name = ope.trace_name(); }\n  void visit(Reference & /*ope*/) override { name = \"Reference\"; }\n  void visit(Whitespace & /*ope*/) override { name = \"Whitespace\"; }\n  void visit(BackReference & /*ope*/) override { name = \"BackReference\"; }\n  void visit(PrecedenceClimbing & /*ope*/) override {\n    name = \"PrecedenceClimbing\";\n  }\n\n  const char *name = nullptr;\n};\n"
    },
    {
        "begin_line": 1713,
        "end_line": 1713,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence & /*ope*/) override { name = \"Sequence\"; }\n"
    },
    {
        "begin_line": 1714,
        "end_line": 1716,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice & /*ope*/) override {\n    name = \"PrioritizedChoice\";\n  }\n"
    },
    {
        "begin_line": 1717,
        "end_line": 1717,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition & /*ope*/) override { name = \"Repetition\"; }\n"
    },
    {
        "begin_line": 1718,
        "end_line": 1718,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate & /*ope*/) override { name = \"AndPredicate\"; }\n"
    },
    {
        "begin_line": 1719,
        "end_line": 1719,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate & /*ope*/) override { name = \"NotPredicate\"; }\n"
    },
    {
        "begin_line": 1720,
        "end_line": 1720,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Dictionary & /*ope*/) override { name = \"Dictionary\"; }\n"
    },
    {
        "begin_line": 1721,
        "end_line": 1721,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(LiteralString & /*ope*/) override { name = \"LiteralString\"; }\n"
    },
    {
        "begin_line": 1722,
        "end_line": 1722,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CharacterClass & /*ope*/) override { name = \"CharacterClass\"; }\n"
    },
    {
        "begin_line": 1723,
        "end_line": 1723,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Character & /*ope*/) override { name = \"Character\"; }\n"
    },
    {
        "begin_line": 1724,
        "end_line": 1724,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AnyCharacter & /*ope*/) override { name = \"AnyCharacter\"; }\n"
    },
    {
        "begin_line": 1725,
        "end_line": 1725,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope & /*ope*/) override { name = \"CaptureScope\"; }\n"
    },
    {
        "begin_line": 1726,
        "end_line": 1726,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture & /*ope*/) override { name = \"Capture\"; }\n"
    },
    {
        "begin_line": 1727,
        "end_line": 1727,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary & /*ope*/) override { name = \"TokenBoundary\"; }\n"
    },
    {
        "begin_line": 1728,
        "end_line": 1728,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore & /*ope*/) override { name = \"Ignore\"; }\n"
    },
    {
        "begin_line": 1729,
        "end_line": 1729,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(User & /*ope*/) override { name = \"User\"; }\n"
    },
    {
        "begin_line": 1730,
        "end_line": 1730,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder & /*ope*/) override { name = \"WeakHolder\"; }\n"
    },
    {
        "begin_line": 1731,
        "end_line": 1731,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Holder &ope) override { name = ope.trace_name(); }\n"
    },
    {
        "begin_line": 1732,
        "end_line": 1732,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Reference & /*ope*/) override { name = \"Reference\"; }\n"
    },
    {
        "begin_line": 1733,
        "end_line": 1733,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace & /*ope*/) override { name = \"Whitespace\"; }\n"
    },
    {
        "begin_line": 1734,
        "end_line": 1734,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(BackReference & /*ope*/) override { name = \"BackReference\"; }\n"
    },
    {
        "begin_line": 1735,
        "end_line": 1737,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing & /*ope*/) override {\n    name = \"PrecedenceClimbing\";\n  }\n"
    },
    {
        "begin_line": 1739,
        "end_line": 1739,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name",
        "snippet": "  const char *name = nullptr;\n"
    },
    {
        "begin_line": 1742,
        "end_line": 1769,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AssignIDToDefinition",
        "snippet": "struct AssignIDToDefinition : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override;\n\n  std::unordered_map<void *, size_t> ids;\n};\n"
    },
    {
        "begin_line": 1745,
        "end_line": 1749,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 1750,
        "end_line": 1754,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 1755,
        "end_line": 1755,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1756,
        "end_line": 1756,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1757,
        "end_line": 1757,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1758,
        "end_line": 1758,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1759,
        "end_line": 1759,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1760,
        "end_line": 1760,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1761,
        "end_line": 1761,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1762,
        "end_line": 1762,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n"
    },
    {
        "begin_line": 1765,
        "end_line": 1765,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1768,
        "end_line": 1768,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ids",
        "snippet": "  std::unordered_map<void *, size_t> ids;\n"
    },
    {
        "begin_line": 1771,
        "end_line": 1792,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "IsLiteralToken",
        "snippet": "struct IsLiteralToken : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      if (!IsLiteralToken::check(*op)) { return; }\n    }\n    result_ = true;\n  }\n\n  void visit(Dictionary & /*ope*/) override { result_ = true; }\n  void visit(LiteralString & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsLiteralToken vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n"
    },
    {
        "begin_line": 1774,
        "end_line": 1779,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      if (!IsLiteralToken::check(*op)) { return; }\n    }\n    result_ = true;\n  }\n"
    },
    {
        "begin_line": 1781,
        "end_line": 1781,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Dictionary & /*ope*/) override { result_ = true; }\n"
    },
    {
        "begin_line": 1782,
        "end_line": 1782,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(LiteralString & /*ope*/) override { result_ = true; }\n"
    },
    {
        "begin_line": 1784,
        "end_line": 1788,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "check",
        "snippet": "  static bool check(Ope &ope) {\n    IsLiteralToken vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n"
    },
    {
        "begin_line": 1791,
        "end_line": 1791,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "result_",
        "snippet": "  bool result_ = false;\n"
    },
    {
        "begin_line": 1794,
        "end_line": 1828,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "TokenChecker",
        "snippet": "struct TokenChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override;\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  static bool is_token(Ope &ope) {\n    if (IsLiteralToken::check(ope)) { return true; }\n\n    TokenChecker vis;\n    ope.accept(vis);\n    return vis.has_token_boundary_ || !vis.has_rule_;\n  }\n\nprivate:\n  bool has_token_boundary_ = false;\n  bool has_rule_ = false;\n};\n"
    },
    {
        "begin_line": 1797,
        "end_line": 1801,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 1802,
        "end_line": 1806,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 1807,
        "end_line": 1807,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1808,
        "end_line": 1808,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1809,
        "end_line": 1809,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1810,
        "end_line": 1810,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }\n"
    },
    {
        "begin_line": 1811,
        "end_line": 1811,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1814,
        "end_line": 1814,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1815,
        "end_line": 1815,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n"
    },
    {
        "begin_line": 1817,
        "end_line": 1823,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_token",
        "snippet": "  static bool is_token(Ope &ope) {\n    if (IsLiteralToken::check(ope)) { return true; }\n\n    TokenChecker vis;\n    ope.accept(vis);\n    return vis.has_token_boundary_ || !vis.has_rule_;\n  }\n"
    },
    {
        "begin_line": 1826,
        "end_line": 1826,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "has_token_boundary_",
        "snippet": "  bool has_token_boundary_ = false;\n"
    },
    {
        "begin_line": 1827,
        "end_line": 1827,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "has_rule_",
        "snippet": "  bool has_rule_ = false;\n"
    },
    {
        "begin_line": 1830,
        "end_line": 1888,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "DetectLeftRecursion",
        "snippet": "struct DetectLeftRecursion : public Ope::Visitor {\n  DetectLeftRecursion(const std::string &name) : name_(name) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (done_) {\n        break;\n      } else if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    done_ = ope.min_ > 0;\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n  void visit(Dictionary & /*ope*/) override { done_ = true; }\n  void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }\n  void visit(CharacterClass & /*ope*/) override { done_ = true; }\n  void visit(Character & /*ope*/) override { done_ = true; }\n  void visit(AnyCharacter & /*ope*/) override { done_ = true; }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(User & /*ope*/) override { done_ = true; }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(BackReference & /*ope*/) override { done_ = true; }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  const char *error_s = nullptr;\n\nprivate:\n  std::string name_;\n  std::set<std::string> refs_;\n  bool done_ = false;\n};\n"
    },
    {
        "begin_line": 1831,
        "end_line": 1831,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "DetectLeftRecursion",
        "snippet": "  DetectLeftRecursion(const std::string &name) : name_(name) {}\n"
    },
    {
        "begin_line": 1833,
        "end_line": 1843,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (done_) {\n        break;\n      } else if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n"
    },
    {
        "begin_line": 1844,
        "end_line": 1852,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (error_s) {\n        done_ = true;\n        break;\n      }\n    }\n  }\n"
    },
    {
        "begin_line": 1853,
        "end_line": 1856,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    done_ = ope.min_ > 0;\n  }\n"
    },
    {
        "begin_line": 1857,
        "end_line": 1860,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n"
    },
    {
        "begin_line": 1861,
        "end_line": 1864,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    done_ = false;\n  }\n"
    },
    {
        "begin_line": 1865,
        "end_line": 1865,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Dictionary & /*ope*/) override { done_ = true; }\n"
    },
    {
        "begin_line": 1866,
        "end_line": 1866,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }\n"
    },
    {
        "begin_line": 1867,
        "end_line": 1867,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CharacterClass & /*ope*/) override { done_ = true; }\n"
    },
    {
        "begin_line": 1868,
        "end_line": 1868,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Character & /*ope*/) override { done_ = true; }\n"
    },
    {
        "begin_line": 1869,
        "end_line": 1869,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AnyCharacter & /*ope*/) override { done_ = true; }\n"
    },
    {
        "begin_line": 1870,
        "end_line": 1870,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1871,
        "end_line": 1871,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1872,
        "end_line": 1872,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1873,
        "end_line": 1873,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1874,
        "end_line": 1874,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(User & /*ope*/) override { done_ = true; }\n"
    },
    {
        "begin_line": 1875,
        "end_line": 1875,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n"
    },
    {
        "begin_line": 1876,
        "end_line": 1876,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1878,
        "end_line": 1878,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1879,
        "end_line": 1879,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(BackReference & /*ope*/) override { done_ = true; }\n"
    },
    {
        "begin_line": 1880,
        "end_line": 1880,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n"
    },
    {
        "begin_line": 1882,
        "end_line": 1882,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_s",
        "snippet": "  const char *error_s = nullptr;\n"
    },
    {
        "begin_line": 1885,
        "end_line": 1885,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name_",
        "snippet": "  std::string name_;\n"
    },
    {
        "begin_line": 1886,
        "end_line": 1886,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "refs_",
        "snippet": "  std::set<std::string> refs_;\n"
    },
    {
        "begin_line": 1887,
        "end_line": 1887,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "done_",
        "snippet": "  bool done_ = false;\n"
    },
    {
        "begin_line": 1890,
        "end_line": 1952,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "HasEmptyElement",
        "snippet": "struct HasEmptyElement : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)\n      : refs_(refs) {}\n\n  void visit(Sequence &ope) override {\n    bool save_is_empty = false;\n    const char *save_error_s = nullptr;\n    std::string save_error_name;\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (!is_empty) { return; }\n      save_is_empty = is_empty;\n      save_error_s = error_s;\n      save_error_name = error_name;\n      is_empty = false;\n      error_name.clear();\n    }\n    is_empty = save_is_empty;\n    error_s = save_error_s;\n    error_name = save_error_name;\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (is_empty) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.min_ == 0) {\n      set_error();\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate & /*ope*/) override { set_error(); }\n  void visit(NotPredicate & /*ope*/) override { set_error(); }\n  void visit(LiteralString &ope) override {\n    if (ope.lit_.empty()) { set_error(); }\n  }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool is_empty = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  void set_error() {\n    is_empty = true;\n    error_s = refs_.back().first;\n    error_name = refs_.back().second;\n  }\n  std::list<std::pair<const char *, std::string>> &refs_;\n};\n"
    },
    {
        "begin_line": 1893,
        "end_line": 1894,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "HasEmptyElement",
        "snippet": "  HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)\n      : refs_(refs) {}\n"
    },
    {
        "begin_line": 1896,
        "end_line": 1912,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    bool save_is_empty = false;\n    const char *save_error_s = nullptr;\n    std::string save_error_name;\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (!is_empty) { return; }\n      save_is_empty = is_empty;\n      save_error_s = error_s;\n      save_error_name = error_name;\n      is_empty = false;\n      error_name.clear();\n    }\n    is_empty = save_is_empty;\n    error_s = save_error_s;\n    error_name = save_error_name;\n  }\n"
    },
    {
        "begin_line": 1913,
        "end_line": 1918,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (is_empty) { return; }\n    }\n  }\n"
    },
    {
        "begin_line": 1919,
        "end_line": 1925,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override {\n    if (ope.min_ == 0) {\n      set_error();\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 1926,
        "end_line": 1926,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate & /*ope*/) override { set_error(); }\n"
    },
    {
        "begin_line": 1927,
        "end_line": 1927,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate & /*ope*/) override { set_error(); }\n"
    },
    {
        "begin_line": 1928,
        "end_line": 1930,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(LiteralString &ope) override {\n    if (ope.lit_.empty()) { set_error(); }\n  }\n"
    },
    {
        "begin_line": 1931,
        "end_line": 1931,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1932,
        "end_line": 1932,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1933,
        "end_line": 1933,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1934,
        "end_line": 1934,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1935,
        "end_line": 1935,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n"
    },
    {
        "begin_line": 1936,
        "end_line": 1936,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1938,
        "end_line": 1938,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1939,
        "end_line": 1939,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n"
    },
    {
        "begin_line": 1941,
        "end_line": 1941,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_empty",
        "snippet": "  bool is_empty = false;\n"
    },
    {
        "begin_line": 1942,
        "end_line": 1942,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_s",
        "snippet": "  const char *error_s = nullptr;\n"
    },
    {
        "begin_line": 1943,
        "end_line": 1943,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_name",
        "snippet": "  std::string error_name;\n"
    },
    {
        "begin_line": 1946,
        "end_line": 1950,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "set_error",
        "snippet": "  void set_error() {\n    is_empty = true;\n    error_s = refs_.back().first;\n    error_name = refs_.back().second;\n  }\n"
    },
    {
        "begin_line": 1951,
        "end_line": 1951,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "refs_",
        "snippet": "  std::list<std::pair<const char *, std::string>> &refs_;\n"
    },
    {
        "begin_line": 1954,
        "end_line": 2004,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "DetectInfiniteLoop",
        "snippet": "struct DetectInfiniteLoop : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  DetectInfiniteLoop(const char *s, const std::string &name) {\n    refs_.emplace_back(s, name);\n  }\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n  void visit(Repetition &ope) override {\n    if (ope.max_ == std::numeric_limits<size_t>::max()) {\n      HasEmptyElement vis(refs_);\n      ope.ope_->accept(vis);\n      if (vis.is_empty) {\n        has_error = true;\n        error_s = vis.error_s;\n        error_name = vis.error_name;\n      }\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  bool has_error = false;\n  const char *error_s = nullptr;\n  std::string error_name;\n\nprivate:\n  std::list<std::pair<const char *, std::string>> refs_;\n};\n"
    },
    {
        "begin_line": 1957,
        "end_line": 1959,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "DetectInfiniteLoop",
        "snippet": "  DetectInfiniteLoop(const char *s, const std::string &name) {\n    refs_.emplace_back(s, name);\n  }\n"
    },
    {
        "begin_line": 1961,
        "end_line": 1966,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n"
    },
    {
        "begin_line": 1967,
        "end_line": 1972,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n      if (has_error) { return; }\n    }\n  }\n"
    },
    {
        "begin_line": 1973,
        "end_line": 1985,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override {\n    if (ope.max_ == std::numeric_limits<size_t>::max()) {\n      HasEmptyElement vis(refs_);\n      ope.ope_->accept(vis);\n      if (vis.is_empty) {\n        has_error = true;\n        error_s = vis.error_s;\n        error_name = vis.error_name;\n      }\n    } else {\n      ope.ope_->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 1986,
        "end_line": 1986,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1987,
        "end_line": 1987,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1988,
        "end_line": 1988,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1989,
        "end_line": 1989,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1990,
        "end_line": 1990,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1991,
        "end_line": 1991,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1992,
        "end_line": 1992,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n"
    },
    {
        "begin_line": 1993,
        "end_line": 1993,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1995,
        "end_line": 1995,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 1996,
        "end_line": 1996,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n"
    },
    {
        "begin_line": 1998,
        "end_line": 1998,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "has_error",
        "snippet": "  bool has_error = false;\n"
    },
    {
        "begin_line": 1999,
        "end_line": 1999,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_s",
        "snippet": "  const char *error_s = nullptr;\n"
    },
    {
        "begin_line": 2000,
        "end_line": 2000,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_name",
        "snippet": "  std::string error_name;\n"
    },
    {
        "begin_line": 2003,
        "end_line": 2003,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "refs_",
        "snippet": "  std::list<std::pair<const char *, std::string>> refs_;\n"
    },
    {
        "begin_line": 2006,
        "end_line": 2042,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ReferenceChecker",
        "snippet": "struct ReferenceChecker : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  ReferenceChecker(const Grammar &grammar,\n                   const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\n  std::unordered_map<std::string, const char *> error_s;\n  std::unordered_map<std::string, std::string> error_message;\n\nprivate:\n  const Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n"
    },
    {
        "begin_line": 2009,
        "end_line": 2011,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ReferenceChecker",
        "snippet": "  ReferenceChecker(const Grammar &grammar,\n                   const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n"
    },
    {
        "begin_line": 2013,
        "end_line": 2017,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 2018,
        "end_line": 2022,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 2023,
        "end_line": 2023,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2024,
        "end_line": 2024,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2025,
        "end_line": 2025,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2026,
        "end_line": 2026,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2027,
        "end_line": 2027,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2028,
        "end_line": 2028,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2029,
        "end_line": 2029,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2030,
        "end_line": 2030,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n"
    },
    {
        "begin_line": 2031,
        "end_line": 2031,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2033,
        "end_line": 2033,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2034,
        "end_line": 2034,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n"
    },
    {
        "begin_line": 2036,
        "end_line": 2036,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_s",
        "snippet": "  std::unordered_map<std::string, const char *> error_s;\n"
    },
    {
        "begin_line": 2037,
        "end_line": 2037,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_message",
        "snippet": "  std::unordered_map<std::string, std::string> error_message;\n"
    },
    {
        "begin_line": 2040,
        "end_line": 2040,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "grammar_",
        "snippet": "  const Grammar &grammar_;\n"
    },
    {
        "begin_line": 2041,
        "end_line": 2041,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "params_",
        "snippet": "  const std::vector<std::string> &params_;\n"
    },
    {
        "begin_line": 2044,
        "end_line": 2076,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "LinkReferences",
        "snippet": "struct LinkReferences : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  LinkReferences(Grammar &grammar, const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n\nprivate:\n  Grammar &grammar_;\n  const std::vector<std::string> &params_;\n};\n"
    },
    {
        "begin_line": 2047,
        "end_line": 2048,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "LinkReferences",
        "snippet": "  LinkReferences(Grammar &grammar, const std::vector<std::string> &params)\n      : grammar_(grammar), params_(params) {}\n"
    },
    {
        "begin_line": 2050,
        "end_line": 2054,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 2055,
        "end_line": 2059,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    for (auto op : ope.opes_) {\n      op->accept(*this);\n    }\n  }\n"
    },
    {
        "begin_line": 2060,
        "end_line": 2060,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2061,
        "end_line": 2061,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2062,
        "end_line": 2062,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2063,
        "end_line": 2063,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2064,
        "end_line": 2064,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2065,
        "end_line": 2065,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2066,
        "end_line": 2066,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2067,
        "end_line": 2067,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n"
    },
    {
        "begin_line": 2068,
        "end_line": 2068,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2070,
        "end_line": 2070,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2071,
        "end_line": 2071,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }\n"
    },
    {
        "begin_line": 2074,
        "end_line": 2074,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "grammar_",
        "snippet": "  Grammar &grammar_;\n"
    },
    {
        "begin_line": 2075,
        "end_line": 2075,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "params_",
        "snippet": "  const std::vector<std::string> &params_;\n"
    },
    {
        "begin_line": 2078,
        "end_line": 2155,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "FindReference",
        "snippet": "struct FindReference : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  FindReference(const std::vector<std::shared_ptr<Ope>> &args,\n                const std::vector<std::string> &params)\n      : args_(args), params_(params) {}\n\n  void visit(Sequence &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<Sequence>(opes);\n  }\n  void visit(PrioritizedChoice &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<PrioritizedChoice>(opes);\n  }\n  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = rep(found_ope, ope.min_, ope.max_);\n  }\n  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = apd(found_ope);\n  }\n  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = npd(found_ope);\n  }\n  void visit(Dictionary &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(LiteralString &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(CharacterClass &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n  void visit(Character &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(AnyCharacter &ope) override { found_ope = ope.shared_from_this(); }\n  void visit(CaptureScope &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n  void visit(Capture &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = cap(found_ope, ope.match_action_);\n  }\n  void visit(TokenBoundary &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = tok(found_ope);\n  }\n  void visit(Ignore &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = ign(found_ope);\n  }\n  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n  void visit(Reference &ope) override;\n  void visit(Whitespace &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = wsp(found_ope);\n  }\n  void visit(PrecedenceClimbing &ope) override {\n    ope.atom_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n\n  std::shared_ptr<Ope> found_ope;\n\nprivate:\n  const std::vector<std::shared_ptr<Ope>> &args_;\n  const std::vector<std::string> &params_;\n};\n"
    },
    {
        "begin_line": 2081,
        "end_line": 2083,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "FindReference",
        "snippet": "  FindReference(const std::vector<std::shared_ptr<Ope>> &args,\n                const std::vector<std::string> &params)\n      : args_(args), params_(params) {}\n"
    },
    {
        "begin_line": 2085,
        "end_line": 2092,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Sequence &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<Sequence>(opes);\n  }\n"
    },
    {
        "begin_line": 2093,
        "end_line": 2100,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice &ope) override {\n    std::vector<std::shared_ptr<Ope>> opes;\n    for (auto o : ope.opes_) {\n      o->accept(*this);\n      opes.push_back(found_ope);\n    }\n    found_ope = std::make_shared<PrioritizedChoice>(opes);\n  }\n"
    },
    {
        "begin_line": 2101,
        "end_line": 2104,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Repetition &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = rep(found_ope, ope.min_, ope.max_);\n  }\n"
    },
    {
        "begin_line": 2105,
        "end_line": 2108,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AndPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = apd(found_ope);\n  }\n"
    },
    {
        "begin_line": 2109,
        "end_line": 2112,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(NotPredicate &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = npd(found_ope);\n  }\n"
    },
    {
        "begin_line": 2113,
        "end_line": 2113,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Dictionary &ope) override { found_ope = ope.shared_from_this(); }\n"
    },
    {
        "begin_line": 2114,
        "end_line": 2116,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(LiteralString &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n"
    },
    {
        "begin_line": 2117,
        "end_line": 2119,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CharacterClass &ope) override {\n    found_ope = ope.shared_from_this();\n  }\n"
    },
    {
        "begin_line": 2120,
        "end_line": 2120,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Character &ope) override { found_ope = ope.shared_from_this(); }\n"
    },
    {
        "begin_line": 2121,
        "end_line": 2121,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(AnyCharacter &ope) override { found_ope = ope.shared_from_this(); }\n"
    },
    {
        "begin_line": 2122,
        "end_line": 2125,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(CaptureScope &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n"
    },
    {
        "begin_line": 2126,
        "end_line": 2129,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Capture &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = cap(found_ope, ope.match_action_);\n  }\n"
    },
    {
        "begin_line": 2130,
        "end_line": 2133,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(TokenBoundary &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = tok(found_ope);\n  }\n"
    },
    {
        "begin_line": 2134,
        "end_line": 2137,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Ignore &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = ign(found_ope);\n  }\n"
    },
    {
        "begin_line": 2138,
        "end_line": 2138,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }\n"
    },
    {
        "begin_line": 2139,
        "end_line": 2139,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Holder &ope) override { ope.ope_->accept(*this); }\n"
    },
    {
        "begin_line": 2141,
        "end_line": 2144,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(Whitespace &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = wsp(found_ope);\n  }\n"
    },
    {
        "begin_line": 2145,
        "end_line": 2148,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrecedenceClimbing &ope) override {\n    ope.atom_->accept(*this);\n    found_ope = csc(found_ope);\n  }\n"
    },
    {
        "begin_line": 2150,
        "end_line": 2150,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "found_ope",
        "snippet": "  std::shared_ptr<Ope> found_ope;\n"
    },
    {
        "begin_line": 2153,
        "end_line": 2153,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "args_",
        "snippet": "  const std::vector<std::shared_ptr<Ope>> &args_;\n"
    },
    {
        "begin_line": 2154,
        "end_line": 2154,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "params_",
        "snippet": "  const std::vector<std::string> &params_;\n"
    },
    {
        "begin_line": 2157,
        "end_line": 2170,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "IsPrioritizedChoice",
        "snippet": "struct IsPrioritizedChoice : public Ope::Visitor {\n  using Ope::Visitor::visit;\n\n  void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }\n\n  static bool check(Ope &ope) {\n    IsPrioritizedChoice vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n\nprivate:\n  bool result_ = false;\n};\n"
    },
    {
        "begin_line": 2160,
        "end_line": 2160,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "  void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }\n"
    },
    {
        "begin_line": 2162,
        "end_line": 2166,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "check",
        "snippet": "  static bool check(Ope &ope) {\n    IsPrioritizedChoice vis;\n    ope.accept(vis);\n    return vis.result_;\n  }\n"
    },
    {
        "begin_line": 2169,
        "end_line": 2169,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "result_",
        "snippet": "  bool result_ = false;\n"
    },
    {
        "begin_line": 2175,
        "end_line": 2175,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "WHITESPACE_DEFINITION_NAME",
        "snippet": "static const char *WHITESPACE_DEFINITION_NAME = \"%whitespace\";\n"
    },
    {
        "begin_line": 2176,
        "end_line": 2176,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "WORD_DEFINITION_NAME",
        "snippet": "static const char *WORD_DEFINITION_NAME = \"%word\";\n"
    },
    {
        "begin_line": 2181,
        "end_line": 2354,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Definition",
        "snippet": "class Definition {\npublic:\n  struct Result {\n    bool ret;\n    size_t len;\n    const char *error_pos;\n    const char *message_pos;\n    const std::string message;\n  };\n\n  Definition() : holder_(std::make_shared<Holder>(this)) {}\n\n  Definition(const Definition &rhs) : name(rhs.name), holder_(rhs.holder_) {\n    holder_->outer_ = this;\n  }\n\n  Definition(const std::shared_ptr<Ope> &ope)\n      : holder_(std::make_shared<Holder>(this)) {\n    *this <= ope;\n  }\n\n  operator std::shared_ptr<Ope>() {\n    return std::make_shared<WeakHolder>(holder_);\n  }\n\n  Definition &operator<=(const std::shared_ptr<Ope> &ope) {\n    holder_->ope_ = ope;\n    return *this;\n  }\n\n  Result parse(const char *s, size_t n, const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, path);\n  }\n\n  Result parse(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    SemanticValues sv;\n    return parse_core(s, n, sv, dt, path);\n  }\n\n  Result parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, dt, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, val, path);\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n\n  template <typename T>\n  Result parse_and_get_value(const char *s, any &dt, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, dt, val, path);\n  }\n\n  Action operator=(Action a) {\n    action = a;\n    return a;\n  }\n\n  template <typename T> Definition &operator,(T fn) {\n    operator=(fn);\n    return *this;\n  }\n\n  Definition &operator~() {\n    ignoreSemanticValue = true;\n    return *this;\n  }\n\n  void accept(Ope::Visitor &v) { holder_->accept(v); }\n\n  std::shared_ptr<Ope> get_core_operator() const { return holder_->ope_; }\n\n  bool is_token() const {\n    std::call_once(is_token_init_, [this]() {\n      is_token_ = TokenChecker::is_token(*get_core_operator());\n    });\n    return is_token_;\n  }\n\n  std::string name;\n  const char *s_ = nullptr;\n\n  size_t id = 0;\n  Action action;\n  std::function<void(const char *s, size_t n, any &dt)> enter;\n  std::function<void(const char *s, size_t n, size_t matchlen, any &value,\n                     any &dt)>\n      leave;\n  std::function<std::string()> error_message;\n  bool ignoreSemanticValue = false;\n  std::shared_ptr<Ope> whitespaceOpe;\n  std::shared_ptr<Ope> wordOpe;\n  bool enablePackratParsing = false;\n  bool is_macro = false;\n  std::vector<std::string> params;\n  TracerEnter tracer_enter;\n  TracerLeave tracer_leave;\n  bool disable_action = false;\n\nprivate:\n  friend class Reference;\n  friend class ParserGenerator;\n\n  Definition &operator=(const Definition &rhs);\n  Definition &operator=(Definition &&rhs);\n\n  void initialize_definition_ids() const {\n    std::call_once(definition_ids_init_, [&]() {\n      AssignIDToDefinition vis;\n      holder_->accept(vis);\n      if (whitespaceOpe) { whitespaceOpe->accept(vis); }\n      if (wordOpe) { wordOpe->accept(vis); }\n      definition_ids_.swap(vis.ids);\n    });\n  }\n\n  Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,\n                    const char *path) const {\n    initialize_definition_ids();\n\n    std::shared_ptr<Ope> ope = holder_;\n    if (whitespaceOpe) { ope = std::make_shared<Sequence>(whitespaceOpe, ope); }\n\n    Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,\n                enablePackratParsing, tracer_enter, tracer_leave);\n\n    auto len = ope->parse(s, n, sv, cxt, dt);\n    return Result{success(len), len, cxt.error_pos, cxt.message_pos,\n                  cxt.message};\n  }\n\n  std::shared_ptr<Holder> holder_;\n  mutable std::once_flag is_token_init_;\n  mutable bool is_token_ = false;\n  mutable std::once_flag assign_id_to_definition_init_;\n  mutable std::once_flag definition_ids_init_;\n  mutable std::unordered_map<void *, size_t> definition_ids_;\n};\n"
    },
    {
        "begin_line": 2183,
        "end_line": 2189,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Result",
        "snippet": "  struct Result {\n    bool ret;\n    size_t len;\n    const char *error_pos;\n    const char *message_pos;\n    const std::string message;\n  };\n"
    },
    {
        "begin_line": 2184,
        "end_line": 2184,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ret",
        "snippet": "    bool ret;\n"
    },
    {
        "begin_line": 2185,
        "end_line": 2185,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "len",
        "snippet": "    size_t len;\n"
    },
    {
        "begin_line": 2186,
        "end_line": 2186,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_pos",
        "snippet": "    const char *error_pos;\n"
    },
    {
        "begin_line": 2187,
        "end_line": 2187,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "message_pos",
        "snippet": "    const char *message_pos;\n"
    },
    {
        "begin_line": 2188,
        "end_line": 2188,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "message",
        "snippet": "    const std::string message;\n"
    },
    {
        "begin_line": 2191,
        "end_line": 2191,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Definition",
        "snippet": "  Definition() : holder_(std::make_shared<Holder>(this)) {}\n"
    },
    {
        "begin_line": 2193,
        "end_line": 2195,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Definition",
        "snippet": "  Definition(const Definition &rhs) : name(rhs.name), holder_(rhs.holder_) {\n    holder_->outer_ = this;\n  }\n"
    },
    {
        "begin_line": 2197,
        "end_line": 2200,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Definition",
        "snippet": "  Definition(const std::shared_ptr<Ope> &ope)\n      : holder_(std::make_shared<Holder>(this)) {\n    *this <= ope;\n  }\n"
    },
    {
        "begin_line": 2202,
        "end_line": 2204,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator std::shared_ptr<Ope>",
        "snippet": "  operator std::shared_ptr<Ope>() {\n    return std::make_shared<WeakHolder>(holder_);\n  }\n"
    },
    {
        "begin_line": 2206,
        "end_line": 2209,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator <=",
        "snippet": "  Definition &operator<=(const std::shared_ptr<Ope> &ope) {\n    holder_->ope_ = ope;\n    return *this;\n  }\n"
    },
    {
        "begin_line": 2211,
        "end_line": 2215,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  Result parse(const char *s, size_t n, const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    return parse_core(s, n, sv, dt, path);\n  }\n"
    },
    {
        "begin_line": 2217,
        "end_line": 2220,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  Result parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, path);\n  }\n"
    },
    {
        "begin_line": 2222,
        "end_line": 2226,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  Result parse(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    SemanticValues sv;\n    return parse_core(s, n, sv, dt, path);\n  }\n"
    },
    {
        "begin_line": 2228,
        "end_line": 2231,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  Result parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse(s, n, dt, path);\n  }\n"
    },
    {
        "begin_line": 2234,
        "end_line": 2243,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_and_get_value",
        "snippet": "  Result parse_and_get_value(const char *s, size_t n, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    any dt;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n"
    },
    {
        "begin_line": 2246,
        "end_line": 2250,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_and_get_value",
        "snippet": "  Result parse_and_get_value(const char *s, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, val, path);\n  }\n"
    },
    {
        "begin_line": 2253,
        "end_line": 2261,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_and_get_value",
        "snippet": "  Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,\n                             const char *path = nullptr) const {\n    SemanticValues sv;\n    auto r = parse_core(s, n, sv, dt, path);\n    if (r.ret && !sv.empty() && sv.front().has_value()) {\n      val = any_cast<T>(sv[0]);\n    }\n    return r;\n  }\n"
    },
    {
        "begin_line": 2264,
        "end_line": 2268,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_and_get_value",
        "snippet": "  Result parse_and_get_value(const char *s, any &dt, T &val,\n                             const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_and_get_value(s, n, dt, val, path);\n  }\n"
    },
    {
        "begin_line": 2270,
        "end_line": 2273,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator =",
        "snippet": "  Action operator=(Action a) {\n    action = a;\n    return a;\n  }\n"
    },
    {
        "begin_line": 2275,
        "end_line": 2278,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator ,",
        "snippet": "  template <typename T> Definition &operator,(T fn) {\n    operator=(fn);\n    return *this;\n  }\n"
    },
    {
        "begin_line": 2280,
        "end_line": 2283,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator ~",
        "snippet": "  Definition &operator~() {\n    ignoreSemanticValue = true;\n    return *this;\n  }\n"
    },
    {
        "begin_line": 2285,
        "end_line": 2285,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "  void accept(Ope::Visitor &v) { holder_->accept(v); }\n"
    },
    {
        "begin_line": 2287,
        "end_line": 2287,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "get_core_operator",
        "snippet": "  std::shared_ptr<Ope> get_core_operator() const { return holder_->ope_; }\n"
    },
    {
        "begin_line": 2289,
        "end_line": 2294,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_token",
        "snippet": "  bool is_token() const {\n    std::call_once(is_token_init_, [this]() {\n      is_token_ = TokenChecker::is_token(*get_core_operator());\n    });\n    return is_token_;\n  }\n"
    },
    {
        "begin_line": 2290,
        "end_line": 2292,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240b02",
        "snippet": "    std::call_once(is_token_init_, [this]() {\n      is_token_ = TokenChecker::is_token(*get_core_operator());\n    });\n"
    },
    {
        "begin_line": 2296,
        "end_line": 2296,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name",
        "snippet": "  std::string name;\n"
    },
    {
        "begin_line": 2297,
        "end_line": 2297,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "s_",
        "snippet": "  const char *s_ = nullptr;\n"
    },
    {
        "begin_line": 2299,
        "end_line": 2299,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "id",
        "snippet": "  size_t id = 0;\n"
    },
    {
        "begin_line": 2300,
        "end_line": 2300,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "action",
        "snippet": "  Action action;\n"
    },
    {
        "begin_line": 2301,
        "end_line": 2301,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "enter",
        "snippet": "  std::function<void(const char *s, size_t n, any &dt)> enter;\n"
    },
    {
        "begin_line": 2304,
        "end_line": 2304,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "leave",
        "snippet": "      leave;\n"
    },
    {
        "begin_line": 2305,
        "end_line": 2305,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "error_message",
        "snippet": "  std::function<std::string()> error_message;\n"
    },
    {
        "begin_line": 2306,
        "end_line": 2306,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ignoreSemanticValue",
        "snippet": "  bool ignoreSemanticValue = false;\n"
    },
    {
        "begin_line": 2307,
        "end_line": 2307,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "whitespaceOpe",
        "snippet": "  std::shared_ptr<Ope> whitespaceOpe;\n"
    },
    {
        "begin_line": 2308,
        "end_line": 2308,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "wordOpe",
        "snippet": "  std::shared_ptr<Ope> wordOpe;\n"
    },
    {
        "begin_line": 2309,
        "end_line": 2309,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "enablePackratParsing",
        "snippet": "  bool enablePackratParsing = false;\n"
    },
    {
        "begin_line": 2310,
        "end_line": 2310,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_macro",
        "snippet": "  bool is_macro = false;\n"
    },
    {
        "begin_line": 2311,
        "end_line": 2311,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "params",
        "snippet": "  std::vector<std::string> params;\n"
    },
    {
        "begin_line": 2312,
        "end_line": 2312,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tracer_enter",
        "snippet": "  TracerEnter tracer_enter;\n"
    },
    {
        "begin_line": 2313,
        "end_line": 2313,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tracer_leave",
        "snippet": "  TracerLeave tracer_leave;\n"
    },
    {
        "begin_line": 2314,
        "end_line": 2314,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "disable_action",
        "snippet": "  bool disable_action = false;\n"
    },
    {
        "begin_line": 2323,
        "end_line": 2331,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "initialize_definition_ids",
        "snippet": "  void initialize_definition_ids() const {\n    std::call_once(definition_ids_init_, [&]() {\n      AssignIDToDefinition vis;\n      holder_->accept(vis);\n      if (whitespaceOpe) { whitespaceOpe->accept(vis); }\n      if (wordOpe) { wordOpe->accept(vis); }\n      definition_ids_.swap(vis.ids);\n    });\n  }\n"
    },
    {
        "begin_line": 2324,
        "end_line": 2330,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240c02",
        "snippet": "    std::call_once(definition_ids_init_, [&]() {\n      AssignIDToDefinition vis;\n      holder_->accept(vis);\n      if (whitespaceOpe) { whitespaceOpe->accept(vis); }\n      if (wordOpe) { wordOpe->accept(vis); }\n      definition_ids_.swap(vis.ids);\n    });\n"
    },
    {
        "begin_line": 2333,
        "end_line": 2346,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "  Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,\n                    const char *path) const {\n    initialize_definition_ids();\n\n    std::shared_ptr<Ope> ope = holder_;\n    if (whitespaceOpe) { ope = std::make_shared<Sequence>(whitespaceOpe, ope); }\n\n    Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,\n                enablePackratParsing, tracer_enter, tracer_leave);\n\n    auto len = ope->parse(s, n, sv, cxt, dt);\n    return Result{success(len), len, cxt.error_pos, cxt.message_pos,\n                  cxt.message};\n  }\n"
    },
    {
        "begin_line": 2348,
        "end_line": 2348,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "holder_",
        "snippet": "  std::shared_ptr<Holder> holder_;\n"
    },
    {
        "begin_line": 2349,
        "end_line": 2349,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_token_init_",
        "snippet": "  mutable std::once_flag is_token_init_;\n"
    },
    {
        "begin_line": 2350,
        "end_line": 2350,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_token_",
        "snippet": "  mutable bool is_token_ = false;\n"
    },
    {
        "begin_line": 2351,
        "end_line": 2351,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "assign_id_to_definition_init_",
        "snippet": "  mutable std::once_flag assign_id_to_definition_init_;\n"
    },
    {
        "begin_line": 2352,
        "end_line": 2352,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "definition_ids_init_",
        "snippet": "  mutable std::once_flag definition_ids_init_;\n"
    },
    {
        "begin_line": 2353,
        "end_line": 2353,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "definition_ids_",
        "snippet": "  mutable std::unordered_map<void *, size_t> definition_ids_;\n"
    },
    {
        "begin_line": 2360,
        "end_line": 2404,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_literal",
        "snippet": "inline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,\n                            Context &c, any &dt, const std::string &lit,\n                            std::once_flag &init_is_word, bool &is_word,\n                            bool ignore_case) {\n  size_t i = 0;\n  for (; i < lit.size(); i++) {\n    if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i]))\n                               : (s[i] != lit[i]))) {\n      c.set_error_pos(s);\n      return static_cast<size_t>(-1);\n    }\n  }\n\n  // Word check\n  static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr,\n                         nullptr);\n  static SemanticValues dummy_sv;\n  static any dummy_dt;\n\n  std::call_once(init_is_word, [&]() {\n    if (c.wordOpe) {\n      auto len =\n          c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);\n      is_word = success(len);\n    }\n  });\n\n  if (is_word) {\n    NotPredicate ope(c.wordOpe);\n    auto len = ope.parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);\n    if (fail(len)) { return static_cast<size_t>(-1); }\n    i += len;\n  }\n\n  // Skip whiltespace\n  if (!c.in_token) {\n    if (c.whitespaceOpe) {\n      auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);\n      if (fail(len)) { return static_cast<size_t>(-1); }\n      i += len;\n    }\n  }\n\n  return i;\n}\n"
    },
    {
        "begin_line": 2379,
        "end_line": 2385,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240d02",
        "snippet": "  std::call_once(init_is_word, [&]() {\n    if (c.wordOpe) {\n      auto len =\n          c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);\n      is_word = success(len);\n    }\n  });\n"
    },
    {
        "begin_line": 2406,
        "end_line": 2410,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "trace_enter",
        "snippet": "inline void Context::trace_enter(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt) const {\n  trace_ids.push_back(next_trace_id++);\n  tracer_enter(name, a_s, n, sv, *this, dt);\n}\n"
    },
    {
        "begin_line": 2412,
        "end_line": 2417,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "trace_leave",
        "snippet": "inline void Context::trace_leave(const char *name, const char *a_s, size_t n,\n                                 SemanticValues &sv, any &dt,\n                                 size_t len) const {\n  tracer_leave(name, a_s, n, sv, *this, dt, len);\n  trace_ids.pop_back();\n}\n"
    },
    {
        "begin_line": 2419,
        "end_line": 2426,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_traceable",
        "snippet": "inline bool Context::is_traceable(const Ope &ope) const {\n  if (tracer_enter && tracer_leave) {\n    IsReference vis;\n    const_cast<Ope &>(ope).accept(vis);\n    return !vis.is_reference;\n  }\n  return false;\n}\n"
    },
    {
        "begin_line": 2428,
        "end_line": 2439,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "inline size_t Ope::parse(const char *s, size_t n, SemanticValues &sv,\n                         Context &c, any &dt) const {\n  if (c.is_traceable(*this)) {\n    TraceOpeName vis;\n    const_cast<Ope &>(*this).accept(vis);\n    c.trace_enter(vis.name, s, n, sv, dt);\n    auto len = parse_core(s, n, sv, c, dt);\n    c.trace_leave(vis.name, s, n, sv, dt, len);\n    return len;\n  }\n  return parse_core(s, n, sv, c, dt);\n}\n"
    },
    {
        "begin_line": 2441,
        "end_line": 2448,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "inline size_t Dictionary::parse_core(const char *s, size_t n,\n                                     SemanticValues & /*sv*/, Context &c,\n                                     any & /*dt*/) const {\n  auto len = trie_.match(s, n);\n  if (len > 0) { return len; }\n  c.set_error_pos(s);\n  return static_cast<size_t>(-1);\n}\n"
    },
    {
        "begin_line": 2450,
        "end_line": 2455,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "inline size_t LiteralString::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_,\n                       ignore_case_);\n}\n"
    },
    {
        "begin_line": 2457,
        "end_line": 2473,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "inline size_t TokenBoundary::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  c.in_token = true;\n  auto se = make_scope_exit([&]() { c.in_token = false; });\n  auto len = ope_->parse(s, n, sv, c, dt);\n  if (success(len)) {\n    sv.tokens.emplace_back(std::make_pair(s, len));\n\n    if (c.whitespaceOpe) {\n      auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);\n      if (fail(l)) { return static_cast<size_t>(-1); }\n      len += l;\n    }\n  }\n  return len;\n}\n"
    },
    {
        "begin_line": 2461,
        "end_line": 2461,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240e02",
        "snippet": "  auto se = make_scope_exit([&]() { c.in_token = false; });\n"
    },
    {
        "begin_line": 2475,
        "end_line": 2547,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "inline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                 Context &c, any &dt) const {\n  if (!ope_) {\n    throw std::logic_error(\"Uninitialized definition ope was used...\");\n  }\n\n  // Macro reference\n  if (outer_->is_macro) {\n    c.rule_stack.push_back(outer_);\n    auto len = ope_->parse(s, n, sv, c, dt);\n    c.rule_stack.pop_back();\n    return len;\n  }\n\n  size_t len;\n  any val;\n\n  c.packrat(s, outer_->id, len, val, [&](any &a_val) {\n    if (outer_->enter) { outer_->enter(s, n, dt); }\n\n    auto se2 = make_scope_exit([&]() {\n      c.pop();\n\n      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }\n    });\n\n    auto &chldsv = c.push();\n\n    c.rule_stack.push_back(outer_);\n    len = ope_->parse(s, n, chldsv, c, dt);\n    c.rule_stack.pop_back();\n\n    // Invoke action\n    if (success(len)) {\n      chldsv.s_ = s;\n      chldsv.n_ = len;\n      chldsv.name_ = outer_->name;\n\n      if (!IsPrioritizedChoice::check(*ope_)) {\n        chldsv.choice_count_ = 0;\n        chldsv.choice_ = 0;\n      }\n\n      try {\n        a_val = reduce(chldsv, dt);\n      } catch (const parse_error &e) {\n        if (e.what()) {\n          if (c.message_pos < s) {\n            c.message_pos = s;\n            c.message = e.what();\n          }\n        }\n        len = static_cast<size_t>(-1);\n      }\n    }\n  });\n\n  if (success(len)) {\n    if (!outer_->ignoreSemanticValue) {\n      sv.emplace_back(std::move(val));\n      sv.tags.emplace_back(str2tag(outer_->name.c_str()));\n    }\n  } else {\n    if (outer_->error_message) {\n      if (c.message_pos < s) {\n        c.message_pos = s;\n        c.message = outer_->error_message();\n      }\n    }\n  }\n\n  return len;\n}\n"
    },
    {
        "begin_line": 2492,
        "end_line": 2530,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251240f02",
        "snippet": "  c.packrat(s, outer_->id, len, val, [&](any &a_val) {\n    if (outer_->enter) { outer_->enter(s, n, dt); }\n\n    auto se2 = make_scope_exit([&]() {\n      c.pop();\n\n      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }\n    });\n\n    auto &chldsv = c.push();\n\n    c.rule_stack.push_back(outer_);\n    len = ope_->parse(s, n, chldsv, c, dt);\n    c.rule_stack.pop_back();\n\n    // Invoke action\n    if (success(len)) {\n      chldsv.s_ = s;\n      chldsv.n_ = len;\n      chldsv.name_ = outer_->name;\n\n      if (!IsPrioritizedChoice::check(*ope_)) {\n        chldsv.choice_count_ = 0;\n        chldsv.choice_ = 0;\n      }\n\n      try {\n        a_val = reduce(chldsv, dt);\n      } catch (const parse_error &e) {\n        if (e.what()) {\n          if (c.message_pos < s) {\n            c.message_pos = s;\n            c.message = e.what();\n          }\n        }\n        len = static_cast<size_t>(-1);\n      }\n    }\n  });\n"
    },
    {
        "begin_line": 2495,
        "end_line": 2499,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241002",
        "snippet": "    auto se2 = make_scope_exit([&]() {\n      c.pop();\n\n      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }\n    });\n"
    },
    {
        "begin_line": 2549,
        "end_line": 2557,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "reduce",
        "snippet": "inline any Holder::reduce(SemanticValues &sv, any &dt) const {\n  if (outer_->action && !outer_->disable_action) {\n    return outer_->action(sv, dt);\n  } else if (sv.empty()) {\n    return any();\n  } else {\n    return std::move(sv.front());\n  }\n}\n"
    },
    {
        "begin_line": 2559,
        "end_line": 2562,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "trace_name",
        "snippet": "inline const char *Holder::trace_name() const {\n  if (trace_name_.empty()) { trace_name_ = \"[\" + outer_->name + \"]\"; }\n  return trace_name_.c_str();\n}\n"
    },
    {
        "begin_line": 2564,
        "end_line": 2595,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "inline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                    Context &c, any &dt) const {\n  if (rule_) {\n    // Reference rule\n    if (rule_->is_macro) {\n      // Macro\n      FindReference vis(c.top_args(), c.rule_stack.back()->params);\n\n      // Collect arguments\n      std::vector<std::shared_ptr<Ope>> args;\n      for (auto arg : args_) {\n        arg->accept(vis);\n        args.emplace_back(std::move(vis.found_ope));\n      }\n\n      c.push_args(std::move(args));\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    } else {\n      // Definition\n      c.push_args(std::vector<std::shared_ptr<Ope>>());\n      auto se = make_scope_exit([&]() { c.pop_args(); });\n      auto ope = get_core_operator();\n      return ope->parse(s, n, sv, c, dt);\n    }\n  } else {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    return args[iarg_]->parse(s, n, sv, c, dt);\n  }\n}\n"
    },
    {
        "begin_line": 2580,
        "end_line": 2580,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241102",
        "snippet": "      auto se = make_scope_exit([&]() { c.pop_args(); });\n"
    },
    {
        "begin_line": 2586,
        "end_line": 2586,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241202",
        "snippet": "      auto se = make_scope_exit([&]() { c.pop_args(); });\n"
    },
    {
        "begin_line": 2597,
        "end_line": 2599,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "get_core_operator",
        "snippet": "inline std::shared_ptr<Ope> Reference::get_core_operator() const {\n  return rule_->holder_;\n}\n"
    },
    {
        "begin_line": 2601,
        "end_line": 2616,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_core",
        "snippet": "inline size_t BackReference::parse_core(const char *s, size_t n,\n                                        SemanticValues &sv, Context &c,\n                                        any &dt) const {\n  auto size = static_cast<int>(c.capture_scope_stack_size);\n  for (auto i = size - 1; i >= 0; i--) {\n    auto index = static_cast<size_t>(i);\n    const auto &cs = c.capture_scope_stack[index];\n    if (cs.find(name_) != cs.end()) {\n      const auto &lit = cs.at(name_);\n      std::once_flag init_is_word;\n      auto is_word = false;\n      return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);\n    }\n  }\n  throw std::runtime_error(\"Invalid back reference...\");\n}\n"
    },
    {
        "begin_line": 2619,
        "end_line": 2629,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "get_reference_for_binop",
        "snippet": "PrecedenceClimbing::get_reference_for_binop(Context &c) const {\n  if (rule_.is_macro) {\n    // Reference parameter in macro\n    const auto &args = c.top_args();\n    auto iarg = dynamic_cast<Reference &>(*binop_).iarg_;\n    auto arg = args[iarg];\n    return *dynamic_cast<Reference &>(*arg).rule_;\n  }\n\n  return *dynamic_cast<Reference &>(*binop_).rule_;\n}\n"
    },
    {
        "begin_line": 2631,
        "end_line": 2710,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_expression",
        "snippet": "inline size_t PrecedenceClimbing::parse_expression(const char *s, size_t n,\n                                                   SemanticValues &sv,\n                                                   Context &c, any &dt,\n                                                   size_t min_prec) const {\n  auto len = atom_->parse(s, n, sv, c, dt);\n  if (fail(len)) { return len; }\n\n  std::string tok;\n  auto &rule = get_reference_for_binop(c);\n  auto action = rule.action;\n\n  rule.action = [&](SemanticValues &sv2, any &dt2) -> any {\n    tok = sv2.token();\n    if (action) {\n      return action(sv2, dt2);\n    } else if (!sv2.empty()) {\n      return sv2[0];\n    }\n    return any();\n  };\n  auto action_se = make_scope_exit([&]() { rule.action = action; });\n\n  auto save_error_pos = c.error_pos;\n\n  auto i = len;\n  while (i < n) {\n    std::vector<any> save_values(sv.begin(), sv.end());\n    auto save_tokens = sv.tokens;\n\n    auto chv = c.push();\n    auto chl = binop_->parse(s + i, n - i, chv, c, dt);\n    c.pop();\n\n    if (fail(chl)) {\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    auto it = info_.find(tok);\n    if (it == info_.end()) { break; }\n\n    auto level = std::get<0>(it->second);\n    auto assoc = std::get<1>(it->second);\n\n    if (level < min_prec) { break; }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    auto next_min_prec = level;\n    if (assoc == 'L') { next_min_prec = level + 1; }\n\n    chv = c.push();\n    chl = parse_expression(s + i, n - i, chv, c, dt, next_min_prec);\n    c.pop();\n\n    if (fail(chl)) {\n      sv.assign(save_values.begin(), save_values.end());\n      sv.tokens = save_tokens;\n      c.error_pos = save_error_pos;\n      break;\n    }\n\n    sv.emplace_back(std::move(chv[0]));\n    i += chl;\n\n    any val;\n    if (rule_.action) {\n      sv.s_ = s;\n      sv.n_ = i;\n      val = rule_.action(sv, dt);\n    } else if (!sv.empty()) {\n      val = sv[0];\n    }\n    sv.clear();\n    sv.emplace_back(std::move(val));\n  }\n\n  return i;\n}\n"
    },
    {
        "begin_line": 2642,
        "end_line": 2650,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241302",
        "snippet": "  rule.action = [&](SemanticValues &sv2, any &dt2) -> any {\n    tok = sv2.token();\n    if (action) {\n      return action(sv2, dt2);\n    } else if (!sv2.empty()) {\n      return sv2[0];\n    }\n    return any();\n  };\n"
    },
    {
        "begin_line": 2651,
        "end_line": 2651,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241402",
        "snippet": "  auto action_se = make_scope_exit([&]() { rule.action = action; });\n"
    },
    {
        "begin_line": 2712,
        "end_line": 2712,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Sequence::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2713,
        "end_line": 2713,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void PrioritizedChoice::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2714,
        "end_line": 2714,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Repetition::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2715,
        "end_line": 2715,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void AndPredicate::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2716,
        "end_line": 2716,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void NotPredicate::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2717,
        "end_line": 2717,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Dictionary::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2718,
        "end_line": 2718,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void LiteralString::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2719,
        "end_line": 2719,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void CharacterClass::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2720,
        "end_line": 2720,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Character::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2721,
        "end_line": 2721,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void AnyCharacter::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2722,
        "end_line": 2722,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void CaptureScope::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2723,
        "end_line": 2723,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Capture::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2724,
        "end_line": 2724,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void TokenBoundary::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2725,
        "end_line": 2725,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Ignore::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2726,
        "end_line": 2726,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void User::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2727,
        "end_line": 2727,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void WeakHolder::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2728,
        "end_line": 2728,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Holder::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2729,
        "end_line": 2729,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Reference::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2730,
        "end_line": 2730,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void Whitespace::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2731,
        "end_line": 2731,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void BackReference::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2732,
        "end_line": 2732,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "accept",
        "snippet": "inline void PrecedenceClimbing::accept(Visitor &v) { v.visit(*this); }\n"
    },
    {
        "begin_line": 2734,
        "end_line": 2741,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void AssignIDToDefinition::visit(Holder &ope) {\n  auto p = static_cast<void *>(ope.outer_);\n  if (ids.count(p)) { return; }\n  auto id = ids.size();\n  ids[p] = id;\n  ope.outer_->id = id;\n  ope.ope_->accept(*this);\n}\n"
    },
    {
        "begin_line": 2743,
        "end_line": 2750,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void AssignIDToDefinition::visit(Reference &ope) {\n  if (ope.rule_) {\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n    ope.rule_->accept(*this);\n  }\n}\n"
    },
    {
        "begin_line": 2752,
        "end_line": 2755,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void AssignIDToDefinition::visit(PrecedenceClimbing &ope) {\n  ope.atom_->accept(*this);\n  ope.binop_->accept(*this);\n}\n"
    },
    {
        "begin_line": 2757,
        "end_line": 2757,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void TokenChecker::visit(WeakHolder & /*ope*/) { has_rule_ = true; }\n"
    },
    {
        "begin_line": 2759,
        "end_line": 2768,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void TokenChecker::visit(Reference &ope) {\n  if (ope.is_macro_) {\n    ope.rule_->accept(*this);\n    for (auto arg : ope.args_) {\n      arg->accept(*this);\n    }\n  } else {\n    has_rule_ = true;\n  }\n}\n"
    },
    {
        "begin_line": 2770,
        "end_line": 2781,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void DetectLeftRecursion::visit(Reference &ope) {\n  if (ope.name_ == name_) {\n    error_s = ope.s_;\n  } else if (!refs_.count(ope.name_)) {\n    refs_.insert(ope.name_);\n    if (ope.rule_) {\n      ope.rule_->accept(*this);\n      if (done_ == false) { return; }\n    }\n  }\n  done_ = true;\n}\n"
    },
    {
        "begin_line": 2783,
        "end_line": 2795,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void HasEmptyElement::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n"
    },
    {
        "begin_line": 2785,
        "end_line": 2787,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241502",
        "snippet": "                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n"
    },
    {
        "begin_line": 2797,
        "end_line": 2809,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void DetectInfiniteLoop::visit(Reference &ope) {\n  auto it = std::find_if(refs_.begin(), refs_.end(),\n                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n  if (it != refs_.end()) { return; }\n\n  if (ope.rule_) {\n    refs_.emplace_back(ope.s_, ope.name_);\n    ope.rule_->accept(*this);\n    refs_.pop_back();\n  }\n}\n"
    },
    {
        "begin_line": 2799,
        "end_line": 2801,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241602",
        "snippet": "                         [&](const std::pair<const char *, std::string> &ref) {\n                           return ope.name_ == ref.second;\n                         });\n"
    },
    {
        "begin_line": 2811,
        "end_line": 2830,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void ReferenceChecker::visit(Reference &ope) {\n  auto it = std::find(params_.begin(), params_.end(), ope.name_);\n  if (it != params_.end()) { return; }\n\n  if (!grammar_.count(ope.name_)) {\n    error_s[ope.name_] = ope.s_;\n    error_message[ope.name_] = \"'\" + ope.name_ + \"' is not defined.\";\n  } else {\n    const auto &rule = grammar_.at(ope.name_);\n    if (rule.is_macro) {\n      if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {\n        error_s[ope.name_] = ope.s_;\n        error_message[ope.name_] = \"incorrect number of arguments.\";\n      }\n    } else if (ope.is_macro_) {\n      error_s[ope.name_] = ope.s_;\n      error_message[ope.name_] = \"'\" + ope.name_ + \"' is not macro.\";\n    }\n  }\n}\n"
    },
    {
        "begin_line": 2832,
        "end_line": 2853,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void LinkReferences::visit(Reference &ope) {\n  // Check if the reference is a macro parameter\n  auto found_param = false;\n  for (size_t i = 0; i < params_.size(); i++) {\n    const auto &param = params_[i];\n    if (param == ope.name_) {\n      ope.iarg_ = i;\n      found_param = true;\n      break;\n    }\n  }\n\n  // Check if the reference is a definition rule\n  if (!found_param && grammar_.count(ope.name_)) {\n    auto &rule = grammar_.at(ope.name_);\n    ope.rule_ = &rule;\n  }\n\n  for (auto arg : ope.args_) {\n    arg->accept(*this);\n  }\n}\n"
    },
    {
        "begin_line": 2855,
        "end_line": 2864,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "visit",
        "snippet": "inline void FindReference::visit(Reference &ope) {\n  for (size_t i = 0; i < args_.size(); i++) {\n    const auto &name = params_[i];\n    if (name == ope.name_) {\n      found_ope = args_[i];\n      return;\n    }\n  }\n  found_ope = ope.shared_from_this();\n}\n"
    },
    {
        "begin_line": 2873,
        "end_line": 3557,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ParserGenerator",
        "snippet": "class ParserGenerator {\npublic:\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    return get_instance().perform_core(s, n, rules, start, log);\n  }\n\n  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        std::string &start, Log log) {\n    Rules dummy;\n    return parse(s, n, dummy, start, log);\n  }\n\n  // For debuging purpose\n  static Grammar &grammar() { return get_instance().g; }\n\nprivate:\n  static ParserGenerator &get_instance() {\n    static ParserGenerator instance;\n    return instance;\n  }\n\n  ParserGenerator() {\n    make_grammar();\n    setup_actions();\n  }\n\n  struct Instruction {\n    std::string type;\n    any data;\n  };\n\n  struct Data {\n    std::shared_ptr<Grammar> grammar;\n    std::string start;\n    const char *start_pos = nullptr;\n    std::vector<std::pair<std::string, const char *>> duplicates;\n    std::map<std::string, Instruction> instructions;\n\n    Data() : grammar(std::make_shared<Grammar>()) {}\n  };\n\n  void make_grammar() {\n    // Setup PEG syntax parser\n    g[\"Grammar\"] <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);\n    g[\"Definition\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Parameters\"], g[\"LEFTARROW\"],\n                g[\"Expression\"], opt(g[\"Instruction\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"],\n                opt(g[\"Instruction\"])));\n    g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));\n    g[\"Sequence\"] <= zom(g[\"Prefix\"]);\n    g[\"Prefix\"] <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);\n    g[\"Suffix\"] <= seq(g[\"Primary\"], opt(g[\"Loop\"]));\n    g[\"Loop\"] <= cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"], g[\"Repetition\"]);\n    g[\"Primary\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Arguments\"],\n                npd(g[\"LEFTARROW\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"],\n                npd(seq(opt(g[\"Parameters\"]), g[\"LEFTARROW\"]))),\n            seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),\n            seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),\n            seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),\n            seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]), g[\"BackRef\"],\n            g[\"LiteralI\"], g[\"Dictionary\"], g[\"Literal\"], g[\"NegatedClass\"],\n            g[\"Class\"], g[\"DOT\"]);\n\n    g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);\n    g[\"IdentCont\"] <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));\n\n    const static std::vector<std::pair<char32_t, char32_t>> range = {\n        {0x0080, 0xFFFF}};\n    g[\"IdentStart\"] <= cho(cls(\"a-zA-Z_%\"), cls(range));\n\n    g[\"IdentRest\"] <= cho(g[\"IdentStart\"], cls(\"0-9\"));\n\n    g[\"Dictionary\"] <= seq(g[\"LiteralD\"], oom(seq(g[\"PIPE\"], g[\"LiteralD\"])));\n\n    auto lit_ope = cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))),\n                           cls(\"'\"), g[\"Spacing\"]),\n                       seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))),\n                           cls(\"\\\"\"), g[\"Spacing\"]));\n    g[\"Literal\"] <= lit_ope;\n    g[\"LiteralD\"] <= lit_ope;\n\n    g[\"LiteralI\"] <=\n        cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"),\n                g[\"Spacing\"]),\n            seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"),\n                g[\"Spacing\"]));\n\n    // NOTE: The original Brian Ford's paper uses 'zom' instead of 'oom'.\n    g[\"Class\"] <= seq(chr('['), npd(chr('^')),\n                      tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                      g[\"Spacing\"]);\n    g[\"NegatedClass\"] <= seq(lit(\"[^\"),\n                             tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                             g[\"Spacing\"]);\n\n    g[\"Range\"] <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);\n    g[\"Char\"] <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\^\")),\n                     seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),\n                     seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),\n                     seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),\n                     seq(lit(\"\\\\u\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"),\n                         cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\")),\n                     seq(npd(chr('\\\\')), dot()));\n\n    g[\"Repetition\"] <=\n        seq(g[\"BeginBlacket\"], g[\"RepetitionRange\"], g[\"EndBlacket\"]);\n    g[\"RepetitionRange\"] <= cho(seq(g[\"Number\"], g[\"COMMA\"], g[\"Number\"]),\n                                seq(g[\"Number\"], g[\"COMMA\"]), g[\"Number\"],\n                                seq(g[\"COMMA\"], g[\"Number\"]));\n    g[\"Number\"] <= seq(oom(cls(\"0-9\")), g[\"Spacing\"]);\n\n    g[\"LEFTARROW\"] <=\n        seq(cho(lit(\"<-\"), lit(reinterpret_cast<const char *>(u8\"\u2190\"))),\n            g[\"Spacing\"]);\n    ~g[\"SLASH\"] <= seq(chr('/'), g[\"Spacing\"]);\n    ~g[\"PIPE\"] <= seq(chr('|'), g[\"Spacing\"]);\n    g[\"AND\"] <= seq(chr('&'), g[\"Spacing\"]);\n    g[\"NOT\"] <= seq(chr('!'), g[\"Spacing\"]);\n    g[\"QUESTION\"] <= seq(chr('?'), g[\"Spacing\"]);\n    g[\"STAR\"] <= seq(chr('*'), g[\"Spacing\"]);\n    g[\"PLUS\"] <= seq(chr('+'), g[\"Spacing\"]);\n    ~g[\"OPEN\"] <= seq(chr('('), g[\"Spacing\"]);\n    ~g[\"CLOSE\"] <= seq(chr(')'), g[\"Spacing\"]);\n    g[\"DOT\"] <= seq(chr('.'), g[\"Spacing\"]);\n\n    ~g[\"Spacing\"] <= zom(cho(g[\"Space\"], g[\"Comment\"]));\n    g[\"Comment\"] <=\n        seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);\n    g[\"Space\"] <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);\n    g[\"EndOfLine\"] <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));\n    g[\"EndOfFile\"] <= npd(dot());\n\n    ~g[\"BeginTok\"] <= seq(chr('<'), g[\"Spacing\"]);\n    ~g[\"EndTok\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    ~g[\"BeginCapScope\"] <= seq(chr('$'), chr('('), g[\"Spacing\"]);\n    ~g[\"EndCapScope\"] <= seq(chr(')'), g[\"Spacing\"]);\n\n    g[\"BeginCap\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), chr('<'), g[\"Spacing\"]);\n    ~g[\"EndCap\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    g[\"BackRef\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), g[\"Spacing\"]);\n\n    g[\"IGNORE\"] <= chr('~');\n\n    g[\"Ignore\"] <= opt(g[\"IGNORE\"]);\n    g[\"Parameters\"] <= seq(g[\"OPEN\"], g[\"Identifier\"],\n                           zom(seq(g[\"COMMA\"], g[\"Identifier\"])), g[\"CLOSE\"]);\n    g[\"Arguments\"] <= seq(g[\"OPEN\"], g[\"Expression\"],\n                          zom(seq(g[\"COMMA\"], g[\"Expression\"])), g[\"CLOSE\"]);\n    ~g[\"COMMA\"] <= seq(chr(','), g[\"Spacing\"]);\n\n    // Instruction grammars\n    g[\"Instruction\"] <=\n        seq(g[\"BeginBlacket\"], cho(g[\"PrecedenceClimbing\"]), g[\"EndBlacket\"]);\n\n    ~g[\"SpacesZom\"] <= zom(g[\"Space\"]);\n    ~g[\"SpacesOom\"] <= oom(g[\"Space\"]);\n    ~g[\"BeginBlacket\"] <= seq(chr('{'), g[\"Spacing\"]);\n    ~g[\"EndBlacket\"] <= seq(chr('}'), g[\"Spacing\"]);\n\n    // PrecedenceClimbing instruction\n    g[\"PrecedenceClimbing\"] <=\n        seq(lit(\"precedence\"), g[\"SpacesZom\"], g[\"PrecedenceInfo\"],\n            zom(seq(g[\"SpacesOom\"], g[\"PrecedenceInfo\"])), g[\"SpacesZom\"]);\n    g[\"PrecedenceInfo\"] <=\n        seq(g[\"PrecedenceAssoc\"],\n            oom(seq(ign(g[\"SpacesOom\"]), g[\"PrecedenceOpe\"])));\n    g[\"PrecedenceOpe\"] <=\n        tok(oom(\n            seq(npd(cho(g[\"PrecedenceAssoc\"], g[\"Space\"], chr('}'))), dot())));\n    g[\"PrecedenceAssoc\"] <= cls(\"LR\");\n\n    // Set definition names\n    for (auto &x : g) {\n      x.second.name = x.first;\n    }\n  }\n\n  void setup_actions() {\n    g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      auto is_macro = sv.choice() == 0;\n      auto ignore = any_cast<bool>(sv[0]);\n      auto name = any_cast<std::string>(sv[1]);\n\n      std::vector<std::string> params;\n      std::shared_ptr<Ope> ope;\n      if (is_macro) {\n        params = any_cast<std::vector<std::string>>(sv[2]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[4]);\n        if (sv.size() == 6) {\n          data.instructions[name] = any_cast<Instruction>(sv[5]);\n        }\n      } else {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[3]);\n        if (sv.size() == 5) {\n          data.instructions[name] = any_cast<Instruction>(sv[4]);\n        }\n      }\n\n      auto &grammar = *data.grammar;\n      if (!grammar.count(name)) {\n        auto &rule = grammar[name];\n        rule <= ope;\n        rule.name = name;\n        rule.s_ = sv.c_str();\n        rule.ignoreSemanticValue = ignore;\n        rule.is_macro = is_macro;\n        rule.params = params;\n\n        if (data.start.empty()) {\n          data.start = name;\n          data.start_pos = sv.c_str();\n        }\n      } else {\n        data.duplicates.emplace_back(name, sv.c_str());\n      }\n    };\n\n    g[\"Expression\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (auto i = 0u; i < sv.size(); i++) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));\n        }\n        const std::shared_ptr<Ope> ope =\n            std::make_shared<PrioritizedChoice>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Sequence\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (const auto &x : sv) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));\n        }\n        const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Prefix\"] = [&](const SemanticValues &sv) {\n      std::shared_ptr<Ope> ope;\n      if (sv.size() == 1) {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        assert(sv.size() == 2);\n        auto tok = any_cast<char>(sv[0]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        if (tok == '&') {\n          ope = apd(ope);\n        } else { // '!'\n          ope = npd(ope);\n        }\n      }\n      return ope;\n    };\n\n    struct Loop {\n      enum class Type { opt = 0, zom, oom, rep };\n      Type type;\n      std::pair<size_t, size_t> range;\n    };\n\n    g[\"Suffix\"] = [&](const SemanticValues &sv) {\n      auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      if (sv.size() == 1) {\n        return ope;\n      } else {\n        assert(sv.size() == 2);\n        auto loop = any_cast<Loop>(sv[1]);\n        switch (loop.type) {\n        case Loop::Type::opt: return opt(ope);\n        case Loop::Type::zom: return zom(ope);\n        case Loop::Type::oom: return oom(ope);\n        default: // Regex-like repetition\n          return rep(ope, loop.range.first, loop.range.second);\n        }\n      }\n    };\n\n    g[\"Loop\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: // Option\n        return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};\n      case 1: // Zero or More\n        return Loop{Loop::Type::zom, std::pair<size_t, size_t>()};\n      case 2: // One or More\n        return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};\n      default: // Regex-like repetition\n        return Loop{Loop::Type::rep,\n                    any_cast<std::pair<size_t, size_t>>(sv[0])};\n      }\n    };\n\n    g[\"RepetitionRange\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: { // Number COMMA Number\n        auto min = any_cast<size_t>(sv[0]);\n        auto max = any_cast<size_t>(sv[1]);\n        return std::make_pair(min, max);\n      }\n      case 1: // Number COMMA\n        return std::make_pair(any_cast<size_t>(sv[0]),\n                              std::numeric_limits<size_t>::max());\n      case 2: { // Number\n        auto n = any_cast<size_t>(sv[0]);\n        return std::make_pair(n, n);\n      }\n      default: // COMMA Number\n        return std::make_pair(std::numeric_limits<size_t>::min(),\n                              any_cast<size_t>(sv[0]));\n      }\n    };\n    g[\"Number\"] = [&](const SemanticValues &sv) {\n      std::stringstream ss(sv.str());\n      size_t n;\n      ss >> n;\n      return n;\n    };\n\n    g[\"Primary\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      switch (sv.choice()) {\n      case 0:   // Macro Reference\n      case 1: { // Reference\n        auto is_macro = sv.choice() == 0;\n        auto ignore = any_cast<bool>(sv[0]);\n        const auto &ident = any_cast<std::string>(sv[1]);\n\n        std::vector<std::shared_ptr<Ope>> args;\n        if (is_macro) {\n          args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);\n        }\n\n        std::shared_ptr<Ope> ope =\n            ref(*data.grammar, ident, sv.c_str(), is_macro, args);\n\n        if (ignore) {\n          return ign(ope);\n        } else {\n          return ope;\n        }\n      }\n      case 2: { // (Expression)\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      case 3: { // TokenBoundary\n        return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 4: { // CaptureScope\n        return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 5: { // Capture\n        const auto &name = any_cast<std::string>(sv[0]);\n        auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {\n          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];\n          cs[name] = std::string(a_s, a_n);\n        });\n      }\n      default: {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      }\n    };\n\n    g[\"IdentCont\"] = [](const SemanticValues &sv) {\n      return std::string(sv.c_str(), sv.length());\n    };\n\n    g[\"Dictionary\"] = [](const SemanticValues &sv) {\n      auto items = sv.transform<std::string>();\n      return dic(items);\n    };\n\n    g[\"Literal\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return lit(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralI\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return liti(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralD\"] = [](const SemanticValues &sv) {\n      auto &tok = sv.tokens.front();\n      return resolve_escape_sequence(tok.first, tok.second);\n    };\n\n    g[\"Class\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return cls(ranges);\n    };\n    g[\"NegatedClass\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return ncls(ranges);\n    };\n    g[\"Range\"] = [](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: {\n        auto s1 = any_cast<std::string>(sv[0]);\n        auto s2 = any_cast<std::string>(sv[1]);\n        auto cp1 = decode_codepoint(s1.c_str(), s1.length());\n        auto cp2 = decode_codepoint(s2.c_str(), s2.length());\n        return std::make_pair(cp1, cp2);\n      }\n      case 1: {\n        auto s = any_cast<std::string>(sv[0]);\n        auto cp = decode_codepoint(s.c_str(), s.length());\n        return std::make_pair(cp, cp);\n      }\n      }\n      return std::make_pair<char32_t, char32_t>(0, 0);\n    };\n    g[\"Char\"] = [](const SemanticValues &sv) {\n      return resolve_escape_sequence(sv.c_str(), sv.length());\n    };\n\n    g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n\n    g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };\n\n    g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };\n\n    g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };\n\n    g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };\n\n    g[\"Parameters\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n\n    g[\"Arguments\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::shared_ptr<Ope>>();\n    };\n\n    g[\"PrecedenceClimbing\"] = [](const SemanticValues &sv) {\n      PrecedenceClimbing::BinOpeInfo binOpeInfo;\n      size_t level = 1;\n      for (auto v : sv) {\n        auto tokens = any_cast<std::vector<std::string>>(v);\n        auto assoc = tokens[0][0];\n        for (size_t i = 1; i < tokens.size(); i++) {\n          const auto &tok = tokens[i];\n          binOpeInfo[tok] = std::make_pair(level, assoc);\n        }\n        level++;\n      }\n      Instruction instruction;\n      instruction.type = \"precedence\";\n      instruction.data = binOpeInfo;\n      return instruction;\n    };\n    g[\"PrecedenceInfo\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n    g[\"PrecedenceOpe\"] = [](const SemanticValues &sv) { return sv.token(); };\n    g[\"PrecedenceAssoc\"] = [](const SemanticValues &sv) { return sv.token(); };\n  }\n\n  bool apply_precedence_instruction(Definition &rule,\n                                    const PrecedenceClimbing::BinOpeInfo &info,\n                                    const char *s, Log log) {\n    try {\n      auto &seq = dynamic_cast<Sequence &>(*rule.get_core_operator());\n      auto atom = seq.opes_[0];\n      auto &rep = dynamic_cast<Repetition &>(*seq.opes_[1]);\n      auto &seq1 = dynamic_cast<Sequence &>(*rep.ope_);\n      auto binop = seq1.opes_[0];\n      auto atom1 = seq1.opes_[1];\n\n      auto atom_name = dynamic_cast<Reference &>(*atom).name_;\n      auto binop_name = dynamic_cast<Reference &>(*binop).name_;\n      auto atom1_name = dynamic_cast<Reference &>(*atom1).name_;\n\n      if (!rep.is_zom() || atom_name != atom1_name || atom_name == binop_name) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"'precedence' instruction cannt be applied to '\" + rule.name +\n                  \"'.\");\n        }\n        return false;\n      }\n\n      rule.holder_->ope_ = pre(atom, binop, info, rule);\n      rule.disable_action = true;\n    } catch (...) {\n      if (log) {\n        auto line = line_info(s, rule.s_);\n        log(line.first, line.second,\n            \"'precedence' instruction cannt be applied to '\" + rule.name +\n                \"'.\");\n      }\n      return false;\n    }\n    return true;\n  }\n\n  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check if the start rule has ignore operator\n    {\n      auto &rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");\n        }\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }\n\n  Grammar g;\n};\n"
    },
    {
        "begin_line": 2875,
        "end_line": 2879,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    return get_instance().perform_core(s, n, rules, start, log);\n  }\n"
    },
    {
        "begin_line": 2881,
        "end_line": 2885,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  static std::shared_ptr<Grammar> parse(const char *s, size_t n,\n                                        std::string &start, Log log) {\n    Rules dummy;\n    return parse(s, n, dummy, start, log);\n  }\n"
    },
    {
        "begin_line": 2888,
        "end_line": 2888,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "grammar",
        "snippet": "  static Grammar &grammar() { return get_instance().g; }\n"
    },
    {
        "begin_line": 2891,
        "end_line": 2894,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "get_instance",
        "snippet": "  static ParserGenerator &get_instance() {\n    static ParserGenerator instance;\n    return instance;\n  }\n"
    },
    {
        "begin_line": 2896,
        "end_line": 2899,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ParserGenerator",
        "snippet": "  ParserGenerator() {\n    make_grammar();\n    setup_actions();\n  }\n"
    },
    {
        "begin_line": 2901,
        "end_line": 2904,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Instruction",
        "snippet": "  struct Instruction {\n    std::string type;\n    any data;\n  };\n"
    },
    {
        "begin_line": 2902,
        "end_line": 2902,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "type",
        "snippet": "    std::string type;\n"
    },
    {
        "begin_line": 2903,
        "end_line": 2903,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "data",
        "snippet": "    any data;\n"
    },
    {
        "begin_line": 2906,
        "end_line": 2914,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Data",
        "snippet": "  struct Data {\n    std::shared_ptr<Grammar> grammar;\n    std::string start;\n    const char *start_pos = nullptr;\n    std::vector<std::pair<std::string, const char *>> duplicates;\n    std::map<std::string, Instruction> instructions;\n\n    Data() : grammar(std::make_shared<Grammar>()) {}\n  };\n"
    },
    {
        "begin_line": 2907,
        "end_line": 2907,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "grammar",
        "snippet": "    std::shared_ptr<Grammar> grammar;\n"
    },
    {
        "begin_line": 2908,
        "end_line": 2908,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "start",
        "snippet": "    std::string start;\n"
    },
    {
        "begin_line": 2909,
        "end_line": 2909,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "start_pos",
        "snippet": "    const char *start_pos = nullptr;\n"
    },
    {
        "begin_line": 2910,
        "end_line": 2910,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "duplicates",
        "snippet": "    std::vector<std::pair<std::string, const char *>> duplicates;\n"
    },
    {
        "begin_line": 2911,
        "end_line": 2911,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "instructions",
        "snippet": "    std::map<std::string, Instruction> instructions;\n"
    },
    {
        "begin_line": 2913,
        "end_line": 2913,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Data",
        "snippet": "    Data() : grammar(std::make_shared<Grammar>()) {}\n"
    },
    {
        "begin_line": 2916,
        "end_line": 3055,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "make_grammar",
        "snippet": "  void make_grammar() {\n    // Setup PEG syntax parser\n    g[\"Grammar\"] <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);\n    g[\"Definition\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Parameters\"], g[\"LEFTARROW\"],\n                g[\"Expression\"], opt(g[\"Instruction\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"],\n                opt(g[\"Instruction\"])));\n    g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));\n    g[\"Sequence\"] <= zom(g[\"Prefix\"]);\n    g[\"Prefix\"] <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);\n    g[\"Suffix\"] <= seq(g[\"Primary\"], opt(g[\"Loop\"]));\n    g[\"Loop\"] <= cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"], g[\"Repetition\"]);\n    g[\"Primary\"] <=\n        cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Arguments\"],\n                npd(g[\"LEFTARROW\"])),\n            seq(g[\"Ignore\"], g[\"Identifier\"],\n                npd(seq(opt(g[\"Parameters\"]), g[\"LEFTARROW\"]))),\n            seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),\n            seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),\n            seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),\n            seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]), g[\"BackRef\"],\n            g[\"LiteralI\"], g[\"Dictionary\"], g[\"Literal\"], g[\"NegatedClass\"],\n            g[\"Class\"], g[\"DOT\"]);\n\n    g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);\n    g[\"IdentCont\"] <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));\n\n    const static std::vector<std::pair<char32_t, char32_t>> range = {\n        {0x0080, 0xFFFF}};\n    g[\"IdentStart\"] <= cho(cls(\"a-zA-Z_%\"), cls(range));\n\n    g[\"IdentRest\"] <= cho(g[\"IdentStart\"], cls(\"0-9\"));\n\n    g[\"Dictionary\"] <= seq(g[\"LiteralD\"], oom(seq(g[\"PIPE\"], g[\"LiteralD\"])));\n\n    auto lit_ope = cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))),\n                           cls(\"'\"), g[\"Spacing\"]),\n                       seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))),\n                           cls(\"\\\"\"), g[\"Spacing\"]));\n    g[\"Literal\"] <= lit_ope;\n    g[\"LiteralD\"] <= lit_ope;\n\n    g[\"LiteralI\"] <=\n        cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"),\n                g[\"Spacing\"]),\n            seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"),\n                g[\"Spacing\"]));\n\n    // NOTE: The original Brian Ford's paper uses 'zom' instead of 'oom'.\n    g[\"Class\"] <= seq(chr('['), npd(chr('^')),\n                      tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                      g[\"Spacing\"]);\n    g[\"NegatedClass\"] <= seq(lit(\"[^\"),\n                             tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),\n                             g[\"Spacing\"]);\n\n    g[\"Range\"] <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);\n    g[\"Char\"] <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\^\")),\n                     seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),\n                     seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),\n                     seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),\n                     seq(lit(\"\\\\u\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"),\n                         cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\")),\n                     seq(npd(chr('\\\\')), dot()));\n\n    g[\"Repetition\"] <=\n        seq(g[\"BeginBlacket\"], g[\"RepetitionRange\"], g[\"EndBlacket\"]);\n    g[\"RepetitionRange\"] <= cho(seq(g[\"Number\"], g[\"COMMA\"], g[\"Number\"]),\n                                seq(g[\"Number\"], g[\"COMMA\"]), g[\"Number\"],\n                                seq(g[\"COMMA\"], g[\"Number\"]));\n    g[\"Number\"] <= seq(oom(cls(\"0-9\")), g[\"Spacing\"]);\n\n    g[\"LEFTARROW\"] <=\n        seq(cho(lit(\"<-\"), lit(reinterpret_cast<const char *>(u8\"\u2190\"))),\n            g[\"Spacing\"]);\n    ~g[\"SLASH\"] <= seq(chr('/'), g[\"Spacing\"]);\n    ~g[\"PIPE\"] <= seq(chr('|'), g[\"Spacing\"]);\n    g[\"AND\"] <= seq(chr('&'), g[\"Spacing\"]);\n    g[\"NOT\"] <= seq(chr('!'), g[\"Spacing\"]);\n    g[\"QUESTION\"] <= seq(chr('?'), g[\"Spacing\"]);\n    g[\"STAR\"] <= seq(chr('*'), g[\"Spacing\"]);\n    g[\"PLUS\"] <= seq(chr('+'), g[\"Spacing\"]);\n    ~g[\"OPEN\"] <= seq(chr('('), g[\"Spacing\"]);\n    ~g[\"CLOSE\"] <= seq(chr(')'), g[\"Spacing\"]);\n    g[\"DOT\"] <= seq(chr('.'), g[\"Spacing\"]);\n\n    ~g[\"Spacing\"] <= zom(cho(g[\"Space\"], g[\"Comment\"]));\n    g[\"Comment\"] <=\n        seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);\n    g[\"Space\"] <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);\n    g[\"EndOfLine\"] <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));\n    g[\"EndOfFile\"] <= npd(dot());\n\n    ~g[\"BeginTok\"] <= seq(chr('<'), g[\"Spacing\"]);\n    ~g[\"EndTok\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    ~g[\"BeginCapScope\"] <= seq(chr('$'), chr('('), g[\"Spacing\"]);\n    ~g[\"EndCapScope\"] <= seq(chr(')'), g[\"Spacing\"]);\n\n    g[\"BeginCap\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), chr('<'), g[\"Spacing\"]);\n    ~g[\"EndCap\"] <= seq(chr('>'), g[\"Spacing\"]);\n\n    g[\"BackRef\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), g[\"Spacing\"]);\n\n    g[\"IGNORE\"] <= chr('~');\n\n    g[\"Ignore\"] <= opt(g[\"IGNORE\"]);\n    g[\"Parameters\"] <= seq(g[\"OPEN\"], g[\"Identifier\"],\n                           zom(seq(g[\"COMMA\"], g[\"Identifier\"])), g[\"CLOSE\"]);\n    g[\"Arguments\"] <= seq(g[\"OPEN\"], g[\"Expression\"],\n                          zom(seq(g[\"COMMA\"], g[\"Expression\"])), g[\"CLOSE\"]);\n    ~g[\"COMMA\"] <= seq(chr(','), g[\"Spacing\"]);\n\n    // Instruction grammars\n    g[\"Instruction\"] <=\n        seq(g[\"BeginBlacket\"], cho(g[\"PrecedenceClimbing\"]), g[\"EndBlacket\"]);\n\n    ~g[\"SpacesZom\"] <= zom(g[\"Space\"]);\n    ~g[\"SpacesOom\"] <= oom(g[\"Space\"]);\n    ~g[\"BeginBlacket\"] <= seq(chr('{'), g[\"Spacing\"]);\n    ~g[\"EndBlacket\"] <= seq(chr('}'), g[\"Spacing\"]);\n\n    // PrecedenceClimbing instruction\n    g[\"PrecedenceClimbing\"] <=\n        seq(lit(\"precedence\"), g[\"SpacesZom\"], g[\"PrecedenceInfo\"],\n            zom(seq(g[\"SpacesOom\"], g[\"PrecedenceInfo\"])), g[\"SpacesZom\"]);\n    g[\"PrecedenceInfo\"] <=\n        seq(g[\"PrecedenceAssoc\"],\n            oom(seq(ign(g[\"SpacesOom\"]), g[\"PrecedenceOpe\"])));\n    g[\"PrecedenceOpe\"] <=\n        tok(oom(\n            seq(npd(cho(g[\"PrecedenceAssoc\"], g[\"Space\"], chr('}'))), dot())));\n    g[\"PrecedenceAssoc\"] <= cls(\"LR\");\n\n    // Set definition names\n    for (auto &x : g) {\n      x.second.name = x.first;\n    }\n  }\n"
    },
    {
        "begin_line": 3057,
        "end_line": 3348,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "setup_actions",
        "snippet": "  void setup_actions() {\n    g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      auto is_macro = sv.choice() == 0;\n      auto ignore = any_cast<bool>(sv[0]);\n      auto name = any_cast<std::string>(sv[1]);\n\n      std::vector<std::string> params;\n      std::shared_ptr<Ope> ope;\n      if (is_macro) {\n        params = any_cast<std::vector<std::string>>(sv[2]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[4]);\n        if (sv.size() == 6) {\n          data.instructions[name] = any_cast<Instruction>(sv[5]);\n        }\n      } else {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[3]);\n        if (sv.size() == 5) {\n          data.instructions[name] = any_cast<Instruction>(sv[4]);\n        }\n      }\n\n      auto &grammar = *data.grammar;\n      if (!grammar.count(name)) {\n        auto &rule = grammar[name];\n        rule <= ope;\n        rule.name = name;\n        rule.s_ = sv.c_str();\n        rule.ignoreSemanticValue = ignore;\n        rule.is_macro = is_macro;\n        rule.params = params;\n\n        if (data.start.empty()) {\n          data.start = name;\n          data.start_pos = sv.c_str();\n        }\n      } else {\n        data.duplicates.emplace_back(name, sv.c_str());\n      }\n    };\n\n    g[\"Expression\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (auto i = 0u; i < sv.size(); i++) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));\n        }\n        const std::shared_ptr<Ope> ope =\n            std::make_shared<PrioritizedChoice>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Sequence\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (const auto &x : sv) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));\n        }\n        const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);\n        return ope;\n      }\n    };\n\n    g[\"Prefix\"] = [&](const SemanticValues &sv) {\n      std::shared_ptr<Ope> ope;\n      if (sv.size() == 1) {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        assert(sv.size() == 2);\n        auto tok = any_cast<char>(sv[0]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        if (tok == '&') {\n          ope = apd(ope);\n        } else { // '!'\n          ope = npd(ope);\n        }\n      }\n      return ope;\n    };\n\n    struct Loop {\n      enum class Type { opt = 0, zom, oom, rep };\n      Type type;\n      std::pair<size_t, size_t> range;\n    };\n\n    g[\"Suffix\"] = [&](const SemanticValues &sv) {\n      auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      if (sv.size() == 1) {\n        return ope;\n      } else {\n        assert(sv.size() == 2);\n        auto loop = any_cast<Loop>(sv[1]);\n        switch (loop.type) {\n        case Loop::Type::opt: return opt(ope);\n        case Loop::Type::zom: return zom(ope);\n        case Loop::Type::oom: return oom(ope);\n        default: // Regex-like repetition\n          return rep(ope, loop.range.first, loop.range.second);\n        }\n      }\n    };\n\n    g[\"Loop\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: // Option\n        return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};\n      case 1: // Zero or More\n        return Loop{Loop::Type::zom, std::pair<size_t, size_t>()};\n      case 2: // One or More\n        return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};\n      default: // Regex-like repetition\n        return Loop{Loop::Type::rep,\n                    any_cast<std::pair<size_t, size_t>>(sv[0])};\n      }\n    };\n\n    g[\"RepetitionRange\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: { // Number COMMA Number\n        auto min = any_cast<size_t>(sv[0]);\n        auto max = any_cast<size_t>(sv[1]);\n        return std::make_pair(min, max);\n      }\n      case 1: // Number COMMA\n        return std::make_pair(any_cast<size_t>(sv[0]),\n                              std::numeric_limits<size_t>::max());\n      case 2: { // Number\n        auto n = any_cast<size_t>(sv[0]);\n        return std::make_pair(n, n);\n      }\n      default: // COMMA Number\n        return std::make_pair(std::numeric_limits<size_t>::min(),\n                              any_cast<size_t>(sv[0]));\n      }\n    };\n    g[\"Number\"] = [&](const SemanticValues &sv) {\n      std::stringstream ss(sv.str());\n      size_t n;\n      ss >> n;\n      return n;\n    };\n\n    g[\"Primary\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      switch (sv.choice()) {\n      case 0:   // Macro Reference\n      case 1: { // Reference\n        auto is_macro = sv.choice() == 0;\n        auto ignore = any_cast<bool>(sv[0]);\n        const auto &ident = any_cast<std::string>(sv[1]);\n\n        std::vector<std::shared_ptr<Ope>> args;\n        if (is_macro) {\n          args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);\n        }\n\n        std::shared_ptr<Ope> ope =\n            ref(*data.grammar, ident, sv.c_str(), is_macro, args);\n\n        if (ignore) {\n          return ign(ope);\n        } else {\n          return ope;\n        }\n      }\n      case 2: { // (Expression)\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      case 3: { // TokenBoundary\n        return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 4: { // CaptureScope\n        return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 5: { // Capture\n        const auto &name = any_cast<std::string>(sv[0]);\n        auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {\n          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];\n          cs[name] = std::string(a_s, a_n);\n        });\n      }\n      default: {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      }\n    };\n\n    g[\"IdentCont\"] = [](const SemanticValues &sv) {\n      return std::string(sv.c_str(), sv.length());\n    };\n\n    g[\"Dictionary\"] = [](const SemanticValues &sv) {\n      auto items = sv.transform<std::string>();\n      return dic(items);\n    };\n\n    g[\"Literal\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return lit(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralI\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return liti(resolve_escape_sequence(tok.first, tok.second));\n    };\n    g[\"LiteralD\"] = [](const SemanticValues &sv) {\n      auto &tok = sv.tokens.front();\n      return resolve_escape_sequence(tok.first, tok.second);\n    };\n\n    g[\"Class\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return cls(ranges);\n    };\n    g[\"NegatedClass\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return ncls(ranges);\n    };\n    g[\"Range\"] = [](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: {\n        auto s1 = any_cast<std::string>(sv[0]);\n        auto s2 = any_cast<std::string>(sv[1]);\n        auto cp1 = decode_codepoint(s1.c_str(), s1.length());\n        auto cp2 = decode_codepoint(s2.c_str(), s2.length());\n        return std::make_pair(cp1, cp2);\n      }\n      case 1: {\n        auto s = any_cast<std::string>(sv[0]);\n        auto cp = decode_codepoint(s.c_str(), s.length());\n        return std::make_pair(cp, cp);\n      }\n      }\n      return std::make_pair<char32_t, char32_t>(0, 0);\n    };\n    g[\"Char\"] = [](const SemanticValues &sv) {\n      return resolve_escape_sequence(sv.c_str(), sv.length());\n    };\n\n    g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n    g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n\n    g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };\n\n    g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };\n\n    g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };\n\n    g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };\n\n    g[\"Parameters\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n\n    g[\"Arguments\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::shared_ptr<Ope>>();\n    };\n\n    g[\"PrecedenceClimbing\"] = [](const SemanticValues &sv) {\n      PrecedenceClimbing::BinOpeInfo binOpeInfo;\n      size_t level = 1;\n      for (auto v : sv) {\n        auto tokens = any_cast<std::vector<std::string>>(v);\n        auto assoc = tokens[0][0];\n        for (size_t i = 1; i < tokens.size(); i++) {\n          const auto &tok = tokens[i];\n          binOpeInfo[tok] = std::make_pair(level, assoc);\n        }\n        level++;\n      }\n      Instruction instruction;\n      instruction.type = \"precedence\";\n      instruction.data = binOpeInfo;\n      return instruction;\n    };\n    g[\"PrecedenceInfo\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n    g[\"PrecedenceOpe\"] = [](const SemanticValues &sv) { return sv.token(); };\n    g[\"PrecedenceAssoc\"] = [](const SemanticValues &sv) { return sv.token(); };\n  }\n"
    },
    {
        "begin_line": 3058,
        "end_line": 3097,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241702",
        "snippet": "    g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      auto is_macro = sv.choice() == 0;\n      auto ignore = any_cast<bool>(sv[0]);\n      auto name = any_cast<std::string>(sv[1]);\n\n      std::vector<std::string> params;\n      std::shared_ptr<Ope> ope;\n      if (is_macro) {\n        params = any_cast<std::vector<std::string>>(sv[2]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[4]);\n        if (sv.size() == 6) {\n          data.instructions[name] = any_cast<Instruction>(sv[5]);\n        }\n      } else {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[3]);\n        if (sv.size() == 5) {\n          data.instructions[name] = any_cast<Instruction>(sv[4]);\n        }\n      }\n\n      auto &grammar = *data.grammar;\n      if (!grammar.count(name)) {\n        auto &rule = grammar[name];\n        rule <= ope;\n        rule.name = name;\n        rule.s_ = sv.c_str();\n        rule.ignoreSemanticValue = ignore;\n        rule.is_macro = is_macro;\n        rule.params = params;\n\n        if (data.start.empty()) {\n          data.start = name;\n          data.start_pos = sv.c_str();\n        }\n      } else {\n        data.duplicates.emplace_back(name, sv.c_str());\n      }\n    };\n"
    },
    {
        "begin_line": 3099,
        "end_line": 3111,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241802",
        "snippet": "    g[\"Expression\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (auto i = 0u; i < sv.size(); i++) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));\n        }\n        const std::shared_ptr<Ope> ope =\n            std::make_shared<PrioritizedChoice>(opes);\n        return ope;\n      }\n    };\n"
    },
    {
        "begin_line": 3113,
        "end_line": 3124,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241902",
        "snippet": "    g[\"Sequence\"] = [&](const SemanticValues &sv) {\n      if (sv.size() == 1) {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        std::vector<std::shared_ptr<Ope>> opes;\n        for (const auto &x : sv) {\n          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));\n        }\n        const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);\n        return ope;\n      }\n    };\n"
    },
    {
        "begin_line": 3126,
        "end_line": 3141,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241a02",
        "snippet": "    g[\"Prefix\"] = [&](const SemanticValues &sv) {\n      std::shared_ptr<Ope> ope;\n      if (sv.size() == 1) {\n        ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      } else {\n        assert(sv.size() == 2);\n        auto tok = any_cast<char>(sv[0]);\n        ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        if (tok == '&') {\n          ope = apd(ope);\n        } else { // '!'\n          ope = npd(ope);\n        }\n      }\n      return ope;\n    };\n"
    },
    {
        "begin_line": 3143,
        "end_line": 3147,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Loop",
        "snippet": "    struct Loop {\n      enum class Type { opt = 0, zom, oom, rep };\n      Type type;\n      std::pair<size_t, size_t> range;\n    };\n"
    },
    {
        "begin_line": 3144,
        "end_line": 3144,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "Type",
        "snippet": "      enum class Type { opt = 0, zom, oom, rep };\n"
    },
    {
        "begin_line": 3145,
        "end_line": 3145,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "type",
        "snippet": "      Type type;\n"
    },
    {
        "begin_line": 3146,
        "end_line": 3146,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "range",
        "snippet": "      std::pair<size_t, size_t> range;\n"
    },
    {
        "begin_line": 3149,
        "end_line": 3164,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241b02",
        "snippet": "    g[\"Suffix\"] = [&](const SemanticValues &sv) {\n      auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);\n      if (sv.size() == 1) {\n        return ope;\n      } else {\n        assert(sv.size() == 2);\n        auto loop = any_cast<Loop>(sv[1]);\n        switch (loop.type) {\n        case Loop::Type::opt: return opt(ope);\n        case Loop::Type::zom: return zom(ope);\n        case Loop::Type::oom: return oom(ope);\n        default: // Regex-like repetition\n          return rep(ope, loop.range.first, loop.range.second);\n        }\n      }\n    };\n"
    },
    {
        "begin_line": 3166,
        "end_line": 3178,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241c02",
        "snippet": "    g[\"Loop\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: // Option\n        return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};\n      case 1: // Zero or More\n        return Loop{Loop::Type::zom, std::pair<size_t, size_t>()};\n      case 2: // One or More\n        return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};\n      default: // Regex-like repetition\n        return Loop{Loop::Type::rep,\n                    any_cast<std::pair<size_t, size_t>>(sv[0])};\n      }\n    };\n"
    },
    {
        "begin_line": 3180,
        "end_line": 3198,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241d02",
        "snippet": "    g[\"RepetitionRange\"] = [&](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: { // Number COMMA Number\n        auto min = any_cast<size_t>(sv[0]);\n        auto max = any_cast<size_t>(sv[1]);\n        return std::make_pair(min, max);\n      }\n      case 1: // Number COMMA\n        return std::make_pair(any_cast<size_t>(sv[0]),\n                              std::numeric_limits<size_t>::max());\n      case 2: { // Number\n        auto n = any_cast<size_t>(sv[0]);\n        return std::make_pair(n, n);\n      }\n      default: // COMMA Number\n        return std::make_pair(std::numeric_limits<size_t>::min(),\n                              any_cast<size_t>(sv[0]));\n      }\n    };\n"
    },
    {
        "begin_line": 3199,
        "end_line": 3204,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241e02",
        "snippet": "    g[\"Number\"] = [&](const SemanticValues &sv) {\n      std::stringstream ss(sv.str());\n      size_t n;\n      ss >> n;\n      return n;\n    };\n"
    },
    {
        "begin_line": 3206,
        "end_line": 3251,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251241f02",
        "snippet": "    g[\"Primary\"] = [&](const SemanticValues &sv, any &dt) {\n      Data &data = *any_cast<Data *>(dt);\n\n      switch (sv.choice()) {\n      case 0:   // Macro Reference\n      case 1: { // Reference\n        auto is_macro = sv.choice() == 0;\n        auto ignore = any_cast<bool>(sv[0]);\n        const auto &ident = any_cast<std::string>(sv[1]);\n\n        std::vector<std::shared_ptr<Ope>> args;\n        if (is_macro) {\n          args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);\n        }\n\n        std::shared_ptr<Ope> ope =\n            ref(*data.grammar, ident, sv.c_str(), is_macro, args);\n\n        if (ignore) {\n          return ign(ope);\n        } else {\n          return ope;\n        }\n      }\n      case 2: { // (Expression)\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      case 3: { // TokenBoundary\n        return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 4: { // CaptureScope\n        return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));\n      }\n      case 5: { // Capture\n        const auto &name = any_cast<std::string>(sv[0]);\n        auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);\n        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {\n          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];\n          cs[name] = std::string(a_s, a_n);\n        });\n      }\n      default: {\n        return any_cast<std::shared_ptr<Ope>>(sv[0]);\n      }\n      }\n    };\n"
    },
    {
        "begin_line": 3242,
        "end_line": 3245,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242002",
        "snippet": "        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {\n          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];\n          cs[name] = std::string(a_s, a_n);\n        });\n"
    },
    {
        "begin_line": 3253,
        "end_line": 3255,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242102",
        "snippet": "    g[\"IdentCont\"] = [](const SemanticValues &sv) {\n      return std::string(sv.c_str(), sv.length());\n    };\n"
    },
    {
        "begin_line": 3257,
        "end_line": 3260,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242202",
        "snippet": "    g[\"Dictionary\"] = [](const SemanticValues &sv) {\n      auto items = sv.transform<std::string>();\n      return dic(items);\n    };\n"
    },
    {
        "begin_line": 3262,
        "end_line": 3265,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242302",
        "snippet": "    g[\"Literal\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return lit(resolve_escape_sequence(tok.first, tok.second));\n    };\n"
    },
    {
        "begin_line": 3266,
        "end_line": 3269,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242402",
        "snippet": "    g[\"LiteralI\"] = [](const SemanticValues &sv) {\n      const auto &tok = sv.tokens.front();\n      return liti(resolve_escape_sequence(tok.first, tok.second));\n    };\n"
    },
    {
        "begin_line": 3270,
        "end_line": 3273,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242502",
        "snippet": "    g[\"LiteralD\"] = [](const SemanticValues &sv) {\n      auto &tok = sv.tokens.front();\n      return resolve_escape_sequence(tok.first, tok.second);\n    };\n"
    },
    {
        "begin_line": 3275,
        "end_line": 3278,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242602",
        "snippet": "    g[\"Class\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return cls(ranges);\n    };\n"
    },
    {
        "begin_line": 3279,
        "end_line": 3282,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242702",
        "snippet": "    g[\"NegatedClass\"] = [](const SemanticValues &sv) {\n      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();\n      return ncls(ranges);\n    };\n"
    },
    {
        "begin_line": 3283,
        "end_line": 3299,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242802",
        "snippet": "    g[\"Range\"] = [](const SemanticValues &sv) {\n      switch (sv.choice()) {\n      case 0: {\n        auto s1 = any_cast<std::string>(sv[0]);\n        auto s2 = any_cast<std::string>(sv[1]);\n        auto cp1 = decode_codepoint(s1.c_str(), s1.length());\n        auto cp2 = decode_codepoint(s2.c_str(), s2.length());\n        return std::make_pair(cp1, cp2);\n      }\n      case 1: {\n        auto s = any_cast<std::string>(sv[0]);\n        auto cp = decode_codepoint(s.c_str(), s.length());\n        return std::make_pair(cp, cp);\n      }\n      }\n      return std::make_pair<char32_t, char32_t>(0, 0);\n    };\n"
    },
    {
        "begin_line": 3300,
        "end_line": 3302,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242902",
        "snippet": "    g[\"Char\"] = [](const SemanticValues &sv) {\n      return resolve_escape_sequence(sv.c_str(), sv.length());\n    };\n"
    },
    {
        "begin_line": 3304,
        "end_line": 3304,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242a02",
        "snippet": "    g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 3305,
        "end_line": 3305,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242b02",
        "snippet": "    g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 3306,
        "end_line": 3306,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242c02",
        "snippet": "    g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 3307,
        "end_line": 3307,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242d02",
        "snippet": "    g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 3308,
        "end_line": 3308,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242e02",
        "snippet": "    g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 3310,
        "end_line": 3310,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251242f02",
        "snippet": "    g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };\n"
    },
    {
        "begin_line": 3312,
        "end_line": 3312,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243002",
        "snippet": "    g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };\n"
    },
    {
        "begin_line": 3314,
        "end_line": 3314,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243102",
        "snippet": "    g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };\n"
    },
    {
        "begin_line": 3316,
        "end_line": 3316,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243202",
        "snippet": "    g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };\n"
    },
    {
        "begin_line": 3318,
        "end_line": 3320,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243302",
        "snippet": "    g[\"Parameters\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n"
    },
    {
        "begin_line": 3322,
        "end_line": 3324,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243402",
        "snippet": "    g[\"Arguments\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::shared_ptr<Ope>>();\n    };\n"
    },
    {
        "begin_line": 3326,
        "end_line": 3342,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243502",
        "snippet": "    g[\"PrecedenceClimbing\"] = [](const SemanticValues &sv) {\n      PrecedenceClimbing::BinOpeInfo binOpeInfo;\n      size_t level = 1;\n      for (auto v : sv) {\n        auto tokens = any_cast<std::vector<std::string>>(v);\n        auto assoc = tokens[0][0];\n        for (size_t i = 1; i < tokens.size(); i++) {\n          const auto &tok = tokens[i];\n          binOpeInfo[tok] = std::make_pair(level, assoc);\n        }\n        level++;\n      }\n      Instruction instruction;\n      instruction.type = \"precedence\";\n      instruction.data = binOpeInfo;\n      return instruction;\n    };\n"
    },
    {
        "begin_line": 3343,
        "end_line": 3345,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243602",
        "snippet": "    g[\"PrecedenceInfo\"] = [](const SemanticValues &sv) {\n      return sv.transform<std::string>();\n    };\n"
    },
    {
        "begin_line": 3346,
        "end_line": 3346,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243702",
        "snippet": "    g[\"PrecedenceOpe\"] = [](const SemanticValues &sv) { return sv.token(); };\n"
    },
    {
        "begin_line": 3347,
        "end_line": 3347,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243802",
        "snippet": "    g[\"PrecedenceAssoc\"] = [](const SemanticValues &sv) { return sv.token(); };\n"
    },
    {
        "begin_line": 3350,
        "end_line": 3387,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "apply_precedence_instruction",
        "snippet": "  bool apply_precedence_instruction(Definition &rule,\n                                    const PrecedenceClimbing::BinOpeInfo &info,\n                                    const char *s, Log log) {\n    try {\n      auto &seq = dynamic_cast<Sequence &>(*rule.get_core_operator());\n      auto atom = seq.opes_[0];\n      auto &rep = dynamic_cast<Repetition &>(*seq.opes_[1]);\n      auto &seq1 = dynamic_cast<Sequence &>(*rep.ope_);\n      auto binop = seq1.opes_[0];\n      auto atom1 = seq1.opes_[1];\n\n      auto atom_name = dynamic_cast<Reference &>(*atom).name_;\n      auto binop_name = dynamic_cast<Reference &>(*binop).name_;\n      auto atom1_name = dynamic_cast<Reference &>(*atom1).name_;\n\n      if (!rep.is_zom() || atom_name != atom1_name || atom_name == binop_name) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"'precedence' instruction cannt be applied to '\" + rule.name +\n                  \"'.\");\n        }\n        return false;\n      }\n\n      rule.holder_->ope_ = pre(atom, binop, info, rule);\n      rule.disable_action = true;\n    } catch (...) {\n      if (log) {\n        auto line = line_info(s, rule.s_);\n        log(line.first, line.second,\n            \"'precedence' instruction cannt be applied to '\" + rule.name +\n                \"'.\");\n      }\n      return false;\n    }\n    return true;\n  }\n"
    },
    {
        "begin_line": 3389,
        "end_line": 3554,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "perform_core",
        "snippet": "  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check if the start rule has ignore operator\n    {\n      auto &rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");\n        }\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }\n"
    },
    {
        "begin_line": 3556,
        "end_line": 3556,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "g",
        "snippet": "  Grammar g;\n"
    },
    {
        "begin_line": 3563,
        "end_line": 3617,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AstBase",
        "snippet": "template <typename Annotation> struct AstBase : public Annotation {\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name,\n          const std::vector<std::shared_ptr<AstBase>> &a_nodes,\n          size_t a_position = 0, size_t a_length = 0, size_t a_choice_count = 0,\n          size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(false),\n        nodes(a_nodes) {}\n\n  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name, const std::string &a_token, size_t a_position = 0,\n          size_t a_length = 0, size_t a_choice_count = 0, size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(true),\n        token(a_token) {}\n\n  AstBase(const AstBase &ast, const char *a_original_name,\n          size_t a_position = 0, size_t a_length = 0,\n          size_t a_original_choice_count = 0, size_t a_original_choise = 0)\n      : path(ast.path), line(ast.line), column(ast.column), name(ast.name),\n        position(a_position), length(a_length), choice_count(ast.choice_count),\n        choice(ast.choice), original_name(a_original_name),\n        original_choice_count(a_original_choice_count),\n        original_choice(a_original_choise), tag(ast.tag),\n        original_tag(str2tag(a_original_name)), is_token(ast.is_token),\n        token(ast.token), nodes(ast.nodes), parent(ast.parent) {}\n\n  const std::string path;\n  const size_t line = 1;\n  const size_t column = 1;\n\n  const std::string name;\n  size_t position;\n  size_t length;\n  const size_t choice_count;\n  const size_t choice;\n  const std::string original_name;\n  const size_t original_choice_count;\n  const size_t original_choice;\n  const unsigned int tag;\n  const unsigned int original_tag;\n\n  const bool is_token;\n  const std::string token;\n\n  std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;\n  std::weak_ptr<AstBase<Annotation>> parent;\n};\n"
    },
    {
        "begin_line": 3564,
        "end_line": 3574,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AstBase",
        "snippet": "  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name,\n          const std::vector<std::shared_ptr<AstBase>> &a_nodes,\n          size_t a_position = 0, size_t a_length = 0, size_t a_choice_count = 0,\n          size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(false),\n        nodes(a_nodes) {}\n"
    },
    {
        "begin_line": 3576,
        "end_line": 3584,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AstBase",
        "snippet": "  AstBase(const char *a_path, size_t a_line, size_t a_column,\n          const char *a_name, const std::string &a_token, size_t a_position = 0,\n          size_t a_length = 0, size_t a_choice_count = 0, size_t a_choice = 0)\n      : path(a_path ? a_path : \"\"), line(a_line), column(a_column),\n        name(a_name), position(a_position), length(a_length),\n        choice_count(a_choice_count), choice(a_choice), original_name(a_name),\n        original_choice_count(a_choice_count), original_choice(a_choice),\n        tag(str2tag(a_name)), original_tag(tag), is_token(true),\n        token(a_token) {}\n"
    },
    {
        "begin_line": 3586,
        "end_line": 3595,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AstBase",
        "snippet": "  AstBase(const AstBase &ast, const char *a_original_name,\n          size_t a_position = 0, size_t a_length = 0,\n          size_t a_original_choice_count = 0, size_t a_original_choise = 0)\n      : path(ast.path), line(ast.line), column(ast.column), name(ast.name),\n        position(a_position), length(a_length), choice_count(ast.choice_count),\n        choice(ast.choice), original_name(a_original_name),\n        original_choice_count(a_original_choice_count),\n        original_choice(a_original_choise), tag(ast.tag),\n        original_tag(str2tag(a_original_name)), is_token(ast.is_token),\n        token(ast.token), nodes(ast.nodes), parent(ast.parent) {}\n"
    },
    {
        "begin_line": 3597,
        "end_line": 3597,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "path",
        "snippet": "  const std::string path;\n"
    },
    {
        "begin_line": 3598,
        "end_line": 3598,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "line",
        "snippet": "  const size_t line = 1;\n"
    },
    {
        "begin_line": 3599,
        "end_line": 3599,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "column",
        "snippet": "  const size_t column = 1;\n"
    },
    {
        "begin_line": 3601,
        "end_line": 3601,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "name",
        "snippet": "  const std::string name;\n"
    },
    {
        "begin_line": 3602,
        "end_line": 3602,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "position",
        "snippet": "  size_t position;\n"
    },
    {
        "begin_line": 3603,
        "end_line": 3603,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "length",
        "snippet": "  size_t length;\n"
    },
    {
        "begin_line": 3604,
        "end_line": 3604,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "choice_count",
        "snippet": "  const size_t choice_count;\n"
    },
    {
        "begin_line": 3605,
        "end_line": 3605,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "choice",
        "snippet": "  const size_t choice;\n"
    },
    {
        "begin_line": 3606,
        "end_line": 3606,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "original_name",
        "snippet": "  const std::string original_name;\n"
    },
    {
        "begin_line": 3607,
        "end_line": 3607,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "original_choice_count",
        "snippet": "  const size_t original_choice_count;\n"
    },
    {
        "begin_line": 3608,
        "end_line": 3608,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "original_choice",
        "snippet": "  const size_t original_choice;\n"
    },
    {
        "begin_line": 3609,
        "end_line": 3609,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "tag",
        "snippet": "  const unsigned int tag;\n"
    },
    {
        "begin_line": 3610,
        "end_line": 3610,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "original_tag",
        "snippet": "  const unsigned int original_tag;\n"
    },
    {
        "begin_line": 3612,
        "end_line": 3612,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "is_token",
        "snippet": "  const bool is_token;\n"
    },
    {
        "begin_line": 3613,
        "end_line": 3613,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "token",
        "snippet": "  const std::string token;\n"
    },
    {
        "begin_line": 3615,
        "end_line": 3615,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "nodes",
        "snippet": "  std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;\n"
    },
    {
        "begin_line": 3616,
        "end_line": 3616,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parent",
        "snippet": "  std::weak_ptr<AstBase<Annotation>> parent;\n"
    },
    {
        "begin_line": 3620,
        "end_line": 3640,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ast_to_s_core",
        "snippet": "void ast_to_s_core(const std::shared_ptr<T> &ptr, std::string &s, int level,\n                   std::function<std::string(const T &ast, int level)> fn) {\n  const auto &ast = *ptr;\n  for (auto i = 0; i < level; i++) {\n    s += \"  \";\n  }\n  auto name = ast.original_name;\n  if (ast.original_choice_count > 0) {\n    name += \"/\" + std::to_string(ast.original_choice);\n  }\n  if (ast.name != ast.original_name) { name += \"[\" + ast.name + \"]\"; }\n  if (ast.is_token) {\n    s += \"- \" + name + \" (\" + ast.token + \")\\n\";\n  } else {\n    s += \"+ \" + name + \"\\n\";\n  }\n  if (fn) { s += fn(ast, level + 1); }\n  for (auto node : ast.nodes) {\n    ast_to_s_core(node, s, level + 1, fn);\n  }\n}\n"
    },
    {
        "begin_line": 3644,
        "end_line": 3649,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "ast_to_s",
        "snippet": "ast_to_s(const std::shared_ptr<T> &ptr,\n         std::function<std::string(const T &ast, int level)> fn = nullptr) {\n  std::string s;\n  ast_to_s_core(ptr, s, 0, fn);\n  return s;\n}\n"
    },
    {
        "begin_line": 3651,
        "end_line": 3682,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AstOptimizer",
        "snippet": "struct AstOptimizer {\n  AstOptimizer(bool mode, const std::vector<std::string> &rules = {})\n      : mode_(mode), rules_(rules) {}\n\n  template <typename T>\n  std::shared_ptr<T> optimize(std::shared_ptr<T> original,\n                              std::shared_ptr<T> parent = nullptr) {\n    auto found =\n        std::find(rules_.begin(), rules_.end(), original->name) != rules_.end();\n    bool opt = mode_ ? !found : found;\n\n    if (opt && original->nodes.size() == 1) {\n      auto child = optimize(original->nodes[0], parent);\n      return std::make_shared<T>(*child, original->name.c_str(),\n                                 original->choice_count, original->position,\n                                 original->length, original->choice);\n    }\n\n    auto ast = std::make_shared<T>(*original);\n    ast->parent = parent;\n    ast->nodes.clear();\n    for (auto node : original->nodes) {\n      auto child = optimize(node, ast);\n      ast->nodes.push_back(child);\n    }\n    return ast;\n  }\n\nprivate:\n  const bool mode_;\n  const std::vector<std::string> rules_;\n};\n"
    },
    {
        "begin_line": 3652,
        "end_line": 3653,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AstOptimizer",
        "snippet": "  AstOptimizer(bool mode, const std::vector<std::string> &rules = {})\n      : mode_(mode), rules_(rules) {}\n"
    },
    {
        "begin_line": 3656,
        "end_line": 3677,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "optimize",
        "snippet": "  std::shared_ptr<T> optimize(std::shared_ptr<T> original,\n                              std::shared_ptr<T> parent = nullptr) {\n    auto found =\n        std::find(rules_.begin(), rules_.end(), original->name) != rules_.end();\n    bool opt = mode_ ? !found : found;\n\n    if (opt && original->nodes.size() == 1) {\n      auto child = optimize(original->nodes[0], parent);\n      return std::make_shared<T>(*child, original->name.c_str(),\n                                 original->choice_count, original->position,\n                                 original->length, original->choice);\n    }\n\n    auto ast = std::make_shared<T>(*original);\n    ast->parent = parent;\n    ast->nodes.clear();\n    for (auto node : original->nodes) {\n      auto child = optimize(node, ast);\n      ast->nodes.push_back(child);\n    }\n    return ast;\n  }\n"
    },
    {
        "begin_line": 3680,
        "end_line": 3680,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "mode_",
        "snippet": "  const bool mode_;\n"
    },
    {
        "begin_line": 3681,
        "end_line": 3681,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "rules_",
        "snippet": "  const std::vector<std::string> rules_;\n"
    },
    {
        "begin_line": 3684,
        "end_line": 3684,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "EmptyType",
        "snippet": "struct EmptyType {};\n"
    },
    {
        "begin_line": 3687,
        "end_line": 3708,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "add_ast_action",
        "snippet": "template <typename T = Ast> void add_ast_action(Definition &rule) {\n  rule.action = [&](const SemanticValues &sv) {\n    auto line = sv.line_info();\n\n    if (rule.is_token()) {\n      return std::make_shared<T>(sv.path, line.first, line.second,\n                                 rule.name.c_str(), sv.token(),\n                                 std::distance(sv.ss, sv.c_str()), sv.length(),\n                                 sv.choice_count(), sv.choice());\n    }\n\n    auto ast = std::make_shared<T>(\n        sv.path, line.first, line.second, rule.name.c_str(),\n        sv.transform<std::shared_ptr<T>>(), std::distance(sv.ss, sv.c_str()),\n        sv.length(), sv.choice_count(), sv.choice());\n\n    for (auto node : ast->nodes) {\n      node->parent = ast;\n    }\n    return ast;\n  };\n}\n"
    },
    {
        "begin_line": 3688,
        "end_line": 3707,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "__anond9b251243902",
        "snippet": "  rule.action = [&](const SemanticValues &sv) {\n    auto line = sv.line_info();\n\n    if (rule.is_token()) {\n      return std::make_shared<T>(sv.path, line.first, line.second,\n                                 rule.name.c_str(), sv.token(),\n                                 std::distance(sv.ss, sv.c_str()), sv.length(),\n                                 sv.choice_count(), sv.choice());\n    }\n\n    auto ast = std::make_shared<T>(\n        sv.path, line.first, line.second, rule.name.c_str(),\n        sv.transform<std::shared_ptr<T>>(), std::distance(sv.ss, sv.c_str()),\n        sv.length(), sv.choice_count(), sv.choice());\n\n    for (auto node : ast->nodes) {\n      node->parent = ast;\n    }\n    return ast;\n  };\n"
    },
    {
        "begin_line": 3710,
        "end_line": 3710,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_EXPAND",
        "snippet": "#define PEG_EXPAND(...) __VA_ARGS__\n"
    },
    {
        "begin_line": 3711,
        "end_line": 3711,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_CONCAT",
        "snippet": "#define PEG_CONCAT(a, b) a##b\n"
    },
    {
        "begin_line": 3712,
        "end_line": 3712,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_CONCAT2",
        "snippet": "#define PEG_CONCAT2(a, b) PEG_CONCAT(a, b)\n"
    },
    {
        "begin_line": 3714,
        "end_line": 3722,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_PICK",
        "snippet": "#define PEG_PICK(                                                              \\\n    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, \\\n    a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, \\\n    a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, \\\n    a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, \\\n    a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, \\\n    a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, \\\n    a92, a93, a94, a95, a96, a97, a98, a99, a100, ...)                         \\\n  a100\n"
    },
    {
        "begin_line": 3724,
        "end_line": 3731,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_COUNT",
        "snippet": "#define PEG_COUNT(...)                                                         \\\n  PEG_EXPAND(PEG_PICK(                                                         \\\n      __VA_ARGS__, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87,    \\\n      86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69,  \\\n      68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,  \\\n      50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,  \\\n      32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,  \\\n      14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))\n"
    },
    {
        "begin_line": 3733,
        "end_line": 3736,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_1",
        "snippet": "#define PEG_DEF_1(r)                                                           \\\n  peg::Definition r;                                                           \\\n  r.name = #r;                                                                 \\\n  peg::add_ast_action(r);\n"
    },
    {
        "begin_line": 3738,
        "end_line": 3738,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_2",
        "snippet": "#define PEG_DEF_2(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_1(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3739,
        "end_line": 3739,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_3",
        "snippet": "#define PEG_DEF_3(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_2(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3740,
        "end_line": 3740,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_4",
        "snippet": "#define PEG_DEF_4(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_3(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3741,
        "end_line": 3741,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_5",
        "snippet": "#define PEG_DEF_5(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_4(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3742,
        "end_line": 3742,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_6",
        "snippet": "#define PEG_DEF_6(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_5(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3743,
        "end_line": 3743,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_7",
        "snippet": "#define PEG_DEF_7(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_6(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3744,
        "end_line": 3744,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_8",
        "snippet": "#define PEG_DEF_8(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_7(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3745,
        "end_line": 3745,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_9",
        "snippet": "#define PEG_DEF_9(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_8(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3746,
        "end_line": 3746,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_10",
        "snippet": "#define PEG_DEF_10(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_9(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3747,
        "end_line": 3747,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_11",
        "snippet": "#define PEG_DEF_11(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_10(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3748,
        "end_line": 3748,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_12",
        "snippet": "#define PEG_DEF_12(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_11(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3749,
        "end_line": 3749,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_13",
        "snippet": "#define PEG_DEF_13(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_12(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3750,
        "end_line": 3750,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_14",
        "snippet": "#define PEG_DEF_14(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_13(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3751,
        "end_line": 3751,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_15",
        "snippet": "#define PEG_DEF_15(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_14(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3752,
        "end_line": 3752,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_16",
        "snippet": "#define PEG_DEF_16(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_15(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3753,
        "end_line": 3753,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_17",
        "snippet": "#define PEG_DEF_17(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_16(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3754,
        "end_line": 3754,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_18",
        "snippet": "#define PEG_DEF_18(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_17(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3755,
        "end_line": 3755,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_19",
        "snippet": "#define PEG_DEF_19(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_18(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3756,
        "end_line": 3756,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_20",
        "snippet": "#define PEG_DEF_20(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_19(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3757,
        "end_line": 3757,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_21",
        "snippet": "#define PEG_DEF_21(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_20(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3758,
        "end_line": 3758,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_22",
        "snippet": "#define PEG_DEF_22(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_21(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3759,
        "end_line": 3759,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_23",
        "snippet": "#define PEG_DEF_23(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_22(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3760,
        "end_line": 3760,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_24",
        "snippet": "#define PEG_DEF_24(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_23(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3761,
        "end_line": 3761,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_25",
        "snippet": "#define PEG_DEF_25(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_24(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3762,
        "end_line": 3762,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_26",
        "snippet": "#define PEG_DEF_26(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_25(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3763,
        "end_line": 3763,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_27",
        "snippet": "#define PEG_DEF_27(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_26(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3764,
        "end_line": 3764,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_28",
        "snippet": "#define PEG_DEF_28(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_27(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3765,
        "end_line": 3765,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_29",
        "snippet": "#define PEG_DEF_29(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_28(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3766,
        "end_line": 3766,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_30",
        "snippet": "#define PEG_DEF_30(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_29(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3767,
        "end_line": 3767,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_31",
        "snippet": "#define PEG_DEF_31(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_30(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3768,
        "end_line": 3768,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_32",
        "snippet": "#define PEG_DEF_32(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_31(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3769,
        "end_line": 3769,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_33",
        "snippet": "#define PEG_DEF_33(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_32(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3770,
        "end_line": 3770,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_34",
        "snippet": "#define PEG_DEF_34(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_33(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3771,
        "end_line": 3771,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_35",
        "snippet": "#define PEG_DEF_35(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_34(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3772,
        "end_line": 3772,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_36",
        "snippet": "#define PEG_DEF_36(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_35(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3773,
        "end_line": 3773,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_37",
        "snippet": "#define PEG_DEF_37(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_36(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3774,
        "end_line": 3774,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_38",
        "snippet": "#define PEG_DEF_38(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_37(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3775,
        "end_line": 3775,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_39",
        "snippet": "#define PEG_DEF_39(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_38(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3776,
        "end_line": 3776,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_40",
        "snippet": "#define PEG_DEF_40(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_39(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3777,
        "end_line": 3777,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_41",
        "snippet": "#define PEG_DEF_41(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_40(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3778,
        "end_line": 3778,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_42",
        "snippet": "#define PEG_DEF_42(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_41(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3779,
        "end_line": 3779,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_43",
        "snippet": "#define PEG_DEF_43(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_42(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3780,
        "end_line": 3780,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_44",
        "snippet": "#define PEG_DEF_44(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_43(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3781,
        "end_line": 3781,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_45",
        "snippet": "#define PEG_DEF_45(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_44(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3782,
        "end_line": 3782,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_46",
        "snippet": "#define PEG_DEF_46(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_45(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3783,
        "end_line": 3783,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_47",
        "snippet": "#define PEG_DEF_47(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_46(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3784,
        "end_line": 3784,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_48",
        "snippet": "#define PEG_DEF_48(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_47(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3785,
        "end_line": 3785,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_49",
        "snippet": "#define PEG_DEF_49(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_48(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3786,
        "end_line": 3786,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_50",
        "snippet": "#define PEG_DEF_50(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_49(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3787,
        "end_line": 3787,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_51",
        "snippet": "#define PEG_DEF_51(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_50(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3788,
        "end_line": 3788,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_52",
        "snippet": "#define PEG_DEF_52(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_51(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3789,
        "end_line": 3789,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_53",
        "snippet": "#define PEG_DEF_53(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_52(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3790,
        "end_line": 3790,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_54",
        "snippet": "#define PEG_DEF_54(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_53(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3791,
        "end_line": 3791,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_55",
        "snippet": "#define PEG_DEF_55(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_54(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3792,
        "end_line": 3792,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_56",
        "snippet": "#define PEG_DEF_56(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_55(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3793,
        "end_line": 3793,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_57",
        "snippet": "#define PEG_DEF_57(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_56(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3794,
        "end_line": 3794,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_58",
        "snippet": "#define PEG_DEF_58(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_57(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3795,
        "end_line": 3795,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_59",
        "snippet": "#define PEG_DEF_59(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_58(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3796,
        "end_line": 3796,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_60",
        "snippet": "#define PEG_DEF_60(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_59(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3797,
        "end_line": 3797,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_61",
        "snippet": "#define PEG_DEF_61(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_60(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3798,
        "end_line": 3798,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_62",
        "snippet": "#define PEG_DEF_62(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_61(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3799,
        "end_line": 3799,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_63",
        "snippet": "#define PEG_DEF_63(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_62(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3800,
        "end_line": 3800,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_64",
        "snippet": "#define PEG_DEF_64(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_63(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3801,
        "end_line": 3801,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_65",
        "snippet": "#define PEG_DEF_65(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_64(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3802,
        "end_line": 3802,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_66",
        "snippet": "#define PEG_DEF_66(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_65(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3803,
        "end_line": 3803,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_67",
        "snippet": "#define PEG_DEF_67(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_66(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3804,
        "end_line": 3804,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_68",
        "snippet": "#define PEG_DEF_68(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_67(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3805,
        "end_line": 3805,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_69",
        "snippet": "#define PEG_DEF_69(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_68(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3806,
        "end_line": 3806,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_70",
        "snippet": "#define PEG_DEF_70(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_69(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3807,
        "end_line": 3807,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_71",
        "snippet": "#define PEG_DEF_71(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_70(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3808,
        "end_line": 3808,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_72",
        "snippet": "#define PEG_DEF_72(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_71(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3809,
        "end_line": 3809,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_73",
        "snippet": "#define PEG_DEF_73(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_72(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3810,
        "end_line": 3810,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_74",
        "snippet": "#define PEG_DEF_74(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_73(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3811,
        "end_line": 3811,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_75",
        "snippet": "#define PEG_DEF_75(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_74(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3812,
        "end_line": 3812,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_76",
        "snippet": "#define PEG_DEF_76(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_75(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3813,
        "end_line": 3813,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_77",
        "snippet": "#define PEG_DEF_77(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_76(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3814,
        "end_line": 3814,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_78",
        "snippet": "#define PEG_DEF_78(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_77(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3815,
        "end_line": 3815,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_79",
        "snippet": "#define PEG_DEF_79(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_78(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3816,
        "end_line": 3816,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_80",
        "snippet": "#define PEG_DEF_80(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_79(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3817,
        "end_line": 3817,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_81",
        "snippet": "#define PEG_DEF_81(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_80(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3818,
        "end_line": 3818,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_82",
        "snippet": "#define PEG_DEF_82(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_81(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3819,
        "end_line": 3819,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_83",
        "snippet": "#define PEG_DEF_83(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_82(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3820,
        "end_line": 3820,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_84",
        "snippet": "#define PEG_DEF_84(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_83(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3821,
        "end_line": 3821,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_85",
        "snippet": "#define PEG_DEF_85(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_84(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3822,
        "end_line": 3822,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_86",
        "snippet": "#define PEG_DEF_86(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_85(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3823,
        "end_line": 3823,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_87",
        "snippet": "#define PEG_DEF_87(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_86(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3824,
        "end_line": 3824,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_88",
        "snippet": "#define PEG_DEF_88(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_87(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3825,
        "end_line": 3825,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_89",
        "snippet": "#define PEG_DEF_89(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_88(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3826,
        "end_line": 3826,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_90",
        "snippet": "#define PEG_DEF_90(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_89(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3827,
        "end_line": 3827,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_91",
        "snippet": "#define PEG_DEF_91(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_90(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3828,
        "end_line": 3828,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_92",
        "snippet": "#define PEG_DEF_92(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_91(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3829,
        "end_line": 3829,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_93",
        "snippet": "#define PEG_DEF_93(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_92(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3830,
        "end_line": 3830,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_94",
        "snippet": "#define PEG_DEF_94(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_93(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3831,
        "end_line": 3831,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_95",
        "snippet": "#define PEG_DEF_95(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_94(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3832,
        "end_line": 3832,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_96",
        "snippet": "#define PEG_DEF_96(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_95(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3833,
        "end_line": 3833,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_97",
        "snippet": "#define PEG_DEF_97(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_96(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3834,
        "end_line": 3834,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_98",
        "snippet": "#define PEG_DEF_98(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_97(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3835,
        "end_line": 3835,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_99",
        "snippet": "#define PEG_DEF_99(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_98(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3836,
        "end_line": 3836,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "PEG_DEF_100",
        "snippet": "#define PEG_DEF_100(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_99(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3838,
        "end_line": 3839,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "AST_DEFINITIONS",
        "snippet": "#define AST_DEFINITIONS(...)                                                   \\\n  PEG_EXPAND(PEG_CONCAT2(PEG_DEF_, PEG_COUNT(__VA_ARGS__))(__VA_ARGS__))\n"
    },
    {
        "begin_line": 3845,
        "end_line": 4006,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parser",
        "snippet": "class parser {\npublic:\n  parser() = default;\n\n  parser(const char *s, size_t n, const Rules &rules) {\n    load_grammar(s, n, rules);\n  }\n\n  parser(const char *s, const Rules &rules) : parser(s, strlen(s), rules) {}\n\n  parser(const char *s, size_t n) : parser(s, n, Rules()) {}\n\n  parser(const char *s) : parser(s, strlen(s), Rules()) {}\n\n  operator bool() { return grammar_ != nullptr; }\n\n  bool load_grammar(const char *s, size_t n, const Rules &rules) {\n    grammar_ = ParserGenerator::parse(s, n, rules, start_, log);\n    return grammar_ != nullptr;\n  }\n\n  bool load_grammar(const char *s, size_t n) {\n    return load_grammar(s, n, Rules());\n  }\n\n  bool load_grammar(const char *s, const Rules &rules) {\n    auto n = strlen(s);\n    return load_grammar(s, n, rules);\n  }\n\n  bool load_grammar(const char *s) {\n    auto n = strlen(s);\n    return load_grammar(s, n);\n  }\n\n  bool parse_n(const char *s, size_t n, const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, path);\n  }\n\n  bool parse_n(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, dt, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  bool parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, T &val, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, val, path);\n  }\n\n  template <typename T>\n  bool parse_n(const char *s, size_t n, any &dt, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, dt, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n\n  template <typename T>\n  bool parse(const char *s, any &dt, T &val,\n             const char * /*path*/ = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, val);\n  }\n\n  Definition &operator[](const char *s) { return (*grammar_)[s]; }\n\n  const Definition &operator[](const char *s) const { return (*grammar_)[s]; }\n\n  std::vector<std::string> get_rule_names() {\n    std::vector<std::string> rules;\n    rules.reserve(grammar_->size());\n    for (auto const &r : *grammar_) {\n      rules.emplace_back(r.first);\n    }\n    return rules;\n  }\n\n  void enable_packrat_parsing() {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.enablePackratParsing = true;\n    }\n  }\n\n  template <typename T = Ast> parser &enable_ast() {\n    for (auto &x : *grammar_) {\n      auto &rule = x.second;\n      if (!rule.action) { add_ast_action<T>(rule); }\n    }\n    return *this;\n  }\n\n  void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.tracer_enter = tracer_enter;\n      rule.tracer_leave = tracer_leave;\n    }\n  }\n\n  Log log;\n\nprivate:\n  void output_log(const char *s, size_t n, const Definition::Result &r) const {\n    if (log) {\n      if (!r.ret) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      } else if (r.len != n) {\n        auto line = line_info(s, s + r.len);\n        log(line.first, line.second, \"syntax error\");\n      }\n    }\n  }\n\n  std::shared_ptr<Grammar> grammar_;\n  std::string start_;\n};\n"
    },
    {
        "begin_line": 3849,
        "end_line": 3851,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parser",
        "snippet": "  parser(const char *s, size_t n, const Rules &rules) {\n    load_grammar(s, n, rules);\n  }\n"
    },
    {
        "begin_line": 3853,
        "end_line": 3853,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parser",
        "snippet": "  parser(const char *s, const Rules &rules) : parser(s, strlen(s), rules) {}\n"
    },
    {
        "begin_line": 3855,
        "end_line": 3855,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parser",
        "snippet": "  parser(const char *s, size_t n) : parser(s, n, Rules()) {}\n"
    },
    {
        "begin_line": 3857,
        "end_line": 3857,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parser",
        "snippet": "  parser(const char *s) : parser(s, strlen(s), Rules()) {}\n"
    },
    {
        "begin_line": 3859,
        "end_line": 3859,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator bool",
        "snippet": "  operator bool() { return grammar_ != nullptr; }\n"
    },
    {
        "begin_line": 3861,
        "end_line": 3864,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "load_grammar",
        "snippet": "  bool load_grammar(const char *s, size_t n, const Rules &rules) {\n    grammar_ = ParserGenerator::parse(s, n, rules, start_, log);\n    return grammar_ != nullptr;\n  }\n"
    },
    {
        "begin_line": 3866,
        "end_line": 3868,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "load_grammar",
        "snippet": "  bool load_grammar(const char *s, size_t n) {\n    return load_grammar(s, n, Rules());\n  }\n"
    },
    {
        "begin_line": 3870,
        "end_line": 3873,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "load_grammar",
        "snippet": "  bool load_grammar(const char *s, const Rules &rules) {\n    auto n = strlen(s);\n    return load_grammar(s, n, rules);\n  }\n"
    },
    {
        "begin_line": 3875,
        "end_line": 3878,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "load_grammar",
        "snippet": "  bool load_grammar(const char *s) {\n    auto n = strlen(s);\n    return load_grammar(s, n);\n  }\n"
    },
    {
        "begin_line": 3880,
        "end_line": 3888,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_n",
        "snippet": "  bool parse_n(const char *s, size_t n, const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n"
    },
    {
        "begin_line": 3890,
        "end_line": 3893,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  bool parse(const char *s, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, path);\n  }\n"
    },
    {
        "begin_line": 3895,
        "end_line": 3904,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_n",
        "snippet": "  bool parse_n(const char *s, size_t n, any &dt,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse(s, n, dt, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n"
    },
    {
        "begin_line": 3906,
        "end_line": 3909,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  bool parse(const char *s, any &dt, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, path);\n  }\n"
    },
    {
        "begin_line": 3912,
        "end_line": 3921,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_n",
        "snippet": "  bool parse_n(const char *s, size_t n, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n"
    },
    {
        "begin_line": 3924,
        "end_line": 3927,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  bool parse(const char *s, T &val, const char *path = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, val, path);\n  }\n"
    },
    {
        "begin_line": 3930,
        "end_line": 3939,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse_n",
        "snippet": "  bool parse_n(const char *s, size_t n, any &dt, T &val,\n               const char *path = nullptr) const {\n    if (grammar_ != nullptr) {\n      const auto &rule = (*grammar_)[start_];\n      auto r = rule.parse_and_get_value(s, n, dt, val, path);\n      output_log(s, n, r);\n      return r.ret && r.len == n;\n    }\n    return false;\n  }\n"
    },
    {
        "begin_line": 3942,
        "end_line": 3946,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "parse",
        "snippet": "  bool parse(const char *s, any &dt, T &val,\n             const char * /*path*/ = nullptr) const {\n    auto n = strlen(s);\n    return parse_n(s, n, dt, val);\n  }\n"
    },
    {
        "begin_line": 3948,
        "end_line": 3948,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator []",
        "snippet": "  Definition &operator[](const char *s) { return (*grammar_)[s]; }\n"
    },
    {
        "begin_line": 3950,
        "end_line": 3950,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "operator []",
        "snippet": "  const Definition &operator[](const char *s) const { return (*grammar_)[s]; }\n"
    },
    {
        "begin_line": 3952,
        "end_line": 3959,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "get_rule_names",
        "snippet": "  std::vector<std::string> get_rule_names() {\n    std::vector<std::string> rules;\n    rules.reserve(grammar_->size());\n    for (auto const &r : *grammar_) {\n      rules.emplace_back(r.first);\n    }\n    return rules;\n  }\n"
    },
    {
        "begin_line": 3961,
        "end_line": 3966,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "enable_packrat_parsing",
        "snippet": "  void enable_packrat_parsing() {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.enablePackratParsing = true;\n    }\n  }\n"
    },
    {
        "begin_line": 3968,
        "end_line": 3974,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "enable_ast",
        "snippet": "  template <typename T = Ast> parser &enable_ast() {\n    for (auto &x : *grammar_) {\n      auto &rule = x.second;\n      if (!rule.action) { add_ast_action<T>(rule); }\n    }\n    return *this;\n  }\n"
    },
    {
        "begin_line": 3976,
        "end_line": 3982,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "enable_trace",
        "snippet": "  void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {\n    if (grammar_ != nullptr) {\n      auto &rule = (*grammar_)[start_];\n      rule.tracer_enter = tracer_enter;\n      rule.tracer_leave = tracer_leave;\n    }\n  }\n"
    },
    {
        "begin_line": 3984,
        "end_line": 3984,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "log",
        "snippet": "  Log log;\n"
    },
    {
        "begin_line": 3987,
        "end_line": 4002,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "output_log",
        "snippet": "  void output_log(const char *s, size_t n, const Definition::Result &r) const {\n    if (log) {\n      if (!r.ret) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      } else if (r.len != n) {\n        auto line = line_info(s, s + r.len);\n        log(line.first, line.second, \"syntax error\");\n      }\n    }\n  }\n"
    },
    {
        "begin_line": 4004,
        "end_line": 4004,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "grammar_",
        "snippet": "  std::shared_ptr<Grammar> grammar_;\n"
    },
    {
        "begin_line": 4005,
        "end_line": 4005,
        "file_name": "./proj/cpp_peglib/buggy-1/peglib.h",
        "func_name": "start_",
        "snippet": "  std::string start_;\n"
    },
    {
        "begin_line": 12,
        "end_line": 12,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED",
        "snippet": "#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED\n"
    },
    {
        "begin_line": 16,
        "end_line": 16,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_VERSION_MAJOR",
        "snippet": "#define CATCH_VERSION_MAJOR 2\n"
    },
    {
        "begin_line": 17,
        "end_line": 17,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_VERSION_MINOR",
        "snippet": "#define CATCH_VERSION_MINOR 2\n"
    },
    {
        "begin_line": 18,
        "end_line": 18,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_VERSION_PATCH",
        "snippet": "#define CATCH_VERSION_PATCH 2\n"
    },
    {
        "begin_line": 47,
        "end_line": 47,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_IMPL",
        "snippet": "#  define CATCH_IMPL\n"
    },
    {
        "begin_line": 48,
        "end_line": 48,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_ALL_PARTS",
        "snippet": "#  define CATCH_CONFIG_ALL_PARTS\n"
    },
    {
        "begin_line": 54,
        "end_line": 54,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_EXTERNAL_INTERFACES",
        "snippet": "#  define CATCH_CONFIG_EXTERNAL_INTERFACES\n"
    },
    {
        "begin_line": 58,
        "end_line": 58,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER",
        "snippet": "#  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER\n"
    },
    {
        "begin_line": 67,
        "end_line": 67,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_PLATFORM_MAC",
        "snippet": "#  define CATCH_PLATFORM_MAC\n"
    },
    {
        "begin_line": 69,
        "end_line": 69,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_PLATFORM_IPHONE",
        "snippet": "#  define CATCH_PLATFORM_IPHONE\n"
    },
    {
        "begin_line": 73,
        "end_line": 73,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_PLATFORM_LINUX",
        "snippet": "#  define CATCH_PLATFORM_LINUX\n"
    },
    {
        "begin_line": 76,
        "end_line": 76,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_PLATFORM_WINDOWS",
        "snippet": "#  define CATCH_PLATFORM_WINDOWS\n"
    },
    {
        "begin_line": 83,
        "end_line": 83,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CLARA_CONFIG_MAIN_NOT_DEFINED",
        "snippet": "#    define CLARA_CONFIG_MAIN_NOT_DEFINED\n"
    },
    {
        "begin_line": 84,
        "end_line": 84,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CLARA_CONFIG_MAIN",
        "snippet": "#    define CLARA_CONFIG_MAIN\n"
    },
    {
        "begin_line": 90,
        "end_line": 92,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    unsigned int rngSeed();\n}\n"
    },
    {
        "begin_line": 120,
        "end_line": 120,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CPP14_OR_GREATER",
        "snippet": "#    define CATCH_CPP14_OR_GREATER\n"
    },
    {
        "begin_line": 124,
        "end_line": 124,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CPP17_OR_GREATER",
        "snippet": "#    define CATCH_CPP17_OR_GREATER\n"
    },
    {
        "begin_line": 130,
        "end_line": 130,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS",
        "snippet": "#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n"
    },
    {
        "begin_line": 135,
        "end_line": 138,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS",
        "snippet": "#       define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n            _Pragma( \"clang diagnostic push\" ) \\\n            _Pragma( \"clang diagnostic ignored \\\"-Wexit-time-destructors\\\"\" ) \\\n            _Pragma( \"clang diagnostic ignored \\\"-Wglobal-constructors\\\"\")\n"
    },
    {
        "begin_line": 139,
        "end_line": 140,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS",
        "snippet": "#       define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n            _Pragma( \"clang diagnostic pop\" )\n"
    },
    {
        "begin_line": 142,
        "end_line": 144,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS",
        "snippet": "#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\\n            _Pragma( \"clang diagnostic push\" ) \\\n            _Pragma( \"clang diagnostic ignored \\\"-Wparentheses\\\"\" )\n"
    },
    {
        "begin_line": 145,
        "end_line": 146,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS",
        "snippet": "#       define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\\n            _Pragma( \"clang diagnostic pop\" )\n"
    },
    {
        "begin_line": 153,
        "end_line": 153,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_POSIX_SIGNALS",
        "snippet": "    #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS\n"
    },
    {
        "begin_line": 159,
        "end_line": 159,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS",
        "snippet": "    #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS\n"
    },
    {
        "begin_line": 163,
        "end_line": 163,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS",
        "snippet": "#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS\n"
    },
    {
        "begin_line": 164,
        "end_line": 164,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_COLOUR_NONE",
        "snippet": "#       define CATCH_CONFIG_COLOUR_NONE\n"
    },
    {
        "begin_line": 173,
        "end_line": 173,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "_BSD_SOURCE",
        "snippet": "#   define _BSD_SOURCE\n"
    },
    {
        "begin_line": 182,
        "end_line": 182,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS",
        "snippet": "#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n"
    },
    {
        "begin_line": 188,
        "end_line": 188,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_COLOUR_NONE",
        "snippet": "#    define CATCH_CONFIG_COLOUR_NONE\n"
    },
    {
        "begin_line": 190,
        "end_line": 190,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_WINDOWS_SEH",
        "snippet": "#    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH\n"
    },
    {
        "begin_line": 199,
        "end_line": 199,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_NO_WCHAR",
        "snippet": "#  define CATCH_INTERNAL_CONFIG_NO_WCHAR\n"
    },
    {
        "begin_line": 210,
        "end_line": 210,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_CONFIG_COUNTER",
        "snippet": "    #define CATCH_INTERNAL_CONFIG_COUNTER\n"
    },
    {
        "begin_line": 214,
        "end_line": 214,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_COUNTER",
        "snippet": "#   define CATCH_CONFIG_COUNTER\n"
    },
    {
        "begin_line": 217,
        "end_line": 217,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_WINDOWS_SEH",
        "snippet": "#   define CATCH_CONFIG_WINDOWS_SEH\n"
    },
    {
        "begin_line": 221,
        "end_line": 221,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_POSIX_SIGNALS",
        "snippet": "#   define CATCH_CONFIG_POSIX_SIGNALS\n"
    },
    {
        "begin_line": 225,
        "end_line": 225,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_WCHAR",
        "snippet": "#   define CATCH_CONFIG_WCHAR\n"
    },
    {
        "begin_line": 229,
        "end_line": 229,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS",
        "snippet": "#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n"
    },
    {
        "begin_line": 233,
        "end_line": 233,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS",
        "snippet": "#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS\n"
    },
    {
        "begin_line": 234,
        "end_line": 234,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS",
        "snippet": "#   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS\n"
    },
    {
        "begin_line": 237,
        "end_line": 237,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS",
        "snippet": "#   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\n"
    },
    {
        "begin_line": 238,
        "end_line": 238,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS",
        "snippet": "#   define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n"
    },
    {
        "begin_line": 242,
        "end_line": 242,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_UNIQUE_NAME_LINE2",
        "snippet": "#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line\n"
    },
    {
        "begin_line": 243,
        "end_line": 243,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_UNIQUE_NAME_LINE",
        "snippet": "#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )\n"
    },
    {
        "begin_line": 245,
        "end_line": 245,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_UNIQUE_NAME",
        "snippet": "#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )\n"
    },
    {
        "begin_line": 247,
        "end_line": 247,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_UNIQUE_NAME",
        "snippet": "#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )\n"
    },
    {
        "begin_line": 254,
        "end_line": 306,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct CaseSensitive { enum Choice {\n        Yes,\n        No\n    }; };\n\n    class NonCopyable {\n        NonCopyable( NonCopyable const& )              = delete;\n        NonCopyable( NonCopyable && )                  = delete;\n        NonCopyable& operator = ( NonCopyable const& ) = delete;\n        NonCopyable& operator = ( NonCopyable && )     = delete;\n\n    protected:\n        NonCopyable();\n        virtual ~NonCopyable();\n    };\n\n    struct SourceLineInfo {\n\n        SourceLineInfo() = delete;\n        SourceLineInfo( char const* _file, std::size_t _line ) noexcept\n        :   file( _file ),\n            line( _line )\n        {}\n\n        SourceLineInfo( SourceLineInfo const& other )        = default;\n        SourceLineInfo( SourceLineInfo && )                  = default;\n        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;\n        SourceLineInfo& operator = ( SourceLineInfo && )     = default;\n\n        bool empty() const noexcept;\n        bool operator == ( SourceLineInfo const& other ) const noexcept;\n        bool operator < ( SourceLineInfo const& other ) const noexcept;\n\n        char const* file;\n        std::size_t line;\n    };\n\n    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );\n\n    // Use this in variadic streaming macros to allow\n    //    >> +StreamEndStop\n    // as well as\n    //    >> stuff +StreamEndStop\n    struct StreamEndStop {\n        std::string operator+() const;\n    };\n    template<typename T>\n    T const& operator + ( T const& value, StreamEndStop ) {\n        return value;\n    }\n}\n"
    },
    {
        "begin_line": 256,
        "end_line": 259,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CaseSensitive",
        "snippet": "    struct CaseSensitive { enum Choice {\n        Yes,\n        No\n    }; };\n"
    },
    {
        "begin_line": 256,
        "end_line": 259,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Choice",
        "snippet": "    struct CaseSensitive { enum Choice {\n        Yes,\n        No\n    }; };\n"
    },
    {
        "begin_line": 261,
        "end_line": 270,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NonCopyable",
        "snippet": "    class NonCopyable {\n        NonCopyable( NonCopyable const& )              = delete;\n        NonCopyable( NonCopyable && )                  = delete;\n        NonCopyable& operator = ( NonCopyable const& ) = delete;\n        NonCopyable& operator = ( NonCopyable && )     = delete;\n\n    protected:\n        NonCopyable();\n        virtual ~NonCopyable();\n    };\n"
    },
    {
        "begin_line": 272,
        "end_line": 291,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SourceLineInfo",
        "snippet": "    struct SourceLineInfo {\n\n        SourceLineInfo() = delete;\n        SourceLineInfo( char const* _file, std::size_t _line ) noexcept\n        :   file( _file ),\n            line( _line )\n        {}\n\n        SourceLineInfo( SourceLineInfo const& other )        = default;\n        SourceLineInfo( SourceLineInfo && )                  = default;\n        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;\n        SourceLineInfo& operator = ( SourceLineInfo && )     = default;\n\n        bool empty() const noexcept;\n        bool operator == ( SourceLineInfo const& other ) const noexcept;\n        bool operator < ( SourceLineInfo const& other ) const noexcept;\n\n        char const* file;\n        std::size_t line;\n    };\n"
    },
    {
        "begin_line": 275,
        "end_line": 278,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SourceLineInfo",
        "snippet": "        SourceLineInfo( char const* _file, std::size_t _line ) noexcept\n        :   file( _file ),\n            line( _line )\n        {}\n"
    },
    {
        "begin_line": 289,
        "end_line": 289,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "file",
        "snippet": "        char const* file;\n"
    },
    {
        "begin_line": 290,
        "end_line": 290,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "line",
        "snippet": "        std::size_t line;\n"
    },
    {
        "begin_line": 299,
        "end_line": 301,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StreamEndStop",
        "snippet": "    struct StreamEndStop {\n        std::string operator+() const;\n    };\n"
    },
    {
        "begin_line": 303,
        "end_line": 305,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "    T const& operator + ( T const& value, StreamEndStop ) {\n        return value;\n    }\n"
    },
    {
        "begin_line": 308,
        "end_line": 309,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_LINEINFO",
        "snippet": "#define CATCH_INTERNAL_LINEINFO \\\n    ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )\n"
    },
    {
        "begin_line": 312,
        "end_line": 318,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct RegistrarForTagAliases {\n        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 314,
        "end_line": 316,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RegistrarForTagAliases",
        "snippet": "    struct RegistrarForTagAliases {\n        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );\n    };\n"
    },
    {
        "begin_line": 320,
        "end_line": 323,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REGISTER_TAG_ALIAS",
        "snippet": "#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \\\n    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n    namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \\\n    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n"
    },
    {
        "begin_line": 333,
        "end_line": 357,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class TestSpec;\n\n    struct ITestInvoker {\n        virtual void invoke () const = 0;\n        virtual ~ITestInvoker();\n    };\n\n    using ITestCasePtr = std::shared_ptr<ITestInvoker>;\n\n    class TestCase;\n    struct IConfig;\n\n    struct ITestCaseRegistry {\n        virtual ~ITestCaseRegistry();\n        virtual std::vector<TestCase> const& getAllTests() const = 0;\n        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;\n    };\n\n    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );\n    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );\n\n}\n"
    },
    {
        "begin_line": 337,
        "end_line": 340,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ITestInvoker",
        "snippet": "    struct ITestInvoker {\n        virtual void invoke () const = 0;\n        virtual ~ITestInvoker();\n    };\n"
    },
    {
        "begin_line": 347,
        "end_line": 351,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ITestCaseRegistry",
        "snippet": "    struct ITestCaseRegistry {\n        virtual ~ITestCaseRegistry();\n        virtual std::vector<TestCase> const& getAllTests() const = 0;\n        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;\n    };\n"
    },
    {
        "begin_line": 366,
        "end_line": 479,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class StringData;\n\n    /// A non-owning string class (similar to the forthcoming std::string_view)\n    /// Note that, because a StringRef may be a substring of another string,\n    /// it may not be null terminated. c_str() must return a null terminated\n    /// string, however, and so the StringRef will internally take ownership\n    /// (taking a copy), if necessary. In theory this ownership is not externally\n    /// visible - but it does mean (substring) StringRefs should not be shared between\n    /// threads.\n    class StringRef {\n    public:\n        using size_type = std::size_t;\n\n    private:\n        friend struct StringRefTestAccess;\n\n        char const* m_start;\n        size_type m_size;\n\n        char* m_data = nullptr;\n\n        void takeOwnership();\n\n        static constexpr char const* const s_empty = \"\";\n\n    public: // construction/ assignment\n        StringRef() noexcept\n        :   StringRef( s_empty, 0 )\n        {}\n\n        StringRef( StringRef const& other ) noexcept\n        :   m_start( other.m_start ),\n            m_size( other.m_size )\n        {}\n\n        StringRef( StringRef&& other ) noexcept\n        :   m_start( other.m_start ),\n            m_size( other.m_size ),\n            m_data( other.m_data )\n        {\n            other.m_data = nullptr;\n        }\n\n        StringRef( char const* rawChars ) noexcept;\n\n        StringRef( char const* rawChars, size_type size ) noexcept\n        :   m_start( rawChars ),\n            m_size( size )\n        {}\n\n        StringRef( std::string const& stdString ) noexcept\n        :   m_start( stdString.c_str() ),\n            m_size( stdString.size() )\n        {}\n\n        ~StringRef() noexcept {\n            delete[] m_data;\n        }\n\n        auto operator = ( StringRef const &other ) noexcept -> StringRef& {\n            delete[] m_data;\n            m_data = nullptr;\n            m_start = other.m_start;\n            m_size = other.m_size;\n            return *this;\n        }\n\n        operator std::string() const;\n\n        void swap( StringRef& other ) noexcept;\n\n    public: // operators\n        auto operator == ( StringRef const& other ) const noexcept -> bool;\n        auto operator != ( StringRef const& other ) const noexcept -> bool;\n\n        auto operator[] ( size_type index ) const noexcept -> char;\n\n    public: // named queries\n        auto empty() const noexcept -> bool {\n            return m_size == 0;\n        }\n        auto size() const noexcept -> size_type {\n            return m_size;\n        }\n\n        auto numberOfCharacters() const noexcept -> size_type;\n        auto c_str() const -> char const*;\n\n    public: // substrings and searches\n        auto substr( size_type start, size_type size ) const noexcept -> StringRef;\n\n        // Returns the current start pointer.\n        // Note that the pointer can change when if the StringRef is a substring\n        auto currentData() const noexcept -> char const*;\n\n    private: // ownership queries - may not be consistent between calls\n        auto isOwned() const noexcept -> bool;\n        auto isSubstring() const noexcept -> bool;\n    };\n\n    auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::string;\n    auto operator + ( StringRef const& lhs, char const* rhs ) -> std::string;\n    auto operator + ( char const* lhs, StringRef const& rhs ) -> std::string;\n\n    auto operator += ( std::string& lhs, StringRef const& sr ) -> std::string&;\n    auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;\n\n    inline auto operator \"\" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {\n        return StringRef( rawChars, size );\n    }\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 377,
        "end_line": 466,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringRef",
        "snippet": "    class StringRef {\n    public:\n        using size_type = std::size_t;\n\n    private:\n        friend struct StringRefTestAccess;\n\n        char const* m_start;\n        size_type m_size;\n\n        char* m_data = nullptr;\n\n        void takeOwnership();\n\n        static constexpr char const* const s_empty = \"\";\n\n    public: // construction/ assignment\n        StringRef() noexcept\n        :   StringRef( s_empty, 0 )\n        {}\n\n        StringRef( StringRef const& other ) noexcept\n        :   m_start( other.m_start ),\n            m_size( other.m_size )\n        {}\n\n        StringRef( StringRef&& other ) noexcept\n        :   m_start( other.m_start ),\n            m_size( other.m_size ),\n            m_data( other.m_data )\n        {\n            other.m_data = nullptr;\n        }\n\n        StringRef( char const* rawChars ) noexcept;\n\n        StringRef( char const* rawChars, size_type size ) noexcept\n        :   m_start( rawChars ),\n            m_size( size )\n        {}\n\n        StringRef( std::string const& stdString ) noexcept\n        :   m_start( stdString.c_str() ),\n            m_size( stdString.size() )\n        {}\n\n        ~StringRef() noexcept {\n            delete[] m_data;\n        }\n\n        auto operator = ( StringRef const &other ) noexcept -> StringRef& {\n            delete[] m_data;\n            m_data = nullptr;\n            m_start = other.m_start;\n            m_size = other.m_size;\n            return *this;\n        }\n\n        operator std::string() const;\n\n        void swap( StringRef& other ) noexcept;\n\n    public: // operators\n        auto operator == ( StringRef const& other ) const noexcept -> bool;\n        auto operator != ( StringRef const& other ) const noexcept -> bool;\n\n        auto operator[] ( size_type index ) const noexcept -> char;\n\n    public: // named queries\n        auto empty() const noexcept -> bool {\n            return m_size == 0;\n        }\n        auto size() const noexcept -> size_type {\n            return m_size;\n        }\n\n        auto numberOfCharacters() const noexcept -> size_type;\n        auto c_str() const -> char const*;\n\n    public: // substrings and searches\n        auto substr( size_type start, size_type size ) const noexcept -> StringRef;\n\n        // Returns the current start pointer.\n        // Note that the pointer can change when if the StringRef is a substring\n        auto currentData() const noexcept -> char const*;\n\n    private: // ownership queries - may not be consistent between calls\n        auto isOwned() const noexcept -> bool;\n        auto isSubstring() const noexcept -> bool;\n    };\n"
    },
    {
        "begin_line": 384,
        "end_line": 384,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_start",
        "snippet": "        char const* m_start;\n"
    },
    {
        "begin_line": 385,
        "end_line": 385,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_size",
        "snippet": "        size_type m_size;\n"
    },
    {
        "begin_line": 387,
        "end_line": 387,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_data",
        "snippet": "        char* m_data = nullptr;\n"
    },
    {
        "begin_line": 391,
        "end_line": 391,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "s_empty",
        "snippet": "        static constexpr char const* const s_empty = \"\";\n"
    },
    {
        "begin_line": 394,
        "end_line": 396,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringRef",
        "snippet": "        StringRef() noexcept\n        :   StringRef( s_empty, 0 )\n        {}\n"
    },
    {
        "begin_line": 398,
        "end_line": 401,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringRef",
        "snippet": "        StringRef( StringRef const& other ) noexcept\n        :   m_start( other.m_start ),\n            m_size( other.m_size )\n        {}\n"
    },
    {
        "begin_line": 403,
        "end_line": 409,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringRef",
        "snippet": "        StringRef( StringRef&& other ) noexcept\n        :   m_start( other.m_start ),\n            m_size( other.m_size ),\n            m_data( other.m_data )\n        {\n            other.m_data = nullptr;\n        }\n"
    },
    {
        "begin_line": 413,
        "end_line": 416,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringRef",
        "snippet": "        StringRef( char const* rawChars, size_type size ) noexcept\n        :   m_start( rawChars ),\n            m_size( size )\n        {}\n"
    },
    {
        "begin_line": 418,
        "end_line": 421,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringRef",
        "snippet": "        StringRef( std::string const& stdString ) noexcept\n        :   m_start( stdString.c_str() ),\n            m_size( stdString.size() )\n        {}\n"
    },
    {
        "begin_line": 423,
        "end_line": 425,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~StringRef",
        "snippet": "        ~StringRef() noexcept {\n            delete[] m_data;\n        }\n"
    },
    {
        "begin_line": 427,
        "end_line": 433,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator =",
        "snippet": "        auto operator = ( StringRef const &other ) noexcept -> StringRef& {\n            delete[] m_data;\n            m_data = nullptr;\n            m_start = other.m_start;\n            m_size = other.m_size;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 446,
        "end_line": 448,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "empty",
        "snippet": "        auto empty() const noexcept -> bool {\n            return m_size == 0;\n        }\n"
    },
    {
        "begin_line": 449,
        "end_line": 451,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "size",
        "snippet": "        auto size() const noexcept -> size_type {\n            return m_size;\n        }\n"
    },
    {
        "begin_line": 475,
        "end_line": 477,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator \"\"_sr",
        "snippet": "    inline auto operator \"\" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {\n        return StringRef( rawChars, size );\n    }\n"
    },
    {
        "begin_line": 482,
        "end_line": 514,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\ntemplate<typename C>\nclass TestInvokerAsMethod : public ITestInvoker {\n    void (C::*m_testAsMethod)();\npublic:\n    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}\n\n    void invoke() const override {\n        C obj;\n        (obj.*m_testAsMethod)();\n    }\n};\n\nauto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker*;\n\ntemplate<typename C>\nauto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -> ITestInvoker* {\n    return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );\n}\n\nstruct NameAndTags {\n    NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;\n    StringRef name;\n    StringRef tags;\n};\n\nstruct AutoReg : NonCopyable {\n    AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;\n    ~AutoReg();\n};\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 485,
        "end_line": 494,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestInvokerAsMethod",
        "snippet": "class TestInvokerAsMethod : public ITestInvoker {\n    void (C::*m_testAsMethod)();\npublic:\n    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}\n\n    void invoke() const override {\n        C obj;\n        (obj.*m_testAsMethod)();\n    }\n};\n"
    },
    {
        "begin_line": 486,
        "end_line": 486,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testAsMethod",
        "snippet": "    void (C::*m_testAsMethod)();\n"
    },
    {
        "begin_line": 488,
        "end_line": 488,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestInvokerAsMethod",
        "snippet": "    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}\n"
    },
    {
        "begin_line": 490,
        "end_line": 493,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invoke",
        "snippet": "    void invoke() const override {\n        C obj;\n        (obj.*m_testAsMethod)();\n    }\n"
    },
    {
        "begin_line": 499,
        "end_line": 501,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeTestInvoker",
        "snippet": "auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -> ITestInvoker* {\n    return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );\n}\n"
    },
    {
        "begin_line": 503,
        "end_line": 507,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NameAndTags",
        "snippet": "struct NameAndTags {\n    NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;\n    StringRef name;\n    StringRef tags;\n};\n"
    },
    {
        "begin_line": 505,
        "end_line": 505,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "    StringRef name;\n"
    },
    {
        "begin_line": 506,
        "end_line": 506,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "tags",
        "snippet": "    StringRef tags;\n"
    },
    {
        "begin_line": 509,
        "end_line": 512,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AutoReg",
        "snippet": "struct AutoReg : NonCopyable {\n    AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;\n    ~AutoReg();\n};\n"
    },
    {
        "begin_line": 517,
        "end_line": 518,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TESTCASE_NO_REGISTRATION",
        "snippet": "    #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \\\n        static void TestName()\n"
    },
    {
        "begin_line": 519,
        "end_line": 525,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION",
        "snippet": "    #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \\\n        namespace{                        \\\n            struct TestName : ClassName { \\\n                void test();              \\\n            };                            \\\n        }                                 \\\n        void TestName::test()\n"
    },
    {
        "begin_line": 530,
        "end_line": 535,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TESTCASE2",
        "snippet": "    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \\\n        static void TestName(); \\\n        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, \"\", Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \\\n        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n        static void TestName()\n"
    },
    {
        "begin_line": 536,
        "end_line": 537,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TESTCASE",
        "snippet": "    #define INTERNAL_CATCH_TESTCASE( ... ) \\\n        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )\n"
    },
    {
        "begin_line": 540,
        "end_line": 543,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_METHOD_AS_TEST_CASE",
        "snippet": "    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\\n        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, \"&\" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \\\n        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n"
    },
    {
        "begin_line": 546,
        "end_line": 555,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TEST_CASE_METHOD2",
        "snippet": "    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\\n        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n        namespace{ \\\n            struct TestName : ClassName{ \\\n                void test(); \\\n            }; \\\n            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \\\n        } \\\n        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n        void TestName::test()\n"
    },
    {
        "begin_line": 556,
        "end_line": 557,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TEST_CASE_METHOD",
        "snippet": "    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \\\n        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 560,
        "end_line": 563,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_REGISTER_TESTCASE",
        "snippet": "    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \\\n        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n        Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, \"\", Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \\\n        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n"
    },
    {
        "begin_line": 574,
        "end_line": 615,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    // ResultWas::OfType enum\n    struct ResultWas { enum OfType {\n        Unknown = -1,\n        Ok = 0,\n        Info = 1,\n        Warning = 2,\n\n        FailureBit = 0x10,\n\n        ExpressionFailed = FailureBit | 1,\n        ExplicitFailure = FailureBit | 2,\n\n        Exception = 0x100 | FailureBit,\n\n        ThrewException = Exception | 1,\n        DidntThrowException = Exception | 2,\n\n        FatalErrorCondition = 0x200 | FailureBit\n\n    }; };\n\n    bool isOk( ResultWas::OfType resultType );\n    bool isJustInfo( int flags );\n\n    // ResultDisposition::Flags enum\n    struct ResultDisposition { enum Flags {\n        Normal = 0x01,\n\n        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues\n        FalseTest = 0x04,           // Prefix expression with !\n        SuppressFail = 0x08         // Failures are reported but do not fail the test\n    }; };\n\n    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );\n\n    bool shouldContinueOnFailure( int flags );\n    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }\n    bool shouldSuppressFailure( int flags );\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 577,
        "end_line": 595,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultWas",
        "snippet": "    struct ResultWas { enum OfType {\n        Unknown = -1,\n        Ok = 0,\n        Info = 1,\n        Warning = 2,\n\n        FailureBit = 0x10,\n\n        ExpressionFailed = FailureBit | 1,\n        ExplicitFailure = FailureBit | 2,\n\n        Exception = 0x100 | FailureBit,\n\n        ThrewException = Exception | 1,\n        DidntThrowException = Exception | 2,\n\n        FatalErrorCondition = 0x200 | FailureBit\n\n    }; };\n"
    },
    {
        "begin_line": 577,
        "end_line": 595,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OfType",
        "snippet": "    struct ResultWas { enum OfType {\n        Unknown = -1,\n        Ok = 0,\n        Info = 1,\n        Warning = 2,\n\n        FailureBit = 0x10,\n\n        ExpressionFailed = FailureBit | 1,\n        ExplicitFailure = FailureBit | 2,\n\n        Exception = 0x100 | FailureBit,\n\n        ThrewException = Exception | 1,\n        DidntThrowException = Exception | 2,\n\n        FatalErrorCondition = 0x200 | FailureBit\n\n    }; };\n"
    },
    {
        "begin_line": 601,
        "end_line": 607,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultDisposition",
        "snippet": "    struct ResultDisposition { enum Flags {\n        Normal = 0x01,\n\n        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues\n        FalseTest = 0x04,           // Prefix expression with !\n        SuppressFail = 0x08         // Failures are reported but do not fail the test\n    }; };\n"
    },
    {
        "begin_line": 601,
        "end_line": 607,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Flags",
        "snippet": "    struct ResultDisposition { enum Flags {\n        Normal = 0x01,\n\n        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues\n        FalseTest = 0x04,           // Prefix expression with !\n        SuppressFail = 0x08         // Failures are reported but do not fail the test\n    }; };\n"
    },
    {
        "begin_line": 612,
        "end_line": 612,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isFalseTest",
        "snippet": "    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }\n"
    },
    {
        "begin_line": 618,
        "end_line": 632,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct AssertionInfo\n    {\n        StringRef macroName;\n        SourceLineInfo lineInfo;\n        StringRef capturedExpression;\n        ResultDisposition::Flags resultDisposition;\n\n        // We want to delete this constructor but a compiler bug in 4.8 means\n        // the struct is then treated as non-aggregate\n        //AssertionInfo() = delete;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 620,
        "end_line": 630,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionInfo",
        "snippet": "    struct AssertionInfo\n    {\n        StringRef macroName;\n        SourceLineInfo lineInfo;\n        StringRef capturedExpression;\n        ResultDisposition::Flags resultDisposition;\n\n        // We want to delete this constructor but a compiler bug in 4.8 means\n        // the struct is then treated as non-aggregate\n        //AssertionInfo() = delete;\n    };\n"
    },
    {
        "begin_line": 622,
        "end_line": 622,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "macroName",
        "snippet": "        StringRef macroName;\n"
    },
    {
        "begin_line": 623,
        "end_line": 623,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lineInfo",
        "snippet": "        SourceLineInfo lineInfo;\n"
    },
    {
        "begin_line": 624,
        "end_line": 624,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "capturedExpression",
        "snippet": "        StringRef capturedExpression;\n"
    },
    {
        "begin_line": 625,
        "end_line": 625,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "resultDisposition",
        "snippet": "        ResultDisposition::Flags resultDisposition;\n"
    },
    {
        "begin_line": 649,
        "end_line": 682,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    std::ostream& cout();\n    std::ostream& cerr();\n    std::ostream& clog();\n\n    class StringRef;\n\n    struct IStream {\n        virtual ~IStream();\n        virtual std::ostream& stream() const = 0;\n    };\n\n    auto makeStream( StringRef const &filename ) -> IStream const*;\n\n    class ReusableStringStream {\n        std::size_t m_index;\n        std::ostream* m_oss;\n    public:\n        ReusableStringStream();\n        ~ReusableStringStream();\n\n        auto str() const -> std::string;\n\n        template<typename T>\n        auto operator << ( T const& value ) -> ReusableStringStream& {\n            *m_oss << value;\n            return *this;\n        }\n        auto get() -> std::ostream& { return *m_oss; }\n\n        static void cleanup();\n    };\n}\n"
    },
    {
        "begin_line": 657,
        "end_line": 660,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IStream",
        "snippet": "    struct IStream {\n        virtual ~IStream();\n        virtual std::ostream& stream() const = 0;\n    };\n"
    },
    {
        "begin_line": 664,
        "end_line": 681,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReusableStringStream",
        "snippet": "    class ReusableStringStream {\n        std::size_t m_index;\n        std::ostream* m_oss;\n    public:\n        ReusableStringStream();\n        ~ReusableStringStream();\n\n        auto str() const -> std::string;\n\n        template<typename T>\n        auto operator << ( T const& value ) -> ReusableStringStream& {\n            *m_oss << value;\n            return *this;\n        }\n        auto get() -> std::ostream& { return *m_oss; }\n\n        static void cleanup();\n    };\n"
    },
    {
        "begin_line": 665,
        "end_line": 665,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_index",
        "snippet": "        std::size_t m_index;\n"
    },
    {
        "begin_line": 666,
        "end_line": 666,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_oss",
        "snippet": "        std::ostream* m_oss;\n"
    },
    {
        "begin_line": 674,
        "end_line": 677,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "        auto operator << ( T const& value ) -> ReusableStringStream& {\n            *m_oss << value;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 678,
        "end_line": 678,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "get",
        "snippet": "        auto get() -> std::ostream& { return *m_oss; }\n"
    },
    {
        "begin_line": 692,
        "end_line": 692,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ARC_ENABLED",
        "snippet": "#define CATCH_ARC_ENABLED __has_feature(objc_arc)\n"
    },
    {
        "begin_line": 694,
        "end_line": 694,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ARC_ENABLED",
        "snippet": "#define CATCH_ARC_ENABLED 0\n"
    },
    {
        "begin_line": 701,
        "end_line": 703,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "arcSafeRelease",
        "snippet": "inline void arcSafeRelease( NSObject* obj ) {\n    [obj release];\n}\n"
    },
    {
        "begin_line": 704,
        "end_line": 708,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "performOptionalSelector",
        "snippet": "inline id performOptionalSelector( id obj, SEL sel ) {\n    if( [obj respondsToSelector: sel] )\n        return [obj performSelector: sel];\n    return nil;\n}\n"
    },
    {
        "begin_line": 709,
        "end_line": 709,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_UNSAFE_UNRETAINED",
        "snippet": "#define CATCH_UNSAFE_UNRETAINED\n"
    },
    {
        "begin_line": 710,
        "end_line": 710,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ARC_STRONG",
        "snippet": "#define CATCH_ARC_STRONG\n"
    },
    {
        "begin_line": 712,
        "end_line": 712,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "arcSafeRelease",
        "snippet": "inline void arcSafeRelease( NSObject* ){}\n"
    },
    {
        "begin_line": 713,
        "end_line": 724,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "performOptionalSelector",
        "snippet": "inline id performOptionalSelector( id obj, SEL sel ) {\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n#endif\n    if( [obj respondsToSelector: sel] )\n        return [obj performSelector: sel];\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n    return nil;\n}\n"
    },
    {
        "begin_line": 725,
        "end_line": 725,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_UNSAFE_UNRETAINED",
        "snippet": "#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained\n"
    },
    {
        "begin_line": 726,
        "end_line": 726,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ARC_STRONG",
        "snippet": "#define CATCH_ARC_STRONG __strong\n"
    },
    {
        "begin_line": 738,
        "end_line": 738,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch_global_namespace_dummy",
        "snippet": "struct Catch_global_namespace_dummy {};\n"
    },
    {
        "begin_line": 741,
        "end_line": 1025,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    // Bring in operator<< from global namespace into Catch namespace\n    using ::operator<<;\n\n    namespace Detail {\n\n        extern const std::string unprintableString;\n\n        std::string rawMemoryToString( const void *object, std::size_t size );\n\n        template<typename T>\n        std::string rawMemoryToString( const T& object ) {\n          return rawMemoryToString( &object, sizeof(object) );\n        }\n\n        template<typename T>\n        class IsStreamInsertable {\n            template<typename SS, typename TT>\n            static auto test(int)\n                -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());\n\n            template<typename, typename>\n            static auto test(...)->std::false_type;\n\n        public:\n            static const bool value = decltype(test<std::ostream, const T&>(0))::value;\n        };\n\n        template<typename E>\n        std::string convertUnknownEnumToString( E e );\n\n        template<typename T>\n        typename std::enable_if<!std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {\n#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)\n            (void)value;\n            return Detail::unprintableString;\n#else\n            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\n#endif\n        }\n        template<typename T>\n        typename std::enable_if<std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {\n            return convertUnknownEnumToString( value );\n        }\n\n#if defined(_MANAGED)\n        //! Convert a CLR string to a utf8 std::string\n        template<typename T>\n        std::string clrReferenceToString( T^ ref ) {\n            if (ref == nullptr)\n                return std::string(\"null\");\n            auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());\n            cli::pin_ptr<System::Byte> p = &bytes[0];\n            return std::string(reinterpret_cast<char const *>(p), bytes->Length);\n        }\n#endif\n\n    } // namespace Detail\n\n    // If we decide for C++14, change these to enable_if_ts\n    template <typename T, typename = void>\n    struct StringMaker {\n        template <typename Fake = T>\n        static\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\n            convert(const Fake& value) {\n                ReusableStringStream rss;\n                rss << value;\n                return rss.str();\n        }\n\n        template <typename Fake = T>\n        static\n        typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\n            convert( const Fake& value ) {\n                return Detail::convertUnstreamable( value );\n        }\n    };\n\n    namespace Detail {\n\n        // This function dispatches all stringification requests inside of Catch.\n        // Should be preferably called fully qualified, like ::Catch::Detail::stringify\n        template <typename T>\n        std::string stringify(const T& e) {\n            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\n        }\n\n        template<typename E>\n        std::string convertUnknownEnumToString( E e ) {\n            return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));\n        }\n\n#if defined(_MANAGED)\n        template <typename T>\n        std::string stringify( T^ e ) {\n            return ::Catch::StringMaker<T^>::convert(e);\n        }\n#endif\n\n    } // namespace Detail\n\n    // Some predefined specializations\n\n    template<>\n    struct StringMaker<std::string> {\n        static std::string convert(const std::string& str);\n    };\n#ifdef CATCH_CONFIG_WCHAR\n    template<>\n    struct StringMaker<std::wstring> {\n        static std::string convert(const std::wstring& wstr);\n    };\n#endif\n\n    template<>\n    struct StringMaker<char const *> {\n        static std::string convert(char const * str);\n    };\n    template<>\n    struct StringMaker<char *> {\n        static std::string convert(char * str);\n    };\n\n#ifdef CATCH_CONFIG_WCHAR\n    template<>\n    struct StringMaker<wchar_t const *> {\n        static std::string convert(wchar_t const * str);\n    };\n    template<>\n    struct StringMaker<wchar_t *> {\n        static std::string convert(wchar_t * str);\n    };\n#endif\n\n    // TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,\n    //      while keeping string semantics?\n    template<int SZ>\n    struct StringMaker<char[SZ]> {\n        static std::string convert(char const* str) {\n            return ::Catch::Detail::stringify(std::string{ str });\n        }\n    };\n    template<int SZ>\n    struct StringMaker<signed char[SZ]> {\n        static std::string convert(signed char const* str) {\n            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });\n        }\n    };\n    template<int SZ>\n    struct StringMaker<unsigned char[SZ]> {\n        static std::string convert(unsigned char const* str) {\n            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });\n        }\n    };\n\n    template<>\n    struct StringMaker<int> {\n        static std::string convert(int value);\n    };\n    template<>\n    struct StringMaker<long> {\n        static std::string convert(long value);\n    };\n    template<>\n    struct StringMaker<long long> {\n        static std::string convert(long long value);\n    };\n    template<>\n    struct StringMaker<unsigned int> {\n        static std::string convert(unsigned int value);\n    };\n    template<>\n    struct StringMaker<unsigned long> {\n        static std::string convert(unsigned long value);\n    };\n    template<>\n    struct StringMaker<unsigned long long> {\n        static std::string convert(unsigned long long value);\n    };\n\n    template<>\n    struct StringMaker<bool> {\n        static std::string convert(bool b);\n    };\n\n    template<>\n    struct StringMaker<char> {\n        static std::string convert(char c);\n    };\n    template<>\n    struct StringMaker<signed char> {\n        static std::string convert(signed char c);\n    };\n    template<>\n    struct StringMaker<unsigned char> {\n        static std::string convert(unsigned char c);\n    };\n\n    template<>\n    struct StringMaker<std::nullptr_t> {\n        static std::string convert(std::nullptr_t);\n    };\n\n    template<>\n    struct StringMaker<float> {\n        static std::string convert(float value);\n    };\n    template<>\n    struct StringMaker<double> {\n        static std::string convert(double value);\n    };\n\n    template <typename T>\n    struct StringMaker<T*> {\n        template <typename U>\n        static std::string convert(U* p) {\n            if (p) {\n                return ::Catch::Detail::rawMemoryToString(p);\n            } else {\n                return \"nullptr\";\n            }\n        }\n    };\n\n    template <typename R, typename C>\n    struct StringMaker<R C::*> {\n        static std::string convert(R C::* p) {\n            if (p) {\n                return ::Catch::Detail::rawMemoryToString(p);\n            } else {\n                return \"nullptr\";\n            }\n        }\n    };\n\n#if defined(_MANAGED)\n    template <typename T>\n    struct StringMaker<T^> {\n        static std::string convert( T^ ref ) {\n            return ::Catch::Detail::clrReferenceToString(ref);\n        }\n    };\n#endif\n\n    namespace Detail {\n        template<typename InputIterator>\n        std::string rangeToString(InputIterator first, InputIterator last) {\n            ReusableStringStream rss;\n            rss << \"{ \";\n            if (first != last) {\n                rss << ::Catch::Detail::stringify(*first);\n                for (++first; first != last; ++first)\n                    rss << \", \" << ::Catch::Detail::stringify(*first);\n            }\n            rss << \" }\";\n            return rss.str();\n        }\n    }\n\n#ifdef __OBJC__\n    template<>\n    struct StringMaker<NSString*> {\n        static std::string convert(NSString * nsstring) {\n            if (!nsstring)\n                return \"nil\";\n            return std::string(\"@\") + [nsstring UTF8String];\n        }\n    };\n    template<>\n    struct StringMaker<NSObject*> {\n        static std::string convert(NSObject* nsObject) {\n            return ::Catch::Detail::stringify([nsObject description]);\n        }\n\n    };\n    namespace Detail {\n        inline std::string stringify( NSString* nsstring ) {\n            return StringMaker<NSString*>::convert( nsstring );\n        }\n\n    } // namespace Detail\n#endif // __OBJC__\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 745,
        "end_line": 798,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "    namespace Detail {\n\n        extern const std::string unprintableString;\n\n        std::string rawMemoryToString( const void *object, std::size_t size );\n\n        template<typename T>\n        std::string rawMemoryToString( const T& object ) {\n          return rawMemoryToString( &object, sizeof(object) );\n        }\n\n        template<typename T>\n        class IsStreamInsertable {\n            template<typename SS, typename TT>\n            static auto test(int)\n                -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());\n\n            template<typename, typename>\n            static auto test(...)->std::false_type;\n\n        public:\n            static const bool value = decltype(test<std::ostream, const T&>(0))::value;\n        };\n\n        template<typename E>\n        std::string convertUnknownEnumToString( E e );\n\n        template<typename T>\n        typename std::enable_if<!std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {\n#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)\n            (void)value;\n            return Detail::unprintableString;\n#else\n            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\n#endif\n        }\n        template<typename T>\n        typename std::enable_if<std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {\n            return convertUnknownEnumToString( value );\n        }\n\n#if defined(_MANAGED)\n        //! Convert a CLR string to a utf8 std::string\n        template<typename T>\n        std::string clrReferenceToString( T^ ref ) {\n            if (ref == nullptr)\n                return std::string(\"null\");\n            auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());\n            cli::pin_ptr<System::Byte> p = &bytes[0];\n            return std::string(reinterpret_cast<char const *>(p), bytes->Length);\n        }\n#endif\n\n    } // namespace Detail\n"
    },
    {
        "begin_line": 752,
        "end_line": 754,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rawMemoryToString",
        "snippet": "        std::string rawMemoryToString( const T& object ) {\n          return rawMemoryToString( &object, sizeof(object) );\n        }\n"
    },
    {
        "begin_line": 757,
        "end_line": 767,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IsStreamInsertable",
        "snippet": "        class IsStreamInsertable {\n            template<typename SS, typename TT>\n            static auto test(int)\n                -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());\n\n            template<typename, typename>\n            static auto test(...)->std::false_type;\n\n        public:\n            static const bool value = decltype(test<std::ostream, const T&>(0))::value;\n        };\n"
    },
    {
        "begin_line": 766,
        "end_line": 766,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "value",
        "snippet": "            static const bool value = decltype(test<std::ostream, const T&>(0))::value;\n"
    },
    {
        "begin_line": 773,
        "end_line": 780,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convertUnstreamable",
        "snippet": "        typename std::enable_if<!std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {\n#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)\n            (void)value;\n            return Detail::unprintableString;\n#else\n            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\n#endif\n        }\n"
    },
    {
        "begin_line": 782,
        "end_line": 784,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convertUnstreamable",
        "snippet": "        typename std::enable_if<std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {\n            return convertUnknownEnumToString( value );\n        }\n"
    },
    {
        "begin_line": 792,
        "end_line": 792,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "bytes",
        "snippet": "            auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());\n"
    },
    {
        "begin_line": 793,
        "end_line": 793,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "p",
        "snippet": "            cli::pin_ptr<System::Byte> p = &bytes[0];\n"
    },
    {
        "begin_line": 802,
        "end_line": 818,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker {\n        template <typename Fake = T>\n        static\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\n            convert(const Fake& value) {\n                ReusableStringStream rss;\n                rss << value;\n                return rss.str();\n        }\n\n        template <typename Fake = T>\n        static\n        typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\n            convert( const Fake& value ) {\n                return Detail::convertUnstreamable( value );\n        }\n    };\n"
    },
    {
        "begin_line": 806,
        "end_line": 810,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "            convert(const Fake& value) {\n                ReusableStringStream rss;\n                rss << value;\n                return rss.str();\n        }\n"
    },
    {
        "begin_line": 815,
        "end_line": 817,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "            convert( const Fake& value ) {\n                return Detail::convertUnstreamable( value );\n        }\n"
    },
    {
        "begin_line": 820,
        "end_line": 841,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "    namespace Detail {\n\n        // This function dispatches all stringification requests inside of Catch.\n        // Should be preferably called fully qualified, like ::Catch::Detail::stringify\n        template <typename T>\n        std::string stringify(const T& e) {\n            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\n        }\n\n        template<typename E>\n        std::string convertUnknownEnumToString( E e ) {\n            return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));\n        }\n\n#if defined(_MANAGED)\n        template <typename T>\n        std::string stringify( T^ e ) {\n            return ::Catch::StringMaker<T^>::convert(e);\n        }\n#endif\n\n    } // namespace Detail\n"
    },
    {
        "begin_line": 825,
        "end_line": 827,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stringify",
        "snippet": "        std::string stringify(const T& e) {\n            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\n        }\n"
    },
    {
        "begin_line": 830,
        "end_line": 832,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convertUnknownEnumToString",
        "snippet": "        std::string convertUnknownEnumToString( E e ) {\n            return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));\n        }\n"
    },
    {
        "begin_line": 846,
        "end_line": 848,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::string> {\n        static std::string convert(const std::string& str);\n    };\n"
    },
    {
        "begin_line": 851,
        "end_line": 853,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::wstring> {\n        static std::string convert(const std::wstring& wstr);\n    };\n"
    },
    {
        "begin_line": 857,
        "end_line": 859,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<char const *> {\n        static std::string convert(char const * str);\n    };\n"
    },
    {
        "begin_line": 861,
        "end_line": 863,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<char *> {\n        static std::string convert(char * str);\n    };\n"
    },
    {
        "begin_line": 867,
        "end_line": 869,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<wchar_t const *> {\n        static std::string convert(wchar_t const * str);\n    };\n"
    },
    {
        "begin_line": 871,
        "end_line": 873,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<wchar_t *> {\n        static std::string convert(wchar_t * str);\n    };\n"
    },
    {
        "begin_line": 879,
        "end_line": 883,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<char[SZ]> {\n        static std::string convert(char const* str) {\n            return ::Catch::Detail::stringify(std::string{ str });\n        }\n    };\n"
    },
    {
        "begin_line": 880,
        "end_line": 882,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(char const* str) {\n            return ::Catch::Detail::stringify(std::string{ str });\n        }\n"
    },
    {
        "begin_line": 885,
        "end_line": 889,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<signed char[SZ]> {\n        static std::string convert(signed char const* str) {\n            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });\n        }\n    };\n"
    },
    {
        "begin_line": 886,
        "end_line": 888,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(signed char const* str) {\n            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });\n        }\n"
    },
    {
        "begin_line": 891,
        "end_line": 895,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<unsigned char[SZ]> {\n        static std::string convert(unsigned char const* str) {\n            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });\n        }\n    };\n"
    },
    {
        "begin_line": 892,
        "end_line": 894,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(unsigned char const* str) {\n            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });\n        }\n"
    },
    {
        "begin_line": 898,
        "end_line": 900,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<int> {\n        static std::string convert(int value);\n    };\n"
    },
    {
        "begin_line": 902,
        "end_line": 904,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<long> {\n        static std::string convert(long value);\n    };\n"
    },
    {
        "begin_line": 906,
        "end_line": 908,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<long long> {\n        static std::string convert(long long value);\n    };\n"
    },
    {
        "begin_line": 910,
        "end_line": 912,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<unsigned int> {\n        static std::string convert(unsigned int value);\n    };\n"
    },
    {
        "begin_line": 914,
        "end_line": 916,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<unsigned long> {\n        static std::string convert(unsigned long value);\n    };\n"
    },
    {
        "begin_line": 918,
        "end_line": 920,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<unsigned long long> {\n        static std::string convert(unsigned long long value);\n    };\n"
    },
    {
        "begin_line": 923,
        "end_line": 925,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<bool> {\n        static std::string convert(bool b);\n    };\n"
    },
    {
        "begin_line": 928,
        "end_line": 930,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<char> {\n        static std::string convert(char c);\n    };\n"
    },
    {
        "begin_line": 932,
        "end_line": 934,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<signed char> {\n        static std::string convert(signed char c);\n    };\n"
    },
    {
        "begin_line": 936,
        "end_line": 938,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<unsigned char> {\n        static std::string convert(unsigned char c);\n    };\n"
    },
    {
        "begin_line": 941,
        "end_line": 943,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::nullptr_t> {\n        static std::string convert(std::nullptr_t);\n    };\n"
    },
    {
        "begin_line": 946,
        "end_line": 948,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<float> {\n        static std::string convert(float value);\n    };\n"
    },
    {
        "begin_line": 950,
        "end_line": 952,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<double> {\n        static std::string convert(double value);\n    };\n"
    },
    {
        "begin_line": 955,
        "end_line": 964,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<T*> {\n        template <typename U>\n        static std::string convert(U* p) {\n            if (p) {\n                return ::Catch::Detail::rawMemoryToString(p);\n            } else {\n                return \"nullptr\";\n            }\n        }\n    };\n"
    },
    {
        "begin_line": 957,
        "end_line": 963,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(U* p) {\n            if (p) {\n                return ::Catch::Detail::rawMemoryToString(p);\n            } else {\n                return \"nullptr\";\n            }\n        }\n"
    },
    {
        "begin_line": 967,
        "end_line": 975,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<R C::*> {\n        static std::string convert(R C::* p) {\n            if (p) {\n                return ::Catch::Detail::rawMemoryToString(p);\n            } else {\n                return \"nullptr\";\n            }\n        }\n    };\n"
    },
    {
        "begin_line": 968,
        "end_line": 974,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(R C::* p) {\n            if (p) {\n                return ::Catch::Detail::rawMemoryToString(p);\n            } else {\n                return \"nullptr\";\n            }\n        }\n"
    },
    {
        "begin_line": 979,
        "end_line": 983,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<T^> {\n        static std::string convert( T^ ref ) {\n            return ::Catch::Detail::clrReferenceToString(ref);\n        }\n    };\n"
    },
    {
        "begin_line": 986,
        "end_line": 999,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "    namespace Detail {\n        template<typename InputIterator>\n        std::string rangeToString(InputIterator first, InputIterator last) {\n            ReusableStringStream rss;\n            rss << \"{ \";\n            if (first != last) {\n                rss << ::Catch::Detail::stringify(*first);\n                for (++first; first != last; ++first)\n                    rss << \", \" << ::Catch::Detail::stringify(*first);\n            }\n            rss << \" }\";\n            return rss.str();\n        }\n    }\n"
    },
    {
        "begin_line": 988,
        "end_line": 998,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rangeToString",
        "snippet": "        std::string rangeToString(InputIterator first, InputIterator last) {\n            ReusableStringStream rss;\n            rss << \"{ \";\n            if (first != last) {\n                rss << ::Catch::Detail::stringify(*first);\n                for (++first; first != last; ++first)\n                    rss << \", \" << ::Catch::Detail::stringify(*first);\n            }\n            rss << \" }\";\n            return rss.str();\n        }\n"
    },
    {
        "begin_line": 1003,
        "end_line": 1009,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<NSString*> {\n        static std::string convert(NSString * nsstring) {\n            if (!nsstring)\n                return \"nil\";\n            return std::string(\"@\") + [nsstring UTF8String];\n        }\n    };\n"
    },
    {
        "begin_line": 1004,
        "end_line": 1008,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(NSString * nsstring) {\n            if (!nsstring)\n                return \"nil\";\n            return std::string(\"@\") + [nsstring UTF8String];\n        }\n"
    },
    {
        "begin_line": 1011,
        "end_line": 1016,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<NSObject*> {\n        static std::string convert(NSObject* nsObject) {\n            return ::Catch::Detail::stringify([nsObject description]);\n        }\n\n    };\n"
    },
    {
        "begin_line": 1012,
        "end_line": 1014,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(NSObject* nsObject) {\n            return ::Catch::Detail::stringify([nsObject description]);\n        }\n"
    },
    {
        "begin_line": 1017,
        "end_line": 1022,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "    namespace Detail {\n        inline std::string stringify( NSString* nsstring ) {\n            return StringMaker<NSString*>::convert( nsstring );\n        }\n\n    } // namespace Detail\n"
    },
    {
        "begin_line": 1018,
        "end_line": 1020,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stringify",
        "snippet": "        inline std::string stringify( NSString* nsstring ) {\n            return StringMaker<NSString*>::convert( nsstring );\n        }\n"
    },
    {
        "begin_line": 1032,
        "end_line": 1032,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER",
        "snippet": "#  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER\n"
    },
    {
        "begin_line": 1033,
        "end_line": 1033,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER",
        "snippet": "#  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER\n"
    },
    {
        "begin_line": 1034,
        "end_line": 1034,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER",
        "snippet": "#  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER\n"
    },
    {
        "begin_line": 1040,
        "end_line": 1053,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    template<typename T1, typename T2>\n    struct StringMaker<std::pair<T1, T2> > {\n        static std::string convert(const std::pair<T1, T2>& pair) {\n            ReusableStringStream rss;\n            rss << \"{ \"\n                << ::Catch::Detail::stringify(pair.first)\n                << \", \"\n                << ::Catch::Detail::stringify(pair.second)\n                << \" }\";\n            return rss.str();\n        }\n    };\n}\n"
    },
    {
        "begin_line": 1042,
        "end_line": 1052,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::pair<T1, T2> > {\n        static std::string convert(const std::pair<T1, T2>& pair) {\n            ReusableStringStream rss;\n            rss << \"{ \"\n                << ::Catch::Detail::stringify(pair.first)\n                << \", \"\n                << ::Catch::Detail::stringify(pair.second)\n                << \" }\";\n            return rss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 1043,
        "end_line": 1051,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(const std::pair<T1, T2>& pair) {\n            ReusableStringStream rss;\n            rss << \"{ \"\n                << ::Catch::Detail::stringify(pair.first)\n                << \", \"\n                << ::Catch::Detail::stringify(pair.second)\n                << \" }\";\n            return rss.str();\n        }\n"
    },
    {
        "begin_line": 1059,
        "end_line": 1094,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    namespace Detail {\n        template<\n            typename Tuple,\n            std::size_t N = 0,\n            bool = (N < std::tuple_size<Tuple>::value)\n            >\n            struct TupleElementPrinter {\n            static void print(const Tuple& tuple, std::ostream& os) {\n                os << (N ? \", \" : \" \")\n                    << ::Catch::Detail::stringify(std::get<N>(tuple));\n                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);\n            }\n        };\n\n        template<\n            typename Tuple,\n            std::size_t N\n        >\n            struct TupleElementPrinter<Tuple, N, false> {\n            static void print(const Tuple&, std::ostream&) {}\n        };\n\n    }\n\n    template<typename ...Types>\n    struct StringMaker<std::tuple<Types...>> {\n        static std::string convert(const std::tuple<Types...>& tuple) {\n            ReusableStringStream rss;\n            rss << '{';\n            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());\n            rss << \" }\";\n            return rss.str();\n        }\n    };\n}\n"
    },
    {
        "begin_line": 1060,
        "end_line": 1082,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "    namespace Detail {\n        template<\n            typename Tuple,\n            std::size_t N = 0,\n            bool = (N < std::tuple_size<Tuple>::value)\n            >\n            struct TupleElementPrinter {\n            static void print(const Tuple& tuple, std::ostream& os) {\n                os << (N ? \", \" : \" \")\n                    << ::Catch::Detail::stringify(std::get<N>(tuple));\n                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);\n            }\n        };\n\n        template<\n            typename Tuple,\n            std::size_t N\n        >\n            struct TupleElementPrinter<Tuple, N, false> {\n            static void print(const Tuple&, std::ostream&) {}\n        };\n\n    }\n"
    },
    {
        "begin_line": 1066,
        "end_line": 1072,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TupleElementPrinter",
        "snippet": "            struct TupleElementPrinter {\n            static void print(const Tuple& tuple, std::ostream& os) {\n                os << (N ? \", \" : \" \")\n                    << ::Catch::Detail::stringify(std::get<N>(tuple));\n                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);\n            }\n        };\n"
    },
    {
        "begin_line": 1067,
        "end_line": 1071,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "print",
        "snippet": "            static void print(const Tuple& tuple, std::ostream& os) {\n                os << (N ? \", \" : \" \")\n                    << ::Catch::Detail::stringify(std::get<N>(tuple));\n                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);\n            }\n"
    },
    {
        "begin_line": 1078,
        "end_line": 1080,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TupleElementPrinter",
        "snippet": "            struct TupleElementPrinter<Tuple, N, false> {\n            static void print(const Tuple&, std::ostream&) {}\n        };\n"
    },
    {
        "begin_line": 1079,
        "end_line": 1079,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "print",
        "snippet": "            static void print(const Tuple&, std::ostream&) {}\n"
    },
    {
        "begin_line": 1085,
        "end_line": 1093,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::tuple<Types...>> {\n        static std::string convert(const std::tuple<Types...>& tuple) {\n            ReusableStringStream rss;\n            rss << '{';\n            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());\n            rss << \" }\";\n            return rss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 1086,
        "end_line": 1092,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(const std::tuple<Types...>& tuple) {\n            ReusableStringStream rss;\n            rss << '{';\n            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());\n            rss << \" }\";\n            return rss.str();\n        }\n"
    },
    {
        "begin_line": 1097,
        "end_line": 1157,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    struct not_this_one {}; // Tag type for detecting which begin/ end are being selected\n\n    // Import begin/ end from std here so they are considered alongside the fallback (...) overloads in this namespace\n    using std::begin;\n    using std::end;\n\n    not_this_one begin( ... );\n    not_this_one end( ... );\n\n    template <typename T>\n    struct is_range {\n        static const bool value =\n            !std::is_same<decltype(begin(std::declval<T>())), not_this_one>::value &&\n            !std::is_same<decltype(end(std::declval<T>())), not_this_one>::value;\n    };\n\n#if defined(_MANAGED) // Managed types are never ranges\n    template <typename T>\n    struct is_range<T^> {\n        static const bool value = false;\n    };\n#endif\n\n    template<typename Range>\n    std::string rangeToString( Range const& range ) {\n        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );\n    }\n\n    // Handle vector<bool> specially\n    template<typename Allocator>\n    std::string rangeToString( std::vector<bool, Allocator> const& v ) {\n        ReusableStringStream rss;\n        rss << \"{ \";\n        bool first = true;\n        for( bool b : v ) {\n            if( first )\n                first = false;\n            else\n                rss << \", \";\n            rss << ::Catch::Detail::stringify( b );\n        }\n        rss << \" }\";\n        return rss.str();\n    }\n\n    template<typename R>\n    struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {\n        static std::string convert( R const& range ) {\n            return rangeToString( range );\n        }\n    };\n\n    template <typename T, int SZ>\n    struct StringMaker<T[SZ]> {\n        static std::string convert(T const(&arr)[SZ]) {\n            return rangeToString(arr);\n        }\n    };\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 1098,
        "end_line": 1098,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "not_this_one",
        "snippet": "    struct not_this_one {}; // Tag type for detecting which begin/ end are being selected\n"
    },
    {
        "begin_line": 1108,
        "end_line": 1112,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "is_range",
        "snippet": "    struct is_range {\n        static const bool value =\n            !std::is_same<decltype(begin(std::declval<T>())), not_this_one>::value &&\n            !std::is_same<decltype(end(std::declval<T>())), not_this_one>::value;\n    };\n"
    },
    {
        "begin_line": 1116,
        "end_line": 1118,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "is_range",
        "snippet": "    struct is_range<T^> {\n        static const bool value = false;\n    };\n"
    },
    {
        "begin_line": 1117,
        "end_line": 1117,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "value",
        "snippet": "        static const bool value = false;\n"
    },
    {
        "begin_line": 1122,
        "end_line": 1124,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rangeToString",
        "snippet": "    std::string rangeToString( Range const& range ) {\n        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );\n    }\n"
    },
    {
        "begin_line": 1128,
        "end_line": 1141,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rangeToString",
        "snippet": "    std::string rangeToString( std::vector<bool, Allocator> const& v ) {\n        ReusableStringStream rss;\n        rss << \"{ \";\n        bool first = true;\n        for( bool b : v ) {\n            if( first )\n                first = false;\n            else\n                rss << \", \";\n            rss << ::Catch::Detail::stringify( b );\n        }\n        rss << \" }\";\n        return rss.str();\n    }\n"
    },
    {
        "begin_line": 1144,
        "end_line": 1148,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {\n        static std::string convert( R const& range ) {\n            return rangeToString( range );\n        }\n    };\n"
    },
    {
        "begin_line": 1145,
        "end_line": 1147,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert( R const& range ) {\n            return rangeToString( range );\n        }\n"
    },
    {
        "begin_line": 1151,
        "end_line": 1155,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<T[SZ]> {\n        static std::string convert(T const(&arr)[SZ]) {\n            return rangeToString(arr);\n        }\n    };\n"
    },
    {
        "begin_line": 1152,
        "end_line": 1154,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(T const(&arr)[SZ]) {\n            return rangeToString(arr);\n        }\n"
    },
    {
        "begin_line": 1165,
        "end_line": 1273,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\ntemplate <class Ratio>\nstruct ratio_string {\n    static std::string symbol();\n};\n\ntemplate <class Ratio>\nstd::string ratio_string<Ratio>::symbol() {\n    Catch::ReusableStringStream rss;\n    rss << '[' << Ratio::num << '/'\n        << Ratio::den << ']';\n    return rss.str();\n}\ntemplate <>\nstruct ratio_string<std::atto> {\n    static std::string symbol();\n};\ntemplate <>\nstruct ratio_string<std::femto> {\n    static std::string symbol();\n};\ntemplate <>\nstruct ratio_string<std::pico> {\n    static std::string symbol();\n};\ntemplate <>\nstruct ratio_string<std::nano> {\n    static std::string symbol();\n};\ntemplate <>\nstruct ratio_string<std::micro> {\n    static std::string symbol();\n};\ntemplate <>\nstruct ratio_string<std::milli> {\n    static std::string symbol();\n};\n\n    ////////////\n    // std::chrono::duration specializations\n    template<typename Value, typename Ratio>\n    struct StringMaker<std::chrono::duration<Value, Ratio>> {\n        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';\n            return rss.str();\n        }\n    };\n    template<typename Value>\n    struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {\n        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" s\";\n            return rss.str();\n        }\n    };\n    template<typename Value>\n    struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {\n        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" m\";\n            return rss.str();\n        }\n    };\n    template<typename Value>\n    struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {\n        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" h\";\n            return rss.str();\n        }\n    };\n\n    ////////////\n    // std::chrono::time_point specialization\n    // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>\n    template<typename Clock, typename Duration>\n    struct StringMaker<std::chrono::time_point<Clock, Duration>> {\n        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {\n            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + \" since epoch\";\n        }\n    };\n    // std::chrono::time_point<system_clock> specialization\n    template<typename Duration>\n    struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {\n        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {\n            auto converted = std::chrono::system_clock::to_time_t(time_point);\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &converted);\n#else\n            std::tm* timeInfo = std::gmtime(&converted);\n#endif\n\n            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp);\n        }\n    };\n}\n"
    },
    {
        "begin_line": 1168,
        "end_line": 1170,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ratio_string",
        "snippet": "struct ratio_string {\n    static std::string symbol();\n};\n"
    },
    {
        "begin_line": 1173,
        "end_line": 1178,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "symbol",
        "snippet": "std::string ratio_string<Ratio>::symbol() {\n    Catch::ReusableStringStream rss;\n    rss << '[' << Ratio::num << '/'\n        << Ratio::den << ']';\n    return rss.str();\n}\n"
    },
    {
        "begin_line": 1180,
        "end_line": 1182,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ratio_string",
        "snippet": "struct ratio_string<std::atto> {\n    static std::string symbol();\n};\n"
    },
    {
        "begin_line": 1184,
        "end_line": 1186,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ratio_string",
        "snippet": "struct ratio_string<std::femto> {\n    static std::string symbol();\n};\n"
    },
    {
        "begin_line": 1188,
        "end_line": 1190,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ratio_string",
        "snippet": "struct ratio_string<std::pico> {\n    static std::string symbol();\n};\n"
    },
    {
        "begin_line": 1192,
        "end_line": 1194,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ratio_string",
        "snippet": "struct ratio_string<std::nano> {\n    static std::string symbol();\n};\n"
    },
    {
        "begin_line": 1196,
        "end_line": 1198,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ratio_string",
        "snippet": "struct ratio_string<std::micro> {\n    static std::string symbol();\n};\n"
    },
    {
        "begin_line": 1200,
        "end_line": 1202,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ratio_string",
        "snippet": "struct ratio_string<std::milli> {\n    static std::string symbol();\n};\n"
    },
    {
        "begin_line": 1207,
        "end_line": 1213,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::chrono::duration<Value, Ratio>> {\n        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';\n            return rss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 1208,
        "end_line": 1212,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';\n            return rss.str();\n        }\n"
    },
    {
        "begin_line": 1215,
        "end_line": 1221,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {\n        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" s\";\n            return rss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 1216,
        "end_line": 1220,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" s\";\n            return rss.str();\n        }\n"
    },
    {
        "begin_line": 1223,
        "end_line": 1229,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {\n        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" m\";\n            return rss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 1224,
        "end_line": 1228,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" m\";\n            return rss.str();\n        }\n"
    },
    {
        "begin_line": 1231,
        "end_line": 1237,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {\n        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" h\";\n            return rss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 1232,
        "end_line": 1236,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {\n            ReusableStringStream rss;\n            rss << duration.count() << \" h\";\n            return rss.str();\n        }\n"
    },
    {
        "begin_line": 1243,
        "end_line": 1247,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::chrono::time_point<Clock, Duration>> {\n        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {\n            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + \" since epoch\";\n        }\n    };\n"
    },
    {
        "begin_line": 1244,
        "end_line": 1246,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {\n            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + \" since epoch\";\n        }\n"
    },
    {
        "begin_line": 1250,
        "end_line": 1272,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "    struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {\n        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {\n            auto converted = std::chrono::system_clock::to_time_t(time_point);\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &converted);\n#else\n            std::tm* timeInfo = std::gmtime(&converted);\n#endif\n\n            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp);\n        }\n    };\n"
    },
    {
        "begin_line": 1251,
        "end_line": 1271,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {\n            auto converted = std::chrono::system_clock::to_time_t(time_point);\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &converted);\n#else\n            std::tm* timeInfo = std::gmtime(&converted);\n#endif\n\n            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp);\n        }\n"
    },
    {
        "begin_line": 1291,
        "end_line": 1434,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct ITransientExpression {\n        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }\n        auto getResult() const -> bool { return m_result; }\n        virtual void streamReconstructedExpression( std::ostream &os ) const = 0;\n\n        ITransientExpression( bool isBinaryExpression, bool result )\n        :   m_isBinaryExpression( isBinaryExpression ),\n            m_result( result )\n        {}\n\n        // We don't actually need a virtual destructor, but many static analysers\n        // complain if it's not here :-(\n        virtual ~ITransientExpression();\n\n        bool m_isBinaryExpression;\n        bool m_result;\n\n    };\n\n    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );\n\n    template<typename LhsT, typename RhsT>\n    class BinaryExpr  : public ITransientExpression {\n        LhsT m_lhs;\n        StringRef m_op;\n        RhsT m_rhs;\n\n        void streamReconstructedExpression( std::ostream &os ) const override {\n            formatReconstructedExpression\n                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\n        }\n\n    public:\n        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )\n        :   ITransientExpression{ true, comparisonResult },\n            m_lhs( lhs ),\n            m_op( op ),\n            m_rhs( rhs )\n        {}\n    };\n\n    template<typename LhsT>\n    class UnaryExpr : public ITransientExpression {\n        LhsT m_lhs;\n\n        void streamReconstructedExpression( std::ostream &os ) const override {\n            os << Catch::Detail::stringify( m_lhs );\n        }\n\n    public:\n        explicit UnaryExpr( LhsT lhs )\n        :   ITransientExpression{ false, lhs ? true : false },\n            m_lhs( lhs )\n        {}\n    };\n\n    // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)\n    template<typename LhsT, typename RhsT>\n    auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }\n    template<typename T>\n    auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }\n    template<typename T>\n    auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }\n    template<typename T>\n    auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }\n    template<typename T>\n    auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }\n\n    template<typename LhsT, typename RhsT>\n    auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }\n    template<typename T>\n    auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }\n    template<typename T>\n    auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }\n    template<typename T>\n    auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }\n    template<typename T>\n    auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }\n\n    template<typename LhsT>\n    class ExprLhs {\n        LhsT m_lhs;\n    public:\n        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}\n\n        template<typename RhsT>\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\", rhs };\n        }\n        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n            return { m_lhs == rhs, m_lhs, \"==\", rhs };\n        }\n\n        template<typename RhsT>\n        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { compareNotEqual( m_lhs, rhs ), m_lhs, \"!=\", rhs };\n        }\n        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n            return { m_lhs != rhs, m_lhs, \"!=\", rhs };\n        }\n\n        template<typename RhsT>\n        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs > rhs), m_lhs, \">\", rhs };\n        }\n        template<typename RhsT>\n        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs < rhs), m_lhs, \"<\", rhs };\n        }\n        template<typename RhsT>\n        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs >= rhs), m_lhs, \">=\", rhs };\n        }\n        template<typename RhsT>\n        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\", rhs };\n        }\n\n        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {\n            return UnaryExpr<LhsT>{ m_lhs };\n        }\n    };\n\n    void handleExpression( ITransientExpression const& expr );\n\n    template<typename T>\n    void handleExpression( ExprLhs<T> const& expr ) {\n        handleExpression( expr.makeUnaryExpr() );\n    }\n\n    struct Decomposer {\n        template<typename T>\n        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {\n            return ExprLhs<T const&>{ lhs };\n        }\n\n        auto operator <=( bool value ) -> ExprLhs<bool> {\n            return ExprLhs<bool>{ value };\n        }\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 1293,
        "end_line": 1310,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ITransientExpression",
        "snippet": "    struct ITransientExpression {\n        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }\n        auto getResult() const -> bool { return m_result; }\n        virtual void streamReconstructedExpression( std::ostream &os ) const = 0;\n\n        ITransientExpression( bool isBinaryExpression, bool result )\n        :   m_isBinaryExpression( isBinaryExpression ),\n            m_result( result )\n        {}\n\n        // We don't actually need a virtual destructor, but many static analysers\n        // complain if it's not here :-(\n        virtual ~ITransientExpression();\n\n        bool m_isBinaryExpression;\n        bool m_result;\n\n    };\n"
    },
    {
        "begin_line": 1294,
        "end_line": 1294,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isBinaryExpression",
        "snippet": "        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }\n"
    },
    {
        "begin_line": 1295,
        "end_line": 1295,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getResult",
        "snippet": "        auto getResult() const -> bool { return m_result; }\n"
    },
    {
        "begin_line": 1298,
        "end_line": 1301,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ITransientExpression",
        "snippet": "        ITransientExpression( bool isBinaryExpression, bool result )\n        :   m_isBinaryExpression( isBinaryExpression ),\n            m_result( result )\n        {}\n"
    },
    {
        "begin_line": 1307,
        "end_line": 1307,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_isBinaryExpression",
        "snippet": "        bool m_isBinaryExpression;\n"
    },
    {
        "begin_line": 1308,
        "end_line": 1308,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_result",
        "snippet": "        bool m_result;\n"
    },
    {
        "begin_line": 1315,
        "end_line": 1332,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BinaryExpr",
        "snippet": "    class BinaryExpr  : public ITransientExpression {\n        LhsT m_lhs;\n        StringRef m_op;\n        RhsT m_rhs;\n\n        void streamReconstructedExpression( std::ostream &os ) const override {\n            formatReconstructedExpression\n                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\n        }\n\n    public:\n        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )\n        :   ITransientExpression{ true, comparisonResult },\n            m_lhs( lhs ),\n            m_op( op ),\n            m_rhs( rhs )\n        {}\n    };\n"
    },
    {
        "begin_line": 1316,
        "end_line": 1316,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lhs",
        "snippet": "        LhsT m_lhs;\n"
    },
    {
        "begin_line": 1317,
        "end_line": 1317,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_op",
        "snippet": "        StringRef m_op;\n"
    },
    {
        "begin_line": 1318,
        "end_line": 1318,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_rhs",
        "snippet": "        RhsT m_rhs;\n"
    },
    {
        "begin_line": 1320,
        "end_line": 1323,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "streamReconstructedExpression",
        "snippet": "        void streamReconstructedExpression( std::ostream &os ) const override {\n            formatReconstructedExpression\n                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\n        }\n"
    },
    {
        "begin_line": 1326,
        "end_line": 1331,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BinaryExpr",
        "snippet": "        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )\n        :   ITransientExpression{ true, comparisonResult },\n            m_lhs( lhs ),\n            m_op( op ),\n            m_rhs( rhs )\n        {}\n"
    },
    {
        "begin_line": 1335,
        "end_line": 1347,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnaryExpr",
        "snippet": "    class UnaryExpr : public ITransientExpression {\n        LhsT m_lhs;\n\n        void streamReconstructedExpression( std::ostream &os ) const override {\n            os << Catch::Detail::stringify( m_lhs );\n        }\n\n    public:\n        explicit UnaryExpr( LhsT lhs )\n        :   ITransientExpression{ false, lhs ? true : false },\n            m_lhs( lhs )\n        {}\n    };\n"
    },
    {
        "begin_line": 1336,
        "end_line": 1336,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lhs",
        "snippet": "        LhsT m_lhs;\n"
    },
    {
        "begin_line": 1338,
        "end_line": 1340,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "streamReconstructedExpression",
        "snippet": "        void streamReconstructedExpression( std::ostream &os ) const override {\n            os << Catch::Detail::stringify( m_lhs );\n        }\n"
    },
    {
        "begin_line": 1343,
        "end_line": 1346,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnaryExpr",
        "snippet": "        explicit UnaryExpr( LhsT lhs )\n        :   ITransientExpression{ false, lhs ? true : false },\n            m_lhs( lhs )\n        {}\n"
    },
    {
        "begin_line": 1351,
        "end_line": 1351,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareEqual",
        "snippet": "    auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }\n"
    },
    {
        "begin_line": 1353,
        "end_line": 1353,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareEqual",
        "snippet": "    auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }\n"
    },
    {
        "begin_line": 1355,
        "end_line": 1355,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareEqual",
        "snippet": "    auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }\n"
    },
    {
        "begin_line": 1357,
        "end_line": 1357,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareEqual",
        "snippet": "    auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }\n"
    },
    {
        "begin_line": 1359,
        "end_line": 1359,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareEqual",
        "snippet": "    auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }\n"
    },
    {
        "begin_line": 1362,
        "end_line": 1362,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareNotEqual",
        "snippet": "    auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }\n"
    },
    {
        "begin_line": 1364,
        "end_line": 1364,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareNotEqual",
        "snippet": "    auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }\n"
    },
    {
        "begin_line": 1366,
        "end_line": 1366,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareNotEqual",
        "snippet": "    auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }\n"
    },
    {
        "begin_line": 1368,
        "end_line": 1368,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareNotEqual",
        "snippet": "    auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }\n"
    },
    {
        "begin_line": 1370,
        "end_line": 1370,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "compareNotEqual",
        "snippet": "    auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }\n"
    },
    {
        "begin_line": 1373,
        "end_line": 1414,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExprLhs",
        "snippet": "    class ExprLhs {\n        LhsT m_lhs;\n    public:\n        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}\n\n        template<typename RhsT>\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\", rhs };\n        }\n        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n            return { m_lhs == rhs, m_lhs, \"==\", rhs };\n        }\n\n        template<typename RhsT>\n        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { compareNotEqual( m_lhs, rhs ), m_lhs, \"!=\", rhs };\n        }\n        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n            return { m_lhs != rhs, m_lhs, \"!=\", rhs };\n        }\n\n        template<typename RhsT>\n        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs > rhs), m_lhs, \">\", rhs };\n        }\n        template<typename RhsT>\n        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs < rhs), m_lhs, \"<\", rhs };\n        }\n        template<typename RhsT>\n        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs >= rhs), m_lhs, \">=\", rhs };\n        }\n        template<typename RhsT>\n        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\", rhs };\n        }\n\n        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {\n            return UnaryExpr<LhsT>{ m_lhs };\n        }\n    };\n"
    },
    {
        "begin_line": 1374,
        "end_line": 1374,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lhs",
        "snippet": "        LhsT m_lhs;\n"
    },
    {
        "begin_line": 1376,
        "end_line": 1376,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExprLhs",
        "snippet": "        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}\n"
    },
    {
        "begin_line": 1379,
        "end_line": 1381,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\", rhs };\n        }\n"
    },
    {
        "begin_line": 1382,
        "end_line": 1384,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n            return { m_lhs == rhs, m_lhs, \"==\", rhs };\n        }\n"
    },
    {
        "begin_line": 1387,
        "end_line": 1389,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !=",
        "snippet": "        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { compareNotEqual( m_lhs, rhs ), m_lhs, \"!=\", rhs };\n        }\n"
    },
    {
        "begin_line": 1390,
        "end_line": 1392,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !=",
        "snippet": "        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n            return { m_lhs != rhs, m_lhs, \"!=\", rhs };\n        }\n"
    },
    {
        "begin_line": 1395,
        "end_line": 1397,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator >",
        "snippet": "        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs > rhs), m_lhs, \">\", rhs };\n        }\n"
    },
    {
        "begin_line": 1399,
        "end_line": 1401,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <",
        "snippet": "        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs < rhs), m_lhs, \"<\", rhs };\n        }\n"
    },
    {
        "begin_line": 1403,
        "end_line": 1405,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator >=",
        "snippet": "        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs >= rhs), m_lhs, \">=\", rhs };\n        }\n"
    },
    {
        "begin_line": 1407,
        "end_line": 1409,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <=",
        "snippet": "        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n            return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\", rhs };\n        }\n"
    },
    {
        "begin_line": 1411,
        "end_line": 1413,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeUnaryExpr",
        "snippet": "        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {\n            return UnaryExpr<LhsT>{ m_lhs };\n        }\n"
    },
    {
        "begin_line": 1419,
        "end_line": 1421,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExpression",
        "snippet": "    void handleExpression( ExprLhs<T> const& expr ) {\n        handleExpression( expr.makeUnaryExpr() );\n    }\n"
    },
    {
        "begin_line": 1423,
        "end_line": 1432,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Decomposer",
        "snippet": "    struct Decomposer {\n        template<typename T>\n        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {\n            return ExprLhs<T const&>{ lhs };\n        }\n\n        auto operator <=( bool value ) -> ExprLhs<bool> {\n            return ExprLhs<bool>{ value };\n        }\n    };\n"
    },
    {
        "begin_line": 1425,
        "end_line": 1427,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <=",
        "snippet": "        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {\n            return ExprLhs<T const&>{ lhs };\n        }\n"
    },
    {
        "begin_line": 1429,
        "end_line": 1431,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <=",
        "snippet": "        auto operator <=( bool value ) -> ExprLhs<bool> {\n            return ExprLhs<bool>{ value };\n        }\n"
    },
    {
        "begin_line": 1445,
        "end_line": 1509,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class AssertionResult;\n    struct AssertionInfo;\n    struct SectionInfo;\n    struct SectionEndInfo;\n    struct MessageInfo;\n    struct Counts;\n    struct BenchmarkInfo;\n    struct BenchmarkStats;\n    struct AssertionReaction;\n\n    struct ITransientExpression;\n\n    struct IResultCapture {\n\n        virtual ~IResultCapture();\n\n        virtual bool sectionStarted(    SectionInfo const& sectionInfo,\n                                        Counts& assertions ) = 0;\n        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;\n        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;\n\n        virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;\n        virtual void benchmarkEnded( BenchmarkStats const& stats ) = 0;\n\n        virtual void pushScopedMessage( MessageInfo const& message ) = 0;\n        virtual void popScopedMessage( MessageInfo const& message ) = 0;\n\n        virtual void handleFatalErrorCondition( StringRef message ) = 0;\n\n        virtual void handleExpr\n                (   AssertionInfo const& info,\n                    ITransientExpression const& expr,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleMessage\n                (   AssertionInfo const& info,\n                    ResultWas::OfType resultType,\n                    StringRef const& message,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleUnexpectedExceptionNotThrown\n                (   AssertionInfo const& info,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleUnexpectedInflightException\n                (   AssertionInfo const& info,\n                    std::string const& message,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleIncomplete\n                (   AssertionInfo const& info ) = 0;\n        virtual void handleNonExpr\n                (   AssertionInfo const &info,\n                    ResultWas::OfType resultType,\n                    AssertionReaction &reaction ) = 0;\n\n        virtual bool lastAssertionPassed() = 0;\n        virtual void assertionPassed() = 0;\n\n        // Deprecated, do not use:\n        virtual std::string getCurrentTestName() const = 0;\n        virtual const AssertionResult* getLastResult() const = 0;\n        virtual void exceptionEarlyReported() = 0;\n    };\n\n    IResultCapture& getResultCapture();\n}\n"
    },
    {
        "begin_line": 1459,
        "end_line": 1506,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IResultCapture",
        "snippet": "    struct IResultCapture {\n\n        virtual ~IResultCapture();\n\n        virtual bool sectionStarted(    SectionInfo const& sectionInfo,\n                                        Counts& assertions ) = 0;\n        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;\n        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;\n\n        virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;\n        virtual void benchmarkEnded( BenchmarkStats const& stats ) = 0;\n\n        virtual void pushScopedMessage( MessageInfo const& message ) = 0;\n        virtual void popScopedMessage( MessageInfo const& message ) = 0;\n\n        virtual void handleFatalErrorCondition( StringRef message ) = 0;\n\n        virtual void handleExpr\n                (   AssertionInfo const& info,\n                    ITransientExpression const& expr,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleMessage\n                (   AssertionInfo const& info,\n                    ResultWas::OfType resultType,\n                    StringRef const& message,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleUnexpectedExceptionNotThrown\n                (   AssertionInfo const& info,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleUnexpectedInflightException\n                (   AssertionInfo const& info,\n                    std::string const& message,\n                    AssertionReaction& reaction ) = 0;\n        virtual void handleIncomplete\n                (   AssertionInfo const& info ) = 0;\n        virtual void handleNonExpr\n                (   AssertionInfo const &info,\n                    ResultWas::OfType resultType,\n                    AssertionReaction &reaction ) = 0;\n\n        virtual bool lastAssertionPassed() = 0;\n        virtual void assertionPassed() = 0;\n\n        // Deprecated, do not use:\n        virtual std::string getCurrentTestName() const = 0;\n        virtual const AssertionResult* getLastResult() const = 0;\n        virtual void exceptionEarlyReported() = 0;\n    };\n"
    },
    {
        "begin_line": 1512,
        "end_line": 1582,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct TestFailureException{};\n    struct AssertionResultData;\n    struct IResultCapture;\n    class RunContext;\n\n    class LazyExpression {\n        friend class AssertionHandler;\n        friend struct AssertionStats;\n        friend class RunContext;\n\n        ITransientExpression const* m_transientExpression = nullptr;\n        bool m_isNegated;\n    public:\n        LazyExpression( bool isNegated );\n        LazyExpression( LazyExpression const& other );\n        LazyExpression& operator = ( LazyExpression const& ) = delete;\n\n        explicit operator bool() const;\n\n        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;\n    };\n\n    struct AssertionReaction {\n        bool shouldDebugBreak = false;\n        bool shouldThrow = false;\n    };\n\n    class AssertionHandler {\n        AssertionInfo m_assertionInfo;\n        AssertionReaction m_reaction;\n        bool m_completed = false;\n        IResultCapture& m_resultCapture;\n\n    public:\n        AssertionHandler\n            (   StringRef macroName,\n                SourceLineInfo const& lineInfo,\n                StringRef capturedExpression,\n                ResultDisposition::Flags resultDisposition );\n        ~AssertionHandler() {\n            if ( !m_completed ) {\n                m_resultCapture.handleIncomplete( m_assertionInfo );\n            }\n        }\n\n        template<typename T>\n        void handleExpr( ExprLhs<T> const& expr ) {\n            handleExpr( expr.makeUnaryExpr() );\n        }\n        void handleExpr( ITransientExpression const& expr );\n\n        void handleMessage(ResultWas::OfType resultType, StringRef const& message);\n\n        void handleExceptionThrownAsExpected();\n        void handleUnexpectedExceptionNotThrown();\n        void handleExceptionNotThrownAsExpected();\n        void handleThrowingCallSkipped();\n        void handleUnexpectedInflightException();\n\n        void complete();\n        void setCompleted();\n\n        // query\n        auto allowThrows() const -> bool;\n    };\n\n    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef matcherString );\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 1514,
        "end_line": 1514,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestFailureException",
        "snippet": "    struct TestFailureException{};\n"
    },
    {
        "begin_line": 1519,
        "end_line": 1534,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LazyExpression",
        "snippet": "    class LazyExpression {\n        friend class AssertionHandler;\n        friend struct AssertionStats;\n        friend class RunContext;\n\n        ITransientExpression const* m_transientExpression = nullptr;\n        bool m_isNegated;\n    public:\n        LazyExpression( bool isNegated );\n        LazyExpression( LazyExpression const& other );\n        LazyExpression& operator = ( LazyExpression const& ) = delete;\n\n        explicit operator bool() const;\n\n        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;\n    };\n"
    },
    {
        "begin_line": 1524,
        "end_line": 1524,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_transientExpression",
        "snippet": "        ITransientExpression const* m_transientExpression = nullptr;\n"
    },
    {
        "begin_line": 1525,
        "end_line": 1525,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_isNegated",
        "snippet": "        bool m_isNegated;\n"
    },
    {
        "begin_line": 1536,
        "end_line": 1539,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionReaction",
        "snippet": "    struct AssertionReaction {\n        bool shouldDebugBreak = false;\n        bool shouldThrow = false;\n    };\n"
    },
    {
        "begin_line": 1537,
        "end_line": 1537,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shouldDebugBreak",
        "snippet": "        bool shouldDebugBreak = false;\n"
    },
    {
        "begin_line": 1538,
        "end_line": 1538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shouldThrow",
        "snippet": "        bool shouldThrow = false;\n"
    },
    {
        "begin_line": 1541,
        "end_line": 1578,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionHandler",
        "snippet": "    class AssertionHandler {\n        AssertionInfo m_assertionInfo;\n        AssertionReaction m_reaction;\n        bool m_completed = false;\n        IResultCapture& m_resultCapture;\n\n    public:\n        AssertionHandler\n            (   StringRef macroName,\n                SourceLineInfo const& lineInfo,\n                StringRef capturedExpression,\n                ResultDisposition::Flags resultDisposition );\n        ~AssertionHandler() {\n            if ( !m_completed ) {\n                m_resultCapture.handleIncomplete( m_assertionInfo );\n            }\n        }\n\n        template<typename T>\n        void handleExpr( ExprLhs<T> const& expr ) {\n            handleExpr( expr.makeUnaryExpr() );\n        }\n        void handleExpr( ITransientExpression const& expr );\n\n        void handleMessage(ResultWas::OfType resultType, StringRef const& message);\n\n        void handleExceptionThrownAsExpected();\n        void handleUnexpectedExceptionNotThrown();\n        void handleExceptionNotThrownAsExpected();\n        void handleThrowingCallSkipped();\n        void handleUnexpectedInflightException();\n\n        void complete();\n        void setCompleted();\n\n        // query\n        auto allowThrows() const -> bool;\n    };\n"
    },
    {
        "begin_line": 1542,
        "end_line": 1542,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_assertionInfo",
        "snippet": "        AssertionInfo m_assertionInfo;\n"
    },
    {
        "begin_line": 1543,
        "end_line": 1543,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_reaction",
        "snippet": "        AssertionReaction m_reaction;\n"
    },
    {
        "begin_line": 1544,
        "end_line": 1544,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_completed",
        "snippet": "        bool m_completed = false;\n"
    },
    {
        "begin_line": 1545,
        "end_line": 1545,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_resultCapture",
        "snippet": "        IResultCapture& m_resultCapture;\n"
    },
    {
        "begin_line": 1553,
        "end_line": 1557,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~AssertionHandler",
        "snippet": "        ~AssertionHandler() {\n            if ( !m_completed ) {\n                m_resultCapture.handleIncomplete( m_assertionInfo );\n            }\n        }\n"
    },
    {
        "begin_line": 1560,
        "end_line": 1562,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExpr",
        "snippet": "        void handleExpr( ExprLhs<T> const& expr ) {\n            handleExpr( expr.makeUnaryExpr() );\n        }\n"
    },
    {
        "begin_line": 1589,
        "end_line": 1641,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct MessageInfo {\n        MessageInfo(    std::string const& _macroName,\n                        SourceLineInfo const& _lineInfo,\n                        ResultWas::OfType _type );\n\n        std::string macroName;\n        std::string message;\n        SourceLineInfo lineInfo;\n        ResultWas::OfType type;\n        unsigned int sequence;\n\n        bool operator == ( MessageInfo const& other ) const;\n        bool operator < ( MessageInfo const& other ) const;\n    private:\n        static unsigned int globalCount;\n    };\n\n    struct MessageStream {\n\n        template<typename T>\n        MessageStream& operator << ( T const& value ) {\n            m_stream << value;\n            return *this;\n        }\n\n        ReusableStringStream m_stream;\n    };\n\n    struct MessageBuilder : MessageStream {\n        MessageBuilder( std::string const& macroName,\n                        SourceLineInfo const& lineInfo,\n                        ResultWas::OfType type );\n\n        template<typename T>\n        MessageBuilder& operator << ( T const& value ) {\n            m_stream << value;\n            return *this;\n        }\n\n        MessageInfo m_info;\n    };\n\n    class ScopedMessage {\n    public:\n        explicit ScopedMessage( MessageBuilder const& builder );\n        ~ScopedMessage();\n\n        MessageInfo m_info;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 1591,
        "end_line": 1606,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MessageInfo",
        "snippet": "    struct MessageInfo {\n        MessageInfo(    std::string const& _macroName,\n                        SourceLineInfo const& _lineInfo,\n                        ResultWas::OfType _type );\n\n        std::string macroName;\n        std::string message;\n        SourceLineInfo lineInfo;\n        ResultWas::OfType type;\n        unsigned int sequence;\n\n        bool operator == ( MessageInfo const& other ) const;\n        bool operator < ( MessageInfo const& other ) const;\n    private:\n        static unsigned int globalCount;\n    };\n"
    },
    {
        "begin_line": 1596,
        "end_line": 1596,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "macroName",
        "snippet": "        std::string macroName;\n"
    },
    {
        "begin_line": 1597,
        "end_line": 1597,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "message",
        "snippet": "        std::string message;\n"
    },
    {
        "begin_line": 1598,
        "end_line": 1598,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lineInfo",
        "snippet": "        SourceLineInfo lineInfo;\n"
    },
    {
        "begin_line": 1599,
        "end_line": 1599,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "type",
        "snippet": "        ResultWas::OfType type;\n"
    },
    {
        "begin_line": 1600,
        "end_line": 1600,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sequence",
        "snippet": "        unsigned int sequence;\n"
    },
    {
        "begin_line": 1605,
        "end_line": 1605,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "globalCount",
        "snippet": "        static unsigned int globalCount;\n"
    },
    {
        "begin_line": 1608,
        "end_line": 1617,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MessageStream",
        "snippet": "    struct MessageStream {\n\n        template<typename T>\n        MessageStream& operator << ( T const& value ) {\n            m_stream << value;\n            return *this;\n        }\n\n        ReusableStringStream m_stream;\n    };\n"
    },
    {
        "begin_line": 1611,
        "end_line": 1614,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "        MessageStream& operator << ( T const& value ) {\n            m_stream << value;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 1616,
        "end_line": 1616,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_stream",
        "snippet": "        ReusableStringStream m_stream;\n"
    },
    {
        "begin_line": 1619,
        "end_line": 1631,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MessageBuilder",
        "snippet": "    struct MessageBuilder : MessageStream {\n        MessageBuilder( std::string const& macroName,\n                        SourceLineInfo const& lineInfo,\n                        ResultWas::OfType type );\n\n        template<typename T>\n        MessageBuilder& operator << ( T const& value ) {\n            m_stream << value;\n            return *this;\n        }\n\n        MessageInfo m_info;\n    };\n"
    },
    {
        "begin_line": 1625,
        "end_line": 1628,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "        MessageBuilder& operator << ( T const& value ) {\n            m_stream << value;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 1630,
        "end_line": 1630,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_info",
        "snippet": "        MessageInfo m_info;\n"
    },
    {
        "begin_line": 1633,
        "end_line": 1639,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ScopedMessage",
        "snippet": "    class ScopedMessage {\n    public:\n        explicit ScopedMessage( MessageBuilder const& builder );\n        ~ScopedMessage();\n\n        MessageInfo m_info;\n    };\n"
    },
    {
        "begin_line": 1638,
        "end_line": 1638,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_info",
        "snippet": "        MessageInfo m_info;\n"
    },
    {
        "begin_line": 1647,
        "end_line": 1647,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_STRINGIFY",
        "snippet": "  #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__\n"
    },
    {
        "begin_line": 1649,
        "end_line": 1649,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_STRINGIFY",
        "snippet": "  #define CATCH_INTERNAL_STRINGIFY(...) \"Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION\"\n"
    },
    {
        "begin_line": 1657,
        "end_line": 1657,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TRY",
        "snippet": "#define INTERNAL_CATCH_TRY\n"
    },
    {
        "begin_line": 1658,
        "end_line": 1658,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_CATCH",
        "snippet": "#define INTERNAL_CATCH_CATCH( capturer )\n"
    },
    {
        "begin_line": 1662,
        "end_line": 1662,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TRY",
        "snippet": "#define INTERNAL_CATCH_TRY try\n"
    },
    {
        "begin_line": 1663,
        "end_line": 1663,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_CATCH",
        "snippet": "#define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }\n"
    },
    {
        "begin_line": 1667,
        "end_line": 1667,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_REACT",
        "snippet": "#define INTERNAL_CATCH_REACT( handler ) handler.complete();\n"
    },
    {
        "begin_line": 1670,
        "end_line": 1679,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TEST",
        "snippet": "#define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\n        INTERNAL_CATCH_TRY { \\\n            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\\n            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \\\n            CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\\n        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( (void)0, false && static_cast<bool>( !!(__VA_ARGS__) ) ) // the expression here is never evaluated at runtime but it forces the compiler to give it a look\n"
    },
    {
        "begin_line": 1683,
        "end_line": 1685,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_IF",
        "snippet": "#define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \\\n    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\\n    if( Catch::getResultCapture().lastAssertionPassed() )\n"
    },
    {
        "begin_line": 1688,
        "end_line": 1690,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_ELSE",
        "snippet": "#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \\\n    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\\n    if( !Catch::getResultCapture().lastAssertionPassed() )\n"
    },
    {
        "begin_line": 1693,
        "end_line": 1704,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_NO_THROW",
        "snippet": "#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\n        try { \\\n            static_cast<void>(__VA_ARGS__); \\\n            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\\n        } \\\n        catch( ... ) { \\\n            catchAssertionHandler.handleUnexpectedInflightException(); \\\n        } \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( false )\n"
    },
    {
        "begin_line": 1707,
        "end_line": 1721,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_THROWS",
        "snippet": "#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\\n        if( catchAssertionHandler.allowThrows() ) \\\n            try { \\\n                static_cast<void>(__VA_ARGS__); \\\n                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n            } \\\n            catch( ... ) { \\\n                catchAssertionHandler.handleExceptionThrownAsExpected(); \\\n            } \\\n        else \\\n            catchAssertionHandler.handleThrowingCallSkipped(); \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( false )\n"
    },
    {
        "begin_line": 1724,
        "end_line": 1741,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_THROWS_AS",
        "snippet": "#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) \", \" CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\\n        if( catchAssertionHandler.allowThrows() ) \\\n            try { \\\n                static_cast<void>(expr); \\\n                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n            } \\\n            catch( exceptionType const& ) { \\\n                catchAssertionHandler.handleExceptionThrownAsExpected(); \\\n            } \\\n            catch( ... ) { \\\n                catchAssertionHandler.handleUnexpectedInflightException(); \\\n            } \\\n        else \\\n            catchAssertionHandler.handleThrowingCallSkipped(); \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( false )\n"
    },
    {
        "begin_line": 1744,
        "end_line": 1749,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_MSG",
        "snippet": "#define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, \"\", resultDisposition ); \\\n        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( false )\n"
    },
    {
        "begin_line": 1752,
        "end_line": 1753,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_INFO",
        "snippet": "#define INTERNAL_CATCH_INFO( macroName, log ) \\\n    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log );\n"
    },
    {
        "begin_line": 1757,
        "end_line": 1771,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_THROWS_STR_MATCHES",
        "snippet": "#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) \", \" CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\n        if( catchAssertionHandler.allowThrows() ) \\\n            try { \\\n                static_cast<void>(__VA_ARGS__); \\\n                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n            } \\\n            catch( ... ) { \\\n                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher ); \\\n            } \\\n        else \\\n            catchAssertionHandler.handleThrowingCallSkipped(); \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( false )\n"
    },
    {
        "begin_line": 1784,
        "end_line": 1810,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct Counts {\n        Counts operator - ( Counts const& other ) const;\n        Counts& operator += ( Counts const& other );\n\n        std::size_t total() const;\n        bool allPassed() const;\n        bool allOk() const;\n\n        std::size_t passed = 0;\n        std::size_t failed = 0;\n        std::size_t failedButOk = 0;\n    };\n\n    struct Totals {\n\n        Totals operator - ( Totals const& other ) const;\n        Totals& operator += ( Totals const& other );\n\n        Totals delta( Totals const& prevTotals ) const;\n\n        int error = 0;\n        Counts assertions;\n        Counts testCases;\n    };\n}\n"
    },
    {
        "begin_line": 1786,
        "end_line": 1797,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Counts",
        "snippet": "    struct Counts {\n        Counts operator - ( Counts const& other ) const;\n        Counts& operator += ( Counts const& other );\n\n        std::size_t total() const;\n        bool allPassed() const;\n        bool allOk() const;\n\n        std::size_t passed = 0;\n        std::size_t failed = 0;\n        std::size_t failedButOk = 0;\n    };\n"
    },
    {
        "begin_line": 1794,
        "end_line": 1794,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "passed",
        "snippet": "        std::size_t passed = 0;\n"
    },
    {
        "begin_line": 1795,
        "end_line": 1795,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "failed",
        "snippet": "        std::size_t failed = 0;\n"
    },
    {
        "begin_line": 1796,
        "end_line": 1796,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "failedButOk",
        "snippet": "        std::size_t failedButOk = 0;\n"
    },
    {
        "begin_line": 1799,
        "end_line": 1809,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Totals",
        "snippet": "    struct Totals {\n\n        Totals operator - ( Totals const& other ) const;\n        Totals& operator += ( Totals const& other );\n\n        Totals delta( Totals const& prevTotals ) const;\n\n        int error = 0;\n        Counts assertions;\n        Counts testCases;\n    };\n"
    },
    {
        "begin_line": 1806,
        "end_line": 1806,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "error",
        "snippet": "        int error = 0;\n"
    },
    {
        "begin_line": 1807,
        "end_line": 1807,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertions",
        "snippet": "        Counts assertions;\n"
    },
    {
        "begin_line": 1808,
        "end_line": 1808,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCases",
        "snippet": "        Counts testCases;\n"
    },
    {
        "begin_line": 1815,
        "end_line": 1836,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct SectionInfo {\n        SectionInfo\n            (   SourceLineInfo const& _lineInfo,\n                std::string const& _name,\n                std::string const& _description = std::string() );\n\n        std::string name;\n        std::string description;\n        SourceLineInfo lineInfo;\n    };\n\n    struct SectionEndInfo {\n        SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds );\n\n        SectionInfo sectionInfo;\n        Counts prevAssertions;\n        double durationInSeconds;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 1817,
        "end_line": 1826,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionInfo",
        "snippet": "    struct SectionInfo {\n        SectionInfo\n            (   SourceLineInfo const& _lineInfo,\n                std::string const& _name,\n                std::string const& _description = std::string() );\n\n        std::string name;\n        std::string description;\n        SourceLineInfo lineInfo;\n    };\n"
    },
    {
        "begin_line": 1823,
        "end_line": 1823,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        std::string name;\n"
    },
    {
        "begin_line": 1824,
        "end_line": 1824,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "description",
        "snippet": "        std::string description;\n"
    },
    {
        "begin_line": 1825,
        "end_line": 1825,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lineInfo",
        "snippet": "        SourceLineInfo lineInfo;\n"
    },
    {
        "begin_line": 1828,
        "end_line": 1834,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionEndInfo",
        "snippet": "    struct SectionEndInfo {\n        SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds );\n\n        SectionInfo sectionInfo;\n        Counts prevAssertions;\n        double durationInSeconds;\n    };\n"
    },
    {
        "begin_line": 1831,
        "end_line": 1831,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionInfo",
        "snippet": "        SectionInfo sectionInfo;\n"
    },
    {
        "begin_line": 1832,
        "end_line": 1832,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "prevAssertions",
        "snippet": "        Counts prevAssertions;\n"
    },
    {
        "begin_line": 1833,
        "end_line": 1833,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "durationInSeconds",
        "snippet": "        double durationInSeconds;\n"
    },
    {
        "begin_line": 1843,
        "end_line": 1858,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    auto getCurrentNanosecondsSinceEpoch() -> uint64_t;\n    auto getEstimatedClockResolution() -> uint64_t;\n\n    class Timer {\n        uint64_t m_nanoseconds = 0;\n    public:\n        void start();\n        auto getElapsedNanoseconds() const -> uint64_t;\n        auto getElapsedMicroseconds() const -> uint64_t;\n        auto getElapsedMilliseconds() const -> unsigned int;\n        auto getElapsedSeconds() const -> double;\n    };\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 1848,
        "end_line": 1856,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Timer",
        "snippet": "    class Timer {\n        uint64_t m_nanoseconds = 0;\n    public:\n        void start();\n        auto getElapsedNanoseconds() const -> uint64_t;\n        auto getElapsedMicroseconds() const -> uint64_t;\n        auto getElapsedMilliseconds() const -> unsigned int;\n        auto getElapsedSeconds() const -> double;\n    };\n"
    },
    {
        "begin_line": 1849,
        "end_line": 1849,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_nanoseconds",
        "snippet": "        uint64_t m_nanoseconds = 0;\n"
    },
    {
        "begin_line": 1863,
        "end_line": 1882,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class Section : NonCopyable {\n    public:\n        Section( SectionInfo const& info );\n        ~Section();\n\n        // This indicates whether the section should be executed or not\n        explicit operator bool() const;\n\n    private:\n        SectionInfo m_info;\n\n        std::string m_name;\n        Counts m_assertions;\n        bool m_sectionIncluded;\n        Timer m_timer;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 1865,
        "end_line": 1880,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Section",
        "snippet": "    class Section : NonCopyable {\n    public:\n        Section( SectionInfo const& info );\n        ~Section();\n\n        // This indicates whether the section should be executed or not\n        explicit operator bool() const;\n\n    private:\n        SectionInfo m_info;\n\n        std::string m_name;\n        Counts m_assertions;\n        bool m_sectionIncluded;\n        Timer m_timer;\n    };\n"
    },
    {
        "begin_line": 1874,
        "end_line": 1874,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_info",
        "snippet": "        SectionInfo m_info;\n"
    },
    {
        "begin_line": 1876,
        "end_line": 1876,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_name",
        "snippet": "        std::string m_name;\n"
    },
    {
        "begin_line": 1877,
        "end_line": 1877,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_assertions",
        "snippet": "        Counts m_assertions;\n"
    },
    {
        "begin_line": 1878,
        "end_line": 1878,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_sectionIncluded",
        "snippet": "        bool m_sectionIncluded;\n"
    },
    {
        "begin_line": 1879,
        "end_line": 1879,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_timer",
        "snippet": "        Timer m_timer;\n"
    },
    {
        "begin_line": 1884,
        "end_line": 1885,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_SECTION",
        "snippet": "    #define INTERNAL_CATCH_SECTION( ... ) \\\n        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )\n"
    },
    {
        "begin_line": 1893,
        "end_line": 1928,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class BenchmarkLooper {\n\n        std::string m_name;\n        std::size_t m_count = 0;\n        std::size_t m_iterationsToRun = 1;\n        uint64_t m_resolution;\n        Timer m_timer;\n\n        static auto getResolution() -> uint64_t;\n    public:\n        // Keep most of this inline as it's on the code path that is being timed\n        BenchmarkLooper( StringRef name )\n        :   m_name( name ),\n            m_resolution( getResolution() )\n        {\n            reportStart();\n            m_timer.start();\n        }\n\n        explicit operator bool() {\n            if( m_count < m_iterationsToRun )\n                return true;\n            return needsMoreIterations();\n        }\n\n        void increment() {\n            ++m_count;\n        }\n\n        void reportStart();\n        auto needsMoreIterations() -> bool;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 1895,
        "end_line": 1926,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BenchmarkLooper",
        "snippet": "    class BenchmarkLooper {\n\n        std::string m_name;\n        std::size_t m_count = 0;\n        std::size_t m_iterationsToRun = 1;\n        uint64_t m_resolution;\n        Timer m_timer;\n\n        static auto getResolution() -> uint64_t;\n    public:\n        // Keep most of this inline as it's on the code path that is being timed\n        BenchmarkLooper( StringRef name )\n        :   m_name( name ),\n            m_resolution( getResolution() )\n        {\n            reportStart();\n            m_timer.start();\n        }\n\n        explicit operator bool() {\n            if( m_count < m_iterationsToRun )\n                return true;\n            return needsMoreIterations();\n        }\n\n        void increment() {\n            ++m_count;\n        }\n\n        void reportStart();\n        auto needsMoreIterations() -> bool;\n    };\n"
    },
    {
        "begin_line": 1897,
        "end_line": 1897,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_name",
        "snippet": "        std::string m_name;\n"
    },
    {
        "begin_line": 1898,
        "end_line": 1898,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_count",
        "snippet": "        std::size_t m_count = 0;\n"
    },
    {
        "begin_line": 1899,
        "end_line": 1899,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_iterationsToRun",
        "snippet": "        std::size_t m_iterationsToRun = 1;\n"
    },
    {
        "begin_line": 1900,
        "end_line": 1900,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_resolution",
        "snippet": "        uint64_t m_resolution;\n"
    },
    {
        "begin_line": 1901,
        "end_line": 1901,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_timer",
        "snippet": "        Timer m_timer;\n"
    },
    {
        "begin_line": 1906,
        "end_line": 1912,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BenchmarkLooper",
        "snippet": "        BenchmarkLooper( StringRef name )\n        :   m_name( name ),\n            m_resolution( getResolution() )\n        {\n            reportStart();\n            m_timer.start();\n        }\n"
    },
    {
        "begin_line": 1914,
        "end_line": 1918,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator bool",
        "snippet": "        explicit operator bool() {\n            if( m_count < m_iterationsToRun )\n                return true;\n            return needsMoreIterations();\n        }\n"
    },
    {
        "begin_line": 1920,
        "end_line": 1922,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "increment",
        "snippet": "        void increment() {\n            ++m_count;\n        }\n"
    },
    {
        "begin_line": 1930,
        "end_line": 1931,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BENCHMARK",
        "snippet": "#define BENCHMARK( name ) \\\n    for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )\n"
    },
    {
        "begin_line": 1941,
        "end_line": 1981,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class TestCase;\n    struct ITestCaseRegistry;\n    struct IExceptionTranslatorRegistry;\n    struct IExceptionTranslator;\n    struct IReporterRegistry;\n    struct IReporterFactory;\n    struct ITagAliasRegistry;\n    class StartupExceptionRegistry;\n\n    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;\n\n    struct IRegistryHub {\n        virtual ~IRegistryHub();\n\n        virtual IReporterRegistry const& getReporterRegistry() const = 0;\n        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;\n        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;\n\n        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;\n\n        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;\n    };\n\n    struct IMutableRegistryHub {\n        virtual ~IMutableRegistryHub();\n        virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;\n        virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;\n        virtual void registerTest( TestCase const& testInfo ) = 0;\n        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;\n        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;\n        virtual void registerStartupException() noexcept = 0;\n    };\n\n    IRegistryHub& getRegistryHub();\n    IMutableRegistryHub& getMutableRegistryHub();\n    void cleanUp();\n    std::string translateActiveException();\n\n}\n"
    },
    {
        "begin_line": 1954,
        "end_line": 1964,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IRegistryHub",
        "snippet": "    struct IRegistryHub {\n        virtual ~IRegistryHub();\n\n        virtual IReporterRegistry const& getReporterRegistry() const = 0;\n        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;\n        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;\n\n        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;\n\n        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;\n    };\n"
    },
    {
        "begin_line": 1966,
        "end_line": 1974,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IMutableRegistryHub",
        "snippet": "    struct IMutableRegistryHub {\n        virtual ~IMutableRegistryHub();\n        virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;\n        virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;\n        virtual void registerTest( TestCase const& testInfo ) = 0;\n        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;\n        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;\n        virtual void registerStartupException() noexcept = 0;\n    };\n"
    },
    {
        "begin_line": 1985,
        "end_line": 1986,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG",
        "snippet": "    #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \\\n        static std::string translatorName( signature )\n"
    },
    {
        "begin_line": 1993,
        "end_line": 2042,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    using exceptionTranslateFunction = std::string(*)();\n\n    struct IExceptionTranslator;\n    using ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;\n\n    struct IExceptionTranslator {\n        virtual ~IExceptionTranslator();\n        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;\n    };\n\n    struct IExceptionTranslatorRegistry {\n        virtual ~IExceptionTranslatorRegistry();\n\n        virtual std::string translateActiveException() const = 0;\n    };\n\n    class ExceptionTranslatorRegistrar {\n        template<typename T>\n        class ExceptionTranslator : public IExceptionTranslator {\n        public:\n\n            ExceptionTranslator( std::string(*translateFunction)( T& ) )\n            : m_translateFunction( translateFunction )\n            {}\n\n            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {\n                try {\n                    if( it == itEnd )\n                        std::rethrow_exception(std::current_exception());\n                    else\n                        return (*it)->translate( it+1, itEnd );\n                }\n                catch( T& ex ) {\n                    return m_translateFunction( ex );\n                }\n            }\n\n        protected:\n            std::string(*m_translateFunction)( T& );\n        };\n\n    public:\n        template<typename T>\n        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {\n            getMutableRegistryHub().registerTranslator\n                ( new ExceptionTranslator<T>( translateFunction ) );\n        }\n    };\n}\n"
    },
    {
        "begin_line": 1999,
        "end_line": 2002,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IExceptionTranslator",
        "snippet": "    struct IExceptionTranslator {\n        virtual ~IExceptionTranslator();\n        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;\n    };\n"
    },
    {
        "begin_line": 2004,
        "end_line": 2008,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IExceptionTranslatorRegistry",
        "snippet": "    struct IExceptionTranslatorRegistry {\n        virtual ~IExceptionTranslatorRegistry();\n\n        virtual std::string translateActiveException() const = 0;\n    };\n"
    },
    {
        "begin_line": 2010,
        "end_line": 2041,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExceptionTranslatorRegistrar",
        "snippet": "    class ExceptionTranslatorRegistrar {\n        template<typename T>\n        class ExceptionTranslator : public IExceptionTranslator {\n        public:\n\n            ExceptionTranslator( std::string(*translateFunction)( T& ) )\n            : m_translateFunction( translateFunction )\n            {}\n\n            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {\n                try {\n                    if( it == itEnd )\n                        std::rethrow_exception(std::current_exception());\n                    else\n                        return (*it)->translate( it+1, itEnd );\n                }\n                catch( T& ex ) {\n                    return m_translateFunction( ex );\n                }\n            }\n\n        protected:\n            std::string(*m_translateFunction)( T& );\n        };\n\n    public:\n        template<typename T>\n        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {\n            getMutableRegistryHub().registerTranslator\n                ( new ExceptionTranslator<T>( translateFunction ) );\n        }\n    };\n"
    },
    {
        "begin_line": 2012,
        "end_line": 2033,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExceptionTranslator",
        "snippet": "        class ExceptionTranslator : public IExceptionTranslator {\n        public:\n\n            ExceptionTranslator( std::string(*translateFunction)( T& ) )\n            : m_translateFunction( translateFunction )\n            {}\n\n            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {\n                try {\n                    if( it == itEnd )\n                        std::rethrow_exception(std::current_exception());\n                    else\n                        return (*it)->translate( it+1, itEnd );\n                }\n                catch( T& ex ) {\n                    return m_translateFunction( ex );\n                }\n            }\n\n        protected:\n            std::string(*m_translateFunction)( T& );\n        };\n"
    },
    {
        "begin_line": 2015,
        "end_line": 2017,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExceptionTranslator",
        "snippet": "            ExceptionTranslator( std::string(*translateFunction)( T& ) )\n            : m_translateFunction( translateFunction )\n            {}\n"
    },
    {
        "begin_line": 2019,
        "end_line": 2029,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "translate",
        "snippet": "            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {\n                try {\n                    if( it == itEnd )\n                        std::rethrow_exception(std::current_exception());\n                    else\n                        return (*it)->translate( it+1, itEnd );\n                }\n                catch( T& ex ) {\n                    return m_translateFunction( ex );\n                }\n            }\n"
    },
    {
        "begin_line": 2032,
        "end_line": 2032,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_translateFunction",
        "snippet": "            std::string(*m_translateFunction)( T& );\n"
    },
    {
        "begin_line": 2037,
        "end_line": 2040,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExceptionTranslatorRegistrar",
        "snippet": "        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {\n            getMutableRegistryHub().registerTranslator\n                ( new ExceptionTranslator<T>( translateFunction ) );\n        }\n"
    },
    {
        "begin_line": 2045,
        "end_line": 2050,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TRANSLATE_EXCEPTION2",
        "snippet": "#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \\\n    static std::string translatorName( signature ); \\\n    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); } \\\n    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n    static std::string translatorName( signature )\n"
    },
    {
        "begin_line": 2052,
        "end_line": 2052,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_TRANSLATE_EXCEPTION",
        "snippet": "#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )\n"
    },
    {
        "begin_line": 2060,
        "end_line": 2174,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Detail {\n\n    class Approx {\n    private:\n        bool equalityComparisonImpl(double other) const;\n\n    public:\n        explicit Approx ( double value );\n\n        static Approx custom();\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx operator()( T const& value ) {\n            Approx approx( static_cast<double>(value) );\n            approx.epsilon( m_epsilon );\n            approx.margin( m_margin );\n            approx.scale( m_scale );\n            return approx;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        explicit Approx( T const& value ): Approx(static_cast<double>(value))\n        {}\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( const T& lhs, Approx const& rhs ) {\n            auto lhs_v = static_cast<double>(lhs);\n            return rhs.equalityComparisonImpl(lhs_v);\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( Approx const& lhs, const T& rhs ) {\n            return operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( T const& lhs, Approx const& rhs ) {\n            return !operator==( lhs, rhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( Approx const& lhs, T const& rhs ) {\n            return !operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& epsilon( T const& newEpsilon ) {\n            double epsilonAsDouble = static_cast<double>(newEpsilon);\n            if( epsilonAsDouble < 0 || epsilonAsDouble > 1.0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::epsilon: \" +\n                        Catch::Detail::stringify( epsilonAsDouble ) +\n                        \", Approx::epsilon has to be between 0 and 1\" );\n            }\n            m_epsilon = epsilonAsDouble;\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& margin( T const& newMargin ) {\n            double marginAsDouble = static_cast<double>(newMargin);\n            if( marginAsDouble < 0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::margin: \" +\n                         Catch::Detail::stringify( marginAsDouble ) +\n                         \", Approx::Margin has to be non-negative.\" );\n\n            }\n            m_margin = marginAsDouble;\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& scale( T const& newScale ) {\n            m_scale = static_cast<double>(newScale);\n            return *this;\n        }\n\n        std::string toString() const;\n\n    private:\n        double m_epsilon;\n        double m_margin;\n        double m_scale;\n        double m_value;\n    };\n}\n\ntemplate<>\nstruct StringMaker<Catch::Detail::Approx> {\n    static std::string convert(Catch::Detail::Approx const& value);\n};\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 2061,
        "end_line": 2167,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "namespace Detail {\n\n    class Approx {\n    private:\n        bool equalityComparisonImpl(double other) const;\n\n    public:\n        explicit Approx ( double value );\n\n        static Approx custom();\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx operator()( T const& value ) {\n            Approx approx( static_cast<double>(value) );\n            approx.epsilon( m_epsilon );\n            approx.margin( m_margin );\n            approx.scale( m_scale );\n            return approx;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        explicit Approx( T const& value ): Approx(static_cast<double>(value))\n        {}\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( const T& lhs, Approx const& rhs ) {\n            auto lhs_v = static_cast<double>(lhs);\n            return rhs.equalityComparisonImpl(lhs_v);\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( Approx const& lhs, const T& rhs ) {\n            return operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( T const& lhs, Approx const& rhs ) {\n            return !operator==( lhs, rhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( Approx const& lhs, T const& rhs ) {\n            return !operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& epsilon( T const& newEpsilon ) {\n            double epsilonAsDouble = static_cast<double>(newEpsilon);\n            if( epsilonAsDouble < 0 || epsilonAsDouble > 1.0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::epsilon: \" +\n                        Catch::Detail::stringify( epsilonAsDouble ) +\n                        \", Approx::epsilon has to be between 0 and 1\" );\n            }\n            m_epsilon = epsilonAsDouble;\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& margin( T const& newMargin ) {\n            double marginAsDouble = static_cast<double>(newMargin);\n            if( marginAsDouble < 0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::margin: \" +\n                         Catch::Detail::stringify( marginAsDouble ) +\n                         \", Approx::Margin has to be non-negative.\" );\n\n            }\n            m_margin = marginAsDouble;\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& scale( T const& newScale ) {\n            m_scale = static_cast<double>(newScale);\n            return *this;\n        }\n\n        std::string toString() const;\n\n    private:\n        double m_epsilon;\n        double m_margin;\n        double m_scale;\n        double m_value;\n    };\n}\n"
    },
    {
        "begin_line": 2063,
        "end_line": 2166,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Approx",
        "snippet": "    class Approx {\n    private:\n        bool equalityComparisonImpl(double other) const;\n\n    public:\n        explicit Approx ( double value );\n\n        static Approx custom();\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx operator()( T const& value ) {\n            Approx approx( static_cast<double>(value) );\n            approx.epsilon( m_epsilon );\n            approx.margin( m_margin );\n            approx.scale( m_scale );\n            return approx;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        explicit Approx( T const& value ): Approx(static_cast<double>(value))\n        {}\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( const T& lhs, Approx const& rhs ) {\n            auto lhs_v = static_cast<double>(lhs);\n            return rhs.equalityComparisonImpl(lhs_v);\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( Approx const& lhs, const T& rhs ) {\n            return operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( T const& lhs, Approx const& rhs ) {\n            return !operator==( lhs, rhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( Approx const& lhs, T const& rhs ) {\n            return !operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& epsilon( T const& newEpsilon ) {\n            double epsilonAsDouble = static_cast<double>(newEpsilon);\n            if( epsilonAsDouble < 0 || epsilonAsDouble > 1.0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::epsilon: \" +\n                        Catch::Detail::stringify( epsilonAsDouble ) +\n                        \", Approx::epsilon has to be between 0 and 1\" );\n            }\n            m_epsilon = epsilonAsDouble;\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& margin( T const& newMargin ) {\n            double marginAsDouble = static_cast<double>(newMargin);\n            if( marginAsDouble < 0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::margin: \" +\n                         Catch::Detail::stringify( marginAsDouble ) +\n                         \", Approx::Margin has to be non-negative.\" );\n\n            }\n            m_margin = marginAsDouble;\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& scale( T const& newScale ) {\n            m_scale = static_cast<double>(newScale);\n            return *this;\n        }\n\n        std::string toString() const;\n\n    private:\n        double m_epsilon;\n        double m_margin;\n        double m_scale;\n        double m_value;\n    };\n"
    },
    {
        "begin_line": 2073,
        "end_line": 2079,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ()",
        "snippet": "        Approx operator()( T const& value ) {\n            Approx approx( static_cast<double>(value) );\n            approx.epsilon( m_epsilon );\n            approx.margin( m_margin );\n            approx.scale( m_scale );\n            return approx;\n        }\n"
    },
    {
        "begin_line": 2082,
        "end_line": 2083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Approx",
        "snippet": "        explicit Approx( T const& value ): Approx(static_cast<double>(value))\n        {}\n"
    },
    {
        "begin_line": 2086,
        "end_line": 2089,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "        friend bool operator == ( const T& lhs, Approx const& rhs ) {\n            auto lhs_v = static_cast<double>(lhs);\n            return rhs.equalityComparisonImpl(lhs_v);\n        }\n"
    },
    {
        "begin_line": 2092,
        "end_line": 2094,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "        friend bool operator == ( Approx const& lhs, const T& rhs ) {\n            return operator==( rhs, lhs );\n        }\n"
    },
    {
        "begin_line": 2097,
        "end_line": 2099,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !=",
        "snippet": "        friend bool operator != ( T const& lhs, Approx const& rhs ) {\n            return !operator==( lhs, rhs );\n        }\n"
    },
    {
        "begin_line": 2102,
        "end_line": 2104,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !=",
        "snippet": "        friend bool operator != ( Approx const& lhs, T const& rhs ) {\n            return !operator==( rhs, lhs );\n        }\n"
    },
    {
        "begin_line": 2107,
        "end_line": 2109,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <=",
        "snippet": "        friend bool operator <= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;\n        }\n"
    },
    {
        "begin_line": 2112,
        "end_line": 2114,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <=",
        "snippet": "        friend bool operator <= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;\n        }\n"
    },
    {
        "begin_line": 2117,
        "end_line": 2119,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator >=",
        "snippet": "        friend bool operator >= ( T const& lhs, Approx const& rhs ) {\n            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;\n        }\n"
    },
    {
        "begin_line": 2122,
        "end_line": 2124,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator >=",
        "snippet": "        friend bool operator >= ( Approx const& lhs, T const& rhs ) {\n            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;\n        }\n"
    },
    {
        "begin_line": 2127,
        "end_line": 2137,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "epsilon",
        "snippet": "        Approx& epsilon( T const& newEpsilon ) {\n            double epsilonAsDouble = static_cast<double>(newEpsilon);\n            if( epsilonAsDouble < 0 || epsilonAsDouble > 1.0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::epsilon: \" +\n                        Catch::Detail::stringify( epsilonAsDouble ) +\n                        \", Approx::epsilon has to be between 0 and 1\" );\n            }\n            m_epsilon = epsilonAsDouble;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 2140,
        "end_line": 2151,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "margin",
        "snippet": "        Approx& margin( T const& newMargin ) {\n            double marginAsDouble = static_cast<double>(newMargin);\n            if( marginAsDouble < 0 ) {\n                throw std::domain_error\n                    (   \"Invalid Approx::margin: \" +\n                         Catch::Detail::stringify( marginAsDouble ) +\n                         \", Approx::Margin has to be non-negative.\" );\n\n            }\n            m_margin = marginAsDouble;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 2154,
        "end_line": 2157,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "scale",
        "snippet": "        Approx& scale( T const& newScale ) {\n            m_scale = static_cast<double>(newScale);\n            return *this;\n        }\n"
    },
    {
        "begin_line": 2162,
        "end_line": 2162,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_epsilon",
        "snippet": "        double m_epsilon;\n"
    },
    {
        "begin_line": 2163,
        "end_line": 2163,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_margin",
        "snippet": "        double m_margin;\n"
    },
    {
        "begin_line": 2164,
        "end_line": 2164,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_scale",
        "snippet": "        double m_scale;\n"
    },
    {
        "begin_line": 2165,
        "end_line": 2165,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_value",
        "snippet": "        double m_value;\n"
    },
    {
        "begin_line": 2170,
        "end_line": 2172,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMaker",
        "snippet": "struct StringMaker<Catch::Detail::Approx> {\n    static std::string convert(Catch::Detail::Approx const& value);\n};\n"
    },
    {
        "begin_line": 2182,
        "end_line": 2202,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    bool startsWith( std::string const& s, std::string const& prefix );\n    bool startsWith( std::string const& s, char prefix );\n    bool endsWith( std::string const& s, std::string const& suffix );\n    bool endsWith( std::string const& s, char suffix );\n    bool contains( std::string const& s, std::string const& infix );\n    void toLowerInPlace( std::string& s );\n    std::string toLower( std::string const& s );\n    std::string trim( std::string const& str );\n    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );\n\n    struct pluralise {\n        pluralise( std::size_t count, std::string const& label );\n\n        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );\n\n        std::size_t m_count;\n        std::string m_label;\n    };\n}\n"
    },
    {
        "begin_line": 2194,
        "end_line": 2201,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "pluralise",
        "snippet": "    struct pluralise {\n        pluralise( std::size_t count, std::string const& label );\n\n        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );\n\n        std::size_t m_count;\n        std::string m_label;\n    };\n"
    },
    {
        "begin_line": 2199,
        "end_line": 2199,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_count",
        "snippet": "        std::size_t m_count;\n"
    },
    {
        "begin_line": 2200,
        "end_line": 2200,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_label",
        "snippet": "        std::string m_label;\n"
    },
    {
        "begin_line": 2213,
        "end_line": 2352,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\n    namespace Impl {\n\n        template<typename ArgT> struct MatchAllOf;\n        template<typename ArgT> struct MatchAnyOf;\n        template<typename ArgT> struct MatchNotOf;\n\n        class MatcherUntypedBase {\n        public:\n            MatcherUntypedBase() = default;\n            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;\n            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;\n            std::string toString() const;\n\n        protected:\n            virtual ~MatcherUntypedBase();\n            virtual std::string describe() const = 0;\n            mutable std::string m_cachedToString;\n        };\n\n        template<typename ObjectT>\n        struct MatcherMethod {\n            virtual bool match( ObjectT const& arg ) const = 0;\n        };\n        template<typename PtrT>\n        struct MatcherMethod<PtrT*> {\n            virtual bool match( PtrT* arg ) const = 0;\n        };\n\n        template<typename T>\n        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {\n\n            MatchAllOf<T> operator && ( MatcherBase const& other ) const;\n            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;\n            MatchNotOf<T> operator ! () const;\n        };\n\n        template<typename ArgT>\n        struct MatchAllOf : MatcherBase<ArgT> {\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (!matcher->match(arg))\n                        return false;\n                }\n                return true;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" and \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n        template<typename ArgT>\n        struct MatchAnyOf : MatcherBase<ArgT> {\n\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (matcher->match(arg))\n                        return true;\n                }\n                return false;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" or \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n\n        template<typename ArgT>\n        struct MatchNotOf : MatcherBase<ArgT> {\n\n            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}\n\n            bool match( ArgT const& arg ) const override {\n                return !m_underlyingMatcher.match( arg );\n            }\n\n            std::string describe() const override {\n                return \"not \" + m_underlyingMatcher.toString();\n            }\n            MatcherBase<ArgT> const& m_underlyingMatcher;\n        };\n\n        template<typename T>\n        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {\n            return MatchAllOf<T>() && *this && other;\n        }\n        template<typename T>\n        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {\n            return MatchAnyOf<T>() || *this || other;\n        }\n        template<typename T>\n        MatchNotOf<T> MatcherBase<T>::operator ! () const {\n            return MatchNotOf<T>( *this );\n        }\n\n    } // namespace Impl\n\n} // namespace Matchers\n\nusing namespace Matchers;\nusing Matchers::Impl::MatcherBase;\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 2214,
        "end_line": 2347,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\n    namespace Impl {\n\n        template<typename ArgT> struct MatchAllOf;\n        template<typename ArgT> struct MatchAnyOf;\n        template<typename ArgT> struct MatchNotOf;\n\n        class MatcherUntypedBase {\n        public:\n            MatcherUntypedBase() = default;\n            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;\n            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;\n            std::string toString() const;\n\n        protected:\n            virtual ~MatcherUntypedBase();\n            virtual std::string describe() const = 0;\n            mutable std::string m_cachedToString;\n        };\n\n        template<typename ObjectT>\n        struct MatcherMethod {\n            virtual bool match( ObjectT const& arg ) const = 0;\n        };\n        template<typename PtrT>\n        struct MatcherMethod<PtrT*> {\n            virtual bool match( PtrT* arg ) const = 0;\n        };\n\n        template<typename T>\n        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {\n\n            MatchAllOf<T> operator && ( MatcherBase const& other ) const;\n            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;\n            MatchNotOf<T> operator ! () const;\n        };\n\n        template<typename ArgT>\n        struct MatchAllOf : MatcherBase<ArgT> {\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (!matcher->match(arg))\n                        return false;\n                }\n                return true;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" and \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n        template<typename ArgT>\n        struct MatchAnyOf : MatcherBase<ArgT> {\n\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (matcher->match(arg))\n                        return true;\n                }\n                return false;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" or \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n\n        template<typename ArgT>\n        struct MatchNotOf : MatcherBase<ArgT> {\n\n            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}\n\n            bool match( ArgT const& arg ) const override {\n                return !m_underlyingMatcher.match( arg );\n            }\n\n            std::string describe() const override {\n                return \"not \" + m_underlyingMatcher.toString();\n            }\n            MatcherBase<ArgT> const& m_underlyingMatcher;\n        };\n\n        template<typename T>\n        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {\n            return MatchAllOf<T>() && *this && other;\n        }\n        template<typename T>\n        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {\n            return MatchAnyOf<T>() || *this || other;\n        }\n        template<typename T>\n        MatchNotOf<T> MatcherBase<T>::operator ! () const {\n            return MatchNotOf<T>( *this );\n        }\n\n    } // namespace Impl\n\n} // namespace Matchers\n"
    },
    {
        "begin_line": 2215,
        "end_line": 2345,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Impl",
        "snippet": "    namespace Impl {\n\n        template<typename ArgT> struct MatchAllOf;\n        template<typename ArgT> struct MatchAnyOf;\n        template<typename ArgT> struct MatchNotOf;\n\n        class MatcherUntypedBase {\n        public:\n            MatcherUntypedBase() = default;\n            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;\n            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;\n            std::string toString() const;\n\n        protected:\n            virtual ~MatcherUntypedBase();\n            virtual std::string describe() const = 0;\n            mutable std::string m_cachedToString;\n        };\n\n        template<typename ObjectT>\n        struct MatcherMethod {\n            virtual bool match( ObjectT const& arg ) const = 0;\n        };\n        template<typename PtrT>\n        struct MatcherMethod<PtrT*> {\n            virtual bool match( PtrT* arg ) const = 0;\n        };\n\n        template<typename T>\n        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {\n\n            MatchAllOf<T> operator && ( MatcherBase const& other ) const;\n            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;\n            MatchNotOf<T> operator ! () const;\n        };\n\n        template<typename ArgT>\n        struct MatchAllOf : MatcherBase<ArgT> {\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (!matcher->match(arg))\n                        return false;\n                }\n                return true;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" and \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n        template<typename ArgT>\n        struct MatchAnyOf : MatcherBase<ArgT> {\n\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (matcher->match(arg))\n                        return true;\n                }\n                return false;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" or \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n\n        template<typename ArgT>\n        struct MatchNotOf : MatcherBase<ArgT> {\n\n            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}\n\n            bool match( ArgT const& arg ) const override {\n                return !m_underlyingMatcher.match( arg );\n            }\n\n            std::string describe() const override {\n                return \"not \" + m_underlyingMatcher.toString();\n            }\n            MatcherBase<ArgT> const& m_underlyingMatcher;\n        };\n\n        template<typename T>\n        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {\n            return MatchAllOf<T>() && *this && other;\n        }\n        template<typename T>\n        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {\n            return MatchAnyOf<T>() || *this || other;\n        }\n        template<typename T>\n        MatchNotOf<T> MatcherBase<T>::operator ! () const {\n            return MatchNotOf<T>( *this );\n        }\n\n    } // namespace Impl\n"
    },
    {
        "begin_line": 2221,
        "end_line": 2232,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatcherUntypedBase",
        "snippet": "        class MatcherUntypedBase {\n        public:\n            MatcherUntypedBase() = default;\n            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;\n            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;\n            std::string toString() const;\n\n        protected:\n            virtual ~MatcherUntypedBase();\n            virtual std::string describe() const = 0;\n            mutable std::string m_cachedToString;\n        };\n"
    },
    {
        "begin_line": 2231,
        "end_line": 2231,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_cachedToString",
        "snippet": "            mutable std::string m_cachedToString;\n"
    },
    {
        "begin_line": 2235,
        "end_line": 2237,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatcherMethod",
        "snippet": "        struct MatcherMethod {\n            virtual bool match( ObjectT const& arg ) const = 0;\n        };\n"
    },
    {
        "begin_line": 2239,
        "end_line": 2241,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatcherMethod",
        "snippet": "        struct MatcherMethod<PtrT*> {\n            virtual bool match( PtrT* arg ) const = 0;\n        };\n"
    },
    {
        "begin_line": 2244,
        "end_line": 2249,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatcherBase",
        "snippet": "        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {\n\n            MatchAllOf<T> operator && ( MatcherBase const& other ) const;\n            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;\n            MatchNotOf<T> operator ! () const;\n        };\n"
    },
    {
        "begin_line": 2252,
        "end_line": 2282,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatchAllOf",
        "snippet": "        struct MatchAllOf : MatcherBase<ArgT> {\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (!matcher->match(arg))\n                        return false;\n                }\n                return true;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" and \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n"
    },
    {
        "begin_line": 2253,
        "end_line": 2259,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (!matcher->match(arg))\n                        return false;\n                }\n                return true;\n            }\n"
    },
    {
        "begin_line": 2260,
        "end_line": 2274,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" and \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n"
    },
    {
        "begin_line": 2276,
        "end_line": 2279,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator &&",
        "snippet": "            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n"
    },
    {
        "begin_line": 2281,
        "end_line": 2281,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_matchers",
        "snippet": "            std::vector<MatcherBase<ArgT> const*> m_matchers;\n"
    },
    {
        "begin_line": 2284,
        "end_line": 2315,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatchAnyOf",
        "snippet": "        struct MatchAnyOf : MatcherBase<ArgT> {\n\n            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (matcher->match(arg))\n                        return true;\n                }\n                return false;\n            }\n            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" or \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n"
    },
    {
        "begin_line": 2286,
        "end_line": 2292,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "            bool match( ArgT const& arg ) const override {\n                for( auto matcher : m_matchers ) {\n                    if (matcher->match(arg))\n                        return true;\n                }\n                return false;\n            }\n"
    },
    {
        "begin_line": 2293,
        "end_line": 2307,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "            std::string describe() const override {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                bool first = true;\n                for( auto matcher : m_matchers ) {\n                    if( first )\n                        first = false;\n                    else\n                        description += \" or \";\n                    description += matcher->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n"
    },
    {
        "begin_line": 2309,
        "end_line": 2312,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ||",
        "snippet": "            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n"
    },
    {
        "begin_line": 2314,
        "end_line": 2314,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_matchers",
        "snippet": "            std::vector<MatcherBase<ArgT> const*> m_matchers;\n"
    },
    {
        "begin_line": 2318,
        "end_line": 2330,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatchNotOf",
        "snippet": "        struct MatchNotOf : MatcherBase<ArgT> {\n\n            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}\n\n            bool match( ArgT const& arg ) const override {\n                return !m_underlyingMatcher.match( arg );\n            }\n\n            std::string describe() const override {\n                return \"not \" + m_underlyingMatcher.toString();\n            }\n            MatcherBase<ArgT> const& m_underlyingMatcher;\n        };\n"
    },
    {
        "begin_line": 2320,
        "end_line": 2320,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatchNotOf",
        "snippet": "            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}\n"
    },
    {
        "begin_line": 2322,
        "end_line": 2324,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "            bool match( ArgT const& arg ) const override {\n                return !m_underlyingMatcher.match( arg );\n            }\n"
    },
    {
        "begin_line": 2326,
        "end_line": 2328,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "            std::string describe() const override {\n                return \"not \" + m_underlyingMatcher.toString();\n            }\n"
    },
    {
        "begin_line": 2329,
        "end_line": 2329,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_underlyingMatcher",
        "snippet": "            MatcherBase<ArgT> const& m_underlyingMatcher;\n"
    },
    {
        "begin_line": 2333,
        "end_line": 2335,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator &&",
        "snippet": "        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {\n            return MatchAllOf<T>() && *this && other;\n        }\n"
    },
    {
        "begin_line": 2337,
        "end_line": 2339,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ||",
        "snippet": "        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {\n            return MatchAnyOf<T>() || *this || other;\n        }\n"
    },
    {
        "begin_line": 2341,
        "end_line": 2343,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !",
        "snippet": "        MatchNotOf<T> MatcherBase<T>::operator ! () const {\n            return MatchNotOf<T>( *this );\n        }\n"
    },
    {
        "begin_line": 2360,
        "end_line": 2395,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\n\n    namespace Floating {\n\n        enum class FloatingPointKind : uint8_t;\n\n        struct WithinAbsMatcher : MatcherBase<double> {\n            WithinAbsMatcher(double target, double margin);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            double m_margin;\n        };\n\n        struct WithinUlpsMatcher : MatcherBase<double> {\n            WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            int m_ulps;\n            FloatingPointKind m_type;\n        };\n\n    } // namespace Floating\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n    Floating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff);\n    Floating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff);\n    Floating::WithinAbsMatcher WithinAbs(double target, double margin);\n\n} // namespace Matchers\n} // namespace Catch\n"
    },
    {
        "begin_line": 2361,
        "end_line": 2394,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\n\n    namespace Floating {\n\n        enum class FloatingPointKind : uint8_t;\n\n        struct WithinAbsMatcher : MatcherBase<double> {\n            WithinAbsMatcher(double target, double margin);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            double m_margin;\n        };\n\n        struct WithinUlpsMatcher : MatcherBase<double> {\n            WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            int m_ulps;\n            FloatingPointKind m_type;\n        };\n\n    } // namespace Floating\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n    Floating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff);\n    Floating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff);\n    Floating::WithinAbsMatcher WithinAbs(double target, double margin);\n\n} // namespace Matchers\n"
    },
    {
        "begin_line": 2363,
        "end_line": 2386,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Floating",
        "snippet": "    namespace Floating {\n\n        enum class FloatingPointKind : uint8_t;\n\n        struct WithinAbsMatcher : MatcherBase<double> {\n            WithinAbsMatcher(double target, double margin);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            double m_margin;\n        };\n\n        struct WithinUlpsMatcher : MatcherBase<double> {\n            WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            int m_ulps;\n            FloatingPointKind m_type;\n        };\n\n    } // namespace Floating\n"
    },
    {
        "begin_line": 2367,
        "end_line": 2374,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WithinAbsMatcher",
        "snippet": "        struct WithinAbsMatcher : MatcherBase<double> {\n            WithinAbsMatcher(double target, double margin);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            double m_margin;\n        };\n"
    },
    {
        "begin_line": 2372,
        "end_line": 2372,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_target",
        "snippet": "            double m_target;\n"
    },
    {
        "begin_line": 2373,
        "end_line": 2373,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_margin",
        "snippet": "            double m_margin;\n"
    },
    {
        "begin_line": 2376,
        "end_line": 2384,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WithinUlpsMatcher",
        "snippet": "        struct WithinUlpsMatcher : MatcherBase<double> {\n            WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType);\n            bool match(double const& matchee) const override;\n            std::string describe() const override;\n        private:\n            double m_target;\n            int m_ulps;\n            FloatingPointKind m_type;\n        };\n"
    },
    {
        "begin_line": 2381,
        "end_line": 2381,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_target",
        "snippet": "            double m_target;\n"
    },
    {
        "begin_line": 2382,
        "end_line": 2382,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ulps",
        "snippet": "            int m_ulps;\n"
    },
    {
        "begin_line": 2383,
        "end_line": 2383,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_type",
        "snippet": "            FloatingPointKind m_type;\n"
    },
    {
        "begin_line": 2403,
        "end_line": 2443,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\nnamespace Generic {\n\nnamespace Detail {\n    std::string finalizeDescription(const std::string& desc);\n}\n\ntemplate <typename T>\nclass PredicateMatcher : public MatcherBase<T> {\n    std::function<bool(T const&)> m_predicate;\n    std::string m_description;\npublic:\n\n    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)\n        :m_predicate(std::move(elem)),\n        m_description(Detail::finalizeDescription(descr))\n    {}\n\n    bool match( T const& item ) const override {\n        return m_predicate(item);\n    }\n\n    std::string describe() const override {\n        return m_description;\n    }\n};\n\n} // namespace Generic\n\n    // The following functions create the actual matcher objects.\n    // The user has to explicitly specify type to the function, because\n    // infering std::function<bool(T const&)> is hard (but possible) and\n    // requires a lot of TMP.\n    template<typename T>\n    Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = \"\") {\n        return Generic::PredicateMatcher<T>(predicate, description);\n    }\n\n} // namespace Matchers\n} // namespace Catch\n"
    },
    {
        "begin_line": 2404,
        "end_line": 2442,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\nnamespace Generic {\n\nnamespace Detail {\n    std::string finalizeDescription(const std::string& desc);\n}\n\ntemplate <typename T>\nclass PredicateMatcher : public MatcherBase<T> {\n    std::function<bool(T const&)> m_predicate;\n    std::string m_description;\npublic:\n\n    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)\n        :m_predicate(std::move(elem)),\n        m_description(Detail::finalizeDescription(descr))\n    {}\n\n    bool match( T const& item ) const override {\n        return m_predicate(item);\n    }\n\n    std::string describe() const override {\n        return m_description;\n    }\n};\n\n} // namespace Generic\n\n    // The following functions create the actual matcher objects.\n    // The user has to explicitly specify type to the function, because\n    // infering std::function<bool(T const&)> is hard (but possible) and\n    // requires a lot of TMP.\n    template<typename T>\n    Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = \"\") {\n        return Generic::PredicateMatcher<T>(predicate, description);\n    }\n\n} // namespace Matchers\n"
    },
    {
        "begin_line": 2405,
        "end_line": 2431,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Generic",
        "snippet": "namespace Generic {\n\nnamespace Detail {\n    std::string finalizeDescription(const std::string& desc);\n}\n\ntemplate <typename T>\nclass PredicateMatcher : public MatcherBase<T> {\n    std::function<bool(T const&)> m_predicate;\n    std::string m_description;\npublic:\n\n    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)\n        :m_predicate(std::move(elem)),\n        m_description(Detail::finalizeDescription(descr))\n    {}\n\n    bool match( T const& item ) const override {\n        return m_predicate(item);\n    }\n\n    std::string describe() const override {\n        return m_description;\n    }\n};\n\n} // namespace Generic\n"
    },
    {
        "begin_line": 2407,
        "end_line": 2409,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "namespace Detail {\n    std::string finalizeDescription(const std::string& desc);\n}\n"
    },
    {
        "begin_line": 2412,
        "end_line": 2429,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "PredicateMatcher",
        "snippet": "class PredicateMatcher : public MatcherBase<T> {\n    std::function<bool(T const&)> m_predicate;\n    std::string m_description;\npublic:\n\n    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)\n        :m_predicate(std::move(elem)),\n        m_description(Detail::finalizeDescription(descr))\n    {}\n\n    bool match( T const& item ) const override {\n        return m_predicate(item);\n    }\n\n    std::string describe() const override {\n        return m_description;\n    }\n};\n"
    },
    {
        "begin_line": 2413,
        "end_line": 2413,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_predicate",
        "snippet": "    std::function<bool(T const&)> m_predicate;\n"
    },
    {
        "begin_line": 2414,
        "end_line": 2414,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_description",
        "snippet": "    std::string m_description;\n"
    },
    {
        "begin_line": 2417,
        "end_line": 2420,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "PredicateMatcher",
        "snippet": "    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)\n        :m_predicate(std::move(elem)),\n        m_description(Detail::finalizeDescription(descr))\n    {}\n"
    },
    {
        "begin_line": 2422,
        "end_line": 2424,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "    bool match( T const& item ) const override {\n        return m_predicate(item);\n    }\n"
    },
    {
        "begin_line": 2426,
        "end_line": 2428,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "    std::string describe() const override {\n        return m_description;\n    }\n"
    },
    {
        "begin_line": 2438,
        "end_line": 2440,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Predicate",
        "snippet": "    Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = \"\") {\n        return Generic::PredicateMatcher<T>(predicate, description);\n    }\n"
    },
    {
        "begin_line": 2450,
        "end_line": 2512,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\n\n    namespace StdString {\n\n        struct CasedString\n        {\n            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );\n            std::string adjustString( std::string const& str ) const;\n            std::string caseSensitivitySuffix() const;\n\n            CaseSensitive::Choice m_caseSensitivity;\n            std::string m_str;\n        };\n\n        struct StringMatcherBase : MatcherBase<std::string> {\n            StringMatcherBase( std::string const& operation, CasedString const& comparator );\n            std::string describe() const override;\n\n            CasedString m_comparator;\n            std::string m_operation;\n        };\n\n        struct EqualsMatcher : StringMatcherBase {\n            EqualsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct ContainsMatcher : StringMatcherBase {\n            ContainsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct StartsWithMatcher : StringMatcherBase {\n            StartsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct EndsWithMatcher : StringMatcherBase {\n            EndsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n\n        struct RegexMatcher : MatcherBase<std::string> {\n            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );\n            bool match( std::string const& matchee ) const override;\n            std::string describe() const override;\n\n        private:\n            std::string m_regex;\n            CaseSensitive::Choice m_caseSensitivity;\n        };\n\n    } // namespace StdString\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n\n    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n\n} // namespace Matchers\n} // namespace Catch\n"
    },
    {
        "begin_line": 2451,
        "end_line": 2511,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\n\n    namespace StdString {\n\n        struct CasedString\n        {\n            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );\n            std::string adjustString( std::string const& str ) const;\n            std::string caseSensitivitySuffix() const;\n\n            CaseSensitive::Choice m_caseSensitivity;\n            std::string m_str;\n        };\n\n        struct StringMatcherBase : MatcherBase<std::string> {\n            StringMatcherBase( std::string const& operation, CasedString const& comparator );\n            std::string describe() const override;\n\n            CasedString m_comparator;\n            std::string m_operation;\n        };\n\n        struct EqualsMatcher : StringMatcherBase {\n            EqualsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct ContainsMatcher : StringMatcherBase {\n            ContainsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct StartsWithMatcher : StringMatcherBase {\n            StartsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct EndsWithMatcher : StringMatcherBase {\n            EndsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n\n        struct RegexMatcher : MatcherBase<std::string> {\n            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );\n            bool match( std::string const& matchee ) const override;\n            std::string describe() const override;\n\n        private:\n            std::string m_regex;\n            CaseSensitive::Choice m_caseSensitivity;\n        };\n\n    } // namespace StdString\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n\n    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n\n} // namespace Matchers\n"
    },
    {
        "begin_line": 2453,
        "end_line": 2500,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StdString",
        "snippet": "    namespace StdString {\n\n        struct CasedString\n        {\n            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );\n            std::string adjustString( std::string const& str ) const;\n            std::string caseSensitivitySuffix() const;\n\n            CaseSensitive::Choice m_caseSensitivity;\n            std::string m_str;\n        };\n\n        struct StringMatcherBase : MatcherBase<std::string> {\n            StringMatcherBase( std::string const& operation, CasedString const& comparator );\n            std::string describe() const override;\n\n            CasedString m_comparator;\n            std::string m_operation;\n        };\n\n        struct EqualsMatcher : StringMatcherBase {\n            EqualsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct ContainsMatcher : StringMatcherBase {\n            ContainsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct StartsWithMatcher : StringMatcherBase {\n            StartsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n        struct EndsWithMatcher : StringMatcherBase {\n            EndsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n\n        struct RegexMatcher : MatcherBase<std::string> {\n            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );\n            bool match( std::string const& matchee ) const override;\n            std::string describe() const override;\n\n        private:\n            std::string m_regex;\n            CaseSensitive::Choice m_caseSensitivity;\n        };\n\n    } // namespace StdString\n"
    },
    {
        "begin_line": 2455,
        "end_line": 2463,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CasedString",
        "snippet": "        struct CasedString\n        {\n            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );\n            std::string adjustString( std::string const& str ) const;\n            std::string caseSensitivitySuffix() const;\n\n            CaseSensitive::Choice m_caseSensitivity;\n            std::string m_str;\n        };\n"
    },
    {
        "begin_line": 2461,
        "end_line": 2461,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_caseSensitivity",
        "snippet": "            CaseSensitive::Choice m_caseSensitivity;\n"
    },
    {
        "begin_line": 2462,
        "end_line": 2462,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_str",
        "snippet": "            std::string m_str;\n"
    },
    {
        "begin_line": 2465,
        "end_line": 2471,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMatcherBase",
        "snippet": "        struct StringMatcherBase : MatcherBase<std::string> {\n            StringMatcherBase( std::string const& operation, CasedString const& comparator );\n            std::string describe() const override;\n\n            CasedString m_comparator;\n            std::string m_operation;\n        };\n"
    },
    {
        "begin_line": 2469,
        "end_line": 2469,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_comparator",
        "snippet": "            CasedString m_comparator;\n"
    },
    {
        "begin_line": 2470,
        "end_line": 2470,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_operation",
        "snippet": "            std::string m_operation;\n"
    },
    {
        "begin_line": 2473,
        "end_line": 2476,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EqualsMatcher",
        "snippet": "        struct EqualsMatcher : StringMatcherBase {\n            EqualsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n"
    },
    {
        "begin_line": 2477,
        "end_line": 2480,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ContainsMatcher",
        "snippet": "        struct ContainsMatcher : StringMatcherBase {\n            ContainsMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n"
    },
    {
        "begin_line": 2481,
        "end_line": 2484,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StartsWithMatcher",
        "snippet": "        struct StartsWithMatcher : StringMatcherBase {\n            StartsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n"
    },
    {
        "begin_line": 2485,
        "end_line": 2488,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EndsWithMatcher",
        "snippet": "        struct EndsWithMatcher : StringMatcherBase {\n            EndsWithMatcher( CasedString const& comparator );\n            bool match( std::string const& source ) const override;\n        };\n"
    },
    {
        "begin_line": 2490,
        "end_line": 2498,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RegexMatcher",
        "snippet": "        struct RegexMatcher : MatcherBase<std::string> {\n            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );\n            bool match( std::string const& matchee ) const override;\n            std::string describe() const override;\n\n        private:\n            std::string m_regex;\n            CaseSensitive::Choice m_caseSensitivity;\n        };\n"
    },
    {
        "begin_line": 2496,
        "end_line": 2496,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_regex",
        "snippet": "            std::string m_regex;\n"
    },
    {
        "begin_line": 2497,
        "end_line": 2497,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_caseSensitivity",
        "snippet": "            CaseSensitive::Choice m_caseSensitivity;\n"
    },
    {
        "begin_line": 2519,
        "end_line": 2685,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\n\n    namespace Vector {\n        namespace Detail {\n            template <typename InputIterator, typename T>\n            size_t count(InputIterator first, InputIterator last, T const& item) {\n                size_t cnt = 0;\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        ++cnt;\n                    }\n                }\n                return cnt;\n            }\n            template <typename InputIterator, typename T>\n            bool contains(InputIterator first, InputIterator last, T const& item) {\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        template<typename T>\n        struct ContainsElementMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}\n\n            bool match(std::vector<T> const &v) const override {\n                for (auto const& el : v) {\n                    if (el == m_comparator) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            T const& m_comparator;\n        };\n\n        template<typename T>\n        struct ContainsMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: see note in EqualsMatcher\n                if (m_comparator.size() > v.size())\n                    return false;\n                for (auto const& comparator : m_comparator) {\n                    auto present = false;\n                    for (const auto& el : v) {\n                        if (el == comparator) {\n                            present = true;\n                            break;\n                        }\n                    }\n                    if (!present) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            std::vector<T> const& m_comparator;\n        };\n\n        template<typename T>\n        struct EqualsMatcher : MatcherBase<std::vector<T>> {\n\n            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: This currently works if all elements can be compared using !=\n                // - a more general approach would be via a compare template that defaults\n                // to using !=. but could be specialised for, e.g. std::vector<T> etc\n                // - then just call that directly\n                if (m_comparator.size() != v.size())\n                    return false;\n                for (std::size_t i = 0; i < v.size(); ++i)\n                    if (m_comparator[i] != v[i])\n                        return false;\n                return true;\n            }\n            std::string describe() const override {\n                return \"Equals: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n            std::vector<T> const& m_comparator;\n        };\n\n        template<typename T>\n        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T>> {\n            UnorderedEqualsMatcher(std::vector<T> const& target) : m_target(target) {}\n            bool match(std::vector<T> const& vec) const override {\n                // Note: This is a reimplementation of std::is_permutation,\n                //       because I don't want to include <algorithm> inside the common path\n                if (m_target.size() != vec.size()) {\n                    return false;\n                }\n                auto lfirst = m_target.begin(), llast = m_target.end();\n                auto rfirst = vec.begin(), rlast = vec.end();\n                // Cut common prefix to optimize checking of permuted parts\n                while (lfirst != llast && *lfirst != *rfirst) {\n                    ++lfirst; ++rfirst;\n                }\n                if (lfirst == llast) {\n                    return true;\n                }\n\n                for (auto mid = lfirst; mid != llast; ++mid) {\n                    // Skip already counted items\n                    if (Detail::contains(lfirst, mid, *mid)) {\n                        continue;\n                    }\n                    size_t num_vec = Detail::count(rfirst, rlast, *mid);\n                    if (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            std::string describe() const override {\n                return \"UnorderedEquals: \" + ::Catch::Detail::stringify(m_target);\n            }\n        private:\n            std::vector<T> const& m_target;\n        };\n\n    } // namespace Vector\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n\n    template<typename T>\n    Vector::ContainsMatcher<T> Contains( std::vector<T> const& comparator ) {\n        return Vector::ContainsMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::ContainsElementMatcher<T> VectorContains( T const& comparator ) {\n        return Vector::ContainsElementMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::EqualsMatcher<T> Equals( std::vector<T> const& comparator ) {\n        return Vector::EqualsMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::UnorderedEqualsMatcher<T> UnorderedEquals(std::vector<T> const& target) {\n        return Vector::UnorderedEqualsMatcher<T>(target);\n    }\n\n} // namespace Matchers\n} // namespace Catch\n"
    },
    {
        "begin_line": 2520,
        "end_line": 2684,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\n\n    namespace Vector {\n        namespace Detail {\n            template <typename InputIterator, typename T>\n            size_t count(InputIterator first, InputIterator last, T const& item) {\n                size_t cnt = 0;\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        ++cnt;\n                    }\n                }\n                return cnt;\n            }\n            template <typename InputIterator, typename T>\n            bool contains(InputIterator first, InputIterator last, T const& item) {\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        template<typename T>\n        struct ContainsElementMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}\n\n            bool match(std::vector<T> const &v) const override {\n                for (auto const& el : v) {\n                    if (el == m_comparator) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            T const& m_comparator;\n        };\n\n        template<typename T>\n        struct ContainsMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: see note in EqualsMatcher\n                if (m_comparator.size() > v.size())\n                    return false;\n                for (auto const& comparator : m_comparator) {\n                    auto present = false;\n                    for (const auto& el : v) {\n                        if (el == comparator) {\n                            present = true;\n                            break;\n                        }\n                    }\n                    if (!present) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            std::vector<T> const& m_comparator;\n        };\n\n        template<typename T>\n        struct EqualsMatcher : MatcherBase<std::vector<T>> {\n\n            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: This currently works if all elements can be compared using !=\n                // - a more general approach would be via a compare template that defaults\n                // to using !=. but could be specialised for, e.g. std::vector<T> etc\n                // - then just call that directly\n                if (m_comparator.size() != v.size())\n                    return false;\n                for (std::size_t i = 0; i < v.size(); ++i)\n                    if (m_comparator[i] != v[i])\n                        return false;\n                return true;\n            }\n            std::string describe() const override {\n                return \"Equals: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n            std::vector<T> const& m_comparator;\n        };\n\n        template<typename T>\n        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T>> {\n            UnorderedEqualsMatcher(std::vector<T> const& target) : m_target(target) {}\n            bool match(std::vector<T> const& vec) const override {\n                // Note: This is a reimplementation of std::is_permutation,\n                //       because I don't want to include <algorithm> inside the common path\n                if (m_target.size() != vec.size()) {\n                    return false;\n                }\n                auto lfirst = m_target.begin(), llast = m_target.end();\n                auto rfirst = vec.begin(), rlast = vec.end();\n                // Cut common prefix to optimize checking of permuted parts\n                while (lfirst != llast && *lfirst != *rfirst) {\n                    ++lfirst; ++rfirst;\n                }\n                if (lfirst == llast) {\n                    return true;\n                }\n\n                for (auto mid = lfirst; mid != llast; ++mid) {\n                    // Skip already counted items\n                    if (Detail::contains(lfirst, mid, *mid)) {\n                        continue;\n                    }\n                    size_t num_vec = Detail::count(rfirst, rlast, *mid);\n                    if (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            std::string describe() const override {\n                return \"UnorderedEquals: \" + ::Catch::Detail::stringify(m_target);\n            }\n        private:\n            std::vector<T> const& m_target;\n        };\n\n    } // namespace Vector\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n\n    template<typename T>\n    Vector::ContainsMatcher<T> Contains( std::vector<T> const& comparator ) {\n        return Vector::ContainsMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::ContainsElementMatcher<T> VectorContains( T const& comparator ) {\n        return Vector::ContainsElementMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::EqualsMatcher<T> Equals( std::vector<T> const& comparator ) {\n        return Vector::EqualsMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::UnorderedEqualsMatcher<T> UnorderedEquals(std::vector<T> const& target) {\n        return Vector::UnorderedEqualsMatcher<T>(target);\n    }\n\n} // namespace Matchers\n"
    },
    {
        "begin_line": 2522,
        "end_line": 2659,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Vector",
        "snippet": "    namespace Vector {\n        namespace Detail {\n            template <typename InputIterator, typename T>\n            size_t count(InputIterator first, InputIterator last, T const& item) {\n                size_t cnt = 0;\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        ++cnt;\n                    }\n                }\n                return cnt;\n            }\n            template <typename InputIterator, typename T>\n            bool contains(InputIterator first, InputIterator last, T const& item) {\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        template<typename T>\n        struct ContainsElementMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}\n\n            bool match(std::vector<T> const &v) const override {\n                for (auto const& el : v) {\n                    if (el == m_comparator) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            T const& m_comparator;\n        };\n\n        template<typename T>\n        struct ContainsMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: see note in EqualsMatcher\n                if (m_comparator.size() > v.size())\n                    return false;\n                for (auto const& comparator : m_comparator) {\n                    auto present = false;\n                    for (const auto& el : v) {\n                        if (el == comparator) {\n                            present = true;\n                            break;\n                        }\n                    }\n                    if (!present) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            std::vector<T> const& m_comparator;\n        };\n\n        template<typename T>\n        struct EqualsMatcher : MatcherBase<std::vector<T>> {\n\n            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: This currently works if all elements can be compared using !=\n                // - a more general approach would be via a compare template that defaults\n                // to using !=. but could be specialised for, e.g. std::vector<T> etc\n                // - then just call that directly\n                if (m_comparator.size() != v.size())\n                    return false;\n                for (std::size_t i = 0; i < v.size(); ++i)\n                    if (m_comparator[i] != v[i])\n                        return false;\n                return true;\n            }\n            std::string describe() const override {\n                return \"Equals: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n            std::vector<T> const& m_comparator;\n        };\n\n        template<typename T>\n        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T>> {\n            UnorderedEqualsMatcher(std::vector<T> const& target) : m_target(target) {}\n            bool match(std::vector<T> const& vec) const override {\n                // Note: This is a reimplementation of std::is_permutation,\n                //       because I don't want to include <algorithm> inside the common path\n                if (m_target.size() != vec.size()) {\n                    return false;\n                }\n                auto lfirst = m_target.begin(), llast = m_target.end();\n                auto rfirst = vec.begin(), rlast = vec.end();\n                // Cut common prefix to optimize checking of permuted parts\n                while (lfirst != llast && *lfirst != *rfirst) {\n                    ++lfirst; ++rfirst;\n                }\n                if (lfirst == llast) {\n                    return true;\n                }\n\n                for (auto mid = lfirst; mid != llast; ++mid) {\n                    // Skip already counted items\n                    if (Detail::contains(lfirst, mid, *mid)) {\n                        continue;\n                    }\n                    size_t num_vec = Detail::count(rfirst, rlast, *mid);\n                    if (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            std::string describe() const override {\n                return \"UnorderedEquals: \" + ::Catch::Detail::stringify(m_target);\n            }\n        private:\n            std::vector<T> const& m_target;\n        };\n\n    } // namespace Vector\n"
    },
    {
        "begin_line": 2523,
        "end_line": 2543,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "        namespace Detail {\n            template <typename InputIterator, typename T>\n            size_t count(InputIterator first, InputIterator last, T const& item) {\n                size_t cnt = 0;\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        ++cnt;\n                    }\n                }\n                return cnt;\n            }\n            template <typename InputIterator, typename T>\n            bool contains(InputIterator first, InputIterator last, T const& item) {\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n"
    },
    {
        "begin_line": 2525,
        "end_line": 2533,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "count",
        "snippet": "            size_t count(InputIterator first, InputIterator last, T const& item) {\n                size_t cnt = 0;\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        ++cnt;\n                    }\n                }\n                return cnt;\n            }\n"
    },
    {
        "begin_line": 2535,
        "end_line": 2542,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "contains",
        "snippet": "            bool contains(InputIterator first, InputIterator last, T const& item) {\n                for (; first != last; ++first) {\n                    if (*first == item) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n"
    },
    {
        "begin_line": 2546,
        "end_line": 2564,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ContainsElementMatcher",
        "snippet": "        struct ContainsElementMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}\n\n            bool match(std::vector<T> const &v) const override {\n                for (auto const& el : v) {\n                    if (el == m_comparator) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            T const& m_comparator;\n        };\n"
    },
    {
        "begin_line": 2548,
        "end_line": 2548,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ContainsElementMatcher",
        "snippet": "            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}\n"
    },
    {
        "begin_line": 2550,
        "end_line": 2557,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "            bool match(std::vector<T> const &v) const override {\n                for (auto const& el : v) {\n                    if (el == m_comparator) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n"
    },
    {
        "begin_line": 2559,
        "end_line": 2561,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n"
    },
    {
        "begin_line": 2563,
        "end_line": 2563,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_comparator",
        "snippet": "            T const& m_comparator;\n"
    },
    {
        "begin_line": 2567,
        "end_line": 2594,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ContainsMatcher",
        "snippet": "        struct ContainsMatcher : MatcherBase<std::vector<T>> {\n\n            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: see note in EqualsMatcher\n                if (m_comparator.size() > v.size())\n                    return false;\n                for (auto const& comparator : m_comparator) {\n                    auto present = false;\n                    for (const auto& el : v) {\n                        if (el == comparator) {\n                            present = true;\n                            break;\n                        }\n                    }\n                    if (!present) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n\n            std::vector<T> const& m_comparator;\n        };\n"
    },
    {
        "begin_line": 2569,
        "end_line": 2569,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ContainsMatcher",
        "snippet": "            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n"
    },
    {
        "begin_line": 2571,
        "end_line": 2588,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "            bool match(std::vector<T> const &v) const override {\n                // !TBD: see note in EqualsMatcher\n                if (m_comparator.size() > v.size())\n                    return false;\n                for (auto const& comparator : m_comparator) {\n                    auto present = false;\n                    for (const auto& el : v) {\n                        if (el == comparator) {\n                            present = true;\n                            break;\n                        }\n                    }\n                    if (!present) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n"
    },
    {
        "begin_line": 2589,
        "end_line": 2591,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "            std::string describe() const override {\n                return \"Contains: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n"
    },
    {
        "begin_line": 2593,
        "end_line": 2593,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_comparator",
        "snippet": "            std::vector<T> const& m_comparator;\n"
    },
    {
        "begin_line": 2597,
        "end_line": 2617,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EqualsMatcher",
        "snippet": "        struct EqualsMatcher : MatcherBase<std::vector<T>> {\n\n            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const override {\n                // !TBD: This currently works if all elements can be compared using !=\n                // - a more general approach would be via a compare template that defaults\n                // to using !=. but could be specialised for, e.g. std::vector<T> etc\n                // - then just call that directly\n                if (m_comparator.size() != v.size())\n                    return false;\n                for (std::size_t i = 0; i < v.size(); ++i)\n                    if (m_comparator[i] != v[i])\n                        return false;\n                return true;\n            }\n            std::string describe() const override {\n                return \"Equals: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n            std::vector<T> const& m_comparator;\n        };\n"
    },
    {
        "begin_line": 2599,
        "end_line": 2599,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EqualsMatcher",
        "snippet": "            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n"
    },
    {
        "begin_line": 2601,
        "end_line": 2612,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "            bool match(std::vector<T> const &v) const override {\n                // !TBD: This currently works if all elements can be compared using !=\n                // - a more general approach would be via a compare template that defaults\n                // to using !=. but could be specialised for, e.g. std::vector<T> etc\n                // - then just call that directly\n                if (m_comparator.size() != v.size())\n                    return false;\n                for (std::size_t i = 0; i < v.size(); ++i)\n                    if (m_comparator[i] != v[i])\n                        return false;\n                return true;\n            }\n"
    },
    {
        "begin_line": 2613,
        "end_line": 2615,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "            std::string describe() const override {\n                return \"Equals: \" + ::Catch::Detail::stringify( m_comparator );\n            }\n"
    },
    {
        "begin_line": 2616,
        "end_line": 2616,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_comparator",
        "snippet": "            std::vector<T> const& m_comparator;\n"
    },
    {
        "begin_line": 2620,
        "end_line": 2657,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnorderedEqualsMatcher",
        "snippet": "        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T>> {\n            UnorderedEqualsMatcher(std::vector<T> const& target) : m_target(target) {}\n            bool match(std::vector<T> const& vec) const override {\n                // Note: This is a reimplementation of std::is_permutation,\n                //       because I don't want to include <algorithm> inside the common path\n                if (m_target.size() != vec.size()) {\n                    return false;\n                }\n                auto lfirst = m_target.begin(), llast = m_target.end();\n                auto rfirst = vec.begin(), rlast = vec.end();\n                // Cut common prefix to optimize checking of permuted parts\n                while (lfirst != llast && *lfirst != *rfirst) {\n                    ++lfirst; ++rfirst;\n                }\n                if (lfirst == llast) {\n                    return true;\n                }\n\n                for (auto mid = lfirst; mid != llast; ++mid) {\n                    // Skip already counted items\n                    if (Detail::contains(lfirst, mid, *mid)) {\n                        continue;\n                    }\n                    size_t num_vec = Detail::count(rfirst, rlast, *mid);\n                    if (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            std::string describe() const override {\n                return \"UnorderedEquals: \" + ::Catch::Detail::stringify(m_target);\n            }\n        private:\n            std::vector<T> const& m_target;\n        };\n"
    },
    {
        "begin_line": 2621,
        "end_line": 2621,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnorderedEqualsMatcher",
        "snippet": "            UnorderedEqualsMatcher(std::vector<T> const& target) : m_target(target) {}\n"
    },
    {
        "begin_line": 2622,
        "end_line": 2650,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "            bool match(std::vector<T> const& vec) const override {\n                // Note: This is a reimplementation of std::is_permutation,\n                //       because I don't want to include <algorithm> inside the common path\n                if (m_target.size() != vec.size()) {\n                    return false;\n                }\n                auto lfirst = m_target.begin(), llast = m_target.end();\n                auto rfirst = vec.begin(), rlast = vec.end();\n                // Cut common prefix to optimize checking of permuted parts\n                while (lfirst != llast && *lfirst != *rfirst) {\n                    ++lfirst; ++rfirst;\n                }\n                if (lfirst == llast) {\n                    return true;\n                }\n\n                for (auto mid = lfirst; mid != llast; ++mid) {\n                    // Skip already counted items\n                    if (Detail::contains(lfirst, mid, *mid)) {\n                        continue;\n                    }\n                    size_t num_vec = Detail::count(rfirst, rlast, *mid);\n                    if (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n"
    },
    {
        "begin_line": 2652,
        "end_line": 2654,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "            std::string describe() const override {\n                return \"UnorderedEquals: \" + ::Catch::Detail::stringify(m_target);\n            }\n"
    },
    {
        "begin_line": 2656,
        "end_line": 2656,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_target",
        "snippet": "            std::vector<T> const& m_target;\n"
    },
    {
        "begin_line": 2665,
        "end_line": 2667,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Contains",
        "snippet": "    Vector::ContainsMatcher<T> Contains( std::vector<T> const& comparator ) {\n        return Vector::ContainsMatcher<T>( comparator );\n    }\n"
    },
    {
        "begin_line": 2670,
        "end_line": 2672,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "VectorContains",
        "snippet": "    Vector::ContainsElementMatcher<T> VectorContains( T const& comparator ) {\n        return Vector::ContainsElementMatcher<T>( comparator );\n    }\n"
    },
    {
        "begin_line": 2675,
        "end_line": 2677,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Equals",
        "snippet": "    Vector::EqualsMatcher<T> Equals( std::vector<T> const& comparator ) {\n        return Vector::EqualsMatcher<T>( comparator );\n    }\n"
    },
    {
        "begin_line": 2680,
        "end_line": 2682,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnorderedEquals",
        "snippet": "    Vector::UnorderedEqualsMatcher<T> UnorderedEquals(std::vector<T> const& target) {\n        return Vector::UnorderedEqualsMatcher<T>(target);\n    }\n"
    },
    {
        "begin_line": 2688,
        "end_line": 2722,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    template<typename ArgT, typename MatcherT>\n    class MatchExpr : public ITransientExpression {\n        ArgT const& m_arg;\n        MatcherT m_matcher;\n        StringRef m_matcherString;\n    public:\n        MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef matcherString )\n        :   ITransientExpression{ true, matcher.match( arg ) },\n            m_arg( arg ),\n            m_matcher( matcher ),\n            m_matcherString( matcherString )\n        {}\n\n        void streamReconstructedExpression( std::ostream &os ) const override {\n            auto matcherAsString = m_matcher.toString();\n            os << Catch::Detail::stringify( m_arg ) << ' ';\n            if( matcherAsString == Detail::unprintableString )\n                os << m_matcherString;\n            else\n                os << matcherAsString;\n        }\n    };\n\n    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;\n\n    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef matcherString  );\n\n    template<typename ArgT, typename MatcherT>\n    auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef matcherString  ) -> MatchExpr<ArgT, MatcherT> {\n        return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );\n    }\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 2691,
        "end_line": 2711,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatchExpr",
        "snippet": "    class MatchExpr : public ITransientExpression {\n        ArgT const& m_arg;\n        MatcherT m_matcher;\n        StringRef m_matcherString;\n    public:\n        MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef matcherString )\n        :   ITransientExpression{ true, matcher.match( arg ) },\n            m_arg( arg ),\n            m_matcher( matcher ),\n            m_matcherString( matcherString )\n        {}\n\n        void streamReconstructedExpression( std::ostream &os ) const override {\n            auto matcherAsString = m_matcher.toString();\n            os << Catch::Detail::stringify( m_arg ) << ' ';\n            if( matcherAsString == Detail::unprintableString )\n                os << m_matcherString;\n            else\n                os << matcherAsString;\n        }\n    };\n"
    },
    {
        "begin_line": 2692,
        "end_line": 2692,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_arg",
        "snippet": "        ArgT const& m_arg;\n"
    },
    {
        "begin_line": 2693,
        "end_line": 2693,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_matcher",
        "snippet": "        MatcherT m_matcher;\n"
    },
    {
        "begin_line": 2694,
        "end_line": 2694,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_matcherString",
        "snippet": "        StringRef m_matcherString;\n"
    },
    {
        "begin_line": 2696,
        "end_line": 2701,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MatchExpr",
        "snippet": "        MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef matcherString )\n        :   ITransientExpression{ true, matcher.match( arg ) },\n            m_arg( arg ),\n            m_matcher( matcher ),\n            m_matcherString( matcherString )\n        {}\n"
    },
    {
        "begin_line": 2703,
        "end_line": 2710,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "streamReconstructedExpression",
        "snippet": "        void streamReconstructedExpression( std::ostream &os ) const override {\n            auto matcherAsString = m_matcher.toString();\n            os << Catch::Detail::stringify( m_arg ) << ' ';\n            if( matcherAsString == Detail::unprintableString )\n                os << m_matcherString;\n            else\n                os << matcherAsString;\n        }\n"
    },
    {
        "begin_line": 2718,
        "end_line": 2720,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeMatchExpr",
        "snippet": "    auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef matcherString  ) -> MatchExpr<ArgT, MatcherT> {\n        return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );\n    }\n"
    },
    {
        "begin_line": 2725,
        "end_line": 2732,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CHECK_THAT",
        "snippet": "#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) \", \" CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\n        INTERNAL_CATCH_TRY { \\\n            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher ) ); \\\n        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( false )\n"
    },
    {
        "begin_line": 2735,
        "end_line": 2752,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INTERNAL_CATCH_THROWS_MATCHES",
        "snippet": "#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \\\n    do { \\\n        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) \", \" CATCH_INTERNAL_STRINGIFY(exceptionType) \", \" CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\n        if( catchAssertionHandler.allowThrows() ) \\\n            try { \\\n                static_cast<void>(__VA_ARGS__ ); \\\n                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n            } \\\n            catch( exceptionType const& ex ) { \\\n                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher ) ); \\\n            } \\\n            catch( ... ) { \\\n                catchAssertionHandler.handleUnexpectedInflightException(); \\\n            } \\\n        else \\\n            catchAssertionHandler.handleThrowingCallSkipped(); \\\n        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\n    } while( false )\n"
    },
    {
        "begin_line": 2770,
        "end_line": 2831,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct ITestInvoker;\n\n    struct TestCaseInfo {\n        enum SpecialProperties{\n            None = 0,\n            IsHidden = 1 << 1,\n            ShouldFail = 1 << 2,\n            MayFail = 1 << 3,\n            Throws = 1 << 4,\n            NonPortable = 1 << 5,\n            Benchmark = 1 << 6\n        };\n\n        TestCaseInfo(   std::string const& _name,\n                        std::string const& _className,\n                        std::string const& _description,\n                        std::vector<std::string> const& _tags,\n                        SourceLineInfo const& _lineInfo );\n\n        friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );\n\n        bool isHidden() const;\n        bool throws() const;\n        bool okToFail() const;\n        bool expectedToFail() const;\n\n        std::string tagsAsString() const;\n\n        std::string name;\n        std::string className;\n        std::string description;\n        std::vector<std::string> tags;\n        std::vector<std::string> lcaseTags;\n        SourceLineInfo lineInfo;\n        SpecialProperties properties;\n    };\n\n    class TestCase : public TestCaseInfo {\n    public:\n\n        TestCase( ITestInvoker* testCase, TestCaseInfo&& info );\n\n        TestCase withName( std::string const& _newName ) const;\n\n        void invoke() const;\n\n        TestCaseInfo const& getTestCaseInfo() const;\n\n        bool operator == ( TestCase const& other ) const;\n        bool operator < ( TestCase const& other ) const;\n\n    private:\n        std::shared_ptr<ITestInvoker> test;\n    };\n\n    TestCase makeTestCase(  ITestInvoker* testCase,\n                            std::string const& className,\n                            NameAndTags const& nameAndTags,\n                            SourceLineInfo const& lineInfo );\n}\n"
    },
    {
        "begin_line": 2774,
        "end_line": 2807,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCaseInfo",
        "snippet": "    struct TestCaseInfo {\n        enum SpecialProperties{\n            None = 0,\n            IsHidden = 1 << 1,\n            ShouldFail = 1 << 2,\n            MayFail = 1 << 3,\n            Throws = 1 << 4,\n            NonPortable = 1 << 5,\n            Benchmark = 1 << 6\n        };\n\n        TestCaseInfo(   std::string const& _name,\n                        std::string const& _className,\n                        std::string const& _description,\n                        std::vector<std::string> const& _tags,\n                        SourceLineInfo const& _lineInfo );\n\n        friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );\n\n        bool isHidden() const;\n        bool throws() const;\n        bool okToFail() const;\n        bool expectedToFail() const;\n\n        std::string tagsAsString() const;\n\n        std::string name;\n        std::string className;\n        std::string description;\n        std::vector<std::string> tags;\n        std::vector<std::string> lcaseTags;\n        SourceLineInfo lineInfo;\n        SpecialProperties properties;\n    };\n"
    },
    {
        "begin_line": 2775,
        "end_line": 2783,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SpecialProperties",
        "snippet": "        enum SpecialProperties{\n            None = 0,\n            IsHidden = 1 << 1,\n            ShouldFail = 1 << 2,\n            MayFail = 1 << 3,\n            Throws = 1 << 4,\n            NonPortable = 1 << 5,\n            Benchmark = 1 << 6\n        };\n"
    },
    {
        "begin_line": 2800,
        "end_line": 2800,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        std::string name;\n"
    },
    {
        "begin_line": 2801,
        "end_line": 2801,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "className",
        "snippet": "        std::string className;\n"
    },
    {
        "begin_line": 2802,
        "end_line": 2802,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "description",
        "snippet": "        std::string description;\n"
    },
    {
        "begin_line": 2803,
        "end_line": 2803,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "tags",
        "snippet": "        std::vector<std::string> tags;\n"
    },
    {
        "begin_line": 2804,
        "end_line": 2804,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lcaseTags",
        "snippet": "        std::vector<std::string> lcaseTags;\n"
    },
    {
        "begin_line": 2805,
        "end_line": 2805,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lineInfo",
        "snippet": "        SourceLineInfo lineInfo;\n"
    },
    {
        "begin_line": 2806,
        "end_line": 2806,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "properties",
        "snippet": "        SpecialProperties properties;\n"
    },
    {
        "begin_line": 2809,
        "end_line": 2825,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCase",
        "snippet": "    class TestCase : public TestCaseInfo {\n    public:\n\n        TestCase( ITestInvoker* testCase, TestCaseInfo&& info );\n\n        TestCase withName( std::string const& _newName ) const;\n\n        void invoke() const;\n\n        TestCaseInfo const& getTestCaseInfo() const;\n\n        bool operator == ( TestCase const& other ) const;\n        bool operator < ( TestCase const& other ) const;\n\n    private:\n        std::shared_ptr<ITestInvoker> test;\n    };\n"
    },
    {
        "begin_line": 2824,
        "end_line": 2824,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "test",
        "snippet": "        std::shared_ptr<ITestInvoker> test;\n"
    },
    {
        "begin_line": 2840,
        "end_line": 2846,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct IRunner {\n        virtual ~IRunner();\n        virtual bool aborting() const = 0;\n    };\n}\n"
    },
    {
        "begin_line": 2842,
        "end_line": 2845,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IRunner",
        "snippet": "    struct IRunner {\n        virtual ~IRunner();\n        virtual bool aborting() const = 0;\n    };\n"
    },
    {
        "begin_line": 2873,
        "end_line": 3034,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class OcMethod : public ITestInvoker {\n\n    public:\n        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}\n\n        virtual void invoke() const {\n            id obj = [[m_cls alloc] init];\n\n            performOptionalSelector( obj, @selector(setUp)  );\n            performOptionalSelector( obj, m_sel );\n            performOptionalSelector( obj, @selector(tearDown)  );\n\n            arcSafeRelease( obj );\n        }\n    private:\n        virtual ~OcMethod() {}\n\n        Class m_cls;\n        SEL m_sel;\n    };\n\n    namespace Detail{\n\n        inline std::string getAnnotation(   Class cls,\n                                            std::string const& annotationName,\n                                            std::string const& testCaseName ) {\n            NSString* selStr = [[NSString alloc] initWithFormat:@\"Catch_%s_%s\", annotationName.c_str(), testCaseName.c_str()];\n            SEL sel = NSSelectorFromString( selStr );\n            arcSafeRelease( selStr );\n            id value = performOptionalSelector( cls, sel );\n            if( value )\n                return [(NSString*)value UTF8String];\n            return \"\";\n        }\n    }\n\n    inline std::size_t registerTestMethods() {\n        std::size_t noTestMethods = 0;\n        int noClasses = objc_getClassList( nullptr, 0 );\n\n        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);\n        objc_getClassList( classes, noClasses );\n\n        for( int c = 0; c < noClasses; c++ ) {\n            Class cls = classes[c];\n            {\n                u_int count;\n                Method* methods = class_copyMethodList( cls, &count );\n                for( u_int m = 0; m < count ; m++ ) {\n                    SEL selector = method_getName(methods[m]);\n                    std::string methodName = sel_getName(selector);\n                    if( startsWith( methodName, \"Catch_TestCase_\" ) ) {\n                        std::string testCaseName = methodName.substr( 15 );\n                        std::string name = Detail::getAnnotation( cls, \"Name\", testCaseName );\n                        std::string desc = Detail::getAnnotation( cls, \"Description\", testCaseName );\n                        const char* className = class_getName( cls );\n\n                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo(\"\",0) ) );\n                        noTestMethods++;\n                    }\n                }\n                free(methods);\n            }\n        }\n        return noTestMethods;\n    }\n\n#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)\n\n    namespace Matchers {\n        namespace Impl {\n        namespace NSStringMatchers {\n\n            struct StringHolder : MatcherBase<NSString*>{\n                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}\n                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}\n                StringHolder() {\n                    arcSafeRelease( m_substr );\n                }\n\n                bool match( NSString* arg ) const override {\n                    return false;\n                }\n\n                NSString* CATCH_ARC_STRONG m_substr;\n            };\n\n            struct Equals : StringHolder {\n                Equals( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str isEqualToString:m_substr];\n                }\n\n                std::string describe() const override {\n                    return \"equals string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct Contains : StringHolder {\n                Contains( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location != NSNotFound;\n                }\n\n                std::string describe() const override {\n                    return \"contains string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct StartsWith : StringHolder {\n                StartsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == 0;\n                }\n\n                std::string describe() const override {\n                    return \"starts with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n            struct EndsWith : StringHolder {\n                EndsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];\n                }\n\n                std::string describe() const override {\n                    return \"ends with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n        } // namespace NSStringMatchers\n        } // namespace Impl\n\n        inline Impl::NSStringMatchers::Equals\n            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }\n\n        inline Impl::NSStringMatchers::Contains\n            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }\n\n        inline Impl::NSStringMatchers::StartsWith\n            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }\n\n        inline Impl::NSStringMatchers::EndsWith\n            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }\n\n    } // namespace Matchers\n\n    using namespace Matchers;\n\n#endif // CATCH_CONFIG_DISABLE_MATCHERS\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 2875,
        "end_line": 2894,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OcMethod",
        "snippet": "    class OcMethod : public ITestInvoker {\n\n    public:\n        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}\n\n        virtual void invoke() const {\n            id obj = [[m_cls alloc] init];\n\n            performOptionalSelector( obj, @selector(setUp)  );\n            performOptionalSelector( obj, m_sel );\n            performOptionalSelector( obj, @selector(tearDown)  );\n\n            arcSafeRelease( obj );\n        }\n    private:\n        virtual ~OcMethod() {}\n\n        Class m_cls;\n        SEL m_sel;\n    };\n"
    },
    {
        "begin_line": 2878,
        "end_line": 2878,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OcMethod",
        "snippet": "        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}\n"
    },
    {
        "begin_line": 2880,
        "end_line": 2888,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invoke",
        "snippet": "        virtual void invoke() const {\n            id obj = [[m_cls alloc] init];\n\n            performOptionalSelector( obj, @selector(setUp)  );\n            performOptionalSelector( obj, m_sel );\n            performOptionalSelector( obj, @selector(tearDown)  );\n\n            arcSafeRelease( obj );\n        }\n"
    },
    {
        "begin_line": 2890,
        "end_line": 2890,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~OcMethod",
        "snippet": "        virtual ~OcMethod() {}\n"
    },
    {
        "begin_line": 2892,
        "end_line": 2892,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_cls",
        "snippet": "        Class m_cls;\n"
    },
    {
        "begin_line": 2893,
        "end_line": 2893,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_sel",
        "snippet": "        SEL m_sel;\n"
    },
    {
        "begin_line": 2896,
        "end_line": 2909,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "    namespace Detail{\n\n        inline std::string getAnnotation(   Class cls,\n                                            std::string const& annotationName,\n                                            std::string const& testCaseName ) {\n            NSString* selStr = [[NSString alloc] initWithFormat:@\"Catch_%s_%s\", annotationName.c_str(), testCaseName.c_str()];\n            SEL sel = NSSelectorFromString( selStr );\n            arcSafeRelease( selStr );\n            id value = performOptionalSelector( cls, sel );\n            if( value )\n                return [(NSString*)value UTF8String];\n            return \"\";\n        }\n    }\n"
    },
    {
        "begin_line": 2898,
        "end_line": 2908,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getAnnotation",
        "snippet": "        inline std::string getAnnotation(   Class cls,\n                                            std::string const& annotationName,\n                                            std::string const& testCaseName ) {\n            NSString* selStr = [[NSString alloc] initWithFormat:@\"Catch_%s_%s\", annotationName.c_str(), testCaseName.c_str()];\n            SEL sel = NSSelectorFromString( selStr );\n            arcSafeRelease( selStr );\n            id value = performOptionalSelector( cls, sel );\n            if( value )\n                return [(NSString*)value UTF8String];\n            return \"\";\n        }\n"
    },
    {
        "begin_line": 2911,
        "end_line": 2940,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerTestMethods",
        "snippet": "    inline std::size_t registerTestMethods() {\n        std::size_t noTestMethods = 0;\n        int noClasses = objc_getClassList( nullptr, 0 );\n\n        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);\n        objc_getClassList( classes, noClasses );\n\n        for( int c = 0; c < noClasses; c++ ) {\n            Class cls = classes[c];\n            {\n                u_int count;\n                Method* methods = class_copyMethodList( cls, &count );\n                for( u_int m = 0; m < count ; m++ ) {\n                    SEL selector = method_getName(methods[m]);\n                    std::string methodName = sel_getName(selector);\n                    if( startsWith( methodName, \"Catch_TestCase_\" ) ) {\n                        std::string testCaseName = methodName.substr( 15 );\n                        std::string name = Detail::getAnnotation( cls, \"Name\", testCaseName );\n                        std::string desc = Detail::getAnnotation( cls, \"Description\", testCaseName );\n                        const char* className = class_getName( cls );\n\n                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo(\"\",0) ) );\n                        noTestMethods++;\n                    }\n                }\n                free(methods);\n            }\n        }\n        return noTestMethods;\n    }\n"
    },
    {
        "begin_line": 2944,
        "end_line": 3028,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "    namespace Matchers {\n        namespace Impl {\n        namespace NSStringMatchers {\n\n            struct StringHolder : MatcherBase<NSString*>{\n                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}\n                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}\n                StringHolder() {\n                    arcSafeRelease( m_substr );\n                }\n\n                bool match( NSString* arg ) const override {\n                    return false;\n                }\n\n                NSString* CATCH_ARC_STRONG m_substr;\n            };\n\n            struct Equals : StringHolder {\n                Equals( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str isEqualToString:m_substr];\n                }\n\n                std::string describe() const override {\n                    return \"equals string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct Contains : StringHolder {\n                Contains( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location != NSNotFound;\n                }\n\n                std::string describe() const override {\n                    return \"contains string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct StartsWith : StringHolder {\n                StartsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == 0;\n                }\n\n                std::string describe() const override {\n                    return \"starts with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n            struct EndsWith : StringHolder {\n                EndsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];\n                }\n\n                std::string describe() const override {\n                    return \"ends with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n        } // namespace NSStringMatchers\n        } // namespace Impl\n\n        inline Impl::NSStringMatchers::Equals\n            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }\n\n        inline Impl::NSStringMatchers::Contains\n            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }\n\n        inline Impl::NSStringMatchers::StartsWith\n            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }\n\n        inline Impl::NSStringMatchers::EndsWith\n            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }\n\n    } // namespace Matchers\n"
    },
    {
        "begin_line": 2945,
        "end_line": 3014,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Impl",
        "snippet": "        namespace Impl {\n        namespace NSStringMatchers {\n\n            struct StringHolder : MatcherBase<NSString*>{\n                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}\n                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}\n                StringHolder() {\n                    arcSafeRelease( m_substr );\n                }\n\n                bool match( NSString* arg ) const override {\n                    return false;\n                }\n\n                NSString* CATCH_ARC_STRONG m_substr;\n            };\n\n            struct Equals : StringHolder {\n                Equals( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str isEqualToString:m_substr];\n                }\n\n                std::string describe() const override {\n                    return \"equals string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct Contains : StringHolder {\n                Contains( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location != NSNotFound;\n                }\n\n                std::string describe() const override {\n                    return \"contains string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct StartsWith : StringHolder {\n                StartsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == 0;\n                }\n\n                std::string describe() const override {\n                    return \"starts with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n            struct EndsWith : StringHolder {\n                EndsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];\n                }\n\n                std::string describe() const override {\n                    return \"ends with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n        } // namespace NSStringMatchers\n        } // namespace Impl\n"
    },
    {
        "begin_line": 2946,
        "end_line": 3013,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NSStringMatchers",
        "snippet": "        namespace NSStringMatchers {\n\n            struct StringHolder : MatcherBase<NSString*>{\n                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}\n                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}\n                StringHolder() {\n                    arcSafeRelease( m_substr );\n                }\n\n                bool match( NSString* arg ) const override {\n                    return false;\n                }\n\n                NSString* CATCH_ARC_STRONG m_substr;\n            };\n\n            struct Equals : StringHolder {\n                Equals( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str isEqualToString:m_substr];\n                }\n\n                std::string describe() const override {\n                    return \"equals string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct Contains : StringHolder {\n                Contains( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location != NSNotFound;\n                }\n\n                std::string describe() const override {\n                    return \"contains string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n            struct StartsWith : StringHolder {\n                StartsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == 0;\n                }\n\n                std::string describe() const override {\n                    return \"starts with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n            struct EndsWith : StringHolder {\n                EndsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];\n                }\n\n                std::string describe() const override {\n                    return \"ends with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n\n        } // namespace NSStringMatchers\n"
    },
    {
        "begin_line": 2948,
        "end_line": 2960,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringHolder",
        "snippet": "            struct StringHolder : MatcherBase<NSString*>{\n                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}\n                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}\n                StringHolder() {\n                    arcSafeRelease( m_substr );\n                }\n\n                bool match( NSString* arg ) const override {\n                    return false;\n                }\n\n                NSString* CATCH_ARC_STRONG m_substr;\n            };\n"
    },
    {
        "begin_line": 2949,
        "end_line": 2949,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringHolder",
        "snippet": "                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}\n"
    },
    {
        "begin_line": 2950,
        "end_line": 2950,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringHolder",
        "snippet": "                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}\n"
    },
    {
        "begin_line": 2951,
        "end_line": 2953,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringHolder",
        "snippet": "                StringHolder() {\n                    arcSafeRelease( m_substr );\n                }\n"
    },
    {
        "begin_line": 2955,
        "end_line": 2957,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "                bool match( NSString* arg ) const override {\n                    return false;\n                }\n"
    },
    {
        "begin_line": 2959,
        "end_line": 2959,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_substr",
        "snippet": "                NSString* CATCH_ARC_STRONG m_substr;\n"
    },
    {
        "begin_line": 2962,
        "end_line": 2973,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Equals",
        "snippet": "            struct Equals : StringHolder {\n                Equals( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str isEqualToString:m_substr];\n                }\n\n                std::string describe() const override {\n                    return \"equals string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n"
    },
    {
        "begin_line": 2963,
        "end_line": 2963,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Equals",
        "snippet": "                Equals( NSString* substr ) : StringHolder( substr ){}\n"
    },
    {
        "begin_line": 2965,
        "end_line": 2968,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str isEqualToString:m_substr];\n                }\n"
    },
    {
        "begin_line": 2970,
        "end_line": 2972,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "                std::string describe() const override {\n                    return \"equals string: \" + Catch::Detail::stringify( m_substr );\n                }\n"
    },
    {
        "begin_line": 2975,
        "end_line": 2986,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Contains",
        "snippet": "            struct Contains : StringHolder {\n                Contains( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location != NSNotFound;\n                }\n\n                std::string describe() const override {\n                    return \"contains string: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n"
    },
    {
        "begin_line": 2976,
        "end_line": 2976,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Contains",
        "snippet": "                Contains( NSString* substr ) : StringHolder( substr ){}\n"
    },
    {
        "begin_line": 2978,
        "end_line": 2981,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "                bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location != NSNotFound;\n                }\n"
    },
    {
        "begin_line": 2983,
        "end_line": 2985,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "                std::string describe() const override {\n                    return \"contains string: \" + Catch::Detail::stringify( m_substr );\n                }\n"
    },
    {
        "begin_line": 2988,
        "end_line": 2999,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StartsWith",
        "snippet": "            struct StartsWith : StringHolder {\n                StartsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == 0;\n                }\n\n                std::string describe() const override {\n                    return \"starts with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n"
    },
    {
        "begin_line": 2989,
        "end_line": 2989,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StartsWith",
        "snippet": "                StartsWith( NSString* substr ) : StringHolder( substr ){}\n"
    },
    {
        "begin_line": 2991,
        "end_line": 2994,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == 0;\n                }\n"
    },
    {
        "begin_line": 2996,
        "end_line": 2998,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "                std::string describe() const override {\n                    return \"starts with: \" + Catch::Detail::stringify( m_substr );\n                }\n"
    },
    {
        "begin_line": 3000,
        "end_line": 3011,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EndsWith",
        "snippet": "            struct EndsWith : StringHolder {\n                EndsWith( NSString* substr ) : StringHolder( substr ){}\n\n                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];\n                }\n\n                std::string describe() const override {\n                    return \"ends with: \" + Catch::Detail::stringify( m_substr );\n                }\n            };\n"
    },
    {
        "begin_line": 3001,
        "end_line": 3001,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EndsWith",
        "snippet": "                EndsWith( NSString* substr ) : StringHolder( substr ){}\n"
    },
    {
        "begin_line": 3003,
        "end_line": 3006,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "                bool match( NSString* str ) const override {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];\n                }\n"
    },
    {
        "begin_line": 3008,
        "end_line": 3010,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "                std::string describe() const override {\n                    return \"ends with: \" + Catch::Detail::stringify( m_substr );\n                }\n"
    },
    {
        "begin_line": 3017,
        "end_line": 3017,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Equals",
        "snippet": "            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }\n"
    },
    {
        "begin_line": 3020,
        "end_line": 3020,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Contains",
        "snippet": "            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }\n"
    },
    {
        "begin_line": 3023,
        "end_line": 3023,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StartsWith",
        "snippet": "            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }\n"
    },
    {
        "begin_line": 3026,
        "end_line": 3026,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EndsWith",
        "snippet": "            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }\n"
    },
    {
        "begin_line": 3037,
        "end_line": 3037,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OC_MAKE_UNIQUE_NAME",
        "snippet": "#define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix\n"
    },
    {
        "begin_line": 3038,
        "end_line": 3047,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OC_TEST_CASE2",
        "snippet": "#define OC_TEST_CASE2( name, desc, uniqueSuffix ) \\\n+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \\\n{ \\\nreturn @ name; \\\n} \\\n+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \\\n{ \\\nreturn @ desc; \\\n} \\\n-(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )\n"
    },
    {
        "begin_line": 3049,
        "end_line": 3049,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OC_TEST_CASE",
        "snippet": "#define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )\n"
    },
    {
        "begin_line": 3079,
        "end_line": 3101,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch\n{\n    class WildcardPattern {\n        enum WildcardPosition {\n            NoWildcard = 0,\n            WildcardAtStart = 1,\n            WildcardAtEnd = 2,\n            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd\n        };\n\n    public:\n\n        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity );\n        virtual ~WildcardPattern() = default;\n        virtual bool matches( std::string const& str ) const;\n\n    private:\n        std::string adjustCase( std::string const& str ) const;\n        CaseSensitive::Choice m_caseSensitivity;\n        WildcardPosition m_wildcard = NoWildcard;\n        std::string m_pattern;\n    };\n}\n"
    },
    {
        "begin_line": 3081,
        "end_line": 3100,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WildcardPattern",
        "snippet": "    class WildcardPattern {\n        enum WildcardPosition {\n            NoWildcard = 0,\n            WildcardAtStart = 1,\n            WildcardAtEnd = 2,\n            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd\n        };\n\n    public:\n\n        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity );\n        virtual ~WildcardPattern() = default;\n        virtual bool matches( std::string const& str ) const;\n\n    private:\n        std::string adjustCase( std::string const& str ) const;\n        CaseSensitive::Choice m_caseSensitivity;\n        WildcardPosition m_wildcard = NoWildcard;\n        std::string m_pattern;\n    };\n"
    },
    {
        "begin_line": 3082,
        "end_line": 3087,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WildcardPosition",
        "snippet": "        enum WildcardPosition {\n            NoWildcard = 0,\n            WildcardAtStart = 1,\n            WildcardAtEnd = 2,\n            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd\n        };\n"
    },
    {
        "begin_line": 3097,
        "end_line": 3097,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_caseSensitivity",
        "snippet": "        CaseSensitive::Choice m_caseSensitivity;\n"
    },
    {
        "begin_line": 3098,
        "end_line": 3098,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_wildcard",
        "snippet": "        WildcardPosition m_wildcard = NoWildcard;\n"
    },
    {
        "begin_line": 3099,
        "end_line": 3099,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_pattern",
        "snippet": "        std::string m_pattern;\n"
    },
    {
        "begin_line": 3108,
        "end_line": 3159,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class TestSpec {\n        struct Pattern {\n            virtual ~Pattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const = 0;\n        };\n        using PatternPtr = std::shared_ptr<Pattern>;\n\n        class NamePattern : public Pattern {\n        public:\n            NamePattern( std::string const& name );\n            virtual ~NamePattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            WildcardPattern m_wildcardPattern;\n        };\n\n        class TagPattern : public Pattern {\n        public:\n            TagPattern( std::string const& tag );\n            virtual ~TagPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            std::string m_tag;\n        };\n\n        class ExcludedPattern : public Pattern {\n        public:\n            ExcludedPattern( PatternPtr const& underlyingPattern );\n            virtual ~ExcludedPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            PatternPtr m_underlyingPattern;\n        };\n\n        struct Filter {\n            std::vector<PatternPtr> m_patterns;\n\n            bool matches( TestCaseInfo const& testCase ) const;\n        };\n\n    public:\n        bool hasFilters() const;\n        bool matches( TestCaseInfo const& testCase ) const;\n\n    private:\n        std::vector<Filter> m_filters;\n\n        friend class TestSpecParser;\n    };\n}\n"
    },
    {
        "begin_line": 3110,
        "end_line": 3158,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestSpec",
        "snippet": "    class TestSpec {\n        struct Pattern {\n            virtual ~Pattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const = 0;\n        };\n        using PatternPtr = std::shared_ptr<Pattern>;\n\n        class NamePattern : public Pattern {\n        public:\n            NamePattern( std::string const& name );\n            virtual ~NamePattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            WildcardPattern m_wildcardPattern;\n        };\n\n        class TagPattern : public Pattern {\n        public:\n            TagPattern( std::string const& tag );\n            virtual ~TagPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            std::string m_tag;\n        };\n\n        class ExcludedPattern : public Pattern {\n        public:\n            ExcludedPattern( PatternPtr const& underlyingPattern );\n            virtual ~ExcludedPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            PatternPtr m_underlyingPattern;\n        };\n\n        struct Filter {\n            std::vector<PatternPtr> m_patterns;\n\n            bool matches( TestCaseInfo const& testCase ) const;\n        };\n\n    public:\n        bool hasFilters() const;\n        bool matches( TestCaseInfo const& testCase ) const;\n\n    private:\n        std::vector<Filter> m_filters;\n\n        friend class TestSpecParser;\n    };\n"
    },
    {
        "begin_line": 3111,
        "end_line": 3114,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Pattern",
        "snippet": "        struct Pattern {\n            virtual ~Pattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const = 0;\n        };\n"
    },
    {
        "begin_line": 3117,
        "end_line": 3124,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NamePattern",
        "snippet": "        class NamePattern : public Pattern {\n        public:\n            NamePattern( std::string const& name );\n            virtual ~NamePattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            WildcardPattern m_wildcardPattern;\n        };\n"
    },
    {
        "begin_line": 3123,
        "end_line": 3123,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_wildcardPattern",
        "snippet": "            WildcardPattern m_wildcardPattern;\n"
    },
    {
        "begin_line": 3126,
        "end_line": 3133,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TagPattern",
        "snippet": "        class TagPattern : public Pattern {\n        public:\n            TagPattern( std::string const& tag );\n            virtual ~TagPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            std::string m_tag;\n        };\n"
    },
    {
        "begin_line": 3132,
        "end_line": 3132,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_tag",
        "snippet": "            std::string m_tag;\n"
    },
    {
        "begin_line": 3135,
        "end_line": 3142,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExcludedPattern",
        "snippet": "        class ExcludedPattern : public Pattern {\n        public:\n            ExcludedPattern( PatternPtr const& underlyingPattern );\n            virtual ~ExcludedPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const override;\n        private:\n            PatternPtr m_underlyingPattern;\n        };\n"
    },
    {
        "begin_line": 3141,
        "end_line": 3141,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_underlyingPattern",
        "snippet": "            PatternPtr m_underlyingPattern;\n"
    },
    {
        "begin_line": 3144,
        "end_line": 3148,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Filter",
        "snippet": "        struct Filter {\n            std::vector<PatternPtr> m_patterns;\n\n            bool matches( TestCaseInfo const& testCase ) const;\n        };\n"
    },
    {
        "begin_line": 3145,
        "end_line": 3145,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_patterns",
        "snippet": "            std::vector<PatternPtr> m_patterns;\n"
    },
    {
        "begin_line": 3155,
        "end_line": 3155,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_filters",
        "snippet": "        std::vector<Filter> m_filters;\n"
    },
    {
        "begin_line": 3170,
        "end_line": 3183,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct TagAlias;\n\n    struct ITagAliasRegistry {\n        virtual ~ITagAliasRegistry();\n        // Nullptr if not present\n        virtual TagAlias const* find( std::string const& alias ) const = 0;\n        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;\n\n        static ITagAliasRegistry const& get();\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 3174,
        "end_line": 3181,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ITagAliasRegistry",
        "snippet": "    struct ITagAliasRegistry {\n        virtual ~ITagAliasRegistry();\n        // Nullptr if not present\n        virtual TagAlias const* find( std::string const& alias ) const = 0;\n        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;\n\n        static ITagAliasRegistry const& get();\n    };\n"
    },
    {
        "begin_line": 3186,
        "end_line": 3235,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class TestSpecParser {\n        enum Mode{ None, Name, QuotedName, Tag, EscapedName };\n        Mode m_mode = None;\n        bool m_exclusion = false;\n        std::size_t m_start = std::string::npos, m_pos = 0;\n        std::string m_arg;\n        std::vector<std::size_t> m_escapeChars;\n        TestSpec::Filter m_currentFilter;\n        TestSpec m_testSpec;\n        ITagAliasRegistry const* m_tagAliases = nullptr;\n\n    public:\n        TestSpecParser( ITagAliasRegistry const& tagAliases );\n\n        TestSpecParser& parse( std::string const& arg );\n        TestSpec testSpec();\n\n    private:\n        void visitChar( char c );\n        void startNewMode( Mode mode, std::size_t start );\n        void escape();\n        std::string subString() const;\n\n        template<typename T>\n        void addPattern() {\n            std::string token = subString();\n            for( std::size_t i = 0; i < m_escapeChars.size(); ++i )\n                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\n            m_escapeChars.clear();\n            if( startsWith( token, \"exclude:\" ) ) {\n                m_exclusion = true;\n                token = token.substr( 8 );\n            }\n            if( !token.empty() ) {\n                TestSpec::PatternPtr pattern = std::make_shared<T>( token );\n                if( m_exclusion )\n                    pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );\n                m_currentFilter.m_patterns.push_back( pattern );\n            }\n            m_exclusion = false;\n            m_mode = None;\n        }\n\n        void addFilter();\n    };\n    TestSpec parseTestSpec( std::string const& arg );\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 3188,
        "end_line": 3232,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestSpecParser",
        "snippet": "    class TestSpecParser {\n        enum Mode{ None, Name, QuotedName, Tag, EscapedName };\n        Mode m_mode = None;\n        bool m_exclusion = false;\n        std::size_t m_start = std::string::npos, m_pos = 0;\n        std::string m_arg;\n        std::vector<std::size_t> m_escapeChars;\n        TestSpec::Filter m_currentFilter;\n        TestSpec m_testSpec;\n        ITagAliasRegistry const* m_tagAliases = nullptr;\n\n    public:\n        TestSpecParser( ITagAliasRegistry const& tagAliases );\n\n        TestSpecParser& parse( std::string const& arg );\n        TestSpec testSpec();\n\n    private:\n        void visitChar( char c );\n        void startNewMode( Mode mode, std::size_t start );\n        void escape();\n        std::string subString() const;\n\n        template<typename T>\n        void addPattern() {\n            std::string token = subString();\n            for( std::size_t i = 0; i < m_escapeChars.size(); ++i )\n                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\n            m_escapeChars.clear();\n            if( startsWith( token, \"exclude:\" ) ) {\n                m_exclusion = true;\n                token = token.substr( 8 );\n            }\n            if( !token.empty() ) {\n                TestSpec::PatternPtr pattern = std::make_shared<T>( token );\n                if( m_exclusion )\n                    pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );\n                m_currentFilter.m_patterns.push_back( pattern );\n            }\n            m_exclusion = false;\n            m_mode = None;\n        }\n\n        void addFilter();\n    };\n"
    },
    {
        "begin_line": 3189,
        "end_line": 3189,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Mode",
        "snippet": "        enum Mode{ None, Name, QuotedName, Tag, EscapedName };\n"
    },
    {
        "begin_line": 3190,
        "end_line": 3190,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_mode",
        "snippet": "        Mode m_mode = None;\n"
    },
    {
        "begin_line": 3191,
        "end_line": 3191,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_exclusion",
        "snippet": "        bool m_exclusion = false;\n"
    },
    {
        "begin_line": 3192,
        "end_line": 3192,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_start",
        "snippet": "        std::size_t m_start = std::string::npos, m_pos = 0;\n"
    },
    {
        "begin_line": 3192,
        "end_line": 3192,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_pos",
        "snippet": "        std::size_t m_start = std::string::npos, m_pos = 0;\n"
    },
    {
        "begin_line": 3193,
        "end_line": 3193,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_arg",
        "snippet": "        std::string m_arg;\n"
    },
    {
        "begin_line": 3194,
        "end_line": 3194,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_escapeChars",
        "snippet": "        std::vector<std::size_t> m_escapeChars;\n"
    },
    {
        "begin_line": 3195,
        "end_line": 3195,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_currentFilter",
        "snippet": "        TestSpec::Filter m_currentFilter;\n"
    },
    {
        "begin_line": 3196,
        "end_line": 3196,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testSpec",
        "snippet": "        TestSpec m_testSpec;\n"
    },
    {
        "begin_line": 3197,
        "end_line": 3197,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_tagAliases",
        "snippet": "        ITagAliasRegistry const* m_tagAliases = nullptr;\n"
    },
    {
        "begin_line": 3212,
        "end_line": 3229,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addPattern",
        "snippet": "        void addPattern() {\n            std::string token = subString();\n            for( std::size_t i = 0; i < m_escapeChars.size(); ++i )\n                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\n            m_escapeChars.clear();\n            if( startsWith( token, \"exclude:\" ) ) {\n                m_exclusion = true;\n                token = token.substr( 8 );\n            }\n            if( !token.empty() ) {\n                TestSpec::PatternPtr pattern = std::make_shared<T>( token );\n                if( m_exclusion )\n                    pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );\n                m_currentFilter.m_patterns.push_back( pattern );\n            }\n            m_exclusion = false;\n            m_mode = None;\n        }\n"
    },
    {
        "begin_line": 3249,
        "end_line": 3312,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    enum class Verbosity {\n        Quiet = 0,\n        Normal,\n        High\n    };\n\n    struct WarnAbout { enum What {\n        Nothing = 0x00,\n        NoAssertions = 0x01,\n        NoTests = 0x02\n    }; };\n\n    struct ShowDurations { enum OrNot {\n        DefaultForReporter,\n        Always,\n        Never\n    }; };\n    struct RunTests { enum InWhatOrder {\n        InDeclarationOrder,\n        InLexicographicalOrder,\n        InRandomOrder\n    }; };\n    struct UseColour { enum YesOrNo {\n        Auto,\n        Yes,\n        No\n    }; };\n    struct WaitForKeypress { enum When {\n        Never,\n        BeforeStart = 1,\n        BeforeExit = 2,\n        BeforeStartAndExit = BeforeStart | BeforeExit\n    }; };\n\n    class TestSpec;\n\n    struct IConfig : NonCopyable {\n\n        virtual ~IConfig();\n\n        virtual bool allowThrows() const = 0;\n        virtual std::ostream& stream() const = 0;\n        virtual std::string name() const = 0;\n        virtual bool includeSuccessfulResults() const = 0;\n        virtual bool shouldDebugBreak() const = 0;\n        virtual bool warnAboutMissingAssertions() const = 0;\n        virtual bool warnAboutNoTests() const = 0;\n        virtual int abortAfter() const = 0;\n        virtual bool showInvisibles() const = 0;\n        virtual ShowDurations::OrNot showDurations() const = 0;\n        virtual TestSpec const& testSpec() const = 0;\n        virtual bool hasTestFilters() const = 0;\n        virtual RunTests::InWhatOrder runOrder() const = 0;\n        virtual unsigned int rngSeed() const = 0;\n        virtual int benchmarkResolutionMultiple() const = 0;\n        virtual UseColour::YesOrNo useColour() const = 0;\n        virtual std::vector<std::string> const& getSectionsToRun() const = 0;\n        virtual Verbosity verbosity() const = 0;\n    };\n\n    using IConfigPtr = std::shared_ptr<IConfig const>;\n}\n"
    },
    {
        "begin_line": 3251,
        "end_line": 3255,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Verbosity",
        "snippet": "    enum class Verbosity {\n        Quiet = 0,\n        Normal,\n        High\n    };\n"
    },
    {
        "begin_line": 3257,
        "end_line": 3261,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WarnAbout",
        "snippet": "    struct WarnAbout { enum What {\n        Nothing = 0x00,\n        NoAssertions = 0x01,\n        NoTests = 0x02\n    }; };\n"
    },
    {
        "begin_line": 3257,
        "end_line": 3261,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "What",
        "snippet": "    struct WarnAbout { enum What {\n        Nothing = 0x00,\n        NoAssertions = 0x01,\n        NoTests = 0x02\n    }; };\n"
    },
    {
        "begin_line": 3263,
        "end_line": 3267,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ShowDurations",
        "snippet": "    struct ShowDurations { enum OrNot {\n        DefaultForReporter,\n        Always,\n        Never\n    }; };\n"
    },
    {
        "begin_line": 3263,
        "end_line": 3267,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OrNot",
        "snippet": "    struct ShowDurations { enum OrNot {\n        DefaultForReporter,\n        Always,\n        Never\n    }; };\n"
    },
    {
        "begin_line": 3268,
        "end_line": 3272,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RunTests",
        "snippet": "    struct RunTests { enum InWhatOrder {\n        InDeclarationOrder,\n        InLexicographicalOrder,\n        InRandomOrder\n    }; };\n"
    },
    {
        "begin_line": 3268,
        "end_line": 3272,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "InWhatOrder",
        "snippet": "    struct RunTests { enum InWhatOrder {\n        InDeclarationOrder,\n        InLexicographicalOrder,\n        InRandomOrder\n    }; };\n"
    },
    {
        "begin_line": 3273,
        "end_line": 3277,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UseColour",
        "snippet": "    struct UseColour { enum YesOrNo {\n        Auto,\n        Yes,\n        No\n    }; };\n"
    },
    {
        "begin_line": 3273,
        "end_line": 3277,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "YesOrNo",
        "snippet": "    struct UseColour { enum YesOrNo {\n        Auto,\n        Yes,\n        No\n    }; };\n"
    },
    {
        "begin_line": 3278,
        "end_line": 3283,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WaitForKeypress",
        "snippet": "    struct WaitForKeypress { enum When {\n        Never,\n        BeforeStart = 1,\n        BeforeExit = 2,\n        BeforeStartAndExit = BeforeStart | BeforeExit\n    }; };\n"
    },
    {
        "begin_line": 3278,
        "end_line": 3283,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "When",
        "snippet": "    struct WaitForKeypress { enum When {\n        Never,\n        BeforeStart = 1,\n        BeforeExit = 2,\n        BeforeStartAndExit = BeforeStart | BeforeExit\n    }; };\n"
    },
    {
        "begin_line": 3287,
        "end_line": 3309,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IConfig",
        "snippet": "    struct IConfig : NonCopyable {\n\n        virtual ~IConfig();\n\n        virtual bool allowThrows() const = 0;\n        virtual std::ostream& stream() const = 0;\n        virtual std::string name() const = 0;\n        virtual bool includeSuccessfulResults() const = 0;\n        virtual bool shouldDebugBreak() const = 0;\n        virtual bool warnAboutMissingAssertions() const = 0;\n        virtual bool warnAboutNoTests() const = 0;\n        virtual int abortAfter() const = 0;\n        virtual bool showInvisibles() const = 0;\n        virtual ShowDurations::OrNot showDurations() const = 0;\n        virtual TestSpec const& testSpec() const = 0;\n        virtual bool hasTestFilters() const = 0;\n        virtual RunTests::InWhatOrder runOrder() const = 0;\n        virtual unsigned int rngSeed() const = 0;\n        virtual int benchmarkResolutionMultiple() const = 0;\n        virtual UseColour::YesOrNo useColour() const = 0;\n        virtual std::vector<std::string> const& getSectionsToRun() const = 0;\n        virtual Verbosity verbosity() const = 0;\n    };\n"
    },
    {
        "begin_line": 3322,
        "end_line": 3322,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_CONSOLE_WIDTH",
        "snippet": "#define CATCH_CONFIG_CONSOLE_WIDTH 80\n"
    },
    {
        "begin_line": 3325,
        "end_line": 3415,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct IStream;\n\n    struct ConfigData {\n        bool listTests = false;\n        bool listTags = false;\n        bool listReporters = false;\n        bool listTestNamesOnly = false;\n\n        bool showSuccessfulTests = false;\n        bool shouldDebugBreak = false;\n        bool noThrow = false;\n        bool showHelp = false;\n        bool showInvisibles = false;\n        bool filenamesAsTags = false;\n        bool libIdentify = false;\n\n        int abortAfter = -1;\n        unsigned int rngSeed = 0;\n        int benchmarkResolutionMultiple = 100;\n\n        Verbosity verbosity = Verbosity::Normal;\n        WarnAbout::What warnings = WarnAbout::Nothing;\n        ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;\n        RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;\n        UseColour::YesOrNo useColour = UseColour::Auto;\n        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;\n\n        std::string outputFilename;\n        std::string name;\n        std::string processName;\n\n        std::vector<std::string> reporterNames;\n        std::vector<std::string> testsOrTags;\n        std::vector<std::string> sectionsToRun;\n    };\n\n    class Config : public IConfig {\n    public:\n\n        Config() = default;\n        Config( ConfigData const& data );\n        virtual ~Config() = default;\n\n        std::string const& getFilename() const;\n\n        bool listTests() const;\n        bool listTestNamesOnly() const;\n        bool listTags() const;\n        bool listReporters() const;\n\n        std::string getProcessName() const;\n\n        std::vector<std::string> const& getReporterNames() const;\n        std::vector<std::string> const& getTestsOrTags() const;\n        std::vector<std::string> const& getSectionsToRun() const override;\n\n        virtual TestSpec const& testSpec() const override;\n        bool hasTestFilters() const override;\n\n        bool showHelp() const;\n\n        // IConfig interface\n        bool allowThrows() const override;\n        std::ostream& stream() const override;\n        std::string name() const override;\n        bool includeSuccessfulResults() const override;\n        bool warnAboutMissingAssertions() const override;\n        bool warnAboutNoTests() const override;\n        ShowDurations::OrNot showDurations() const override;\n        RunTests::InWhatOrder runOrder() const override;\n        unsigned int rngSeed() const override;\n        int benchmarkResolutionMultiple() const override;\n        UseColour::YesOrNo useColour() const override;\n        bool shouldDebugBreak() const override;\n        int abortAfter() const override;\n        bool showInvisibles() const override;\n        Verbosity verbosity() const override;\n\n    private:\n\n        IStream const* openStream();\n        ConfigData m_data;\n\n        std::unique_ptr<IStream const> m_stream;\n        TestSpec m_testSpec;\n        bool m_hasTestFilters = false;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 3329,
        "end_line": 3361,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ConfigData",
        "snippet": "    struct ConfigData {\n        bool listTests = false;\n        bool listTags = false;\n        bool listReporters = false;\n        bool listTestNamesOnly = false;\n\n        bool showSuccessfulTests = false;\n        bool shouldDebugBreak = false;\n        bool noThrow = false;\n        bool showHelp = false;\n        bool showInvisibles = false;\n        bool filenamesAsTags = false;\n        bool libIdentify = false;\n\n        int abortAfter = -1;\n        unsigned int rngSeed = 0;\n        int benchmarkResolutionMultiple = 100;\n\n        Verbosity verbosity = Verbosity::Normal;\n        WarnAbout::What warnings = WarnAbout::Nothing;\n        ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;\n        RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;\n        UseColour::YesOrNo useColour = UseColour::Auto;\n        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;\n\n        std::string outputFilename;\n        std::string name;\n        std::string processName;\n\n        std::vector<std::string> reporterNames;\n        std::vector<std::string> testsOrTags;\n        std::vector<std::string> sectionsToRun;\n    };\n"
    },
    {
        "begin_line": 3330,
        "end_line": 3330,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTests",
        "snippet": "        bool listTests = false;\n"
    },
    {
        "begin_line": 3331,
        "end_line": 3331,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTags",
        "snippet": "        bool listTags = false;\n"
    },
    {
        "begin_line": 3332,
        "end_line": 3332,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listReporters",
        "snippet": "        bool listReporters = false;\n"
    },
    {
        "begin_line": 3333,
        "end_line": 3333,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTestNamesOnly",
        "snippet": "        bool listTestNamesOnly = false;\n"
    },
    {
        "begin_line": 3335,
        "end_line": 3335,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showSuccessfulTests",
        "snippet": "        bool showSuccessfulTests = false;\n"
    },
    {
        "begin_line": 3336,
        "end_line": 3336,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shouldDebugBreak",
        "snippet": "        bool shouldDebugBreak = false;\n"
    },
    {
        "begin_line": 3337,
        "end_line": 3337,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "noThrow",
        "snippet": "        bool noThrow = false;\n"
    },
    {
        "begin_line": 3338,
        "end_line": 3338,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showHelp",
        "snippet": "        bool showHelp = false;\n"
    },
    {
        "begin_line": 3339,
        "end_line": 3339,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showInvisibles",
        "snippet": "        bool showInvisibles = false;\n"
    },
    {
        "begin_line": 3340,
        "end_line": 3340,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "filenamesAsTags",
        "snippet": "        bool filenamesAsTags = false;\n"
    },
    {
        "begin_line": 3341,
        "end_line": 3341,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "libIdentify",
        "snippet": "        bool libIdentify = false;\n"
    },
    {
        "begin_line": 3343,
        "end_line": 3343,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "abortAfter",
        "snippet": "        int abortAfter = -1;\n"
    },
    {
        "begin_line": 3344,
        "end_line": 3344,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rngSeed",
        "snippet": "        unsigned int rngSeed = 0;\n"
    },
    {
        "begin_line": 3345,
        "end_line": 3345,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkResolutionMultiple",
        "snippet": "        int benchmarkResolutionMultiple = 100;\n"
    },
    {
        "begin_line": 3347,
        "end_line": 3347,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "verbosity",
        "snippet": "        Verbosity verbosity = Verbosity::Normal;\n"
    },
    {
        "begin_line": 3348,
        "end_line": 3348,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "warnings",
        "snippet": "        WarnAbout::What warnings = WarnAbout::Nothing;\n"
    },
    {
        "begin_line": 3349,
        "end_line": 3349,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showDurations",
        "snippet": "        ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;\n"
    },
    {
        "begin_line": 3350,
        "end_line": 3350,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runOrder",
        "snippet": "        RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;\n"
    },
    {
        "begin_line": 3351,
        "end_line": 3351,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "useColour",
        "snippet": "        UseColour::YesOrNo useColour = UseColour::Auto;\n"
    },
    {
        "begin_line": 3352,
        "end_line": 3352,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "waitForKeypress",
        "snippet": "        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;\n"
    },
    {
        "begin_line": 3354,
        "end_line": 3354,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "outputFilename",
        "snippet": "        std::string outputFilename;\n"
    },
    {
        "begin_line": 3355,
        "end_line": 3355,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        std::string name;\n"
    },
    {
        "begin_line": 3356,
        "end_line": 3356,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "processName",
        "snippet": "        std::string processName;\n"
    },
    {
        "begin_line": 3358,
        "end_line": 3358,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reporterNames",
        "snippet": "        std::vector<std::string> reporterNames;\n"
    },
    {
        "begin_line": 3359,
        "end_line": 3359,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testsOrTags",
        "snippet": "        std::vector<std::string> testsOrTags;\n"
    },
    {
        "begin_line": 3360,
        "end_line": 3360,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionsToRun",
        "snippet": "        std::vector<std::string> sectionsToRun;\n"
    },
    {
        "begin_line": 3363,
        "end_line": 3413,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Config",
        "snippet": "    class Config : public IConfig {\n    public:\n\n        Config() = default;\n        Config( ConfigData const& data );\n        virtual ~Config() = default;\n\n        std::string const& getFilename() const;\n\n        bool listTests() const;\n        bool listTestNamesOnly() const;\n        bool listTags() const;\n        bool listReporters() const;\n\n        std::string getProcessName() const;\n\n        std::vector<std::string> const& getReporterNames() const;\n        std::vector<std::string> const& getTestsOrTags() const;\n        std::vector<std::string> const& getSectionsToRun() const override;\n\n        virtual TestSpec const& testSpec() const override;\n        bool hasTestFilters() const override;\n\n        bool showHelp() const;\n\n        // IConfig interface\n        bool allowThrows() const override;\n        std::ostream& stream() const override;\n        std::string name() const override;\n        bool includeSuccessfulResults() const override;\n        bool warnAboutMissingAssertions() const override;\n        bool warnAboutNoTests() const override;\n        ShowDurations::OrNot showDurations() const override;\n        RunTests::InWhatOrder runOrder() const override;\n        unsigned int rngSeed() const override;\n        int benchmarkResolutionMultiple() const override;\n        UseColour::YesOrNo useColour() const override;\n        bool shouldDebugBreak() const override;\n        int abortAfter() const override;\n        bool showInvisibles() const override;\n        Verbosity verbosity() const override;\n\n    private:\n\n        IStream const* openStream();\n        ConfigData m_data;\n\n        std::unique_ptr<IStream const> m_stream;\n        TestSpec m_testSpec;\n        bool m_hasTestFilters = false;\n    };\n"
    },
    {
        "begin_line": 3408,
        "end_line": 3408,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_data",
        "snippet": "        ConfigData m_data;\n"
    },
    {
        "begin_line": 3410,
        "end_line": 3410,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_stream",
        "snippet": "        std::unique_ptr<IStream const> m_stream;\n"
    },
    {
        "begin_line": 3411,
        "end_line": 3411,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testSpec",
        "snippet": "        TestSpec m_testSpec;\n"
    },
    {
        "begin_line": 3412,
        "end_line": 3412,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_hasTestFilters",
        "snippet": "        bool m_hasTestFilters = false;\n"
    },
    {
        "begin_line": 3422,
        "end_line": 3461,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct AssertionResultData\n    {\n        AssertionResultData() = delete;\n\n        AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );\n\n        std::string message;\n        mutable std::string reconstructedExpression;\n        LazyExpression lazyExpression;\n        ResultWas::OfType resultType;\n\n        std::string reconstructExpression() const;\n    };\n\n    class AssertionResult {\n    public:\n        AssertionResult() = delete;\n        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );\n\n        bool isOk() const;\n        bool succeeded() const;\n        ResultWas::OfType getResultType() const;\n        bool hasExpression() const;\n        bool hasMessage() const;\n        std::string getExpression() const;\n        std::string getExpressionInMacro() const;\n        bool hasExpandedExpression() const;\n        std::string getExpandedExpression() const;\n        std::string getMessage() const;\n        SourceLineInfo getSourceInfo() const;\n        StringRef getTestMacroName() const;\n\n    //protected:\n        AssertionInfo m_info;\n        AssertionResultData m_resultData;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 3424,
        "end_line": 3436,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionResultData",
        "snippet": "    struct AssertionResultData\n    {\n        AssertionResultData() = delete;\n\n        AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );\n\n        std::string message;\n        mutable std::string reconstructedExpression;\n        LazyExpression lazyExpression;\n        ResultWas::OfType resultType;\n\n        std::string reconstructExpression() const;\n    };\n"
    },
    {
        "begin_line": 3430,
        "end_line": 3430,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "message",
        "snippet": "        std::string message;\n"
    },
    {
        "begin_line": 3431,
        "end_line": 3431,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reconstructedExpression",
        "snippet": "        mutable std::string reconstructedExpression;\n"
    },
    {
        "begin_line": 3432,
        "end_line": 3432,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lazyExpression",
        "snippet": "        LazyExpression lazyExpression;\n"
    },
    {
        "begin_line": 3433,
        "end_line": 3433,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "resultType",
        "snippet": "        ResultWas::OfType resultType;\n"
    },
    {
        "begin_line": 3438,
        "end_line": 3459,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionResult",
        "snippet": "    class AssertionResult {\n    public:\n        AssertionResult() = delete;\n        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );\n\n        bool isOk() const;\n        bool succeeded() const;\n        ResultWas::OfType getResultType() const;\n        bool hasExpression() const;\n        bool hasMessage() const;\n        std::string getExpression() const;\n        std::string getExpressionInMacro() const;\n        bool hasExpandedExpression() const;\n        std::string getExpandedExpression() const;\n        std::string getMessage() const;\n        SourceLineInfo getSourceInfo() const;\n        StringRef getTestMacroName() const;\n\n    //protected:\n        AssertionInfo m_info;\n        AssertionResultData m_resultData;\n    };\n"
    },
    {
        "begin_line": 3457,
        "end_line": 3457,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_info",
        "snippet": "        AssertionInfo m_info;\n"
    },
    {
        "begin_line": 3458,
        "end_line": 3458,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_resultData",
        "snippet": "        AssertionResultData m_resultData;\n"
    },
    {
        "begin_line": 3466,
        "end_line": 3526,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    // An optional type\n    template<typename T>\n    class Option {\n    public:\n        Option() : nullableValue( nullptr ) {}\n        Option( T const& _value )\n        : nullableValue( new( storage ) T( _value ) )\n        {}\n        Option( Option const& _other )\n        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )\n        {}\n\n        ~Option() {\n            reset();\n        }\n\n        Option& operator= ( Option const& _other ) {\n            if( &_other != this ) {\n                reset();\n                if( _other )\n                    nullableValue = new( storage ) T( *_other );\n            }\n            return *this;\n        }\n        Option& operator = ( T const& _value ) {\n            reset();\n            nullableValue = new( storage ) T( _value );\n            return *this;\n        }\n\n        void reset() {\n            if( nullableValue )\n                nullableValue->~T();\n            nullableValue = nullptr;\n        }\n\n        T& operator*() { return *nullableValue; }\n        T const& operator*() const { return *nullableValue; }\n        T* operator->() { return nullableValue; }\n        const T* operator->() const { return nullableValue; }\n\n        T valueOr( T const& defaultValue ) const {\n            return nullableValue ? *nullableValue : defaultValue;\n        }\n\n        bool some() const { return nullableValue != nullptr; }\n        bool none() const { return nullableValue == nullptr; }\n\n        bool operator !() const { return nullableValue == nullptr; }\n        explicit operator bool() const {\n            return some();\n        }\n\n    private:\n        T *nullableValue;\n        alignas(alignof(T)) char storage[sizeof(T)];\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 3470,
        "end_line": 3524,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Option",
        "snippet": "    class Option {\n    public:\n        Option() : nullableValue( nullptr ) {}\n        Option( T const& _value )\n        : nullableValue( new( storage ) T( _value ) )\n        {}\n        Option( Option const& _other )\n        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )\n        {}\n\n        ~Option() {\n            reset();\n        }\n\n        Option& operator= ( Option const& _other ) {\n            if( &_other != this ) {\n                reset();\n                if( _other )\n                    nullableValue = new( storage ) T( *_other );\n            }\n            return *this;\n        }\n        Option& operator = ( T const& _value ) {\n            reset();\n            nullableValue = new( storage ) T( _value );\n            return *this;\n        }\n\n        void reset() {\n            if( nullableValue )\n                nullableValue->~T();\n            nullableValue = nullptr;\n        }\n\n        T& operator*() { return *nullableValue; }\n        T const& operator*() const { return *nullableValue; }\n        T* operator->() { return nullableValue; }\n        const T* operator->() const { return nullableValue; }\n\n        T valueOr( T const& defaultValue ) const {\n            return nullableValue ? *nullableValue : defaultValue;\n        }\n\n        bool some() const { return nullableValue != nullptr; }\n        bool none() const { return nullableValue == nullptr; }\n\n        bool operator !() const { return nullableValue == nullptr; }\n        explicit operator bool() const {\n            return some();\n        }\n\n    private:\n        T *nullableValue;\n        alignas(alignof(T)) char storage[sizeof(T)];\n    };\n"
    },
    {
        "begin_line": 3472,
        "end_line": 3472,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Option",
        "snippet": "        Option() : nullableValue( nullptr ) {}\n"
    },
    {
        "begin_line": 3473,
        "end_line": 3475,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Option",
        "snippet": "        Option( T const& _value )\n        : nullableValue( new( storage ) T( _value ) )\n        {}\n"
    },
    {
        "begin_line": 3476,
        "end_line": 3478,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Option",
        "snippet": "        Option( Option const& _other )\n        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )\n        {}\n"
    },
    {
        "begin_line": 3480,
        "end_line": 3482,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~Option",
        "snippet": "        ~Option() {\n            reset();\n        }\n"
    },
    {
        "begin_line": 3484,
        "end_line": 3491,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator =",
        "snippet": "        Option& operator= ( Option const& _other ) {\n            if( &_other != this ) {\n                reset();\n                if( _other )\n                    nullableValue = new( storage ) T( *_other );\n            }\n            return *this;\n        }\n"
    },
    {
        "begin_line": 3492,
        "end_line": 3496,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator =",
        "snippet": "        Option& operator = ( T const& _value ) {\n            reset();\n            nullableValue = new( storage ) T( _value );\n            return *this;\n        }\n"
    },
    {
        "begin_line": 3498,
        "end_line": 3502,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reset",
        "snippet": "        void reset() {\n            if( nullableValue )\n                nullableValue->~T();\n            nullableValue = nullptr;\n        }\n"
    },
    {
        "begin_line": 3504,
        "end_line": 3504,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator *",
        "snippet": "        T& operator*() { return *nullableValue; }\n"
    },
    {
        "begin_line": 3505,
        "end_line": 3505,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator *",
        "snippet": "        T const& operator*() const { return *nullableValue; }\n"
    },
    {
        "begin_line": 3506,
        "end_line": 3506,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ->",
        "snippet": "        T* operator->() { return nullableValue; }\n"
    },
    {
        "begin_line": 3507,
        "end_line": 3507,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ->",
        "snippet": "        const T* operator->() const { return nullableValue; }\n"
    },
    {
        "begin_line": 3509,
        "end_line": 3511,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "valueOr",
        "snippet": "        T valueOr( T const& defaultValue ) const {\n            return nullableValue ? *nullableValue : defaultValue;\n        }\n"
    },
    {
        "begin_line": 3513,
        "end_line": 3513,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "some",
        "snippet": "        bool some() const { return nullableValue != nullptr; }\n"
    },
    {
        "begin_line": 3514,
        "end_line": 3514,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "none",
        "snippet": "        bool none() const { return nullableValue == nullptr; }\n"
    },
    {
        "begin_line": 3516,
        "end_line": 3516,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !",
        "snippet": "        bool operator !() const { return nullableValue == nullptr; }\n"
    },
    {
        "begin_line": 3517,
        "end_line": 3519,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator bool",
        "snippet": "        explicit operator bool() const {\n            return some();\n        }\n"
    },
    {
        "begin_line": 3522,
        "end_line": 3522,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "nullableValue",
        "snippet": "        T *nullableValue;\n"
    },
    {
        "begin_line": 3535,
        "end_line": 3738,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct ReporterConfig {\n        explicit ReporterConfig( IConfigPtr const& _fullConfig );\n\n        ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream );\n\n        std::ostream& stream() const;\n        IConfigPtr fullConfig() const;\n\n    private:\n        std::ostream* m_stream;\n        IConfigPtr m_fullConfig;\n    };\n\n    struct ReporterPreferences {\n        bool shouldRedirectStdOut = false;\n    };\n\n    template<typename T>\n    struct LazyStat : Option<T> {\n        LazyStat& operator=( T const& _value ) {\n            Option<T>::operator=( _value );\n            used = false;\n            return *this;\n        }\n        void reset() {\n            Option<T>::reset();\n            used = false;\n        }\n        bool used = false;\n    };\n\n    struct TestRunInfo {\n        TestRunInfo( std::string const& _name );\n        std::string name;\n    };\n    struct GroupInfo {\n        GroupInfo(  std::string const& _name,\n                    std::size_t _groupIndex,\n                    std::size_t _groupsCount );\n\n        std::string name;\n        std::size_t groupIndex;\n        std::size_t groupsCounts;\n    };\n\n    struct AssertionStats {\n        AssertionStats( AssertionResult const& _assertionResult,\n                        std::vector<MessageInfo> const& _infoMessages,\n                        Totals const& _totals );\n\n        AssertionStats( AssertionStats const& )              = default;\n        AssertionStats( AssertionStats && )                  = default;\n        AssertionStats& operator = ( AssertionStats const& ) = default;\n        AssertionStats& operator = ( AssertionStats && )     = default;\n        virtual ~AssertionStats();\n\n        AssertionResult assertionResult;\n        std::vector<MessageInfo> infoMessages;\n        Totals totals;\n    };\n\n    struct SectionStats {\n        SectionStats(   SectionInfo const& _sectionInfo,\n                        Counts const& _assertions,\n                        double _durationInSeconds,\n                        bool _missingAssertions );\n        SectionStats( SectionStats const& )              = default;\n        SectionStats( SectionStats && )                  = default;\n        SectionStats& operator = ( SectionStats const& ) = default;\n        SectionStats& operator = ( SectionStats && )     = default;\n        virtual ~SectionStats();\n\n        SectionInfo sectionInfo;\n        Counts assertions;\n        double durationInSeconds;\n        bool missingAssertions;\n    };\n\n    struct TestCaseStats {\n        TestCaseStats(  TestCaseInfo const& _testInfo,\n                        Totals const& _totals,\n                        std::string const& _stdOut,\n                        std::string const& _stdErr,\n                        bool _aborting );\n\n        TestCaseStats( TestCaseStats const& )              = default;\n        TestCaseStats( TestCaseStats && )                  = default;\n        TestCaseStats& operator = ( TestCaseStats const& ) = default;\n        TestCaseStats& operator = ( TestCaseStats && )     = default;\n        virtual ~TestCaseStats();\n\n        TestCaseInfo testInfo;\n        Totals totals;\n        std::string stdOut;\n        std::string stdErr;\n        bool aborting;\n    };\n\n    struct TestGroupStats {\n        TestGroupStats( GroupInfo const& _groupInfo,\n                        Totals const& _totals,\n                        bool _aborting );\n        TestGroupStats( GroupInfo const& _groupInfo );\n\n        TestGroupStats( TestGroupStats const& )              = default;\n        TestGroupStats( TestGroupStats && )                  = default;\n        TestGroupStats& operator = ( TestGroupStats const& ) = default;\n        TestGroupStats& operator = ( TestGroupStats && )     = default;\n        virtual ~TestGroupStats();\n\n        GroupInfo groupInfo;\n        Totals totals;\n        bool aborting;\n    };\n\n    struct TestRunStats {\n        TestRunStats(   TestRunInfo const& _runInfo,\n                        Totals const& _totals,\n                        bool _aborting );\n\n        TestRunStats( TestRunStats const& )              = default;\n        TestRunStats( TestRunStats && )                  = default;\n        TestRunStats& operator = ( TestRunStats const& ) = default;\n        TestRunStats& operator = ( TestRunStats && )     = default;\n        virtual ~TestRunStats();\n\n        TestRunInfo runInfo;\n        Totals totals;\n        bool aborting;\n    };\n\n    struct BenchmarkInfo {\n        std::string name;\n    };\n    struct BenchmarkStats {\n        BenchmarkInfo info;\n        std::size_t iterations;\n        uint64_t elapsedTimeInNanoseconds;\n    };\n\n    struct IStreamingReporter {\n        virtual ~IStreamingReporter() = default;\n\n        // Implementing class must also provide the following static methods:\n        // static std::string getDescription();\n        // static std::set<Verbosity> getSupportedVerbosities()\n\n        virtual ReporterPreferences getPreferences() const = 0;\n\n        virtual void noMatchingTestCases( std::string const& spec ) = 0;\n\n        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;\n        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;\n\n        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;\n        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;\n\n        // *** experimental ***\n        virtual void benchmarkStarting( BenchmarkInfo const& ) {}\n\n        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;\n\n        // The return value indicates if the messages buffer should be cleared:\n        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;\n\n        // *** experimental ***\n        virtual void benchmarkEnded( BenchmarkStats const& ) {}\n\n        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;\n        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;\n        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;\n        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;\n\n        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;\n\n        // Default empty implementation provided\n        virtual void fatalErrorEncountered( StringRef name );\n\n        virtual bool isMulti() const;\n    };\n    using IStreamingReporterPtr = std::unique_ptr<IStreamingReporter>;\n\n    struct IReporterFactory {\n        virtual ~IReporterFactory();\n        virtual IStreamingReporterPtr create( ReporterConfig const& config ) const = 0;\n        virtual std::string getDescription() const = 0;\n    };\n    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;\n\n    struct IReporterRegistry {\n        using FactoryMap = std::map<std::string, IReporterFactoryPtr>;\n        using Listeners = std::vector<IReporterFactoryPtr>;\n\n        virtual ~IReporterRegistry();\n        virtual IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const = 0;\n        virtual FactoryMap const& getFactories() const = 0;\n        virtual Listeners const& getListeners() const = 0;\n    };\n\n    void addReporter( IStreamingReporterPtr& existingReporter, IStreamingReporterPtr&& additionalReporter );\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 3537,
        "end_line": 3548,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterConfig",
        "snippet": "    struct ReporterConfig {\n        explicit ReporterConfig( IConfigPtr const& _fullConfig );\n\n        ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream );\n\n        std::ostream& stream() const;\n        IConfigPtr fullConfig() const;\n\n    private:\n        std::ostream* m_stream;\n        IConfigPtr m_fullConfig;\n    };\n"
    },
    {
        "begin_line": 3546,
        "end_line": 3546,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_stream",
        "snippet": "        std::ostream* m_stream;\n"
    },
    {
        "begin_line": 3547,
        "end_line": 3547,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_fullConfig",
        "snippet": "        IConfigPtr m_fullConfig;\n"
    },
    {
        "begin_line": 3550,
        "end_line": 3552,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterPreferences",
        "snippet": "    struct ReporterPreferences {\n        bool shouldRedirectStdOut = false;\n    };\n"
    },
    {
        "begin_line": 3551,
        "end_line": 3551,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shouldRedirectStdOut",
        "snippet": "        bool shouldRedirectStdOut = false;\n"
    },
    {
        "begin_line": 3555,
        "end_line": 3566,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LazyStat",
        "snippet": "    struct LazyStat : Option<T> {\n        LazyStat& operator=( T const& _value ) {\n            Option<T>::operator=( _value );\n            used = false;\n            return *this;\n        }\n        void reset() {\n            Option<T>::reset();\n            used = false;\n        }\n        bool used = false;\n    };\n"
    },
    {
        "begin_line": 3556,
        "end_line": 3560,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator =",
        "snippet": "        LazyStat& operator=( T const& _value ) {\n            Option<T>::operator=( _value );\n            used = false;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 3561,
        "end_line": 3564,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reset",
        "snippet": "        void reset() {\n            Option<T>::reset();\n            used = false;\n        }\n"
    },
    {
        "begin_line": 3565,
        "end_line": 3565,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "used",
        "snippet": "        bool used = false;\n"
    },
    {
        "begin_line": 3568,
        "end_line": 3571,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestRunInfo",
        "snippet": "    struct TestRunInfo {\n        TestRunInfo( std::string const& _name );\n        std::string name;\n    };\n"
    },
    {
        "begin_line": 3570,
        "end_line": 3570,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        std::string name;\n"
    },
    {
        "begin_line": 3572,
        "end_line": 3580,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "GroupInfo",
        "snippet": "    struct GroupInfo {\n        GroupInfo(  std::string const& _name,\n                    std::size_t _groupIndex,\n                    std::size_t _groupsCount );\n\n        std::string name;\n        std::size_t groupIndex;\n        std::size_t groupsCounts;\n    };\n"
    },
    {
        "begin_line": 3577,
        "end_line": 3577,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        std::string name;\n"
    },
    {
        "begin_line": 3578,
        "end_line": 3578,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "groupIndex",
        "snippet": "        std::size_t groupIndex;\n"
    },
    {
        "begin_line": 3579,
        "end_line": 3579,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "groupsCounts",
        "snippet": "        std::size_t groupsCounts;\n"
    },
    {
        "begin_line": 3582,
        "end_line": 3596,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionStats",
        "snippet": "    struct AssertionStats {\n        AssertionStats( AssertionResult const& _assertionResult,\n                        std::vector<MessageInfo> const& _infoMessages,\n                        Totals const& _totals );\n\n        AssertionStats( AssertionStats const& )              = default;\n        AssertionStats( AssertionStats && )                  = default;\n        AssertionStats& operator = ( AssertionStats const& ) = default;\n        AssertionStats& operator = ( AssertionStats && )     = default;\n        virtual ~AssertionStats();\n\n        AssertionResult assertionResult;\n        std::vector<MessageInfo> infoMessages;\n        Totals totals;\n    };\n"
    },
    {
        "begin_line": 3593,
        "end_line": 3593,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionResult",
        "snippet": "        AssertionResult assertionResult;\n"
    },
    {
        "begin_line": 3594,
        "end_line": 3594,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "infoMessages",
        "snippet": "        std::vector<MessageInfo> infoMessages;\n"
    },
    {
        "begin_line": 3595,
        "end_line": 3595,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "totals",
        "snippet": "        Totals totals;\n"
    },
    {
        "begin_line": 3598,
        "end_line": 3613,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionStats",
        "snippet": "    struct SectionStats {\n        SectionStats(   SectionInfo const& _sectionInfo,\n                        Counts const& _assertions,\n                        double _durationInSeconds,\n                        bool _missingAssertions );\n        SectionStats( SectionStats const& )              = default;\n        SectionStats( SectionStats && )                  = default;\n        SectionStats& operator = ( SectionStats const& ) = default;\n        SectionStats& operator = ( SectionStats && )     = default;\n        virtual ~SectionStats();\n\n        SectionInfo sectionInfo;\n        Counts assertions;\n        double durationInSeconds;\n        bool missingAssertions;\n    };\n"
    },
    {
        "begin_line": 3609,
        "end_line": 3609,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionInfo",
        "snippet": "        SectionInfo sectionInfo;\n"
    },
    {
        "begin_line": 3610,
        "end_line": 3610,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertions",
        "snippet": "        Counts assertions;\n"
    },
    {
        "begin_line": 3611,
        "end_line": 3611,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "durationInSeconds",
        "snippet": "        double durationInSeconds;\n"
    },
    {
        "begin_line": 3612,
        "end_line": 3612,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "missingAssertions",
        "snippet": "        bool missingAssertions;\n"
    },
    {
        "begin_line": 3615,
        "end_line": 3633,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCaseStats",
        "snippet": "    struct TestCaseStats {\n        TestCaseStats(  TestCaseInfo const& _testInfo,\n                        Totals const& _totals,\n                        std::string const& _stdOut,\n                        std::string const& _stdErr,\n                        bool _aborting );\n\n        TestCaseStats( TestCaseStats const& )              = default;\n        TestCaseStats( TestCaseStats && )                  = default;\n        TestCaseStats& operator = ( TestCaseStats const& ) = default;\n        TestCaseStats& operator = ( TestCaseStats && )     = default;\n        virtual ~TestCaseStats();\n\n        TestCaseInfo testInfo;\n        Totals totals;\n        std::string stdOut;\n        std::string stdErr;\n        bool aborting;\n    };\n"
    },
    {
        "begin_line": 3628,
        "end_line": 3628,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testInfo",
        "snippet": "        TestCaseInfo testInfo;\n"
    },
    {
        "begin_line": 3629,
        "end_line": 3629,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "totals",
        "snippet": "        Totals totals;\n"
    },
    {
        "begin_line": 3630,
        "end_line": 3630,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stdOut",
        "snippet": "        std::string stdOut;\n"
    },
    {
        "begin_line": 3631,
        "end_line": 3631,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stdErr",
        "snippet": "        std::string stdErr;\n"
    },
    {
        "begin_line": 3632,
        "end_line": 3632,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "aborting",
        "snippet": "        bool aborting;\n"
    },
    {
        "begin_line": 3635,
        "end_line": 3650,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestGroupStats",
        "snippet": "    struct TestGroupStats {\n        TestGroupStats( GroupInfo const& _groupInfo,\n                        Totals const& _totals,\n                        bool _aborting );\n        TestGroupStats( GroupInfo const& _groupInfo );\n\n        TestGroupStats( TestGroupStats const& )              = default;\n        TestGroupStats( TestGroupStats && )                  = default;\n        TestGroupStats& operator = ( TestGroupStats const& ) = default;\n        TestGroupStats& operator = ( TestGroupStats && )     = default;\n        virtual ~TestGroupStats();\n\n        GroupInfo groupInfo;\n        Totals totals;\n        bool aborting;\n    };\n"
    },
    {
        "begin_line": 3647,
        "end_line": 3647,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "groupInfo",
        "snippet": "        GroupInfo groupInfo;\n"
    },
    {
        "begin_line": 3648,
        "end_line": 3648,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "totals",
        "snippet": "        Totals totals;\n"
    },
    {
        "begin_line": 3649,
        "end_line": 3649,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "aborting",
        "snippet": "        bool aborting;\n"
    },
    {
        "begin_line": 3652,
        "end_line": 3666,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestRunStats",
        "snippet": "    struct TestRunStats {\n        TestRunStats(   TestRunInfo const& _runInfo,\n                        Totals const& _totals,\n                        bool _aborting );\n\n        TestRunStats( TestRunStats const& )              = default;\n        TestRunStats( TestRunStats && )                  = default;\n        TestRunStats& operator = ( TestRunStats const& ) = default;\n        TestRunStats& operator = ( TestRunStats && )     = default;\n        virtual ~TestRunStats();\n\n        TestRunInfo runInfo;\n        Totals totals;\n        bool aborting;\n    };\n"
    },
    {
        "begin_line": 3663,
        "end_line": 3663,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runInfo",
        "snippet": "        TestRunInfo runInfo;\n"
    },
    {
        "begin_line": 3664,
        "end_line": 3664,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "totals",
        "snippet": "        Totals totals;\n"
    },
    {
        "begin_line": 3665,
        "end_line": 3665,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "aborting",
        "snippet": "        bool aborting;\n"
    },
    {
        "begin_line": 3668,
        "end_line": 3670,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BenchmarkInfo",
        "snippet": "    struct BenchmarkInfo {\n        std::string name;\n    };\n"
    },
    {
        "begin_line": 3669,
        "end_line": 3669,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        std::string name;\n"
    },
    {
        "begin_line": 3671,
        "end_line": 3675,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BenchmarkStats",
        "snippet": "    struct BenchmarkStats {\n        BenchmarkInfo info;\n        std::size_t iterations;\n        uint64_t elapsedTimeInNanoseconds;\n    };\n"
    },
    {
        "begin_line": 3672,
        "end_line": 3672,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "info",
        "snippet": "        BenchmarkInfo info;\n"
    },
    {
        "begin_line": 3673,
        "end_line": 3673,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "iterations",
        "snippet": "        std::size_t iterations;\n"
    },
    {
        "begin_line": 3674,
        "end_line": 3674,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "elapsedTimeInNanoseconds",
        "snippet": "        uint64_t elapsedTimeInNanoseconds;\n"
    },
    {
        "begin_line": 3677,
        "end_line": 3716,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IStreamingReporter",
        "snippet": "    struct IStreamingReporter {\n        virtual ~IStreamingReporter() = default;\n\n        // Implementing class must also provide the following static methods:\n        // static std::string getDescription();\n        // static std::set<Verbosity> getSupportedVerbosities()\n\n        virtual ReporterPreferences getPreferences() const = 0;\n\n        virtual void noMatchingTestCases( std::string const& spec ) = 0;\n\n        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;\n        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;\n\n        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;\n        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;\n\n        // *** experimental ***\n        virtual void benchmarkStarting( BenchmarkInfo const& ) {}\n\n        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;\n\n        // The return value indicates if the messages buffer should be cleared:\n        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;\n\n        // *** experimental ***\n        virtual void benchmarkEnded( BenchmarkStats const& ) {}\n\n        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;\n        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;\n        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;\n        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;\n\n        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;\n\n        // Default empty implementation provided\n        virtual void fatalErrorEncountered( StringRef name );\n\n        virtual bool isMulti() const;\n    };\n"
    },
    {
        "begin_line": 3695,
        "end_line": 3695,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkStarting",
        "snippet": "        virtual void benchmarkStarting( BenchmarkInfo const& ) {}\n"
    },
    {
        "begin_line": 3703,
        "end_line": 3703,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkEnded",
        "snippet": "        virtual void benchmarkEnded( BenchmarkStats const& ) {}\n"
    },
    {
        "begin_line": 3719,
        "end_line": 3723,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IReporterFactory",
        "snippet": "    struct IReporterFactory {\n        virtual ~IReporterFactory();\n        virtual IStreamingReporterPtr create( ReporterConfig const& config ) const = 0;\n        virtual std::string getDescription() const = 0;\n    };\n"
    },
    {
        "begin_line": 3726,
        "end_line": 3734,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IReporterRegistry",
        "snippet": "    struct IReporterRegistry {\n        using FactoryMap = std::map<std::string, IReporterFactoryPtr>;\n        using Listeners = std::vector<IReporterFactoryPtr>;\n\n        virtual ~IReporterRegistry();\n        virtual IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const = 0;\n        virtual FactoryMap const& getFactories() const = 0;\n        virtual Listeners const& getListeners() const = 0;\n    };\n"
    },
    {
        "begin_line": 3749,
        "end_line": 3998,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    void prepareExpandedExpression(AssertionResult& result);\n\n    // Returns double formatted as %.3f (format expected on output)\n    std::string getFormattedDuration( double duration );\n\n    template<typename DerivedT>\n    struct StreamingReporterBase : IStreamingReporter {\n\n        StreamingReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\n                throw std::domain_error( \"Verbosity level not supported by this reporter\" );\n        }\n\n        ReporterPreferences getPreferences() const override {\n            return m_reporterPrefs;\n        }\n\n        static std::set<Verbosity> getSupportedVerbosities() {\n            return { Verbosity::Normal };\n        }\n\n        ~StreamingReporterBase() override = default;\n\n        void noMatchingTestCases(std::string const&) override {}\n\n        void testRunStarting(TestRunInfo const& _testRunInfo) override {\n            currentTestRunInfo = _testRunInfo;\n        }\n        void testGroupStarting(GroupInfo const& _groupInfo) override {\n            currentGroupInfo = _groupInfo;\n        }\n\n        void testCaseStarting(TestCaseInfo const& _testInfo) override  {\n            currentTestCaseInfo = _testInfo;\n        }\n        void sectionStarting(SectionInfo const& _sectionInfo) override {\n            m_sectionStack.push_back(_sectionInfo);\n        }\n\n        void sectionEnded(SectionStats const& /* _sectionStats */) override {\n            m_sectionStack.pop_back();\n        }\n        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {\n            currentTestCaseInfo.reset();\n        }\n        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {\n            currentGroupInfo.reset();\n        }\n        void testRunEnded(TestRunStats const& /* _testRunStats */) override {\n            currentTestCaseInfo.reset();\n            currentGroupInfo.reset();\n            currentTestRunInfo.reset();\n        }\n\n        void skipTest(TestCaseInfo const&) override {\n            // Don't do anything with this by default.\n            // It can optionally be overridden in the derived class.\n        }\n\n        IConfigPtr m_config;\n        std::ostream& stream;\n\n        LazyStat<TestRunInfo> currentTestRunInfo;\n        LazyStat<GroupInfo> currentGroupInfo;\n        LazyStat<TestCaseInfo> currentTestCaseInfo;\n\n        std::vector<SectionInfo> m_sectionStack;\n        ReporterPreferences m_reporterPrefs;\n    };\n\n    template<typename DerivedT>\n    struct CumulativeReporterBase : IStreamingReporter {\n        template<typename T, typename ChildNodeT>\n        struct Node {\n            explicit Node( T const& _value ) : value( _value ) {}\n            virtual ~Node() {}\n\n            using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;\n            T value;\n            ChildNodes children;\n        };\n        struct SectionNode {\n            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}\n            virtual ~SectionNode() = default;\n\n            bool operator == (SectionNode const& other) const {\n                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\n            }\n            bool operator == (std::shared_ptr<SectionNode> const& other) const {\n                return operator==(*other);\n            }\n\n            SectionStats stats;\n            using ChildSections = std::vector<std::shared_ptr<SectionNode>>;\n            using Assertions = std::vector<AssertionStats>;\n            ChildSections childSections;\n            Assertions assertions;\n            std::string stdOut;\n            std::string stdErr;\n        };\n\n        struct BySectionInfo {\n            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}\n            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}\n            bool operator() (std::shared_ptr<SectionNode> const& node) const {\n                return ((node->stats.sectionInfo.name == m_other.name) &&\n                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));\n            }\n            void operator=(BySectionInfo const&) = delete;\n\n        private:\n            SectionInfo const& m_other;\n        };\n\n        using TestCaseNode = Node<TestCaseStats, SectionNode>;\n        using TestGroupNode = Node<TestGroupStats, TestCaseNode>;\n        using TestRunNode = Node<TestRunStats, TestGroupNode>;\n\n        CumulativeReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\n                throw std::domain_error( \"Verbosity level not supported by this reporter\" );\n        }\n        ~CumulativeReporterBase() override = default;\n\n        ReporterPreferences getPreferences() const override {\n            return m_reporterPrefs;\n        }\n\n        static std::set<Verbosity> getSupportedVerbosities() {\n            return { Verbosity::Normal };\n        }\n\n        void testRunStarting( TestRunInfo const& ) override {}\n        void testGroupStarting( GroupInfo const& ) override {}\n\n        void testCaseStarting( TestCaseInfo const& ) override {}\n\n        void sectionStarting( SectionInfo const& sectionInfo ) override {\n            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );\n            std::shared_ptr<SectionNode> node;\n            if( m_sectionStack.empty() ) {\n                if( !m_rootSection )\n                    m_rootSection = std::make_shared<SectionNode>( incompleteStats );\n                node = m_rootSection;\n            }\n            else {\n                SectionNode& parentNode = *m_sectionStack.back();\n                auto it =\n                    std::find_if(   parentNode.childSections.begin(),\n                                    parentNode.childSections.end(),\n                                    BySectionInfo( sectionInfo ) );\n                if( it == parentNode.childSections.end() ) {\n                    node = std::make_shared<SectionNode>( incompleteStats );\n                    parentNode.childSections.push_back( node );\n                }\n                else\n                    node = *it;\n            }\n            m_sectionStack.push_back( node );\n            m_deepestSection = std::move(node);\n        }\n\n        void assertionStarting(AssertionInfo const&) override {}\n\n        bool assertionEnded(AssertionStats const& assertionStats) override {\n            assert(!m_sectionStack.empty());\n            // AssertionResult holds a pointer to a temporary DecomposedExpression,\n            // which getExpandedExpression() calls to build the expression string.\n            // Our section stack copy of the assertionResult will likely outlive the\n            // temporary, so it must be expanded or discarded now to avoid calling\n            // a destroyed object later.\n            prepareExpandedExpression(const_cast<AssertionResult&>( assertionStats.assertionResult ) );\n            SectionNode& sectionNode = *m_sectionStack.back();\n            sectionNode.assertions.push_back(assertionStats);\n            return true;\n        }\n        void sectionEnded(SectionStats const& sectionStats) override {\n            assert(!m_sectionStack.empty());\n            SectionNode& node = *m_sectionStack.back();\n            node.stats = sectionStats;\n            m_sectionStack.pop_back();\n        }\n        void testCaseEnded(TestCaseStats const& testCaseStats) override {\n            auto node = std::make_shared<TestCaseNode>(testCaseStats);\n            assert(m_sectionStack.size() == 0);\n            node->children.push_back(m_rootSection);\n            m_testCases.push_back(node);\n            m_rootSection.reset();\n\n            assert(m_deepestSection);\n            m_deepestSection->stdOut = testCaseStats.stdOut;\n            m_deepestSection->stdErr = testCaseStats.stdErr;\n        }\n        void testGroupEnded(TestGroupStats const& testGroupStats) override {\n            auto node = std::make_shared<TestGroupNode>(testGroupStats);\n            node->children.swap(m_testCases);\n            m_testGroups.push_back(node);\n        }\n        void testRunEnded(TestRunStats const& testRunStats) override {\n            auto node = std::make_shared<TestRunNode>(testRunStats);\n            node->children.swap(m_testGroups);\n            m_testRuns.push_back(node);\n            testRunEndedCumulative();\n        }\n        virtual void testRunEndedCumulative() = 0;\n\n        void skipTest(TestCaseInfo const&) override {}\n\n        IConfigPtr m_config;\n        std::ostream& stream;\n        std::vector<AssertionStats> m_assertions;\n        std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;\n        std::vector<std::shared_ptr<TestCaseNode>> m_testCases;\n        std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;\n\n        std::vector<std::shared_ptr<TestRunNode>> m_testRuns;\n\n        std::shared_ptr<SectionNode> m_rootSection;\n        std::shared_ptr<SectionNode> m_deepestSection;\n        std::vector<std::shared_ptr<SectionNode>> m_sectionStack;\n        ReporterPreferences m_reporterPrefs;\n    };\n\n    template<char C>\n    char const* getLineOfChars() {\n        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};\n        if( !*line ) {\n            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );\n            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;\n        }\n        return line;\n    }\n\n    struct TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> {\n        TestEventListenerBase( ReporterConfig const& _config );\n\n        void assertionStarting(AssertionInfo const&) override;\n        bool assertionEnded(AssertionStats const&) override;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 3756,
        "end_line": 3822,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StreamingReporterBase",
        "snippet": "    struct StreamingReporterBase : IStreamingReporter {\n\n        StreamingReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\n                throw std::domain_error( \"Verbosity level not supported by this reporter\" );\n        }\n\n        ReporterPreferences getPreferences() const override {\n            return m_reporterPrefs;\n        }\n\n        static std::set<Verbosity> getSupportedVerbosities() {\n            return { Verbosity::Normal };\n        }\n\n        ~StreamingReporterBase() override = default;\n\n        void noMatchingTestCases(std::string const&) override {}\n\n        void testRunStarting(TestRunInfo const& _testRunInfo) override {\n            currentTestRunInfo = _testRunInfo;\n        }\n        void testGroupStarting(GroupInfo const& _groupInfo) override {\n            currentGroupInfo = _groupInfo;\n        }\n\n        void testCaseStarting(TestCaseInfo const& _testInfo) override  {\n            currentTestCaseInfo = _testInfo;\n        }\n        void sectionStarting(SectionInfo const& _sectionInfo) override {\n            m_sectionStack.push_back(_sectionInfo);\n        }\n\n        void sectionEnded(SectionStats const& /* _sectionStats */) override {\n            m_sectionStack.pop_back();\n        }\n        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {\n            currentTestCaseInfo.reset();\n        }\n        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {\n            currentGroupInfo.reset();\n        }\n        void testRunEnded(TestRunStats const& /* _testRunStats */) override {\n            currentTestCaseInfo.reset();\n            currentGroupInfo.reset();\n            currentTestRunInfo.reset();\n        }\n\n        void skipTest(TestCaseInfo const&) override {\n            // Don't do anything with this by default.\n            // It can optionally be overridden in the derived class.\n        }\n\n        IConfigPtr m_config;\n        std::ostream& stream;\n\n        LazyStat<TestRunInfo> currentTestRunInfo;\n        LazyStat<GroupInfo> currentGroupInfo;\n        LazyStat<TestCaseInfo> currentTestCaseInfo;\n\n        std::vector<SectionInfo> m_sectionStack;\n        ReporterPreferences m_reporterPrefs;\n    };\n"
    },
    {
        "begin_line": 3758,
        "end_line": 3765,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StreamingReporterBase",
        "snippet": "        StreamingReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\n                throw std::domain_error( \"Verbosity level not supported by this reporter\" );\n        }\n"
    },
    {
        "begin_line": 3767,
        "end_line": 3769,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getPreferences",
        "snippet": "        ReporterPreferences getPreferences() const override {\n            return m_reporterPrefs;\n        }\n"
    },
    {
        "begin_line": 3771,
        "end_line": 3773,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getSupportedVerbosities",
        "snippet": "        static std::set<Verbosity> getSupportedVerbosities() {\n            return { Verbosity::Normal };\n        }\n"
    },
    {
        "begin_line": 3777,
        "end_line": 3777,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "noMatchingTestCases",
        "snippet": "        void noMatchingTestCases(std::string const&) override {}\n"
    },
    {
        "begin_line": 3779,
        "end_line": 3781,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunStarting",
        "snippet": "        void testRunStarting(TestRunInfo const& _testRunInfo) override {\n            currentTestRunInfo = _testRunInfo;\n        }\n"
    },
    {
        "begin_line": 3782,
        "end_line": 3784,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupStarting",
        "snippet": "        void testGroupStarting(GroupInfo const& _groupInfo) override {\n            currentGroupInfo = _groupInfo;\n        }\n"
    },
    {
        "begin_line": 3786,
        "end_line": 3788,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseStarting",
        "snippet": "        void testCaseStarting(TestCaseInfo const& _testInfo) override  {\n            currentTestCaseInfo = _testInfo;\n        }\n"
    },
    {
        "begin_line": 3789,
        "end_line": 3791,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionStarting",
        "snippet": "        void sectionStarting(SectionInfo const& _sectionInfo) override {\n            m_sectionStack.push_back(_sectionInfo);\n        }\n"
    },
    {
        "begin_line": 3793,
        "end_line": 3795,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEnded",
        "snippet": "        void sectionEnded(SectionStats const& /* _sectionStats */) override {\n            m_sectionStack.pop_back();\n        }\n"
    },
    {
        "begin_line": 3796,
        "end_line": 3798,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseEnded",
        "snippet": "        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {\n            currentTestCaseInfo.reset();\n        }\n"
    },
    {
        "begin_line": 3799,
        "end_line": 3801,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupEnded",
        "snippet": "        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {\n            currentGroupInfo.reset();\n        }\n"
    },
    {
        "begin_line": 3802,
        "end_line": 3806,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunEnded",
        "snippet": "        void testRunEnded(TestRunStats const& /* _testRunStats */) override {\n            currentTestCaseInfo.reset();\n            currentGroupInfo.reset();\n            currentTestRunInfo.reset();\n        }\n"
    },
    {
        "begin_line": 3808,
        "end_line": 3811,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "skipTest",
        "snippet": "        void skipTest(TestCaseInfo const&) override {\n            // Don't do anything with this by default.\n            // It can optionally be overridden in the derived class.\n        }\n"
    },
    {
        "begin_line": 3813,
        "end_line": 3813,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_config",
        "snippet": "        IConfigPtr m_config;\n"
    },
    {
        "begin_line": 3814,
        "end_line": 3814,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "        std::ostream& stream;\n"
    },
    {
        "begin_line": 3816,
        "end_line": 3816,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "currentTestRunInfo",
        "snippet": "        LazyStat<TestRunInfo> currentTestRunInfo;\n"
    },
    {
        "begin_line": 3817,
        "end_line": 3817,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "currentGroupInfo",
        "snippet": "        LazyStat<GroupInfo> currentGroupInfo;\n"
    },
    {
        "begin_line": 3818,
        "end_line": 3818,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "currentTestCaseInfo",
        "snippet": "        LazyStat<TestCaseInfo> currentTestCaseInfo;\n"
    },
    {
        "begin_line": 3820,
        "end_line": 3820,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_sectionStack",
        "snippet": "        std::vector<SectionInfo> m_sectionStack;\n"
    },
    {
        "begin_line": 3821,
        "end_line": 3821,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_reporterPrefs",
        "snippet": "        ReporterPreferences m_reporterPrefs;\n"
    },
    {
        "begin_line": 3825,
        "end_line": 3979,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CumulativeReporterBase",
        "snippet": "    struct CumulativeReporterBase : IStreamingReporter {\n        template<typename T, typename ChildNodeT>\n        struct Node {\n            explicit Node( T const& _value ) : value( _value ) {}\n            virtual ~Node() {}\n\n            using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;\n            T value;\n            ChildNodes children;\n        };\n        struct SectionNode {\n            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}\n            virtual ~SectionNode() = default;\n\n            bool operator == (SectionNode const& other) const {\n                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\n            }\n            bool operator == (std::shared_ptr<SectionNode> const& other) const {\n                return operator==(*other);\n            }\n\n            SectionStats stats;\n            using ChildSections = std::vector<std::shared_ptr<SectionNode>>;\n            using Assertions = std::vector<AssertionStats>;\n            ChildSections childSections;\n            Assertions assertions;\n            std::string stdOut;\n            std::string stdErr;\n        };\n\n        struct BySectionInfo {\n            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}\n            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}\n            bool operator() (std::shared_ptr<SectionNode> const& node) const {\n                return ((node->stats.sectionInfo.name == m_other.name) &&\n                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));\n            }\n            void operator=(BySectionInfo const&) = delete;\n\n        private:\n            SectionInfo const& m_other;\n        };\n\n        using TestCaseNode = Node<TestCaseStats, SectionNode>;\n        using TestGroupNode = Node<TestGroupStats, TestCaseNode>;\n        using TestRunNode = Node<TestRunStats, TestGroupNode>;\n\n        CumulativeReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\n                throw std::domain_error( \"Verbosity level not supported by this reporter\" );\n        }\n        ~CumulativeReporterBase() override = default;\n\n        ReporterPreferences getPreferences() const override {\n            return m_reporterPrefs;\n        }\n\n        static std::set<Verbosity> getSupportedVerbosities() {\n            return { Verbosity::Normal };\n        }\n\n        void testRunStarting( TestRunInfo const& ) override {}\n        void testGroupStarting( GroupInfo const& ) override {}\n\n        void testCaseStarting( TestCaseInfo const& ) override {}\n\n        void sectionStarting( SectionInfo const& sectionInfo ) override {\n            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );\n            std::shared_ptr<SectionNode> node;\n            if( m_sectionStack.empty() ) {\n                if( !m_rootSection )\n                    m_rootSection = std::make_shared<SectionNode>( incompleteStats );\n                node = m_rootSection;\n            }\n            else {\n                SectionNode& parentNode = *m_sectionStack.back();\n                auto it =\n                    std::find_if(   parentNode.childSections.begin(),\n                                    parentNode.childSections.end(),\n                                    BySectionInfo( sectionInfo ) );\n                if( it == parentNode.childSections.end() ) {\n                    node = std::make_shared<SectionNode>( incompleteStats );\n                    parentNode.childSections.push_back( node );\n                }\n                else\n                    node = *it;\n            }\n            m_sectionStack.push_back( node );\n            m_deepestSection = std::move(node);\n        }\n\n        void assertionStarting(AssertionInfo const&) override {}\n\n        bool assertionEnded(AssertionStats const& assertionStats) override {\n            assert(!m_sectionStack.empty());\n            // AssertionResult holds a pointer to a temporary DecomposedExpression,\n            // which getExpandedExpression() calls to build the expression string.\n            // Our section stack copy of the assertionResult will likely outlive the\n            // temporary, so it must be expanded or discarded now to avoid calling\n            // a destroyed object later.\n            prepareExpandedExpression(const_cast<AssertionResult&>( assertionStats.assertionResult ) );\n            SectionNode& sectionNode = *m_sectionStack.back();\n            sectionNode.assertions.push_back(assertionStats);\n            return true;\n        }\n        void sectionEnded(SectionStats const& sectionStats) override {\n            assert(!m_sectionStack.empty());\n            SectionNode& node = *m_sectionStack.back();\n            node.stats = sectionStats;\n            m_sectionStack.pop_back();\n        }\n        void testCaseEnded(TestCaseStats const& testCaseStats) override {\n            auto node = std::make_shared<TestCaseNode>(testCaseStats);\n            assert(m_sectionStack.size() == 0);\n            node->children.push_back(m_rootSection);\n            m_testCases.push_back(node);\n            m_rootSection.reset();\n\n            assert(m_deepestSection);\n            m_deepestSection->stdOut = testCaseStats.stdOut;\n            m_deepestSection->stdErr = testCaseStats.stdErr;\n        }\n        void testGroupEnded(TestGroupStats const& testGroupStats) override {\n            auto node = std::make_shared<TestGroupNode>(testGroupStats);\n            node->children.swap(m_testCases);\n            m_testGroups.push_back(node);\n        }\n        void testRunEnded(TestRunStats const& testRunStats) override {\n            auto node = std::make_shared<TestRunNode>(testRunStats);\n            node->children.swap(m_testGroups);\n            m_testRuns.push_back(node);\n            testRunEndedCumulative();\n        }\n        virtual void testRunEndedCumulative() = 0;\n\n        void skipTest(TestCaseInfo const&) override {}\n\n        IConfigPtr m_config;\n        std::ostream& stream;\n        std::vector<AssertionStats> m_assertions;\n        std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;\n        std::vector<std::shared_ptr<TestCaseNode>> m_testCases;\n        std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;\n\n        std::vector<std::shared_ptr<TestRunNode>> m_testRuns;\n\n        std::shared_ptr<SectionNode> m_rootSection;\n        std::shared_ptr<SectionNode> m_deepestSection;\n        std::vector<std::shared_ptr<SectionNode>> m_sectionStack;\n        ReporterPreferences m_reporterPrefs;\n    };\n"
    },
    {
        "begin_line": 3827,
        "end_line": 3834,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Node",
        "snippet": "        struct Node {\n            explicit Node( T const& _value ) : value( _value ) {}\n            virtual ~Node() {}\n\n            using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;\n            T value;\n            ChildNodes children;\n        };\n"
    },
    {
        "begin_line": 3828,
        "end_line": 3828,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Node",
        "snippet": "            explicit Node( T const& _value ) : value( _value ) {}\n"
    },
    {
        "begin_line": 3829,
        "end_line": 3829,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~Node",
        "snippet": "            virtual ~Node() {}\n"
    },
    {
        "begin_line": 3832,
        "end_line": 3832,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "value",
        "snippet": "            T value;\n"
    },
    {
        "begin_line": 3833,
        "end_line": 3833,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "children",
        "snippet": "            ChildNodes children;\n"
    },
    {
        "begin_line": 3835,
        "end_line": 3853,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionNode",
        "snippet": "        struct SectionNode {\n            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}\n            virtual ~SectionNode() = default;\n\n            bool operator == (SectionNode const& other) const {\n                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\n            }\n            bool operator == (std::shared_ptr<SectionNode> const& other) const {\n                return operator==(*other);\n            }\n\n            SectionStats stats;\n            using ChildSections = std::vector<std::shared_ptr<SectionNode>>;\n            using Assertions = std::vector<AssertionStats>;\n            ChildSections childSections;\n            Assertions assertions;\n            std::string stdOut;\n            std::string stdErr;\n        };\n"
    },
    {
        "begin_line": 3836,
        "end_line": 3836,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionNode",
        "snippet": "            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}\n"
    },
    {
        "begin_line": 3839,
        "end_line": 3841,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "            bool operator == (SectionNode const& other) const {\n                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\n            }\n"
    },
    {
        "begin_line": 3842,
        "end_line": 3844,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "            bool operator == (std::shared_ptr<SectionNode> const& other) const {\n                return operator==(*other);\n            }\n"
    },
    {
        "begin_line": 3846,
        "end_line": 3846,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stats",
        "snippet": "            SectionStats stats;\n"
    },
    {
        "begin_line": 3849,
        "end_line": 3849,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "childSections",
        "snippet": "            ChildSections childSections;\n"
    },
    {
        "begin_line": 3850,
        "end_line": 3850,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertions",
        "snippet": "            Assertions assertions;\n"
    },
    {
        "begin_line": 3851,
        "end_line": 3851,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stdOut",
        "snippet": "            std::string stdOut;\n"
    },
    {
        "begin_line": 3852,
        "end_line": 3852,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stdErr",
        "snippet": "            std::string stdErr;\n"
    },
    {
        "begin_line": 3855,
        "end_line": 3866,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BySectionInfo",
        "snippet": "        struct BySectionInfo {\n            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}\n            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}\n            bool operator() (std::shared_ptr<SectionNode> const& node) const {\n                return ((node->stats.sectionInfo.name == m_other.name) &&\n                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));\n            }\n            void operator=(BySectionInfo const&) = delete;\n\n        private:\n            SectionInfo const& m_other;\n        };\n"
    },
    {
        "begin_line": 3856,
        "end_line": 3856,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BySectionInfo",
        "snippet": "            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}\n"
    },
    {
        "begin_line": 3857,
        "end_line": 3857,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BySectionInfo",
        "snippet": "            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}\n"
    },
    {
        "begin_line": 3858,
        "end_line": 3861,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ()",
        "snippet": "            bool operator() (std::shared_ptr<SectionNode> const& node) const {\n                return ((node->stats.sectionInfo.name == m_other.name) &&\n                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));\n            }\n"
    },
    {
        "begin_line": 3865,
        "end_line": 3865,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_other",
        "snippet": "            SectionInfo const& m_other;\n"
    },
    {
        "begin_line": 3872,
        "end_line": 3879,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CumulativeReporterBase",
        "snippet": "        CumulativeReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\n                throw std::domain_error( \"Verbosity level not supported by this reporter\" );\n        }\n"
    },
    {
        "begin_line": 3882,
        "end_line": 3884,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getPreferences",
        "snippet": "        ReporterPreferences getPreferences() const override {\n            return m_reporterPrefs;\n        }\n"
    },
    {
        "begin_line": 3886,
        "end_line": 3888,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getSupportedVerbosities",
        "snippet": "        static std::set<Verbosity> getSupportedVerbosities() {\n            return { Verbosity::Normal };\n        }\n"
    },
    {
        "begin_line": 3890,
        "end_line": 3890,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunStarting",
        "snippet": "        void testRunStarting( TestRunInfo const& ) override {}\n"
    },
    {
        "begin_line": 3891,
        "end_line": 3891,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupStarting",
        "snippet": "        void testGroupStarting( GroupInfo const& ) override {}\n"
    },
    {
        "begin_line": 3893,
        "end_line": 3893,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseStarting",
        "snippet": "        void testCaseStarting( TestCaseInfo const& ) override {}\n"
    },
    {
        "begin_line": 3895,
        "end_line": 3918,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionStarting",
        "snippet": "        void sectionStarting( SectionInfo const& sectionInfo ) override {\n            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );\n            std::shared_ptr<SectionNode> node;\n            if( m_sectionStack.empty() ) {\n                if( !m_rootSection )\n                    m_rootSection = std::make_shared<SectionNode>( incompleteStats );\n                node = m_rootSection;\n            }\n            else {\n                SectionNode& parentNode = *m_sectionStack.back();\n                auto it =\n                    std::find_if(   parentNode.childSections.begin(),\n                                    parentNode.childSections.end(),\n                                    BySectionInfo( sectionInfo ) );\n                if( it == parentNode.childSections.end() ) {\n                    node = std::make_shared<SectionNode>( incompleteStats );\n                    parentNode.childSections.push_back( node );\n                }\n                else\n                    node = *it;\n            }\n            m_sectionStack.push_back( node );\n            m_deepestSection = std::move(node);\n        }\n"
    },
    {
        "begin_line": 3920,
        "end_line": 3920,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionStarting",
        "snippet": "        void assertionStarting(AssertionInfo const&) override {}\n"
    },
    {
        "begin_line": 3922,
        "end_line": 3933,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "        bool assertionEnded(AssertionStats const& assertionStats) override {\n            assert(!m_sectionStack.empty());\n            // AssertionResult holds a pointer to a temporary DecomposedExpression,\n            // which getExpandedExpression() calls to build the expression string.\n            // Our section stack copy of the assertionResult will likely outlive the\n            // temporary, so it must be expanded or discarded now to avoid calling\n            // a destroyed object later.\n            prepareExpandedExpression(const_cast<AssertionResult&>( assertionStats.assertionResult ) );\n            SectionNode& sectionNode = *m_sectionStack.back();\n            sectionNode.assertions.push_back(assertionStats);\n            return true;\n        }\n"
    },
    {
        "begin_line": 3934,
        "end_line": 3939,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEnded",
        "snippet": "        void sectionEnded(SectionStats const& sectionStats) override {\n            assert(!m_sectionStack.empty());\n            SectionNode& node = *m_sectionStack.back();\n            node.stats = sectionStats;\n            m_sectionStack.pop_back();\n        }\n"
    },
    {
        "begin_line": 3940,
        "end_line": 3950,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseEnded",
        "snippet": "        void testCaseEnded(TestCaseStats const& testCaseStats) override {\n            auto node = std::make_shared<TestCaseNode>(testCaseStats);\n            assert(m_sectionStack.size() == 0);\n            node->children.push_back(m_rootSection);\n            m_testCases.push_back(node);\n            m_rootSection.reset();\n\n            assert(m_deepestSection);\n            m_deepestSection->stdOut = testCaseStats.stdOut;\n            m_deepestSection->stdErr = testCaseStats.stdErr;\n        }\n"
    },
    {
        "begin_line": 3951,
        "end_line": 3955,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupEnded",
        "snippet": "        void testGroupEnded(TestGroupStats const& testGroupStats) override {\n            auto node = std::make_shared<TestGroupNode>(testGroupStats);\n            node->children.swap(m_testCases);\n            m_testGroups.push_back(node);\n        }\n"
    },
    {
        "begin_line": 3956,
        "end_line": 3961,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunEnded",
        "snippet": "        void testRunEnded(TestRunStats const& testRunStats) override {\n            auto node = std::make_shared<TestRunNode>(testRunStats);\n            node->children.swap(m_testGroups);\n            m_testRuns.push_back(node);\n            testRunEndedCumulative();\n        }\n"
    },
    {
        "begin_line": 3964,
        "end_line": 3964,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "skipTest",
        "snippet": "        void skipTest(TestCaseInfo const&) override {}\n"
    },
    {
        "begin_line": 3966,
        "end_line": 3966,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_config",
        "snippet": "        IConfigPtr m_config;\n"
    },
    {
        "begin_line": 3967,
        "end_line": 3967,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "        std::ostream& stream;\n"
    },
    {
        "begin_line": 3968,
        "end_line": 3968,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_assertions",
        "snippet": "        std::vector<AssertionStats> m_assertions;\n"
    },
    {
        "begin_line": 3969,
        "end_line": 3969,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_sections",
        "snippet": "        std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;\n"
    },
    {
        "begin_line": 3970,
        "end_line": 3970,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testCases",
        "snippet": "        std::vector<std::shared_ptr<TestCaseNode>> m_testCases;\n"
    },
    {
        "begin_line": 3971,
        "end_line": 3971,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testGroups",
        "snippet": "        std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;\n"
    },
    {
        "begin_line": 3973,
        "end_line": 3973,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testRuns",
        "snippet": "        std::vector<std::shared_ptr<TestRunNode>> m_testRuns;\n"
    },
    {
        "begin_line": 3975,
        "end_line": 3975,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_rootSection",
        "snippet": "        std::shared_ptr<SectionNode> m_rootSection;\n"
    },
    {
        "begin_line": 3976,
        "end_line": 3976,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_deepestSection",
        "snippet": "        std::shared_ptr<SectionNode> m_deepestSection;\n"
    },
    {
        "begin_line": 3977,
        "end_line": 3977,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_sectionStack",
        "snippet": "        std::vector<std::shared_ptr<SectionNode>> m_sectionStack;\n"
    },
    {
        "begin_line": 3978,
        "end_line": 3978,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_reporterPrefs",
        "snippet": "        ReporterPreferences m_reporterPrefs;\n"
    },
    {
        "begin_line": 3982,
        "end_line": 3989,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getLineOfChars",
        "snippet": "    char const* getLineOfChars() {\n        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};\n        if( !*line ) {\n            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );\n            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;\n        }\n        return line;\n    }\n"
    },
    {
        "begin_line": 3991,
        "end_line": 3996,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestEventListenerBase",
        "snippet": "    struct TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> {\n        TestEventListenerBase( ReporterConfig const& _config );\n\n        void assertionStarting(AssertionInfo const&) override;\n        bool assertionEnded(AssertionStats const&) override;\n    };\n"
    },
    {
        "begin_line": 4003,
        "end_line": 4057,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct Colour {\n        enum Code {\n            None = 0,\n\n            White,\n            Red,\n            Green,\n            Blue,\n            Cyan,\n            Yellow,\n            Grey,\n\n            Bright = 0x10,\n\n            BrightRed = Bright | Red,\n            BrightGreen = Bright | Green,\n            LightGrey = Bright | Grey,\n            BrightWhite = Bright | White,\n            BrightYellow = Bright | Yellow,\n\n            // By intention\n            FileName = LightGrey,\n            Warning = BrightYellow,\n            ResultError = BrightRed,\n            ResultSuccess = BrightGreen,\n            ResultExpectedFailure = Warning,\n\n            Error = BrightRed,\n            Success = Green,\n\n            OriginalExpression = Cyan,\n            ReconstructedExpression = BrightYellow,\n\n            SecondaryText = LightGrey,\n            Headers = White\n        };\n\n        // Use constructed object for RAII guard\n        Colour( Code _colourCode );\n        Colour( Colour&& other ) noexcept;\n        Colour& operator=( Colour&& other ) noexcept;\n        ~Colour();\n\n        // Use static method for one-shot changes\n        static void use( Code _colourCode );\n\n    private:\n        bool m_moved = false;\n    };\n\n    std::ostream& operator << ( std::ostream& os, Colour const& );\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 4005,
        "end_line": 4053,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Colour",
        "snippet": "    struct Colour {\n        enum Code {\n            None = 0,\n\n            White,\n            Red,\n            Green,\n            Blue,\n            Cyan,\n            Yellow,\n            Grey,\n\n            Bright = 0x10,\n\n            BrightRed = Bright | Red,\n            BrightGreen = Bright | Green,\n            LightGrey = Bright | Grey,\n            BrightWhite = Bright | White,\n            BrightYellow = Bright | Yellow,\n\n            // By intention\n            FileName = LightGrey,\n            Warning = BrightYellow,\n            ResultError = BrightRed,\n            ResultSuccess = BrightGreen,\n            ResultExpectedFailure = Warning,\n\n            Error = BrightRed,\n            Success = Green,\n\n            OriginalExpression = Cyan,\n            ReconstructedExpression = BrightYellow,\n\n            SecondaryText = LightGrey,\n            Headers = White\n        };\n\n        // Use constructed object for RAII guard\n        Colour( Code _colourCode );\n        Colour( Colour&& other ) noexcept;\n        Colour& operator=( Colour&& other ) noexcept;\n        ~Colour();\n\n        // Use static method for one-shot changes\n        static void use( Code _colourCode );\n\n    private:\n        bool m_moved = false;\n    };\n"
    },
    {
        "begin_line": 4006,
        "end_line": 4040,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Code",
        "snippet": "        enum Code {\n            None = 0,\n\n            White,\n            Red,\n            Green,\n            Blue,\n            Cyan,\n            Yellow,\n            Grey,\n\n            Bright = 0x10,\n\n            BrightRed = Bright | Red,\n            BrightGreen = Bright | Green,\n            LightGrey = Bright | Grey,\n            BrightWhite = Bright | White,\n            BrightYellow = Bright | Yellow,\n\n            // By intention\n            FileName = LightGrey,\n            Warning = BrightYellow,\n            ResultError = BrightRed,\n            ResultSuccess = BrightGreen,\n            ResultExpectedFailure = Warning,\n\n            Error = BrightRed,\n            Success = Green,\n\n            OriginalExpression = Cyan,\n            ReconstructedExpression = BrightYellow,\n\n            SecondaryText = LightGrey,\n            Headers = White\n        };\n"
    },
    {
        "begin_line": 4052,
        "end_line": 4052,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_moved",
        "snippet": "        bool m_moved = false;\n"
    },
    {
        "begin_line": 4063,
        "end_line": 4105,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    template<typename T>\n    class ReporterRegistrar {\n\n        class ReporterFactory : public IReporterFactory {\n\n            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n\n            virtual std::string getDescription() const override {\n                return T::getDescription();\n            }\n        };\n\n    public:\n\n        explicit ReporterRegistrar( std::string const& name ) {\n            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );\n        }\n    };\n\n    template<typename T>\n    class ListenerRegistrar {\n\n        class ListenerFactory : public IReporterFactory {\n\n            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n            virtual std::string getDescription() const override {\n                return std::string();\n            }\n        };\n\n    public:\n\n        ListenerRegistrar() {\n            getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );\n        }\n    };\n}\n"
    },
    {
        "begin_line": 4066,
        "end_line": 4084,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterRegistrar",
        "snippet": "    class ReporterRegistrar {\n\n        class ReporterFactory : public IReporterFactory {\n\n            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n\n            virtual std::string getDescription() const override {\n                return T::getDescription();\n            }\n        };\n\n    public:\n\n        explicit ReporterRegistrar( std::string const& name ) {\n            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );\n        }\n    };\n"
    },
    {
        "begin_line": 4068,
        "end_line": 4077,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterFactory",
        "snippet": "        class ReporterFactory : public IReporterFactory {\n\n            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n\n            virtual std::string getDescription() const override {\n                return T::getDescription();\n            }\n        };\n"
    },
    {
        "begin_line": 4070,
        "end_line": 4072,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "create",
        "snippet": "            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n"
    },
    {
        "begin_line": 4074,
        "end_line": 4076,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getDescription",
        "snippet": "            virtual std::string getDescription() const override {\n                return T::getDescription();\n            }\n"
    },
    {
        "begin_line": 4081,
        "end_line": 4083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterRegistrar",
        "snippet": "        explicit ReporterRegistrar( std::string const& name ) {\n            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );\n        }\n"
    },
    {
        "begin_line": 4087,
        "end_line": 4104,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ListenerRegistrar",
        "snippet": "    class ListenerRegistrar {\n\n        class ListenerFactory : public IReporterFactory {\n\n            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n            virtual std::string getDescription() const override {\n                return std::string();\n            }\n        };\n\n    public:\n\n        ListenerRegistrar() {\n            getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );\n        }\n    };\n"
    },
    {
        "begin_line": 4089,
        "end_line": 4097,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ListenerFactory",
        "snippet": "        class ListenerFactory : public IReporterFactory {\n\n            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n            virtual std::string getDescription() const override {\n                return std::string();\n            }\n        };\n"
    },
    {
        "begin_line": 4091,
        "end_line": 4093,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "create",
        "snippet": "            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {\n                return std::unique_ptr<T>( new T( config ) );\n            }\n"
    },
    {
        "begin_line": 4094,
        "end_line": 4096,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getDescription",
        "snippet": "            virtual std::string getDescription() const override {\n                return std::string();\n            }\n"
    },
    {
        "begin_line": 4101,
        "end_line": 4103,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ListenerRegistrar",
        "snippet": "        ListenerRegistrar() {\n            getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );\n        }\n"
    },
    {
        "begin_line": 4109,
        "end_line": 4112,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REGISTER_REPORTER",
        "snippet": "#define CATCH_REGISTER_REPORTER( name, reporterType ) \\\n    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \\\n    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); } \\\n    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n"
    },
    {
        "begin_line": 4114,
        "end_line": 4117,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REGISTER_LISTENER",
        "snippet": "#define CATCH_REGISTER_LISTENER( listenerType ) \\\n     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS   \\\n     namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; } \\\n     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\n"
    },
    {
        "begin_line": 4120,
        "end_line": 4120,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REGISTER_REPORTER",
        "snippet": "#define CATCH_REGISTER_REPORTER(name, reporterType)\n"
    },
    {
        "begin_line": 4121,
        "end_line": 4121,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REGISTER_LISTENER",
        "snippet": "#define CATCH_REGISTER_LISTENER(listenerType)\n"
    },
    {
        "begin_line": 4129,
        "end_line": 4153,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct CompactReporter : StreamingReporterBase<CompactReporter> {\n\n        using StreamingReporterBase::StreamingReporterBase;\n\n        ~CompactReporter() override;\n\n        static std::string getDescription();\n\n        ReporterPreferences getPreferences() const override;\n\n        void noMatchingTestCases(std::string const& spec) override;\n\n        void assertionStarting(AssertionInfo const&) override;\n\n        bool assertionEnded(AssertionStats const& _assertionStats) override;\n\n        void sectionEnded(SectionStats const& _sectionStats) override;\n\n        void testRunEnded(TestRunStats const& _testRunStats) override;\n\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 4131,
        "end_line": 4151,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CompactReporter",
        "snippet": "    struct CompactReporter : StreamingReporterBase<CompactReporter> {\n\n        using StreamingReporterBase::StreamingReporterBase;\n\n        ~CompactReporter() override;\n\n        static std::string getDescription();\n\n        ReporterPreferences getPreferences() const override;\n\n        void noMatchingTestCases(std::string const& spec) override;\n\n        void assertionStarting(AssertionInfo const&) override;\n\n        bool assertionEnded(AssertionStats const& _assertionStats) override;\n\n        void sectionEnded(SectionStats const& _sectionStats) override;\n\n        void testRunEnded(TestRunStats const& _testRunStats) override;\n\n    };\n"
    },
    {
        "begin_line": 4165,
        "end_line": 4219,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    // Fwd decls\n    struct SummaryColumn;\n    class TablePrinter;\n\n    struct ConsoleReporter : StreamingReporterBase<ConsoleReporter> {\n        std::unique_ptr<TablePrinter> m_tablePrinter;\n\n        ConsoleReporter(ReporterConfig const& config);\n        ~ConsoleReporter() override;\n        static std::string getDescription();\n\n        void noMatchingTestCases(std::string const& spec) override;\n\n        void assertionStarting(AssertionInfo const&) override;\n\n        bool assertionEnded(AssertionStats const& _assertionStats) override;\n\n        void sectionStarting(SectionInfo const& _sectionInfo) override;\n        void sectionEnded(SectionStats const& _sectionStats) override;\n\n        void benchmarkStarting(BenchmarkInfo const& info) override;\n        void benchmarkEnded(BenchmarkStats const& stats) override;\n\n        void testCaseEnded(TestCaseStats const& _testCaseStats) override;\n        void testGroupEnded(TestGroupStats const& _testGroupStats) override;\n        void testRunEnded(TestRunStats const& _testRunStats) override;\n\n    private:\n\n        void lazyPrint();\n\n        void lazyPrintWithoutClosingBenchmarkTable();\n        void lazyPrintRunInfo();\n        void lazyPrintGroupInfo();\n        void printTestCaseAndSectionHeader();\n\n        void printClosedHeader(std::string const& _name);\n        void printOpenHeader(std::string const& _name);\n\n        // if string has a : in first line will set indent to follow it on\n        // subsequent lines\n        void printHeaderString(std::string const& _string, std::size_t indent = 0);\n\n        void printTotals(Totals const& totals);\n        void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row);\n\n        void printTotalsDivider(Totals const& totals);\n        void printSummaryDivider();\n\n    private:\n        bool m_headerPrinted = false;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 4170,
        "end_line": 4217,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ConsoleReporter",
        "snippet": "    struct ConsoleReporter : StreamingReporterBase<ConsoleReporter> {\n        std::unique_ptr<TablePrinter> m_tablePrinter;\n\n        ConsoleReporter(ReporterConfig const& config);\n        ~ConsoleReporter() override;\n        static std::string getDescription();\n\n        void noMatchingTestCases(std::string const& spec) override;\n\n        void assertionStarting(AssertionInfo const&) override;\n\n        bool assertionEnded(AssertionStats const& _assertionStats) override;\n\n        void sectionStarting(SectionInfo const& _sectionInfo) override;\n        void sectionEnded(SectionStats const& _sectionStats) override;\n\n        void benchmarkStarting(BenchmarkInfo const& info) override;\n        void benchmarkEnded(BenchmarkStats const& stats) override;\n\n        void testCaseEnded(TestCaseStats const& _testCaseStats) override;\n        void testGroupEnded(TestGroupStats const& _testGroupStats) override;\n        void testRunEnded(TestRunStats const& _testRunStats) override;\n\n    private:\n\n        void lazyPrint();\n\n        void lazyPrintWithoutClosingBenchmarkTable();\n        void lazyPrintRunInfo();\n        void lazyPrintGroupInfo();\n        void printTestCaseAndSectionHeader();\n\n        void printClosedHeader(std::string const& _name);\n        void printOpenHeader(std::string const& _name);\n\n        // if string has a : in first line will set indent to follow it on\n        // subsequent lines\n        void printHeaderString(std::string const& _string, std::size_t indent = 0);\n\n        void printTotals(Totals const& totals);\n        void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row);\n\n        void printTotalsDivider(Totals const& totals);\n        void printSummaryDivider();\n\n    private:\n        bool m_headerPrinted = false;\n    };\n"
    },
    {
        "begin_line": 4171,
        "end_line": 4171,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_tablePrinter",
        "snippet": "        std::unique_ptr<TablePrinter> m_tablePrinter;\n"
    },
    {
        "begin_line": 4216,
        "end_line": 4216,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_headerPrinted",
        "snippet": "        bool m_headerPrinted = false;\n"
    },
    {
        "begin_line": 4232,
        "end_line": 4319,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class XmlEncode {\n    public:\n        enum ForWhat { ForTextNodes, ForAttributes };\n\n        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );\n\n        void encodeTo( std::ostream& os ) const;\n\n        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );\n\n    private:\n        std::string m_str;\n        ForWhat m_forWhat;\n    };\n\n    class XmlWriter {\n    public:\n\n        class ScopedElement {\n        public:\n            ScopedElement( XmlWriter* writer );\n\n            ScopedElement( ScopedElement&& other ) noexcept;\n            ScopedElement& operator=( ScopedElement&& other ) noexcept;\n\n            ~ScopedElement();\n\n            ScopedElement& writeText( std::string const& text, bool indent = true );\n\n            template<typename T>\n            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {\n                m_writer->writeAttribute( name, attribute );\n                return *this;\n            }\n\n        private:\n            mutable XmlWriter* m_writer = nullptr;\n        };\n\n        XmlWriter( std::ostream& os = Catch::cout() );\n        ~XmlWriter();\n\n        XmlWriter( XmlWriter const& ) = delete;\n        XmlWriter& operator=( XmlWriter const& ) = delete;\n\n        XmlWriter& startElement( std::string const& name );\n\n        ScopedElement scopedElement( std::string const& name );\n\n        XmlWriter& endElement();\n\n        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );\n\n        XmlWriter& writeAttribute( std::string const& name, bool attribute );\n\n        template<typename T>\n        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {\n            ReusableStringStream rss;\n            rss << attribute;\n            return writeAttribute( name, rss.str() );\n        }\n\n        XmlWriter& writeText( std::string const& text, bool indent = true );\n\n        XmlWriter& writeComment( std::string const& text );\n\n        void writeStylesheetRef( std::string const& url );\n\n        XmlWriter& writeBlankLine();\n\n        void ensureTagClosed();\n\n    private:\n\n        void writeDeclaration();\n\n        void newlineIfNecessary();\n\n        bool m_tagIsOpen = false;\n        bool m_needsNewline = false;\n        std::vector<std::string> m_tags;\n        std::string m_indent;\n        std::ostream& m_os;\n    };\n\n}\n"
    },
    {
        "begin_line": 4234,
        "end_line": 4247,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "XmlEncode",
        "snippet": "    class XmlEncode {\n    public:\n        enum ForWhat { ForTextNodes, ForAttributes };\n\n        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );\n\n        void encodeTo( std::ostream& os ) const;\n\n        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );\n\n    private:\n        std::string m_str;\n        ForWhat m_forWhat;\n    };\n"
    },
    {
        "begin_line": 4236,
        "end_line": 4236,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ForWhat",
        "snippet": "        enum ForWhat { ForTextNodes, ForAttributes };\n"
    },
    {
        "begin_line": 4245,
        "end_line": 4245,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_str",
        "snippet": "        std::string m_str;\n"
    },
    {
        "begin_line": 4246,
        "end_line": 4246,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_forWhat",
        "snippet": "        ForWhat m_forWhat;\n"
    },
    {
        "begin_line": 4249,
        "end_line": 4317,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "XmlWriter",
        "snippet": "    class XmlWriter {\n    public:\n\n        class ScopedElement {\n        public:\n            ScopedElement( XmlWriter* writer );\n\n            ScopedElement( ScopedElement&& other ) noexcept;\n            ScopedElement& operator=( ScopedElement&& other ) noexcept;\n\n            ~ScopedElement();\n\n            ScopedElement& writeText( std::string const& text, bool indent = true );\n\n            template<typename T>\n            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {\n                m_writer->writeAttribute( name, attribute );\n                return *this;\n            }\n\n        private:\n            mutable XmlWriter* m_writer = nullptr;\n        };\n\n        XmlWriter( std::ostream& os = Catch::cout() );\n        ~XmlWriter();\n\n        XmlWriter( XmlWriter const& ) = delete;\n        XmlWriter& operator=( XmlWriter const& ) = delete;\n\n        XmlWriter& startElement( std::string const& name );\n\n        ScopedElement scopedElement( std::string const& name );\n\n        XmlWriter& endElement();\n\n        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );\n\n        XmlWriter& writeAttribute( std::string const& name, bool attribute );\n\n        template<typename T>\n        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {\n            ReusableStringStream rss;\n            rss << attribute;\n            return writeAttribute( name, rss.str() );\n        }\n\n        XmlWriter& writeText( std::string const& text, bool indent = true );\n\n        XmlWriter& writeComment( std::string const& text );\n\n        void writeStylesheetRef( std::string const& url );\n\n        XmlWriter& writeBlankLine();\n\n        void ensureTagClosed();\n\n    private:\n\n        void writeDeclaration();\n\n        void newlineIfNecessary();\n\n        bool m_tagIsOpen = false;\n        bool m_needsNewline = false;\n        std::vector<std::string> m_tags;\n        std::string m_indent;\n        std::ostream& m_os;\n    };\n"
    },
    {
        "begin_line": 4252,
        "end_line": 4271,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ScopedElement",
        "snippet": "        class ScopedElement {\n        public:\n            ScopedElement( XmlWriter* writer );\n\n            ScopedElement( ScopedElement&& other ) noexcept;\n            ScopedElement& operator=( ScopedElement&& other ) noexcept;\n\n            ~ScopedElement();\n\n            ScopedElement& writeText( std::string const& text, bool indent = true );\n\n            template<typename T>\n            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {\n                m_writer->writeAttribute( name, attribute );\n                return *this;\n            }\n\n        private:\n            mutable XmlWriter* m_writer = nullptr;\n        };\n"
    },
    {
        "begin_line": 4264,
        "end_line": 4267,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeAttribute",
        "snippet": "            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {\n                m_writer->writeAttribute( name, attribute );\n                return *this;\n            }\n"
    },
    {
        "begin_line": 4270,
        "end_line": 4270,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_writer",
        "snippet": "            mutable XmlWriter* m_writer = nullptr;\n"
    },
    {
        "begin_line": 4290,
        "end_line": 4294,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeAttribute",
        "snippet": "        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {\n            ReusableStringStream rss;\n            rss << attribute;\n            return writeAttribute( name, rss.str() );\n        }\n"
    },
    {
        "begin_line": 4312,
        "end_line": 4312,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_tagIsOpen",
        "snippet": "        bool m_tagIsOpen = false;\n"
    },
    {
        "begin_line": 4313,
        "end_line": 4313,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_needsNewline",
        "snippet": "        bool m_needsNewline = false;\n"
    },
    {
        "begin_line": 4314,
        "end_line": 4314,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_tags",
        "snippet": "        std::vector<std::string> m_tags;\n"
    },
    {
        "begin_line": 4315,
        "end_line": 4315,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_indent",
        "snippet": "        std::string m_indent;\n"
    },
    {
        "begin_line": 4316,
        "end_line": 4316,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_os",
        "snippet": "        std::ostream& m_os;\n"
    },
    {
        "begin_line": 4322,
        "end_line": 4366,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class JunitReporter : public CumulativeReporterBase<JunitReporter> {\n    public:\n        JunitReporter(ReporterConfig const& _config);\n\n        ~JunitReporter() override;\n\n        static std::string getDescription();\n\n        void noMatchingTestCases(std::string const& /*spec*/) override;\n\n        void testRunStarting(TestRunInfo const& runInfo) override;\n\n        void testGroupStarting(GroupInfo const& groupInfo) override;\n\n        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;\n        bool assertionEnded(AssertionStats const& assertionStats) override;\n\n        void testCaseEnded(TestCaseStats const& testCaseStats) override;\n\n        void testGroupEnded(TestGroupStats const& testGroupStats) override;\n\n        void testRunEndedCumulative() override;\n\n        void writeGroup(TestGroupNode const& groupNode, double suiteTime);\n\n        void writeTestCase(TestCaseNode const& testCaseNode);\n\n        void writeSection(std::string const& className,\n                          std::string const& rootName,\n                          SectionNode const& sectionNode);\n\n        void writeAssertions(SectionNode const& sectionNode);\n        void writeAssertion(AssertionStats const& stats);\n\n        XmlWriter xml;\n        Timer suiteTimer;\n        std::string stdOutForSuite;\n        std::string stdErrForSuite;\n        unsigned int unexpectedExceptions = 0;\n        bool m_okToFail = false;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 4324,
        "end_line": 4364,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "JunitReporter",
        "snippet": "    class JunitReporter : public CumulativeReporterBase<JunitReporter> {\n    public:\n        JunitReporter(ReporterConfig const& _config);\n\n        ~JunitReporter() override;\n\n        static std::string getDescription();\n\n        void noMatchingTestCases(std::string const& /*spec*/) override;\n\n        void testRunStarting(TestRunInfo const& runInfo) override;\n\n        void testGroupStarting(GroupInfo const& groupInfo) override;\n\n        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;\n        bool assertionEnded(AssertionStats const& assertionStats) override;\n\n        void testCaseEnded(TestCaseStats const& testCaseStats) override;\n\n        void testGroupEnded(TestGroupStats const& testGroupStats) override;\n\n        void testRunEndedCumulative() override;\n\n        void writeGroup(TestGroupNode const& groupNode, double suiteTime);\n\n        void writeTestCase(TestCaseNode const& testCaseNode);\n\n        void writeSection(std::string const& className,\n                          std::string const& rootName,\n                          SectionNode const& sectionNode);\n\n        void writeAssertions(SectionNode const& sectionNode);\n        void writeAssertion(AssertionStats const& stats);\n\n        XmlWriter xml;\n        Timer suiteTimer;\n        std::string stdOutForSuite;\n        std::string stdErrForSuite;\n        unsigned int unexpectedExceptions = 0;\n        bool m_okToFail = false;\n    };\n"
    },
    {
        "begin_line": 4358,
        "end_line": 4358,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "xml",
        "snippet": "        XmlWriter xml;\n"
    },
    {
        "begin_line": 4359,
        "end_line": 4359,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "suiteTimer",
        "snippet": "        Timer suiteTimer;\n"
    },
    {
        "begin_line": 4360,
        "end_line": 4360,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stdOutForSuite",
        "snippet": "        std::string stdOutForSuite;\n"
    },
    {
        "begin_line": 4361,
        "end_line": 4361,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stdErrForSuite",
        "snippet": "        std::string stdErrForSuite;\n"
    },
    {
        "begin_line": 4362,
        "end_line": 4362,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "unexpectedExceptions",
        "snippet": "        unsigned int unexpectedExceptions = 0;\n"
    },
    {
        "begin_line": 4363,
        "end_line": 4363,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_okToFail",
        "snippet": "        bool m_okToFail = false;\n"
    },
    {
        "begin_line": 4371,
        "end_line": 4414,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    class XmlReporter : public StreamingReporterBase<XmlReporter> {\n    public:\n        XmlReporter(ReporterConfig const& _config);\n\n        ~XmlReporter() override;\n\n        static std::string getDescription();\n\n        virtual std::string getStylesheetRef() const;\n\n        void writeSourceInfo(SourceLineInfo const& sourceInfo);\n\n    public: // StreamingReporterBase\n\n        void noMatchingTestCases(std::string const& s) override;\n\n        void testRunStarting(TestRunInfo const& testInfo) override;\n\n        void testGroupStarting(GroupInfo const& groupInfo) override;\n\n        void testCaseStarting(TestCaseInfo const& testInfo) override;\n\n        void sectionStarting(SectionInfo const& sectionInfo) override;\n\n        void assertionStarting(AssertionInfo const&) override;\n\n        bool assertionEnded(AssertionStats const& assertionStats) override;\n\n        void sectionEnded(SectionStats const& sectionStats) override;\n\n        void testCaseEnded(TestCaseStats const& testCaseStats) override;\n\n        void testGroupEnded(TestGroupStats const& testGroupStats) override;\n\n        void testRunEnded(TestRunStats const& testRunStats) override;\n\n    private:\n        Timer m_testCaseTimer;\n        XmlWriter m_xml;\n        int m_sectionDepth = 0;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 4372,
        "end_line": 4412,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "XmlReporter",
        "snippet": "    class XmlReporter : public StreamingReporterBase<XmlReporter> {\n    public:\n        XmlReporter(ReporterConfig const& _config);\n\n        ~XmlReporter() override;\n\n        static std::string getDescription();\n\n        virtual std::string getStylesheetRef() const;\n\n        void writeSourceInfo(SourceLineInfo const& sourceInfo);\n\n    public: // StreamingReporterBase\n\n        void noMatchingTestCases(std::string const& s) override;\n\n        void testRunStarting(TestRunInfo const& testInfo) override;\n\n        void testGroupStarting(GroupInfo const& groupInfo) override;\n\n        void testCaseStarting(TestCaseInfo const& testInfo) override;\n\n        void sectionStarting(SectionInfo const& sectionInfo) override;\n\n        void assertionStarting(AssertionInfo const&) override;\n\n        bool assertionEnded(AssertionStats const& assertionStats) override;\n\n        void sectionEnded(SectionStats const& sectionStats) override;\n\n        void testCaseEnded(TestCaseStats const& testCaseStats) override;\n\n        void testGroupEnded(TestGroupStats const& testGroupStats) override;\n\n        void testRunEnded(TestRunStats const& testRunStats) override;\n\n    private:\n        Timer m_testCaseTimer;\n        XmlWriter m_xml;\n        int m_sectionDepth = 0;\n    };\n"
    },
    {
        "begin_line": 4409,
        "end_line": 4409,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testCaseTimer",
        "snippet": "        Timer m_testCaseTimer;\n"
    },
    {
        "begin_line": 4410,
        "end_line": 4410,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_xml",
        "snippet": "        XmlWriter m_xml;\n"
    },
    {
        "begin_line": 4411,
        "end_line": 4411,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_sectionDepth",
        "snippet": "        int m_sectionDepth = 0;\n"
    },
    {
        "begin_line": 4438,
        "end_line": 4600,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace TestCaseTracking {\n\n    struct NameAndLocation {\n        std::string name;\n        SourceLineInfo location;\n\n        NameAndLocation( std::string const& _name, SourceLineInfo const& _location );\n    };\n\n    struct ITracker;\n\n    using ITrackerPtr = std::shared_ptr<ITracker>;\n\n    struct ITracker {\n        virtual ~ITracker();\n\n        // static queries\n        virtual NameAndLocation const& nameAndLocation() const = 0;\n\n        // dynamic queries\n        virtual bool isComplete() const = 0; // Successfully completed or failed\n        virtual bool isSuccessfullyCompleted() const = 0;\n        virtual bool isOpen() const = 0; // Started but not complete\n        virtual bool hasChildren() const = 0;\n\n        virtual ITracker& parent() = 0;\n\n        // actions\n        virtual void close() = 0; // Successfully complete\n        virtual void fail() = 0;\n        virtual void markAsNeedingAnotherRun() = 0;\n\n        virtual void addChild( ITrackerPtr const& child ) = 0;\n        virtual ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) = 0;\n        virtual void openChild() = 0;\n\n        // Debug/ checking\n        virtual bool isSectionTracker() const = 0;\n        virtual bool isIndexTracker() const = 0;\n    };\n\n    class TrackerContext {\n\n        enum RunState {\n            NotStarted,\n            Executing,\n            CompletedCycle\n        };\n\n        ITrackerPtr m_rootTracker;\n        ITracker* m_currentTracker = nullptr;\n        RunState m_runState = NotStarted;\n\n    public:\n\n        static TrackerContext& instance();\n\n        ITracker& startRun();\n        void endRun();\n\n        void startCycle();\n        void completeCycle();\n\n        bool completedCycle() const;\n        ITracker& currentTracker();\n        void setCurrentTracker( ITracker* tracker );\n    };\n\n    class TrackerBase : public ITracker {\n    protected:\n        enum CycleState {\n            NotStarted,\n            Executing,\n            ExecutingChildren,\n            NeedsAnotherRun,\n            CompletedSuccessfully,\n            Failed\n        };\n\n        class TrackerHasName {\n            NameAndLocation m_nameAndLocation;\n        public:\n            TrackerHasName( NameAndLocation const& nameAndLocation );\n            bool operator ()( ITrackerPtr const& tracker ) const;\n        };\n\n        using Children = std::vector<ITrackerPtr>;\n        NameAndLocation m_nameAndLocation;\n        TrackerContext& m_ctx;\n        ITracker* m_parent;\n        Children m_children;\n        CycleState m_runState = NotStarted;\n\n    public:\n        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );\n\n        NameAndLocation const& nameAndLocation() const override;\n        bool isComplete() const override;\n        bool isSuccessfullyCompleted() const override;\n        bool isOpen() const override;\n        bool hasChildren() const override;\n\n        void addChild( ITrackerPtr const& child ) override;\n\n        ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) override;\n        ITracker& parent() override;\n\n        void openChild() override;\n\n        bool isSectionTracker() const override;\n        bool isIndexTracker() const override;\n\n        void open();\n\n        void close() override;\n        void fail() override;\n        void markAsNeedingAnotherRun() override;\n\n    private:\n        void moveToParent();\n        void moveToThis();\n    };\n\n    class SectionTracker : public TrackerBase {\n        std::vector<std::string> m_filters;\n    public:\n        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );\n\n        bool isSectionTracker() const override;\n\n        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n\n        void tryOpen();\n\n        void addInitialFilters( std::vector<std::string> const& filters );\n        void addNextFilters( std::vector<std::string> const& filters );\n    };\n\n    class IndexTracker : public TrackerBase {\n        int m_size;\n        int m_index = -1;\n    public:\n        IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size );\n\n        bool isIndexTracker() const override;\n        void close() override;\n\n        static IndexTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size );\n\n        int index() const;\n\n        void moveNext();\n    };\n\n} // namespace TestCaseTracking\n\nusing TestCaseTracking::ITracker;\nusing TestCaseTracking::TrackerContext;\nusing TestCaseTracking::SectionTracker;\nusing TestCaseTracking::IndexTracker;\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 4439,
        "end_line": 4593,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCaseTracking",
        "snippet": "namespace TestCaseTracking {\n\n    struct NameAndLocation {\n        std::string name;\n        SourceLineInfo location;\n\n        NameAndLocation( std::string const& _name, SourceLineInfo const& _location );\n    };\n\n    struct ITracker;\n\n    using ITrackerPtr = std::shared_ptr<ITracker>;\n\n    struct ITracker {\n        virtual ~ITracker();\n\n        // static queries\n        virtual NameAndLocation const& nameAndLocation() const = 0;\n\n        // dynamic queries\n        virtual bool isComplete() const = 0; // Successfully completed or failed\n        virtual bool isSuccessfullyCompleted() const = 0;\n        virtual bool isOpen() const = 0; // Started but not complete\n        virtual bool hasChildren() const = 0;\n\n        virtual ITracker& parent() = 0;\n\n        // actions\n        virtual void close() = 0; // Successfully complete\n        virtual void fail() = 0;\n        virtual void markAsNeedingAnotherRun() = 0;\n\n        virtual void addChild( ITrackerPtr const& child ) = 0;\n        virtual ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) = 0;\n        virtual void openChild() = 0;\n\n        // Debug/ checking\n        virtual bool isSectionTracker() const = 0;\n        virtual bool isIndexTracker() const = 0;\n    };\n\n    class TrackerContext {\n\n        enum RunState {\n            NotStarted,\n            Executing,\n            CompletedCycle\n        };\n\n        ITrackerPtr m_rootTracker;\n        ITracker* m_currentTracker = nullptr;\n        RunState m_runState = NotStarted;\n\n    public:\n\n        static TrackerContext& instance();\n\n        ITracker& startRun();\n        void endRun();\n\n        void startCycle();\n        void completeCycle();\n\n        bool completedCycle() const;\n        ITracker& currentTracker();\n        void setCurrentTracker( ITracker* tracker );\n    };\n\n    class TrackerBase : public ITracker {\n    protected:\n        enum CycleState {\n            NotStarted,\n            Executing,\n            ExecutingChildren,\n            NeedsAnotherRun,\n            CompletedSuccessfully,\n            Failed\n        };\n\n        class TrackerHasName {\n            NameAndLocation m_nameAndLocation;\n        public:\n            TrackerHasName( NameAndLocation const& nameAndLocation );\n            bool operator ()( ITrackerPtr const& tracker ) const;\n        };\n\n        using Children = std::vector<ITrackerPtr>;\n        NameAndLocation m_nameAndLocation;\n        TrackerContext& m_ctx;\n        ITracker* m_parent;\n        Children m_children;\n        CycleState m_runState = NotStarted;\n\n    public:\n        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );\n\n        NameAndLocation const& nameAndLocation() const override;\n        bool isComplete() const override;\n        bool isSuccessfullyCompleted() const override;\n        bool isOpen() const override;\n        bool hasChildren() const override;\n\n        void addChild( ITrackerPtr const& child ) override;\n\n        ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) override;\n        ITracker& parent() override;\n\n        void openChild() override;\n\n        bool isSectionTracker() const override;\n        bool isIndexTracker() const override;\n\n        void open();\n\n        void close() override;\n        void fail() override;\n        void markAsNeedingAnotherRun() override;\n\n    private:\n        void moveToParent();\n        void moveToThis();\n    };\n\n    class SectionTracker : public TrackerBase {\n        std::vector<std::string> m_filters;\n    public:\n        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );\n\n        bool isSectionTracker() const override;\n\n        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n\n        void tryOpen();\n\n        void addInitialFilters( std::vector<std::string> const& filters );\n        void addNextFilters( std::vector<std::string> const& filters );\n    };\n\n    class IndexTracker : public TrackerBase {\n        int m_size;\n        int m_index = -1;\n    public:\n        IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size );\n\n        bool isIndexTracker() const override;\n        void close() override;\n\n        static IndexTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size );\n\n        int index() const;\n\n        void moveNext();\n    };\n\n} // namespace TestCaseTracking\n"
    },
    {
        "begin_line": 4441,
        "end_line": 4446,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NameAndLocation",
        "snippet": "    struct NameAndLocation {\n        std::string name;\n        SourceLineInfo location;\n\n        NameAndLocation( std::string const& _name, SourceLineInfo const& _location );\n    };\n"
    },
    {
        "begin_line": 4442,
        "end_line": 4442,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        std::string name;\n"
    },
    {
        "begin_line": 4443,
        "end_line": 4443,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "location",
        "snippet": "        SourceLineInfo location;\n"
    },
    {
        "begin_line": 4452,
        "end_line": 4478,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ITracker",
        "snippet": "    struct ITracker {\n        virtual ~ITracker();\n\n        // static queries\n        virtual NameAndLocation const& nameAndLocation() const = 0;\n\n        // dynamic queries\n        virtual bool isComplete() const = 0; // Successfully completed or failed\n        virtual bool isSuccessfullyCompleted() const = 0;\n        virtual bool isOpen() const = 0; // Started but not complete\n        virtual bool hasChildren() const = 0;\n\n        virtual ITracker& parent() = 0;\n\n        // actions\n        virtual void close() = 0; // Successfully complete\n        virtual void fail() = 0;\n        virtual void markAsNeedingAnotherRun() = 0;\n\n        virtual void addChild( ITrackerPtr const& child ) = 0;\n        virtual ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) = 0;\n        virtual void openChild() = 0;\n\n        // Debug/ checking\n        virtual bool isSectionTracker() const = 0;\n        virtual bool isIndexTracker() const = 0;\n    };\n"
    },
    {
        "begin_line": 4480,
        "end_line": 4505,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TrackerContext",
        "snippet": "    class TrackerContext {\n\n        enum RunState {\n            NotStarted,\n            Executing,\n            CompletedCycle\n        };\n\n        ITrackerPtr m_rootTracker;\n        ITracker* m_currentTracker = nullptr;\n        RunState m_runState = NotStarted;\n\n    public:\n\n        static TrackerContext& instance();\n\n        ITracker& startRun();\n        void endRun();\n\n        void startCycle();\n        void completeCycle();\n\n        bool completedCycle() const;\n        ITracker& currentTracker();\n        void setCurrentTracker( ITracker* tracker );\n    };\n"
    },
    {
        "begin_line": 4482,
        "end_line": 4486,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RunState",
        "snippet": "        enum RunState {\n            NotStarted,\n            Executing,\n            CompletedCycle\n        };\n"
    },
    {
        "begin_line": 4488,
        "end_line": 4488,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_rootTracker",
        "snippet": "        ITrackerPtr m_rootTracker;\n"
    },
    {
        "begin_line": 4489,
        "end_line": 4489,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_currentTracker",
        "snippet": "        ITracker* m_currentTracker = nullptr;\n"
    },
    {
        "begin_line": 4490,
        "end_line": 4490,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_runState",
        "snippet": "        RunState m_runState = NotStarted;\n"
    },
    {
        "begin_line": 4507,
        "end_line": 4560,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TrackerBase",
        "snippet": "    class TrackerBase : public ITracker {\n    protected:\n        enum CycleState {\n            NotStarted,\n            Executing,\n            ExecutingChildren,\n            NeedsAnotherRun,\n            CompletedSuccessfully,\n            Failed\n        };\n\n        class TrackerHasName {\n            NameAndLocation m_nameAndLocation;\n        public:\n            TrackerHasName( NameAndLocation const& nameAndLocation );\n            bool operator ()( ITrackerPtr const& tracker ) const;\n        };\n\n        using Children = std::vector<ITrackerPtr>;\n        NameAndLocation m_nameAndLocation;\n        TrackerContext& m_ctx;\n        ITracker* m_parent;\n        Children m_children;\n        CycleState m_runState = NotStarted;\n\n    public:\n        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );\n\n        NameAndLocation const& nameAndLocation() const override;\n        bool isComplete() const override;\n        bool isSuccessfullyCompleted() const override;\n        bool isOpen() const override;\n        bool hasChildren() const override;\n\n        void addChild( ITrackerPtr const& child ) override;\n\n        ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) override;\n        ITracker& parent() override;\n\n        void openChild() override;\n\n        bool isSectionTracker() const override;\n        bool isIndexTracker() const override;\n\n        void open();\n\n        void close() override;\n        void fail() override;\n        void markAsNeedingAnotherRun() override;\n\n    private:\n        void moveToParent();\n        void moveToThis();\n    };\n"
    },
    {
        "begin_line": 4509,
        "end_line": 4516,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CycleState",
        "snippet": "        enum CycleState {\n            NotStarted,\n            Executing,\n            ExecutingChildren,\n            NeedsAnotherRun,\n            CompletedSuccessfully,\n            Failed\n        };\n"
    },
    {
        "begin_line": 4518,
        "end_line": 4523,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TrackerHasName",
        "snippet": "        class TrackerHasName {\n            NameAndLocation m_nameAndLocation;\n        public:\n            TrackerHasName( NameAndLocation const& nameAndLocation );\n            bool operator ()( ITrackerPtr const& tracker ) const;\n        };\n"
    },
    {
        "begin_line": 4519,
        "end_line": 4519,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_nameAndLocation",
        "snippet": "            NameAndLocation m_nameAndLocation;\n"
    },
    {
        "begin_line": 4526,
        "end_line": 4526,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_nameAndLocation",
        "snippet": "        NameAndLocation m_nameAndLocation;\n"
    },
    {
        "begin_line": 4527,
        "end_line": 4527,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ctx",
        "snippet": "        TrackerContext& m_ctx;\n"
    },
    {
        "begin_line": 4528,
        "end_line": 4528,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_parent",
        "snippet": "        ITracker* m_parent;\n"
    },
    {
        "begin_line": 4529,
        "end_line": 4529,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_children",
        "snippet": "        Children m_children;\n"
    },
    {
        "begin_line": 4530,
        "end_line": 4530,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_runState",
        "snippet": "        CycleState m_runState = NotStarted;\n"
    },
    {
        "begin_line": 4562,
        "end_line": 4575,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionTracker",
        "snippet": "    class SectionTracker : public TrackerBase {\n        std::vector<std::string> m_filters;\n    public:\n        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );\n\n        bool isSectionTracker() const override;\n\n        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n\n        void tryOpen();\n\n        void addInitialFilters( std::vector<std::string> const& filters );\n        void addNextFilters( std::vector<std::string> const& filters );\n    };\n"
    },
    {
        "begin_line": 4563,
        "end_line": 4563,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_filters",
        "snippet": "        std::vector<std::string> m_filters;\n"
    },
    {
        "begin_line": 4577,
        "end_line": 4591,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IndexTracker",
        "snippet": "    class IndexTracker : public TrackerBase {\n        int m_size;\n        int m_index = -1;\n    public:\n        IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size );\n\n        bool isIndexTracker() const override;\n        void close() override;\n\n        static IndexTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size );\n\n        int index() const;\n\n        void moveNext();\n    };\n"
    },
    {
        "begin_line": 4578,
        "end_line": 4578,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_size",
        "snippet": "        int m_size;\n"
    },
    {
        "begin_line": 4579,
        "end_line": 4579,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_index",
        "snippet": "        int m_index = -1;\n"
    },
    {
        "begin_line": 4606,
        "end_line": 4612,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct LeakDetector {\n        LeakDetector();\n    };\n\n}\n"
    },
    {
        "begin_line": 4608,
        "end_line": 4610,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LeakDetector",
        "snippet": "    struct LeakDetector {\n        LeakDetector();\n    };\n"
    },
    {
        "begin_line": 4620,
        "end_line": 4628,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0111",
        "snippet": "namespace {\n\n// Performs equivalent check of std::fabs(lhs - rhs) <= margin\n// But without the subtraction to allow for INFINITY in comparison\nbool marginComparison(double lhs, double rhs, double margin) {\n    return (lhs + margin >= rhs) && (rhs + margin >= lhs);\n}\n\n}\n"
    },
    {
        "begin_line": 4624,
        "end_line": 4626,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "marginComparison",
        "snippet": "bool marginComparison(double lhs, double rhs, double margin) {\n    return (lhs + margin >= rhs) && (rhs + margin >= lhs);\n}\n"
    },
    {
        "begin_line": 4630,
        "end_line": 4662,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Detail {\n\n    Approx::Approx ( double value )\n    :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),\n        m_margin( 0.0 ),\n        m_scale( 0.0 ),\n        m_value( value )\n    {}\n\n    Approx Approx::custom() {\n        return Approx( 0 );\n    }\n\n    std::string Approx::toString() const {\n        ReusableStringStream rss;\n        rss << \"Approx( \" << ::Catch::Detail::stringify( m_value ) << \" )\";\n        return rss.str();\n    }\n\n    bool Approx::equalityComparisonImpl(const double other) const {\n        // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value\n        // Thanks to Richard Harris for his help refining the scaled margin value\n        return marginComparison(m_value, other, m_margin) || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(m_value)));\n    }\n\n} // end namespace Detail\n\nstd::string StringMaker<Catch::Detail::Approx>::convert(Catch::Detail::Approx const& value) {\n    return value.toString();\n}\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 4631,
        "end_line": 4656,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "namespace Detail {\n\n    Approx::Approx ( double value )\n    :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),\n        m_margin( 0.0 ),\n        m_scale( 0.0 ),\n        m_value( value )\n    {}\n\n    Approx Approx::custom() {\n        return Approx( 0 );\n    }\n\n    std::string Approx::toString() const {\n        ReusableStringStream rss;\n        rss << \"Approx( \" << ::Catch::Detail::stringify( m_value ) << \" )\";\n        return rss.str();\n    }\n\n    bool Approx::equalityComparisonImpl(const double other) const {\n        // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value\n        // Thanks to Richard Harris for his help refining the scaled margin value\n        return marginComparison(m_value, other, m_margin) || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(m_value)));\n    }\n\n} // end namespace Detail\n"
    },
    {
        "begin_line": 4633,
        "end_line": 4638,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Approx",
        "snippet": "    Approx::Approx ( double value )\n    :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),\n        m_margin( 0.0 ),\n        m_scale( 0.0 ),\n        m_value( value )\n    {}\n"
    },
    {
        "begin_line": 4640,
        "end_line": 4642,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "custom",
        "snippet": "    Approx Approx::custom() {\n        return Approx( 0 );\n    }\n"
    },
    {
        "begin_line": 4644,
        "end_line": 4648,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "toString",
        "snippet": "    std::string Approx::toString() const {\n        ReusableStringStream rss;\n        rss << \"Approx( \" << ::Catch::Detail::stringify( m_value ) << \" )\";\n        return rss.str();\n    }\n"
    },
    {
        "begin_line": 4650,
        "end_line": 4654,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "equalityComparisonImpl",
        "snippet": "    bool Approx::equalityComparisonImpl(const double other) const {\n        // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value\n        // Thanks to Richard Harris for his help refining the scaled margin value\n        return marginComparison(m_value, other, m_margin) || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(m_value)));\n    }\n"
    },
    {
        "begin_line": 4658,
        "end_line": 4660,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<Catch::Detail::Approx>::convert(Catch::Detail::Approx const& value) {\n    return value.toString();\n}\n"
    },
    {
        "begin_line": 4670,
        "end_line": 4715,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct IResultCapture;\n    struct IRunner;\n    struct IConfig;\n    struct IMutableContext;\n\n    using IConfigPtr = std::shared_ptr<IConfig const>;\n\n    struct IContext\n    {\n        virtual ~IContext();\n\n        virtual IResultCapture* getResultCapture() = 0;\n        virtual IRunner* getRunner() = 0;\n        virtual IConfigPtr const& getConfig() const = 0;\n    };\n\n    struct IMutableContext : IContext\n    {\n        virtual ~IMutableContext();\n        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;\n        virtual void setRunner( IRunner* runner ) = 0;\n        virtual void setConfig( IConfigPtr const& config ) = 0;\n\n    private:\n        static IMutableContext *currentContext;\n        friend IMutableContext& getCurrentMutableContext();\n        friend void cleanUpContext();\n        static void createContext();\n    };\n\n    inline IMutableContext& getCurrentMutableContext()\n    {\n        if( !IMutableContext::currentContext )\n            IMutableContext::createContext();\n        return *IMutableContext::currentContext;\n    }\n\n    inline IContext& getCurrentContext()\n    {\n        return getCurrentMutableContext();\n    }\n\n    void cleanUpContext();\n}\n"
    },
    {
        "begin_line": 4679,
        "end_line": 4686,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IContext",
        "snippet": "    struct IContext\n    {\n        virtual ~IContext();\n\n        virtual IResultCapture* getResultCapture() = 0;\n        virtual IRunner* getRunner() = 0;\n        virtual IConfigPtr const& getConfig() const = 0;\n    };\n"
    },
    {
        "begin_line": 4688,
        "end_line": 4700,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IMutableContext",
        "snippet": "    struct IMutableContext : IContext\n    {\n        virtual ~IMutableContext();\n        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;\n        virtual void setRunner( IRunner* runner ) = 0;\n        virtual void setConfig( IConfigPtr const& config ) = 0;\n\n    private:\n        static IMutableContext *currentContext;\n        friend IMutableContext& getCurrentMutableContext();\n        friend void cleanUpContext();\n        static void createContext();\n    };\n"
    },
    {
        "begin_line": 4696,
        "end_line": 4696,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "currentContext",
        "snippet": "        static IMutableContext *currentContext;\n"
    },
    {
        "begin_line": 4702,
        "end_line": 4707,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getCurrentMutableContext",
        "snippet": "    inline IMutableContext& getCurrentMutableContext()\n    {\n        if( !IMutableContext::currentContext )\n            IMutableContext::createContext();\n        return *IMutableContext::currentContext;\n    }\n"
    },
    {
        "begin_line": 4709,
        "end_line": 4712,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getCurrentContext",
        "snippet": "    inline IContext& getCurrentContext()\n    {\n        return getCurrentMutableContext();\n    }\n"
    },
    {
        "begin_line": 4720,
        "end_line": 4722,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    bool isDebuggerActive();\n}\n"
    },
    {
        "begin_line": 4726,
        "end_line": 4726,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TRAP",
        "snippet": "    #define CATCH_TRAP() __asm__(\"int $3\\n\" : : ) /* NOLINT */\n"
    },
    {
        "begin_line": 4733,
        "end_line": 4733,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TRAP",
        "snippet": "        #define CATCH_TRAP() asm volatile (\"int $3\") /* NOLINT */\n"
    },
    {
        "begin_line": 4737,
        "end_line": 4737,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TRAP",
        "snippet": "        #define CATCH_TRAP() raise(SIGTRAP)\n"
    },
    {
        "begin_line": 4740,
        "end_line": 4740,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TRAP",
        "snippet": "    #define CATCH_TRAP() __debugbreak()\n"
    },
    {
        "begin_line": 4743,
        "end_line": 4743,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TRAP",
        "snippet": "    #define CATCH_TRAP() DebugBreak()\n"
    },
    {
        "begin_line": 4747,
        "end_line": 4747,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_BREAK_INTO_DEBUGGER",
        "snippet": "    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { CATCH_TRAP(); }\n"
    },
    {
        "begin_line": 4749,
        "end_line": 4751,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "    namespace Catch {\n        inline void doNothing() {}\n    }\n"
    },
    {
        "begin_line": 4750,
        "end_line": 4750,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "doNothing",
        "snippet": "        inline void doNothing() {}\n"
    },
    {
        "begin_line": 4752,
        "end_line": 4752,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_BREAK_INTO_DEBUGGER",
        "snippet": "    #define CATCH_BREAK_INTO_DEBUGGER() Catch::doNothing()\n"
    },
    {
        "begin_line": 4766,
        "end_line": 4766,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_DEFINED_NOMINMAX",
        "snippet": "#  define CATCH_DEFINED_NOMINMAX\n"
    },
    {
        "begin_line": 4767,
        "end_line": 4767,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NOMINMAX",
        "snippet": "#  define NOMINMAX\n"
    },
    {
        "begin_line": 4770,
        "end_line": 4770,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_DEFINED_WIN32_LEAN_AND_MEAN",
        "snippet": "#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN\n"
    },
    {
        "begin_line": 4771,
        "end_line": 4771,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WIN32_LEAN_AND_MEAN",
        "snippet": "#  define WIN32_LEAN_AND_MEAN\n"
    },
    {
        "begin_line": 4792,
        "end_line": 4807,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct FatalConditionHandler {\n\n        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);\n        FatalConditionHandler();\n        static void reset();\n        ~FatalConditionHandler();\n\n    private:\n        static bool isSet;\n        static ULONG guaranteeSize;\n        static PVOID exceptionHandlerHandle;\n    };\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 4794,
        "end_line": 4805,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FatalConditionHandler",
        "snippet": "    struct FatalConditionHandler {\n\n        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);\n        FatalConditionHandler();\n        static void reset();\n        ~FatalConditionHandler();\n\n    private:\n        static bool isSet;\n        static ULONG guaranteeSize;\n        static PVOID exceptionHandlerHandle;\n    };\n"
    },
    {
        "begin_line": 4802,
        "end_line": 4802,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSet",
        "snippet": "        static bool isSet;\n"
    },
    {
        "begin_line": 4803,
        "end_line": 4803,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "guaranteeSize",
        "snippet": "        static ULONG guaranteeSize;\n"
    },
    {
        "begin_line": 4804,
        "end_line": 4804,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "exceptionHandlerHandle",
        "snippet": "        static PVOID exceptionHandlerHandle;\n"
    },
    {
        "begin_line": 4813,
        "end_line": 4829,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct FatalConditionHandler {\n\n        static bool isSet;\n        static struct sigaction oldSigActions[];\n        static stack_t oldSigStack;\n        static char altStackMem[];\n\n        static void handleSignal( int sig );\n\n        FatalConditionHandler();\n        ~FatalConditionHandler();\n        static void reset();\n    };\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 4815,
        "end_line": 4827,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FatalConditionHandler",
        "snippet": "    struct FatalConditionHandler {\n\n        static bool isSet;\n        static struct sigaction oldSigActions[];\n        static stack_t oldSigStack;\n        static char altStackMem[];\n\n        static void handleSignal( int sig );\n\n        FatalConditionHandler();\n        ~FatalConditionHandler();\n        static void reset();\n    };\n"
    },
    {
        "begin_line": 4817,
        "end_line": 4817,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSet",
        "snippet": "        static bool isSet;\n"
    },
    {
        "begin_line": 4818,
        "end_line": 4818,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "oldSigActions",
        "snippet": "        static struct sigaction oldSigActions[];\n"
    },
    {
        "begin_line": 4819,
        "end_line": 4819,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "oldSigStack",
        "snippet": "        static stack_t oldSigStack;\n"
    },
    {
        "begin_line": 4820,
        "end_line": 4820,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "altStackMem",
        "snippet": "        static char altStackMem[];\n"
    },
    {
        "begin_line": 4833,
        "end_line": 4837,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    struct FatalConditionHandler {\n        void reset();\n    };\n}\n"
    },
    {
        "begin_line": 4834,
        "end_line": 4836,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FatalConditionHandler",
        "snippet": "    struct FatalConditionHandler {\n        void reset();\n    };\n"
    },
    {
        "begin_line": 4844,
        "end_line": 4961,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct IMutableContext;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    class RunContext : public IResultCapture, public IRunner {\n\n    public:\n        RunContext( RunContext const& ) = delete;\n        RunContext& operator =( RunContext const& ) = delete;\n\n        explicit RunContext( IConfigPtr const& _config, IStreamingReporterPtr&& reporter );\n\n        ~RunContext() override;\n\n        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount );\n        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount );\n\n        Totals runTest(TestCase const& testCase);\n\n        IConfigPtr config() const;\n        IStreamingReporter& reporter() const;\n\n    public: // IResultCapture\n\n        // Assertion handlers\n        void handleExpr\n                (   AssertionInfo const& info,\n                    ITransientExpression const& expr,\n                    AssertionReaction& reaction ) override;\n        void handleMessage\n                (   AssertionInfo const& info,\n                    ResultWas::OfType resultType,\n                    StringRef const& message,\n                    AssertionReaction& reaction ) override;\n        void handleUnexpectedExceptionNotThrown\n                (   AssertionInfo const& info,\n                    AssertionReaction& reaction ) override;\n        void handleUnexpectedInflightException\n                (   AssertionInfo const& info,\n                    std::string const& message,\n                    AssertionReaction& reaction ) override;\n        void handleIncomplete\n                (   AssertionInfo const& info ) override;\n        void handleNonExpr\n                (   AssertionInfo const &info,\n                    ResultWas::OfType resultType,\n                    AssertionReaction &reaction ) override;\n\n        bool sectionStarted( SectionInfo const& sectionInfo, Counts& assertions ) override;\n\n        void sectionEnded( SectionEndInfo const& endInfo ) override;\n        void sectionEndedEarly( SectionEndInfo const& endInfo ) override;\n\n        void benchmarkStarting( BenchmarkInfo const& info ) override;\n        void benchmarkEnded( BenchmarkStats const& stats ) override;\n\n        void pushScopedMessage( MessageInfo const& message ) override;\n        void popScopedMessage( MessageInfo const& message ) override;\n\n        std::string getCurrentTestName() const override;\n\n        const AssertionResult* getLastResult() const override;\n\n        void exceptionEarlyReported() override;\n\n        void handleFatalErrorCondition( StringRef message ) override;\n\n        bool lastAssertionPassed() override;\n\n        void assertionPassed() override;\n\n    public:\n        // !TBD We need to do this another way!\n        bool aborting() const final;\n\n    private:\n\n        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );\n        void invokeActiveTestCase();\n\n        void resetAssertionInfo();\n        bool testForMissingAssertions( Counts& assertions );\n\n        void assertionEnded( AssertionResult const& result );\n        void reportExpr\n                (   AssertionInfo const &info,\n                    ResultWas::OfType resultType,\n                    ITransientExpression const *expr,\n                    bool negated );\n\n        void populateReaction( AssertionReaction& reaction );\n\n    private:\n\n        void handleUnfinishedSections();\n\n        TestRunInfo m_runInfo;\n        IMutableContext& m_context;\n        TestCase const* m_activeTestCase = nullptr;\n        ITracker* m_testCaseTracker;\n        Option<AssertionResult> m_lastResult;\n\n        IConfigPtr m_config;\n        Totals m_totals;\n        IStreamingReporterPtr m_reporter;\n        std::vector<MessageInfo> m_messages;\n        AssertionInfo m_lastAssertionInfo;\n        std::vector<SectionEndInfo> m_unfinishedSections;\n        std::vector<ITracker*> m_activeSections;\n        TrackerContext m_trackerContext;\n        bool m_lastAssertionPassed = false;\n        bool m_shouldReportUnexpected = true;\n        bool m_includeSuccessfulResults;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 4850,
        "end_line": 4959,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RunContext",
        "snippet": "    class RunContext : public IResultCapture, public IRunner {\n\n    public:\n        RunContext( RunContext const& ) = delete;\n        RunContext& operator =( RunContext const& ) = delete;\n\n        explicit RunContext( IConfigPtr const& _config, IStreamingReporterPtr&& reporter );\n\n        ~RunContext() override;\n\n        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount );\n        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount );\n\n        Totals runTest(TestCase const& testCase);\n\n        IConfigPtr config() const;\n        IStreamingReporter& reporter() const;\n\n    public: // IResultCapture\n\n        // Assertion handlers\n        void handleExpr\n                (   AssertionInfo const& info,\n                    ITransientExpression const& expr,\n                    AssertionReaction& reaction ) override;\n        void handleMessage\n                (   AssertionInfo const& info,\n                    ResultWas::OfType resultType,\n                    StringRef const& message,\n                    AssertionReaction& reaction ) override;\n        void handleUnexpectedExceptionNotThrown\n                (   AssertionInfo const& info,\n                    AssertionReaction& reaction ) override;\n        void handleUnexpectedInflightException\n                (   AssertionInfo const& info,\n                    std::string const& message,\n                    AssertionReaction& reaction ) override;\n        void handleIncomplete\n                (   AssertionInfo const& info ) override;\n        void handleNonExpr\n                (   AssertionInfo const &info,\n                    ResultWas::OfType resultType,\n                    AssertionReaction &reaction ) override;\n\n        bool sectionStarted( SectionInfo const& sectionInfo, Counts& assertions ) override;\n\n        void sectionEnded( SectionEndInfo const& endInfo ) override;\n        void sectionEndedEarly( SectionEndInfo const& endInfo ) override;\n\n        void benchmarkStarting( BenchmarkInfo const& info ) override;\n        void benchmarkEnded( BenchmarkStats const& stats ) override;\n\n        void pushScopedMessage( MessageInfo const& message ) override;\n        void popScopedMessage( MessageInfo const& message ) override;\n\n        std::string getCurrentTestName() const override;\n\n        const AssertionResult* getLastResult() const override;\n\n        void exceptionEarlyReported() override;\n\n        void handleFatalErrorCondition( StringRef message ) override;\n\n        bool lastAssertionPassed() override;\n\n        void assertionPassed() override;\n\n    public:\n        // !TBD We need to do this another way!\n        bool aborting() const final;\n\n    private:\n\n        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );\n        void invokeActiveTestCase();\n\n        void resetAssertionInfo();\n        bool testForMissingAssertions( Counts& assertions );\n\n        void assertionEnded( AssertionResult const& result );\n        void reportExpr\n                (   AssertionInfo const &info,\n                    ResultWas::OfType resultType,\n                    ITransientExpression const *expr,\n                    bool negated );\n\n        void populateReaction( AssertionReaction& reaction );\n\n    private:\n\n        void handleUnfinishedSections();\n\n        TestRunInfo m_runInfo;\n        IMutableContext& m_context;\n        TestCase const* m_activeTestCase = nullptr;\n        ITracker* m_testCaseTracker;\n        Option<AssertionResult> m_lastResult;\n\n        IConfigPtr m_config;\n        Totals m_totals;\n        IStreamingReporterPtr m_reporter;\n        std::vector<MessageInfo> m_messages;\n        AssertionInfo m_lastAssertionInfo;\n        std::vector<SectionEndInfo> m_unfinishedSections;\n        std::vector<ITracker*> m_activeSections;\n        TrackerContext m_trackerContext;\n        bool m_lastAssertionPassed = false;\n        bool m_shouldReportUnexpected = true;\n        bool m_includeSuccessfulResults;\n    };\n"
    },
    {
        "begin_line": 4942,
        "end_line": 4942,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_runInfo",
        "snippet": "        TestRunInfo m_runInfo;\n"
    },
    {
        "begin_line": 4943,
        "end_line": 4943,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_context",
        "snippet": "        IMutableContext& m_context;\n"
    },
    {
        "begin_line": 4944,
        "end_line": 4944,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_activeTestCase",
        "snippet": "        TestCase const* m_activeTestCase = nullptr;\n"
    },
    {
        "begin_line": 4945,
        "end_line": 4945,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testCaseTracker",
        "snippet": "        ITracker* m_testCaseTracker;\n"
    },
    {
        "begin_line": 4946,
        "end_line": 4946,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lastResult",
        "snippet": "        Option<AssertionResult> m_lastResult;\n"
    },
    {
        "begin_line": 4948,
        "end_line": 4948,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_config",
        "snippet": "        IConfigPtr m_config;\n"
    },
    {
        "begin_line": 4949,
        "end_line": 4949,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_totals",
        "snippet": "        Totals m_totals;\n"
    },
    {
        "begin_line": 4950,
        "end_line": 4950,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_reporter",
        "snippet": "        IStreamingReporterPtr m_reporter;\n"
    },
    {
        "begin_line": 4951,
        "end_line": 4951,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_messages",
        "snippet": "        std::vector<MessageInfo> m_messages;\n"
    },
    {
        "begin_line": 4952,
        "end_line": 4952,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lastAssertionInfo",
        "snippet": "        AssertionInfo m_lastAssertionInfo;\n"
    },
    {
        "begin_line": 4953,
        "end_line": 4953,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_unfinishedSections",
        "snippet": "        std::vector<SectionEndInfo> m_unfinishedSections;\n"
    },
    {
        "begin_line": 4954,
        "end_line": 4954,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_activeSections",
        "snippet": "        std::vector<ITracker*> m_activeSections;\n"
    },
    {
        "begin_line": 4955,
        "end_line": 4955,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_trackerContext",
        "snippet": "        TrackerContext m_trackerContext;\n"
    },
    {
        "begin_line": 4956,
        "end_line": 4956,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lastAssertionPassed",
        "snippet": "        bool m_lastAssertionPassed = false;\n"
    },
    {
        "begin_line": 4957,
        "end_line": 4957,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_shouldReportUnexpected",
        "snippet": "        bool m_shouldReportUnexpected = true;\n"
    },
    {
        "begin_line": 4958,
        "end_line": 4958,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_includeSuccessfulResults",
        "snippet": "        bool m_includeSuccessfulResults;\n"
    },
    {
        "begin_line": 4964,
        "end_line": 5059,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    auto operator <<( std::ostream& os, ITransientExpression const& expr ) -> std::ostream& {\n        expr.streamReconstructedExpression( os );\n        return os;\n    }\n\n    LazyExpression::LazyExpression( bool isNegated )\n    :   m_isNegated( isNegated )\n    {}\n\n    LazyExpression::LazyExpression( LazyExpression const& other ) : m_isNegated( other.m_isNegated ) {}\n\n    LazyExpression::operator bool() const {\n        return m_transientExpression != nullptr;\n    }\n\n    auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream& {\n        if( lazyExpr.m_isNegated )\n            os << \"!\";\n\n        if( lazyExpr ) {\n            if( lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression() )\n                os << \"(\" << *lazyExpr.m_transientExpression << \")\";\n            else\n                os << *lazyExpr.m_transientExpression;\n        }\n        else {\n            os << \"{** error - unchecked empty expression requested **}\";\n        }\n        return os;\n    }\n\n    AssertionHandler::AssertionHandler\n        (   StringRef macroName,\n            SourceLineInfo const& lineInfo,\n            StringRef capturedExpression,\n            ResultDisposition::Flags resultDisposition )\n    :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },\n        m_resultCapture( getResultCapture() )\n    {}\n\n    void AssertionHandler::handleExpr( ITransientExpression const& expr ) {\n        m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );\n    }\n    void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const& message) {\n        m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );\n    }\n\n    auto AssertionHandler::allowThrows() const -> bool {\n        return getCurrentContext().getConfig()->allowThrows();\n    }\n\n    void AssertionHandler::complete() {\n        setCompleted();\n        if( m_reaction.shouldDebugBreak ) {\n\n            // If you find your debugger stopping you here then go one level up on the\n            // call-stack for the code that caused it (typically a failed assertion)\n\n            // (To go back to the test and change execution, jump over the throw, next)\n            CATCH_BREAK_INTO_DEBUGGER();\n        }\n        if( m_reaction.shouldThrow )\n            throw Catch::TestFailureException();\n    }\n    void AssertionHandler::setCompleted() {\n        m_completed = true;\n    }\n\n    void AssertionHandler::handleUnexpectedInflightException() {\n        m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );\n    }\n\n    void AssertionHandler::handleExceptionThrownAsExpected() {\n        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\n    }\n    void AssertionHandler::handleExceptionNotThrownAsExpected() {\n        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\n    }\n\n    void AssertionHandler::handleUnexpectedExceptionNotThrown() {\n        m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );\n    }\n\n    void AssertionHandler::handleThrowingCallSkipped() {\n        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\n    }\n\n    // This is the overload that takes a string and infers the Equals matcher from it\n    // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp\n    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef matcherString  ) {\n        handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );\n    }\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 4966,
        "end_line": 4969,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    auto operator <<( std::ostream& os, ITransientExpression const& expr ) -> std::ostream& {\n        expr.streamReconstructedExpression( os );\n        return os;\n    }\n"
    },
    {
        "begin_line": 4971,
        "end_line": 4973,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LazyExpression",
        "snippet": "    LazyExpression::LazyExpression( bool isNegated )\n    :   m_isNegated( isNegated )\n    {}\n"
    },
    {
        "begin_line": 4975,
        "end_line": 4975,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LazyExpression",
        "snippet": "    LazyExpression::LazyExpression( LazyExpression const& other ) : m_isNegated( other.m_isNegated ) {}\n"
    },
    {
        "begin_line": 4977,
        "end_line": 4979,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator bool",
        "snippet": "    LazyExpression::operator bool() const {\n        return m_transientExpression != nullptr;\n    }\n"
    },
    {
        "begin_line": 4981,
        "end_line": 4995,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream& {\n        if( lazyExpr.m_isNegated )\n            os << \"!\";\n\n        if( lazyExpr ) {\n            if( lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression() )\n                os << \"(\" << *lazyExpr.m_transientExpression << \")\";\n            else\n                os << *lazyExpr.m_transientExpression;\n        }\n        else {\n            os << \"{** error - unchecked empty expression requested **}\";\n        }\n        return os;\n    }\n"
    },
    {
        "begin_line": 4997,
        "end_line": 5004,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionHandler",
        "snippet": "    AssertionHandler::AssertionHandler\n        (   StringRef macroName,\n            SourceLineInfo const& lineInfo,\n            StringRef capturedExpression,\n            ResultDisposition::Flags resultDisposition )\n    :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },\n        m_resultCapture( getResultCapture() )\n    {}\n"
    },
    {
        "begin_line": 5006,
        "end_line": 5008,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExpr",
        "snippet": "    void AssertionHandler::handleExpr( ITransientExpression const& expr ) {\n        m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );\n    }\n"
    },
    {
        "begin_line": 5009,
        "end_line": 5011,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleMessage",
        "snippet": "    void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const& message) {\n        m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );\n    }\n"
    },
    {
        "begin_line": 5013,
        "end_line": 5015,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "allowThrows",
        "snippet": "    auto AssertionHandler::allowThrows() const -> bool {\n        return getCurrentContext().getConfig()->allowThrows();\n    }\n"
    },
    {
        "begin_line": 5017,
        "end_line": 5029,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "complete",
        "snippet": "    void AssertionHandler::complete() {\n        setCompleted();\n        if( m_reaction.shouldDebugBreak ) {\n\n            // If you find your debugger stopping you here then go one level up on the\n            // call-stack for the code that caused it (typically a failed assertion)\n\n            // (To go back to the test and change execution, jump over the throw, next)\n            CATCH_BREAK_INTO_DEBUGGER();\n        }\n        if( m_reaction.shouldThrow )\n            throw Catch::TestFailureException();\n    }\n"
    },
    {
        "begin_line": 5030,
        "end_line": 5032,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setCompleted",
        "snippet": "    void AssertionHandler::setCompleted() {\n        m_completed = true;\n    }\n"
    },
    {
        "begin_line": 5034,
        "end_line": 5036,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleUnexpectedInflightException",
        "snippet": "    void AssertionHandler::handleUnexpectedInflightException() {\n        m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );\n    }\n"
    },
    {
        "begin_line": 5038,
        "end_line": 5040,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExceptionThrownAsExpected",
        "snippet": "    void AssertionHandler::handleExceptionThrownAsExpected() {\n        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\n    }\n"
    },
    {
        "begin_line": 5041,
        "end_line": 5043,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExceptionNotThrownAsExpected",
        "snippet": "    void AssertionHandler::handleExceptionNotThrownAsExpected() {\n        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\n    }\n"
    },
    {
        "begin_line": 5045,
        "end_line": 5047,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleUnexpectedExceptionNotThrown",
        "snippet": "    void AssertionHandler::handleUnexpectedExceptionNotThrown() {\n        m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );\n    }\n"
    },
    {
        "begin_line": 5049,
        "end_line": 5051,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleThrowingCallSkipped",
        "snippet": "    void AssertionHandler::handleThrowingCallSkipped() {\n        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\n    }\n"
    },
    {
        "begin_line": 5055,
        "end_line": 5057,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExceptionMatchExpr",
        "snippet": "    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef matcherString  ) {\n        handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );\n    }\n"
    },
    {
        "begin_line": 5063,
        "end_line": 5150,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const & _lazyExpression):\n        lazyExpression(_lazyExpression),\n        resultType(_resultType) {}\n\n    std::string AssertionResultData::reconstructExpression() const {\n\n        if( reconstructedExpression.empty() ) {\n            if( lazyExpression ) {\n                ReusableStringStream rss;\n                rss << lazyExpression;\n                reconstructedExpression = rss.str();\n            }\n        }\n        return reconstructedExpression;\n    }\n\n    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )\n    :   m_info( info ),\n        m_resultData( data )\n    {}\n\n    // Result was a success\n    bool AssertionResult::succeeded() const {\n        return Catch::isOk( m_resultData.resultType );\n    }\n\n    // Result was a success, or failure is suppressed\n    bool AssertionResult::isOk() const {\n        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );\n    }\n\n    ResultWas::OfType AssertionResult::getResultType() const {\n        return m_resultData.resultType;\n    }\n\n    bool AssertionResult::hasExpression() const {\n        return m_info.capturedExpression[0] != 0;\n    }\n\n    bool AssertionResult::hasMessage() const {\n        return !m_resultData.message.empty();\n    }\n\n    std::string AssertionResult::getExpression() const {\n        if( isFalseTest( m_info.resultDisposition ) )\n            return \"!(\" + m_info.capturedExpression + \")\";\n        else\n            return m_info.capturedExpression;\n    }\n\n    std::string AssertionResult::getExpressionInMacro() const {\n        std::string expr;\n        if( m_info.macroName[0] == 0 )\n            expr = m_info.capturedExpression;\n        else {\n            expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );\n            expr += m_info.macroName;\n            expr += \"( \";\n            expr += m_info.capturedExpression;\n            expr += \" )\";\n        }\n        return expr;\n    }\n\n    bool AssertionResult::hasExpandedExpression() const {\n        return hasExpression() && getExpandedExpression() != getExpression();\n    }\n\n    std::string AssertionResult::getExpandedExpression() const {\n        std::string expr = m_resultData.reconstructExpression();\n        return expr.empty()\n                ? getExpression()\n                : expr;\n    }\n\n    std::string AssertionResult::getMessage() const {\n        return m_resultData.message;\n    }\n    SourceLineInfo AssertionResult::getSourceInfo() const {\n        return m_info.lineInfo;\n    }\n\n    StringRef AssertionResult::getTestMacroName() const {\n        return m_info.macroName;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 5064,
        "end_line": 5066,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionResultData",
        "snippet": "    AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const & _lazyExpression):\n        lazyExpression(_lazyExpression),\n        resultType(_resultType) {}\n"
    },
    {
        "begin_line": 5068,
        "end_line": 5078,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reconstructExpression",
        "snippet": "    std::string AssertionResultData::reconstructExpression() const {\n\n        if( reconstructedExpression.empty() ) {\n            if( lazyExpression ) {\n                ReusableStringStream rss;\n                rss << lazyExpression;\n                reconstructedExpression = rss.str();\n            }\n        }\n        return reconstructedExpression;\n    }\n"
    },
    {
        "begin_line": 5080,
        "end_line": 5083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionResult",
        "snippet": "    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )\n    :   m_info( info ),\n        m_resultData( data )\n    {}\n"
    },
    {
        "begin_line": 5086,
        "end_line": 5088,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "succeeded",
        "snippet": "    bool AssertionResult::succeeded() const {\n        return Catch::isOk( m_resultData.resultType );\n    }\n"
    },
    {
        "begin_line": 5091,
        "end_line": 5093,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isOk",
        "snippet": "    bool AssertionResult::isOk() const {\n        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );\n    }\n"
    },
    {
        "begin_line": 5095,
        "end_line": 5097,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getResultType",
        "snippet": "    ResultWas::OfType AssertionResult::getResultType() const {\n        return m_resultData.resultType;\n    }\n"
    },
    {
        "begin_line": 5099,
        "end_line": 5101,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hasExpression",
        "snippet": "    bool AssertionResult::hasExpression() const {\n        return m_info.capturedExpression[0] != 0;\n    }\n"
    },
    {
        "begin_line": 5103,
        "end_line": 5105,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hasMessage",
        "snippet": "    bool AssertionResult::hasMessage() const {\n        return !m_resultData.message.empty();\n    }\n"
    },
    {
        "begin_line": 5107,
        "end_line": 5112,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getExpression",
        "snippet": "    std::string AssertionResult::getExpression() const {\n        if( isFalseTest( m_info.resultDisposition ) )\n            return \"!(\" + m_info.capturedExpression + \")\";\n        else\n            return m_info.capturedExpression;\n    }\n"
    },
    {
        "begin_line": 5114,
        "end_line": 5126,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getExpressionInMacro",
        "snippet": "    std::string AssertionResult::getExpressionInMacro() const {\n        std::string expr;\n        if( m_info.macroName[0] == 0 )\n            expr = m_info.capturedExpression;\n        else {\n            expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );\n            expr += m_info.macroName;\n            expr += \"( \";\n            expr += m_info.capturedExpression;\n            expr += \" )\";\n        }\n        return expr;\n    }\n"
    },
    {
        "begin_line": 5128,
        "end_line": 5130,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hasExpandedExpression",
        "snippet": "    bool AssertionResult::hasExpandedExpression() const {\n        return hasExpression() && getExpandedExpression() != getExpression();\n    }\n"
    },
    {
        "begin_line": 5132,
        "end_line": 5137,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getExpandedExpression",
        "snippet": "    std::string AssertionResult::getExpandedExpression() const {\n        std::string expr = m_resultData.reconstructExpression();\n        return expr.empty()\n                ? getExpression()\n                : expr;\n    }\n"
    },
    {
        "begin_line": 5139,
        "end_line": 5141,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getMessage",
        "snippet": "    std::string AssertionResult::getMessage() const {\n        return m_resultData.message;\n    }\n"
    },
    {
        "begin_line": 5142,
        "end_line": 5144,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getSourceInfo",
        "snippet": "    SourceLineInfo AssertionResult::getSourceInfo() const {\n        return m_info.lineInfo;\n    }\n"
    },
    {
        "begin_line": 5146,
        "end_line": 5148,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getTestMacroName",
        "snippet": "    StringRef AssertionResult::getTestMacroName() const {\n        return m_info.macroName;\n    }\n"
    },
    {
        "begin_line": 5154,
        "end_line": 5176,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    auto BenchmarkLooper::getResolution() -> uint64_t {\n        return getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();\n    }\n\n    void BenchmarkLooper::reportStart() {\n        getResultCapture().benchmarkStarting( { m_name } );\n    }\n    auto BenchmarkLooper::needsMoreIterations() -> bool {\n        auto elapsed = m_timer.getElapsedNanoseconds();\n\n        // Exponentially increasing iterations until we're confident in our timer resolution\n        if( elapsed < m_resolution ) {\n            m_iterationsToRun *= 10;\n            return true;\n        }\n\n        getResultCapture().benchmarkEnded( { { m_name }, m_count, elapsed } );\n        return false;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 5156,
        "end_line": 5158,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getResolution",
        "snippet": "    auto BenchmarkLooper::getResolution() -> uint64_t {\n        return getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();\n    }\n"
    },
    {
        "begin_line": 5160,
        "end_line": 5162,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reportStart",
        "snippet": "    void BenchmarkLooper::reportStart() {\n        getResultCapture().benchmarkStarting( { m_name } );\n    }\n"
    },
    {
        "begin_line": 5163,
        "end_line": 5174,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "needsMoreIterations",
        "snippet": "    auto BenchmarkLooper::needsMoreIterations() -> bool {\n        auto elapsed = m_timer.getElapsedNanoseconds();\n\n        // Exponentially increasing iterations until we're confident in our timer resolution\n        if( elapsed < m_resolution ) {\n            m_iterationsToRun *= 10;\n            return true;\n        }\n\n        getResultCapture().benchmarkEnded( { { m_name }, m_count, elapsed } );\n        return false;\n    }\n"
    },
    {
        "begin_line": 5180,
        "end_line": 5193,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;\n\n    // This is the general overload that takes a any string matcher\n    // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers\n    // the Equals matcher (so the header does not mention matchers)\n    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef matcherString  ) {\n        std::string exceptionMessage = Catch::translateActiveException();\n        MatchExpr<std::string, StringMatcher const&> expr( exceptionMessage, matcher, matcherString );\n        handler.handleExpr( expr );\n    }\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 5187,
        "end_line": 5191,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExceptionMatchExpr",
        "snippet": "    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef matcherString  ) {\n        std::string exceptionMessage = Catch::translateActiveException();\n        MatchExpr<std::string, StringMatcher const&> expr( exceptionMessage, matcher, matcherString );\n        handler.handleExpr( expr );\n    }\n"
    },
    {
        "begin_line": 5203,
        "end_line": 5203,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH",
        "snippet": "#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH\n"
    },
    {
        "begin_line": 5206,
        "end_line": 5206,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH",
        "snippet": "#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1\n"
    },
    {
        "begin_line": 5227,
        "end_line": 5227,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CLARA_CONFIG_CONSOLE_WIDTH",
        "snippet": "#define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80\n"
    },
    {
        "begin_line": 5231,
        "end_line": 5231,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH",
        "snippet": "#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH\n"
    },
    {
        "begin_line": 5238,
        "end_line": 5238,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CLARA_CONFIG_OPTIONAL_TYPE",
        "snippet": "#define CLARA_CONFIG_OPTIONAL_TYPE std::optional\n"
    },
    {
        "begin_line": 5261,
        "end_line": 5261,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH",
        "snippet": "#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80\n"
    },
    {
        "begin_line": 5264,
        "end_line": 5567,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch { namespace clara { namespace TextFlow {\n\n    inline auto isWhitespace( char c ) -> bool {\n        static std::string chars = \" \\t\\n\\r\";\n        return chars.find( c ) != std::string::npos;\n    }\n    inline auto isBreakableBefore( char c ) -> bool {\n        static std::string chars = \"[({<|\";\n        return chars.find( c ) != std::string::npos;\n    }\n    inline auto isBreakableAfter( char c ) -> bool {\n        static std::string chars = \"])}>.,:;*+-=&/\\\\\";\n        return chars.find( c ) != std::string::npos;\n    }\n\n    class Columns;\n\n    class Column {\n        std::vector<std::string> m_strings;\n        size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;\n        size_t m_indent = 0;\n        size_t m_initialIndent = std::string::npos;\n\n    public:\n        class iterator {\n            friend Column;\n\n            Column const& m_column;\n            size_t m_stringIndex = 0;\n            size_t m_pos = 0;\n\n            size_t m_len = 0;\n            size_t m_end = 0;\n            bool m_suffix = false;\n\n            iterator( Column const& column, size_t stringIndex )\n            :   m_column( column ),\n                m_stringIndex( stringIndex )\n            {}\n\n            auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }\n\n            auto isBoundary( size_t at ) const -> bool {\n                assert( at > 0 );\n                assert( at <= line().size() );\n\n                return at == line().size() ||\n                       ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||\n                       isBreakableBefore( line()[at] ) ||\n                       isBreakableAfter( line()[at-1] );\n            }\n\n            void calcLength() {\n                assert( m_stringIndex < m_column.m_strings.size() );\n\n                m_suffix = false;\n                auto width = m_column.m_width-indent();\n                m_end = m_pos;\n                while( m_end < line().size() && line()[m_end] != '\\n' )\n                    ++m_end;\n\n                if( m_end < m_pos + width ) {\n                    m_len = m_end - m_pos;\n                }\n                else {\n                    size_t len = width;\n                    while (len > 0 && !isBoundary(m_pos + len))\n                        --len;\n                    while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))\n                        --len;\n\n                    if (len > 0) {\n                        m_len = len;\n                    } else {\n                        m_suffix = true;\n                        m_len = width - 1;\n                    }\n                }\n            }\n\n            auto indent() const -> size_t {\n                auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;\n                return initial == std::string::npos ? m_column.m_indent : initial;\n            }\n\n            auto addIndentAndSuffix(std::string const &plain) const -> std::string {\n                return std::string( indent(), ' ' ) + (m_suffix ? plain + \"-\" : plain);\n            }\n\n        public:\n            explicit iterator( Column const& column ) : m_column( column ) {\n                assert( m_column.m_width > m_column.m_indent );\n                assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );\n                calcLength();\n                if( m_len == 0 )\n                    m_stringIndex++; // Empty string\n            }\n\n            auto operator *() const -> std::string {\n                assert( m_stringIndex < m_column.m_strings.size() );\n                assert( m_pos <= m_end );\n                if( m_pos + m_column.m_width < m_end )\n                    return addIndentAndSuffix(line().substr(m_pos, m_len));\n                else\n                    return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));\n            }\n\n            auto operator ++() -> iterator& {\n                m_pos += m_len;\n                if( m_pos < line().size() && line()[m_pos] == '\\n' )\n                    m_pos += 1;\n                else\n                    while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )\n                        ++m_pos;\n\n                if( m_pos == line().size() ) {\n                    m_pos = 0;\n                    ++m_stringIndex;\n                }\n                if( m_stringIndex < m_column.m_strings.size() )\n                    calcLength();\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return\n                    m_pos == other.m_pos &&\n                    m_stringIndex == other.m_stringIndex &&\n                    &m_column == &other.m_column;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return !operator==( other );\n            }\n        };\n        using const_iterator = iterator;\n\n        explicit Column( std::string const& text ) { m_strings.push_back( text ); }\n\n        auto width( size_t newWidth ) -> Column& {\n            assert( newWidth > 0 );\n            m_width = newWidth;\n            return *this;\n        }\n        auto indent( size_t newIndent ) -> Column& {\n            m_indent = newIndent;\n            return *this;\n        }\n        auto initialIndent( size_t newIndent ) -> Column& {\n            m_initialIndent = newIndent;\n            return *this;\n        }\n\n        auto width() const -> size_t { return m_width; }\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, m_strings.size() }; }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Column const& col ) {\n            bool first = true;\n            for( auto line : col ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os <<  line;\n            }\n            return os;\n        }\n\n        auto operator + ( Column const& other ) -> Columns;\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n\n    class Spacer : public Column {\n\n    public:\n        explicit Spacer( size_t spaceWidth ) : Column( \"\" ) {\n            width( spaceWidth );\n        }\n    };\n\n    class Columns {\n        std::vector<Column> m_columns;\n\n    public:\n\n        class iterator {\n            friend Columns;\n            struct EndTag {};\n\n            std::vector<Column> const& m_columns;\n            std::vector<Column::iterator> m_iterators;\n            size_t m_activeIterators;\n\n            iterator( Columns const& columns, EndTag )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( 0 )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.end() );\n            }\n\n        public:\n            explicit iterator( Columns const& columns )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( m_columns.size() )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.begin() );\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return m_iterators == other.m_iterators;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return m_iterators != other.m_iterators;\n            }\n            auto operator *() const -> std::string {\n                std::string row, padding;\n\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    auto width = m_columns[i].width();\n                    if( m_iterators[i] != m_columns[i].end() ) {\n                        std::string col = *m_iterators[i];\n                        row += padding + col;\n                        if( col.size() < width )\n                            padding = std::string( width - col.size(), ' ' );\n                        else\n                            padding = \"\";\n                    }\n                    else {\n                        padding += std::string( width, ' ' );\n                    }\n                }\n                return row;\n            }\n            auto operator ++() -> iterator& {\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    if (m_iterators[i] != m_columns[i].end())\n                        ++m_iterators[i];\n                }\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n        };\n        using const_iterator = iterator;\n\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, iterator::EndTag() }; }\n\n        auto operator += ( Column const& col ) -> Columns& {\n            m_columns.push_back( col );\n            return *this;\n        }\n        auto operator + ( Column const& col ) -> Columns {\n            Columns combined = *this;\n            combined += col;\n            return combined;\n        }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Columns const& cols ) {\n\n            bool first = true;\n            for( auto line : cols ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os << line;\n            }\n            return os;\n        }\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n\n    inline auto Column::operator + ( Column const& other ) -> Columns {\n        Columns cols;\n        cols += *this;\n        cols += other;\n        return cols;\n    }\n}}} // namespace Catch::clara::TextFlow\n"
    },
    {
        "begin_line": 5264,
        "end_line": 5567,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "clara",
        "snippet": "namespace Catch { namespace clara { namespace TextFlow {\n\n    inline auto isWhitespace( char c ) -> bool {\n        static std::string chars = \" \\t\\n\\r\";\n        return chars.find( c ) != std::string::npos;\n    }\n    inline auto isBreakableBefore( char c ) -> bool {\n        static std::string chars = \"[({<|\";\n        return chars.find( c ) != std::string::npos;\n    }\n    inline auto isBreakableAfter( char c ) -> bool {\n        static std::string chars = \"])}>.,:;*+-=&/\\\\\";\n        return chars.find( c ) != std::string::npos;\n    }\n\n    class Columns;\n\n    class Column {\n        std::vector<std::string> m_strings;\n        size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;\n        size_t m_indent = 0;\n        size_t m_initialIndent = std::string::npos;\n\n    public:\n        class iterator {\n            friend Column;\n\n            Column const& m_column;\n            size_t m_stringIndex = 0;\n            size_t m_pos = 0;\n\n            size_t m_len = 0;\n            size_t m_end = 0;\n            bool m_suffix = false;\n\n            iterator( Column const& column, size_t stringIndex )\n            :   m_column( column ),\n                m_stringIndex( stringIndex )\n            {}\n\n            auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }\n\n            auto isBoundary( size_t at ) const -> bool {\n                assert( at > 0 );\n                assert( at <= line().size() );\n\n                return at == line().size() ||\n                       ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||\n                       isBreakableBefore( line()[at] ) ||\n                       isBreakableAfter( line()[at-1] );\n            }\n\n            void calcLength() {\n                assert( m_stringIndex < m_column.m_strings.size() );\n\n                m_suffix = false;\n                auto width = m_column.m_width-indent();\n                m_end = m_pos;\n                while( m_end < line().size() && line()[m_end] != '\\n' )\n                    ++m_end;\n\n                if( m_end < m_pos + width ) {\n                    m_len = m_end - m_pos;\n                }\n                else {\n                    size_t len = width;\n                    while (len > 0 && !isBoundary(m_pos + len))\n                        --len;\n                    while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))\n                        --len;\n\n                    if (len > 0) {\n                        m_len = len;\n                    } else {\n                        m_suffix = true;\n                        m_len = width - 1;\n                    }\n                }\n            }\n\n            auto indent() const -> size_t {\n                auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;\n                return initial == std::string::npos ? m_column.m_indent : initial;\n            }\n\n            auto addIndentAndSuffix(std::string const &plain) const -> std::string {\n                return std::string( indent(), ' ' ) + (m_suffix ? plain + \"-\" : plain);\n            }\n\n        public:\n            explicit iterator( Column const& column ) : m_column( column ) {\n                assert( m_column.m_width > m_column.m_indent );\n                assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );\n                calcLength();\n                if( m_len == 0 )\n                    m_stringIndex++; // Empty string\n            }\n\n            auto operator *() const -> std::string {\n                assert( m_stringIndex < m_column.m_strings.size() );\n                assert( m_pos <= m_end );\n                if( m_pos + m_column.m_width < m_end )\n                    return addIndentAndSuffix(line().substr(m_pos, m_len));\n                else\n                    return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));\n            }\n\n            auto operator ++() -> iterator& {\n                m_pos += m_len;\n                if( m_pos < line().size() && line()[m_pos] == '\\n' )\n                    m_pos += 1;\n                else\n                    while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )\n                        ++m_pos;\n\n                if( m_pos == line().size() ) {\n                    m_pos = 0;\n                    ++m_stringIndex;\n                }\n                if( m_stringIndex < m_column.m_strings.size() )\n                    calcLength();\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return\n                    m_pos == other.m_pos &&\n                    m_stringIndex == other.m_stringIndex &&\n                    &m_column == &other.m_column;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return !operator==( other );\n            }\n        };\n        using const_iterator = iterator;\n\n        explicit Column( std::string const& text ) { m_strings.push_back( text ); }\n\n        auto width( size_t newWidth ) -> Column& {\n            assert( newWidth > 0 );\n            m_width = newWidth;\n            return *this;\n        }\n        auto indent( size_t newIndent ) -> Column& {\n            m_indent = newIndent;\n            return *this;\n        }\n        auto initialIndent( size_t newIndent ) -> Column& {\n            m_initialIndent = newIndent;\n            return *this;\n        }\n\n        auto width() const -> size_t { return m_width; }\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, m_strings.size() }; }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Column const& col ) {\n            bool first = true;\n            for( auto line : col ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os <<  line;\n            }\n            return os;\n        }\n\n        auto operator + ( Column const& other ) -> Columns;\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n\n    class Spacer : public Column {\n\n    public:\n        explicit Spacer( size_t spaceWidth ) : Column( \"\" ) {\n            width( spaceWidth );\n        }\n    };\n\n    class Columns {\n        std::vector<Column> m_columns;\n\n    public:\n\n        class iterator {\n            friend Columns;\n            struct EndTag {};\n\n            std::vector<Column> const& m_columns;\n            std::vector<Column::iterator> m_iterators;\n            size_t m_activeIterators;\n\n            iterator( Columns const& columns, EndTag )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( 0 )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.end() );\n            }\n\n        public:\n            explicit iterator( Columns const& columns )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( m_columns.size() )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.begin() );\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return m_iterators == other.m_iterators;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return m_iterators != other.m_iterators;\n            }\n            auto operator *() const -> std::string {\n                std::string row, padding;\n\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    auto width = m_columns[i].width();\n                    if( m_iterators[i] != m_columns[i].end() ) {\n                        std::string col = *m_iterators[i];\n                        row += padding + col;\n                        if( col.size() < width )\n                            padding = std::string( width - col.size(), ' ' );\n                        else\n                            padding = \"\";\n                    }\n                    else {\n                        padding += std::string( width, ' ' );\n                    }\n                }\n                return row;\n            }\n            auto operator ++() -> iterator& {\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    if (m_iterators[i] != m_columns[i].end())\n                        ++m_iterators[i];\n                }\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n        };\n        using const_iterator = iterator;\n\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, iterator::EndTag() }; }\n\n        auto operator += ( Column const& col ) -> Columns& {\n            m_columns.push_back( col );\n            return *this;\n        }\n        auto operator + ( Column const& col ) -> Columns {\n            Columns combined = *this;\n            combined += col;\n            return combined;\n        }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Columns const& cols ) {\n\n            bool first = true;\n            for( auto line : cols ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os << line;\n            }\n            return os;\n        }\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n\n    inline auto Column::operator + ( Column const& other ) -> Columns {\n        Columns cols;\n        cols += *this;\n        cols += other;\n        return cols;\n    }\n}}} // namespace Catch::clara::TextFlow\n"
    },
    {
        "begin_line": 5264,
        "end_line": 5567,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TextFlow",
        "snippet": "namespace Catch { namespace clara { namespace TextFlow {\n\n    inline auto isWhitespace( char c ) -> bool {\n        static std::string chars = \" \\t\\n\\r\";\n        return chars.find( c ) != std::string::npos;\n    }\n    inline auto isBreakableBefore( char c ) -> bool {\n        static std::string chars = \"[({<|\";\n        return chars.find( c ) != std::string::npos;\n    }\n    inline auto isBreakableAfter( char c ) -> bool {\n        static std::string chars = \"])}>.,:;*+-=&/\\\\\";\n        return chars.find( c ) != std::string::npos;\n    }\n\n    class Columns;\n\n    class Column {\n        std::vector<std::string> m_strings;\n        size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;\n        size_t m_indent = 0;\n        size_t m_initialIndent = std::string::npos;\n\n    public:\n        class iterator {\n            friend Column;\n\n            Column const& m_column;\n            size_t m_stringIndex = 0;\n            size_t m_pos = 0;\n\n            size_t m_len = 0;\n            size_t m_end = 0;\n            bool m_suffix = false;\n\n            iterator( Column const& column, size_t stringIndex )\n            :   m_column( column ),\n                m_stringIndex( stringIndex )\n            {}\n\n            auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }\n\n            auto isBoundary( size_t at ) const -> bool {\n                assert( at > 0 );\n                assert( at <= line().size() );\n\n                return at == line().size() ||\n                       ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||\n                       isBreakableBefore( line()[at] ) ||\n                       isBreakableAfter( line()[at-1] );\n            }\n\n            void calcLength() {\n                assert( m_stringIndex < m_column.m_strings.size() );\n\n                m_suffix = false;\n                auto width = m_column.m_width-indent();\n                m_end = m_pos;\n                while( m_end < line().size() && line()[m_end] != '\\n' )\n                    ++m_end;\n\n                if( m_end < m_pos + width ) {\n                    m_len = m_end - m_pos;\n                }\n                else {\n                    size_t len = width;\n                    while (len > 0 && !isBoundary(m_pos + len))\n                        --len;\n                    while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))\n                        --len;\n\n                    if (len > 0) {\n                        m_len = len;\n                    } else {\n                        m_suffix = true;\n                        m_len = width - 1;\n                    }\n                }\n            }\n\n            auto indent() const -> size_t {\n                auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;\n                return initial == std::string::npos ? m_column.m_indent : initial;\n            }\n\n            auto addIndentAndSuffix(std::string const &plain) const -> std::string {\n                return std::string( indent(), ' ' ) + (m_suffix ? plain + \"-\" : plain);\n            }\n\n        public:\n            explicit iterator( Column const& column ) : m_column( column ) {\n                assert( m_column.m_width > m_column.m_indent );\n                assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );\n                calcLength();\n                if( m_len == 0 )\n                    m_stringIndex++; // Empty string\n            }\n\n            auto operator *() const -> std::string {\n                assert( m_stringIndex < m_column.m_strings.size() );\n                assert( m_pos <= m_end );\n                if( m_pos + m_column.m_width < m_end )\n                    return addIndentAndSuffix(line().substr(m_pos, m_len));\n                else\n                    return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));\n            }\n\n            auto operator ++() -> iterator& {\n                m_pos += m_len;\n                if( m_pos < line().size() && line()[m_pos] == '\\n' )\n                    m_pos += 1;\n                else\n                    while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )\n                        ++m_pos;\n\n                if( m_pos == line().size() ) {\n                    m_pos = 0;\n                    ++m_stringIndex;\n                }\n                if( m_stringIndex < m_column.m_strings.size() )\n                    calcLength();\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return\n                    m_pos == other.m_pos &&\n                    m_stringIndex == other.m_stringIndex &&\n                    &m_column == &other.m_column;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return !operator==( other );\n            }\n        };\n        using const_iterator = iterator;\n\n        explicit Column( std::string const& text ) { m_strings.push_back( text ); }\n\n        auto width( size_t newWidth ) -> Column& {\n            assert( newWidth > 0 );\n            m_width = newWidth;\n            return *this;\n        }\n        auto indent( size_t newIndent ) -> Column& {\n            m_indent = newIndent;\n            return *this;\n        }\n        auto initialIndent( size_t newIndent ) -> Column& {\n            m_initialIndent = newIndent;\n            return *this;\n        }\n\n        auto width() const -> size_t { return m_width; }\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, m_strings.size() }; }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Column const& col ) {\n            bool first = true;\n            for( auto line : col ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os <<  line;\n            }\n            return os;\n        }\n\n        auto operator + ( Column const& other ) -> Columns;\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n\n    class Spacer : public Column {\n\n    public:\n        explicit Spacer( size_t spaceWidth ) : Column( \"\" ) {\n            width( spaceWidth );\n        }\n    };\n\n    class Columns {\n        std::vector<Column> m_columns;\n\n    public:\n\n        class iterator {\n            friend Columns;\n            struct EndTag {};\n\n            std::vector<Column> const& m_columns;\n            std::vector<Column::iterator> m_iterators;\n            size_t m_activeIterators;\n\n            iterator( Columns const& columns, EndTag )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( 0 )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.end() );\n            }\n\n        public:\n            explicit iterator( Columns const& columns )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( m_columns.size() )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.begin() );\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return m_iterators == other.m_iterators;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return m_iterators != other.m_iterators;\n            }\n            auto operator *() const -> std::string {\n                std::string row, padding;\n\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    auto width = m_columns[i].width();\n                    if( m_iterators[i] != m_columns[i].end() ) {\n                        std::string col = *m_iterators[i];\n                        row += padding + col;\n                        if( col.size() < width )\n                            padding = std::string( width - col.size(), ' ' );\n                        else\n                            padding = \"\";\n                    }\n                    else {\n                        padding += std::string( width, ' ' );\n                    }\n                }\n                return row;\n            }\n            auto operator ++() -> iterator& {\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    if (m_iterators[i] != m_columns[i].end())\n                        ++m_iterators[i];\n                }\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n        };\n        using const_iterator = iterator;\n\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, iterator::EndTag() }; }\n\n        auto operator += ( Column const& col ) -> Columns& {\n            m_columns.push_back( col );\n            return *this;\n        }\n        auto operator + ( Column const& col ) -> Columns {\n            Columns combined = *this;\n            combined += col;\n            return combined;\n        }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Columns const& cols ) {\n\n            bool first = true;\n            for( auto line : cols ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os << line;\n            }\n            return os;\n        }\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n\n    inline auto Column::operator + ( Column const& other ) -> Columns {\n        Columns cols;\n        cols += *this;\n        cols += other;\n        return cols;\n    }\n}}} // namespace Catch::clara::TextFlow\n"
    },
    {
        "begin_line": 5266,
        "end_line": 5269,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isWhitespace",
        "snippet": "    inline auto isWhitespace( char c ) -> bool {\n        static std::string chars = \" \\t\\n\\r\";\n        return chars.find( c ) != std::string::npos;\n    }\n"
    },
    {
        "begin_line": 5270,
        "end_line": 5273,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isBreakableBefore",
        "snippet": "    inline auto isBreakableBefore( char c ) -> bool {\n        static std::string chars = \"[({<|\";\n        return chars.find( c ) != std::string::npos;\n    }\n"
    },
    {
        "begin_line": 5274,
        "end_line": 5277,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isBreakableAfter",
        "snippet": "    inline auto isBreakableAfter( char c ) -> bool {\n        static std::string chars = \"])}>.,:;*+-=&/\\\\\";\n        return chars.find( c ) != std::string::npos;\n    }\n"
    },
    {
        "begin_line": 5281,
        "end_line": 5444,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Column",
        "snippet": "    class Column {\n        std::vector<std::string> m_strings;\n        size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;\n        size_t m_indent = 0;\n        size_t m_initialIndent = std::string::npos;\n\n    public:\n        class iterator {\n            friend Column;\n\n            Column const& m_column;\n            size_t m_stringIndex = 0;\n            size_t m_pos = 0;\n\n            size_t m_len = 0;\n            size_t m_end = 0;\n            bool m_suffix = false;\n\n            iterator( Column const& column, size_t stringIndex )\n            :   m_column( column ),\n                m_stringIndex( stringIndex )\n            {}\n\n            auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }\n\n            auto isBoundary( size_t at ) const -> bool {\n                assert( at > 0 );\n                assert( at <= line().size() );\n\n                return at == line().size() ||\n                       ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||\n                       isBreakableBefore( line()[at] ) ||\n                       isBreakableAfter( line()[at-1] );\n            }\n\n            void calcLength() {\n                assert( m_stringIndex < m_column.m_strings.size() );\n\n                m_suffix = false;\n                auto width = m_column.m_width-indent();\n                m_end = m_pos;\n                while( m_end < line().size() && line()[m_end] != '\\n' )\n                    ++m_end;\n\n                if( m_end < m_pos + width ) {\n                    m_len = m_end - m_pos;\n                }\n                else {\n                    size_t len = width;\n                    while (len > 0 && !isBoundary(m_pos + len))\n                        --len;\n                    while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))\n                        --len;\n\n                    if (len > 0) {\n                        m_len = len;\n                    } else {\n                        m_suffix = true;\n                        m_len = width - 1;\n                    }\n                }\n            }\n\n            auto indent() const -> size_t {\n                auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;\n                return initial == std::string::npos ? m_column.m_indent : initial;\n            }\n\n            auto addIndentAndSuffix(std::string const &plain) const -> std::string {\n                return std::string( indent(), ' ' ) + (m_suffix ? plain + \"-\" : plain);\n            }\n\n        public:\n            explicit iterator( Column const& column ) : m_column( column ) {\n                assert( m_column.m_width > m_column.m_indent );\n                assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );\n                calcLength();\n                if( m_len == 0 )\n                    m_stringIndex++; // Empty string\n            }\n\n            auto operator *() const -> std::string {\n                assert( m_stringIndex < m_column.m_strings.size() );\n                assert( m_pos <= m_end );\n                if( m_pos + m_column.m_width < m_end )\n                    return addIndentAndSuffix(line().substr(m_pos, m_len));\n                else\n                    return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));\n            }\n\n            auto operator ++() -> iterator& {\n                m_pos += m_len;\n                if( m_pos < line().size() && line()[m_pos] == '\\n' )\n                    m_pos += 1;\n                else\n                    while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )\n                        ++m_pos;\n\n                if( m_pos == line().size() ) {\n                    m_pos = 0;\n                    ++m_stringIndex;\n                }\n                if( m_stringIndex < m_column.m_strings.size() )\n                    calcLength();\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return\n                    m_pos == other.m_pos &&\n                    m_stringIndex == other.m_stringIndex &&\n                    &m_column == &other.m_column;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return !operator==( other );\n            }\n        };\n        using const_iterator = iterator;\n\n        explicit Column( std::string const& text ) { m_strings.push_back( text ); }\n\n        auto width( size_t newWidth ) -> Column& {\n            assert( newWidth > 0 );\n            m_width = newWidth;\n            return *this;\n        }\n        auto indent( size_t newIndent ) -> Column& {\n            m_indent = newIndent;\n            return *this;\n        }\n        auto initialIndent( size_t newIndent ) -> Column& {\n            m_initialIndent = newIndent;\n            return *this;\n        }\n\n        auto width() const -> size_t { return m_width; }\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, m_strings.size() }; }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Column const& col ) {\n            bool first = true;\n            for( auto line : col ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os <<  line;\n            }\n            return os;\n        }\n\n        auto operator + ( Column const& other ) -> Columns;\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 5282,
        "end_line": 5282,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_strings",
        "snippet": "        std::vector<std::string> m_strings;\n"
    },
    {
        "begin_line": 5283,
        "end_line": 5283,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_width",
        "snippet": "        size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;\n"
    },
    {
        "begin_line": 5284,
        "end_line": 5284,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_indent",
        "snippet": "        size_t m_indent = 0;\n"
    },
    {
        "begin_line": 5285,
        "end_line": 5285,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_initialIndent",
        "snippet": "        size_t m_initialIndent = std::string::npos;\n"
    },
    {
        "begin_line": 5288,
        "end_line": 5402,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "iterator",
        "snippet": "        class iterator {\n            friend Column;\n\n            Column const& m_column;\n            size_t m_stringIndex = 0;\n            size_t m_pos = 0;\n\n            size_t m_len = 0;\n            size_t m_end = 0;\n            bool m_suffix = false;\n\n            iterator( Column const& column, size_t stringIndex )\n            :   m_column( column ),\n                m_stringIndex( stringIndex )\n            {}\n\n            auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }\n\n            auto isBoundary( size_t at ) const -> bool {\n                assert( at > 0 );\n                assert( at <= line().size() );\n\n                return at == line().size() ||\n                       ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||\n                       isBreakableBefore( line()[at] ) ||\n                       isBreakableAfter( line()[at-1] );\n            }\n\n            void calcLength() {\n                assert( m_stringIndex < m_column.m_strings.size() );\n\n                m_suffix = false;\n                auto width = m_column.m_width-indent();\n                m_end = m_pos;\n                while( m_end < line().size() && line()[m_end] != '\\n' )\n                    ++m_end;\n\n                if( m_end < m_pos + width ) {\n                    m_len = m_end - m_pos;\n                }\n                else {\n                    size_t len = width;\n                    while (len > 0 && !isBoundary(m_pos + len))\n                        --len;\n                    while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))\n                        --len;\n\n                    if (len > 0) {\n                        m_len = len;\n                    } else {\n                        m_suffix = true;\n                        m_len = width - 1;\n                    }\n                }\n            }\n\n            auto indent() const -> size_t {\n                auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;\n                return initial == std::string::npos ? m_column.m_indent : initial;\n            }\n\n            auto addIndentAndSuffix(std::string const &plain) const -> std::string {\n                return std::string( indent(), ' ' ) + (m_suffix ? plain + \"-\" : plain);\n            }\n\n        public:\n            explicit iterator( Column const& column ) : m_column( column ) {\n                assert( m_column.m_width > m_column.m_indent );\n                assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );\n                calcLength();\n                if( m_len == 0 )\n                    m_stringIndex++; // Empty string\n            }\n\n            auto operator *() const -> std::string {\n                assert( m_stringIndex < m_column.m_strings.size() );\n                assert( m_pos <= m_end );\n                if( m_pos + m_column.m_width < m_end )\n                    return addIndentAndSuffix(line().substr(m_pos, m_len));\n                else\n                    return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));\n            }\n\n            auto operator ++() -> iterator& {\n                m_pos += m_len;\n                if( m_pos < line().size() && line()[m_pos] == '\\n' )\n                    m_pos += 1;\n                else\n                    while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )\n                        ++m_pos;\n\n                if( m_pos == line().size() ) {\n                    m_pos = 0;\n                    ++m_stringIndex;\n                }\n                if( m_stringIndex < m_column.m_strings.size() )\n                    calcLength();\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return\n                    m_pos == other.m_pos &&\n                    m_stringIndex == other.m_stringIndex &&\n                    &m_column == &other.m_column;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return !operator==( other );\n            }\n        };\n"
    },
    {
        "begin_line": 5291,
        "end_line": 5291,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_column",
        "snippet": "            Column const& m_column;\n"
    },
    {
        "begin_line": 5292,
        "end_line": 5292,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_stringIndex",
        "snippet": "            size_t m_stringIndex = 0;\n"
    },
    {
        "begin_line": 5293,
        "end_line": 5293,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_pos",
        "snippet": "            size_t m_pos = 0;\n"
    },
    {
        "begin_line": 5295,
        "end_line": 5295,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_len",
        "snippet": "            size_t m_len = 0;\n"
    },
    {
        "begin_line": 5296,
        "end_line": 5296,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_end",
        "snippet": "            size_t m_end = 0;\n"
    },
    {
        "begin_line": 5297,
        "end_line": 5297,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_suffix",
        "snippet": "            bool m_suffix = false;\n"
    },
    {
        "begin_line": 5299,
        "end_line": 5302,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "iterator",
        "snippet": "            iterator( Column const& column, size_t stringIndex )\n            :   m_column( column ),\n                m_stringIndex( stringIndex )\n            {}\n"
    },
    {
        "begin_line": 5304,
        "end_line": 5304,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "line",
        "snippet": "            auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }\n"
    },
    {
        "begin_line": 5306,
        "end_line": 5314,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isBoundary",
        "snippet": "            auto isBoundary( size_t at ) const -> bool {\n                assert( at > 0 );\n                assert( at <= line().size() );\n\n                return at == line().size() ||\n                       ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||\n                       isBreakableBefore( line()[at] ) ||\n                       isBreakableAfter( line()[at-1] );\n            }\n"
    },
    {
        "begin_line": 5316,
        "end_line": 5342,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "calcLength",
        "snippet": "            void calcLength() {\n                assert( m_stringIndex < m_column.m_strings.size() );\n\n                m_suffix = false;\n                auto width = m_column.m_width-indent();\n                m_end = m_pos;\n                while( m_end < line().size() && line()[m_end] != '\\n' )\n                    ++m_end;\n\n                if( m_end < m_pos + width ) {\n                    m_len = m_end - m_pos;\n                }\n                else {\n                    size_t len = width;\n                    while (len > 0 && !isBoundary(m_pos + len))\n                        --len;\n                    while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))\n                        --len;\n\n                    if (len > 0) {\n                        m_len = len;\n                    } else {\n                        m_suffix = true;\n                        m_len = width - 1;\n                    }\n                }\n            }\n"
    },
    {
        "begin_line": 5344,
        "end_line": 5347,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "indent",
        "snippet": "            auto indent() const -> size_t {\n                auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;\n                return initial == std::string::npos ? m_column.m_indent : initial;\n            }\n"
    },
    {
        "begin_line": 5349,
        "end_line": 5351,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addIndentAndSuffix",
        "snippet": "            auto addIndentAndSuffix(std::string const &plain) const -> std::string {\n                return std::string( indent(), ' ' ) + (m_suffix ? plain + \"-\" : plain);\n            }\n"
    },
    {
        "begin_line": 5354,
        "end_line": 5360,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "iterator",
        "snippet": "            explicit iterator( Column const& column ) : m_column( column ) {\n                assert( m_column.m_width > m_column.m_indent );\n                assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );\n                calcLength();\n                if( m_len == 0 )\n                    m_stringIndex++; // Empty string\n            }\n"
    },
    {
        "begin_line": 5362,
        "end_line": 5369,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator *",
        "snippet": "            auto operator *() const -> std::string {\n                assert( m_stringIndex < m_column.m_strings.size() );\n                assert( m_pos <= m_end );\n                if( m_pos + m_column.m_width < m_end )\n                    return addIndentAndSuffix(line().substr(m_pos, m_len));\n                else\n                    return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));\n            }\n"
    },
    {
        "begin_line": 5371,
        "end_line": 5386,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ++",
        "snippet": "            auto operator ++() -> iterator& {\n                m_pos += m_len;\n                if( m_pos < line().size() && line()[m_pos] == '\\n' )\n                    m_pos += 1;\n                else\n                    while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )\n                        ++m_pos;\n\n                if( m_pos == line().size() ) {\n                    m_pos = 0;\n                    ++m_stringIndex;\n                }\n                if( m_stringIndex < m_column.m_strings.size() )\n                    calcLength();\n                return *this;\n            }\n"
    },
    {
        "begin_line": 5387,
        "end_line": 5391,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ++",
        "snippet": "            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n"
    },
    {
        "begin_line": 5393,
        "end_line": 5398,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "            auto operator ==( iterator const& other ) const -> bool {\n                return\n                    m_pos == other.m_pos &&\n                    m_stringIndex == other.m_stringIndex &&\n                    &m_column == &other.m_column;\n            }\n"
    },
    {
        "begin_line": 5399,
        "end_line": 5401,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !=",
        "snippet": "            auto operator !=( iterator const& other ) const -> bool {\n                return !operator==( other );\n            }\n"
    },
    {
        "begin_line": 5405,
        "end_line": 5405,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Column",
        "snippet": "        explicit Column( std::string const& text ) { m_strings.push_back( text ); }\n"
    },
    {
        "begin_line": 5407,
        "end_line": 5411,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "width",
        "snippet": "        auto width( size_t newWidth ) -> Column& {\n            assert( newWidth > 0 );\n            m_width = newWidth;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 5412,
        "end_line": 5415,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "indent",
        "snippet": "        auto indent( size_t newIndent ) -> Column& {\n            m_indent = newIndent;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 5416,
        "end_line": 5419,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "initialIndent",
        "snippet": "        auto initialIndent( size_t newIndent ) -> Column& {\n            m_initialIndent = newIndent;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 5421,
        "end_line": 5421,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "width",
        "snippet": "        auto width() const -> size_t { return m_width; }\n"
    },
    {
        "begin_line": 5422,
        "end_line": 5422,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "begin",
        "snippet": "        auto begin() const -> iterator { return iterator( *this ); }\n"
    },
    {
        "begin_line": 5423,
        "end_line": 5423,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "end",
        "snippet": "        auto end() const -> iterator { return { *this, m_strings.size() }; }\n"
    },
    {
        "begin_line": 5425,
        "end_line": 5435,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "        inline friend std::ostream& operator << ( std::ostream& os, Column const& col ) {\n            bool first = true;\n            for( auto line : col ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os <<  line;\n            }\n            return os;\n        }\n"
    },
    {
        "begin_line": 5439,
        "end_line": 5443,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "toString",
        "snippet": "        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n"
    },
    {
        "begin_line": 5446,
        "end_line": 5452,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Spacer",
        "snippet": "    class Spacer : public Column {\n\n    public:\n        explicit Spacer( size_t spaceWidth ) : Column( \"\" ) {\n            width( spaceWidth );\n        }\n    };\n"
    },
    {
        "begin_line": 5449,
        "end_line": 5451,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Spacer",
        "snippet": "        explicit Spacer( size_t spaceWidth ) : Column( \"\" ) {\n            width( spaceWidth );\n        }\n"
    },
    {
        "begin_line": 5454,
        "end_line": 5559,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Columns",
        "snippet": "    class Columns {\n        std::vector<Column> m_columns;\n\n    public:\n\n        class iterator {\n            friend Columns;\n            struct EndTag {};\n\n            std::vector<Column> const& m_columns;\n            std::vector<Column::iterator> m_iterators;\n            size_t m_activeIterators;\n\n            iterator( Columns const& columns, EndTag )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( 0 )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.end() );\n            }\n\n        public:\n            explicit iterator( Columns const& columns )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( m_columns.size() )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.begin() );\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return m_iterators == other.m_iterators;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return m_iterators != other.m_iterators;\n            }\n            auto operator *() const -> std::string {\n                std::string row, padding;\n\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    auto width = m_columns[i].width();\n                    if( m_iterators[i] != m_columns[i].end() ) {\n                        std::string col = *m_iterators[i];\n                        row += padding + col;\n                        if( col.size() < width )\n                            padding = std::string( width - col.size(), ' ' );\n                        else\n                            padding = \"\";\n                    }\n                    else {\n                        padding += std::string( width, ' ' );\n                    }\n                }\n                return row;\n            }\n            auto operator ++() -> iterator& {\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    if (m_iterators[i] != m_columns[i].end())\n                        ++m_iterators[i];\n                }\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n        };\n        using const_iterator = iterator;\n\n        auto begin() const -> iterator { return iterator( *this ); }\n        auto end() const -> iterator { return { *this, iterator::EndTag() }; }\n\n        auto operator += ( Column const& col ) -> Columns& {\n            m_columns.push_back( col );\n            return *this;\n        }\n        auto operator + ( Column const& col ) -> Columns {\n            Columns combined = *this;\n            combined += col;\n            return combined;\n        }\n\n        inline friend std::ostream& operator << ( std::ostream& os, Columns const& cols ) {\n\n            bool first = true;\n            for( auto line : cols ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os << line;\n            }\n            return os;\n        }\n\n        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n    };\n"
    },
    {
        "begin_line": 5455,
        "end_line": 5455,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_columns",
        "snippet": "        std::vector<Column> m_columns;\n"
    },
    {
        "begin_line": 5459,
        "end_line": 5525,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "iterator",
        "snippet": "        class iterator {\n            friend Columns;\n            struct EndTag {};\n\n            std::vector<Column> const& m_columns;\n            std::vector<Column::iterator> m_iterators;\n            size_t m_activeIterators;\n\n            iterator( Columns const& columns, EndTag )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( 0 )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.end() );\n            }\n\n        public:\n            explicit iterator( Columns const& columns )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( m_columns.size() )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.begin() );\n            }\n\n            auto operator ==( iterator const& other ) const -> bool {\n                return m_iterators == other.m_iterators;\n            }\n            auto operator !=( iterator const& other ) const -> bool {\n                return m_iterators != other.m_iterators;\n            }\n            auto operator *() const -> std::string {\n                std::string row, padding;\n\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    auto width = m_columns[i].width();\n                    if( m_iterators[i] != m_columns[i].end() ) {\n                        std::string col = *m_iterators[i];\n                        row += padding + col;\n                        if( col.size() < width )\n                            padding = std::string( width - col.size(), ' ' );\n                        else\n                            padding = \"\";\n                    }\n                    else {\n                        padding += std::string( width, ' ' );\n                    }\n                }\n                return row;\n            }\n            auto operator ++() -> iterator& {\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    if (m_iterators[i] != m_columns[i].end())\n                        ++m_iterators[i];\n                }\n                return *this;\n            }\n            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n        };\n"
    },
    {
        "begin_line": 5461,
        "end_line": 5461,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EndTag",
        "snippet": "            struct EndTag {};\n"
    },
    {
        "begin_line": 5463,
        "end_line": 5463,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_columns",
        "snippet": "            std::vector<Column> const& m_columns;\n"
    },
    {
        "begin_line": 5464,
        "end_line": 5464,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_iterators",
        "snippet": "            std::vector<Column::iterator> m_iterators;\n"
    },
    {
        "begin_line": 5465,
        "end_line": 5465,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_activeIterators",
        "snippet": "            size_t m_activeIterators;\n"
    },
    {
        "begin_line": 5467,
        "end_line": 5475,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "iterator",
        "snippet": "            iterator( Columns const& columns, EndTag )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( 0 )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.end() );\n            }\n"
    },
    {
        "begin_line": 5478,
        "end_line": 5486,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "iterator",
        "snippet": "            explicit iterator( Columns const& columns )\n            :   m_columns( columns.m_columns ),\n                m_activeIterators( m_columns.size() )\n            {\n                m_iterators.reserve( m_columns.size() );\n\n                for( auto const& col : m_columns )\n                    m_iterators.push_back( col.begin() );\n            }\n"
    },
    {
        "begin_line": 5488,
        "end_line": 5490,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "            auto operator ==( iterator const& other ) const -> bool {\n                return m_iterators == other.m_iterators;\n            }\n"
    },
    {
        "begin_line": 5491,
        "end_line": 5493,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !=",
        "snippet": "            auto operator !=( iterator const& other ) const -> bool {\n                return m_iterators != other.m_iterators;\n            }\n"
    },
    {
        "begin_line": 5494,
        "end_line": 5512,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator *",
        "snippet": "            auto operator *() const -> std::string {\n                std::string row, padding;\n\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    auto width = m_columns[i].width();\n                    if( m_iterators[i] != m_columns[i].end() ) {\n                        std::string col = *m_iterators[i];\n                        row += padding + col;\n                        if( col.size() < width )\n                            padding = std::string( width - col.size(), ' ' );\n                        else\n                            padding = \"\";\n                    }\n                    else {\n                        padding += std::string( width, ' ' );\n                    }\n                }\n                return row;\n            }\n"
    },
    {
        "begin_line": 5513,
        "end_line": 5519,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ++",
        "snippet": "            auto operator ++() -> iterator& {\n                for( size_t i = 0; i < m_columns.size(); ++i ) {\n                    if (m_iterators[i] != m_columns[i].end())\n                        ++m_iterators[i];\n                }\n                return *this;\n            }\n"
    },
    {
        "begin_line": 5520,
        "end_line": 5524,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ++",
        "snippet": "            auto operator ++(int) -> iterator {\n                iterator prev( *this );\n                operator++();\n                return prev;\n            }\n"
    },
    {
        "begin_line": 5528,
        "end_line": 5528,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "begin",
        "snippet": "        auto begin() const -> iterator { return iterator( *this ); }\n"
    },
    {
        "begin_line": 5529,
        "end_line": 5529,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "end",
        "snippet": "        auto end() const -> iterator { return { *this, iterator::EndTag() }; }\n"
    },
    {
        "begin_line": 5531,
        "end_line": 5534,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +=",
        "snippet": "        auto operator += ( Column const& col ) -> Columns& {\n            m_columns.push_back( col );\n            return *this;\n        }\n"
    },
    {
        "begin_line": 5535,
        "end_line": 5539,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "        auto operator + ( Column const& col ) -> Columns {\n            Columns combined = *this;\n            combined += col;\n            return combined;\n        }\n"
    },
    {
        "begin_line": 5541,
        "end_line": 5552,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "        inline friend std::ostream& operator << ( std::ostream& os, Columns const& cols ) {\n\n            bool first = true;\n            for( auto line : cols ) {\n                if( first )\n                    first = false;\n                else\n                    os << \"\\n\";\n                os << line;\n            }\n            return os;\n        }\n"
    },
    {
        "begin_line": 5554,
        "end_line": 5558,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "toString",
        "snippet": "        auto toString() const -> std::string {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n"
    },
    {
        "begin_line": 5561,
        "end_line": 5566,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "    inline auto Column::operator + ( Column const& other ) -> Columns {\n        Columns cols;\n        cols += *this;\n        cols += other;\n        return cols;\n    }\n"
    },
    {
        "begin_line": 5577,
        "end_line": 5577,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_PLATFORM_WINDOWS",
        "snippet": "#define CATCH_PLATFORM_WINDOWS\n"
    },
    {
        "begin_line": 5580,
        "end_line": 6454,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch { namespace clara {\nnamespace detail {\n\n    // Traits for extracting arg and return type of lambdas (for single argument lambdas)\n    template<typename L>\n    struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};\n\n    template<typename ClassT, typename ReturnT, typename... Args>\n    struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {\n        static const bool isValid = false;\n    };\n\n    template<typename ClassT, typename ReturnT, typename ArgT>\n    struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {\n        static const bool isValid = true;\n        using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;\n        using ReturnType = ReturnT;\n    };\n\n    class TokenStream;\n\n    // Transport for raw args (copied from main args, or supplied via init list for testing)\n    class Args {\n        friend TokenStream;\n        std::string m_exeName;\n        std::vector<std::string> m_args;\n\n    public:\n        Args( int argc, char const* const* argv )\n            : m_exeName(argv[0]),\n              m_args(argv + 1, argv + argc) {}\n\n        Args( std::initializer_list<std::string> args )\n        :   m_exeName( *args.begin() ),\n            m_args( args.begin()+1, args.end() )\n        {}\n\n        auto exeName() const -> std::string {\n            return m_exeName;\n        }\n    };\n\n    // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string\n    // may encode an option + its argument if the : or = form is used\n    enum class TokenType {\n        Option, Argument\n    };\n    struct Token {\n        TokenType type;\n        std::string token;\n    };\n\n    inline auto isOptPrefix( char c ) -> bool {\n        return c == '-'\n#ifdef CATCH_PLATFORM_WINDOWS\n            || c == '/'\n#endif\n        ;\n    }\n\n    // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled\n    class TokenStream {\n        using Iterator = std::vector<std::string>::const_iterator;\n        Iterator it;\n        Iterator itEnd;\n        std::vector<Token> m_tokenBuffer;\n\n        void loadBuffer() {\n            m_tokenBuffer.resize( 0 );\n\n            // Skip any empty strings\n            while( it != itEnd && it->empty() )\n                ++it;\n\n            if( it != itEnd ) {\n                auto const &next = *it;\n                if( isOptPrefix( next[0] ) ) {\n                    auto delimiterPos = next.find_first_of( \" :=\" );\n                    if( delimiterPos != std::string::npos ) {\n                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );\n                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );\n                    } else {\n                        if( next[1] != '-' && next.size() > 2 ) {\n                            std::string opt = \"- \";\n                            for( size_t i = 1; i < next.size(); ++i ) {\n                                opt[1] = next[i];\n                                m_tokenBuffer.push_back( { TokenType::Option, opt } );\n                            }\n                        } else {\n                            m_tokenBuffer.push_back( { TokenType::Option, next } );\n                        }\n                    }\n                } else {\n                    m_tokenBuffer.push_back( { TokenType::Argument, next } );\n                }\n            }\n        }\n\n    public:\n        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}\n\n        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {\n            loadBuffer();\n        }\n\n        explicit operator bool() const {\n            return !m_tokenBuffer.empty() || it != itEnd;\n        }\n\n        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }\n\n        auto operator*() const -> Token {\n            assert( !m_tokenBuffer.empty() );\n            return m_tokenBuffer.front();\n        }\n\n        auto operator->() const -> Token const * {\n            assert( !m_tokenBuffer.empty() );\n            return &m_tokenBuffer.front();\n        }\n\n        auto operator++() -> TokenStream & {\n            if( m_tokenBuffer.size() >= 2 ) {\n                m_tokenBuffer.erase( m_tokenBuffer.begin() );\n            } else {\n                if( it != itEnd )\n                    ++it;\n                loadBuffer();\n            }\n            return *this;\n        }\n    };\n\n    class ResultBase {\n    public:\n        enum Type {\n            Ok, LogicError, RuntimeError\n        };\n\n    protected:\n        ResultBase( Type type ) : m_type( type ) {}\n        virtual ~ResultBase() = default;\n\n        virtual void enforceOk() const = 0;\n\n        Type m_type;\n    };\n\n    template<typename T>\n    class ResultValueBase : public ResultBase {\n    public:\n        auto value() const -> T const & {\n            enforceOk();\n            return m_value;\n        }\n\n    protected:\n        ResultValueBase( Type type ) : ResultBase( type ) {}\n\n        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n        }\n\n        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {\n            new( &m_value ) T( value );\n        }\n\n        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {\n            if( m_type == ResultBase::Ok )\n                m_value.~T();\n            ResultBase::operator=(other);\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n            return *this;\n        }\n\n        ~ResultValueBase() override {\n            if( m_type == Ok )\n                m_value.~T();\n        }\n\n        union {\n            T m_value;\n        };\n    };\n\n    template<>\n    class ResultValueBase<void> : public ResultBase {\n    protected:\n        using ResultBase::ResultBase;\n    };\n\n    template<typename T = void>\n    class BasicResult : public ResultValueBase<T> {\n    public:\n        template<typename U>\n        explicit BasicResult( BasicResult<U> const &other )\n        :   ResultValueBase<T>( other.type() ),\n            m_errorMessage( other.errorMessage() )\n        {\n            assert( type() != ResultBase::Ok );\n        }\n\n        template<typename U>\n        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }\n        static auto ok() -> BasicResult { return { ResultBase::Ok }; }\n        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }\n        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }\n\n        explicit operator bool() const { return m_type == ResultBase::Ok; }\n        auto type() const -> ResultBase::Type { return m_type; }\n        auto errorMessage() const -> std::string { return m_errorMessage; }\n\n    protected:\n        void enforceOk() const override {\n\n            // Errors shouldn't reach this point, but if they do\n            // the actual error message will be in m_errorMessage\n            assert( m_type != ResultBase::LogicError );\n            assert( m_type != ResultBase::RuntimeError );\n            if( m_type != ResultBase::Ok )\n                std::abort();\n        }\n\n        std::string m_errorMessage; // Only populated if resultType is an error\n\n        BasicResult( ResultBase::Type type, std::string const &message )\n        :   ResultValueBase<T>(type),\n            m_errorMessage(message)\n        {\n            assert( m_type != ResultBase::Ok );\n        }\n\n        using ResultValueBase<T>::ResultValueBase;\n        using ResultBase::m_type;\n    };\n\n    enum class ParseResultType {\n        Matched, NoMatch, ShortCircuitAll, ShortCircuitSame\n    };\n\n    class ParseState {\n    public:\n\n        ParseState( ParseResultType type, TokenStream const &remainingTokens )\n        : m_type(type),\n          m_remainingTokens( remainingTokens )\n        {}\n\n        auto type() const -> ParseResultType { return m_type; }\n        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }\n\n    private:\n        ParseResultType m_type;\n        TokenStream m_remainingTokens;\n    };\n\n    using Result = BasicResult<void>;\n    using ParserResult = BasicResult<ParseResultType>;\n    using InternalParseResult = BasicResult<ParseState>;\n\n    struct HelpColumns {\n        std::string left;\n        std::string right;\n    };\n\n    template<typename T>\n    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {\n        std::stringstream ss;\n        ss << source;\n        ss >> target;\n        if( ss.fail() )\n            return ParserResult::runtimeError( \"Unable to convert '\" + source + \"' to destination type\" );\n        else\n            return ParserResult::ok( ParseResultType::Matched );\n    }\n    inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {\n        target = source;\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n    inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {\n        std::string srcLC = source;\n        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( ::tolower(c) ); } );\n        if (srcLC == \"y\" || srcLC == \"1\" || srcLC == \"true\" || srcLC == \"yes\" || srcLC == \"on\")\n            target = true;\n        else if (srcLC == \"n\" || srcLC == \"0\" || srcLC == \"false\" || srcLC == \"no\" || srcLC == \"off\")\n            target = false;\n        else\n            return ParserResult::runtimeError( \"Expected a boolean value but did not recognise: '\" + source + \"'\" );\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n#ifdef CLARA_CONFIG_OPTIONAL_TYPE\n    template<typename T>\n    inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {\n        T temp;\n        auto result = convertInto( source, temp );\n        if( result )\n            target = std::move(temp);\n        return result;\n    }\n#endif // CLARA_CONFIG_OPTIONAL_TYPE\n\n    struct NonCopyable {\n        NonCopyable() = default;\n        NonCopyable( NonCopyable const & ) = delete;\n        NonCopyable( NonCopyable && ) = delete;\n        NonCopyable &operator=( NonCopyable const & ) = delete;\n        NonCopyable &operator=( NonCopyable && ) = delete;\n    };\n\n    struct BoundRef : NonCopyable {\n        virtual ~BoundRef() = default;\n        virtual auto isContainer() const -> bool { return false; }\n        virtual auto isFlag() const -> bool { return false; }\n    };\n    struct BoundValueRefBase : BoundRef {\n        virtual auto setValue( std::string const &arg ) -> ParserResult = 0;\n    };\n    struct BoundFlagRefBase : BoundRef {\n        virtual auto setFlag( bool flag ) -> ParserResult = 0;\n        virtual auto isFlag() const -> bool { return true; }\n    };\n\n    template<typename T>\n    struct BoundValueRef : BoundValueRefBase {\n        T &m_ref;\n\n        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return convertInto( arg, m_ref );\n        }\n    };\n\n    template<typename T>\n    struct BoundValueRef<std::vector<T>> : BoundValueRefBase {\n        std::vector<T> &m_ref;\n\n        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}\n\n        auto isContainer() const -> bool override { return true; }\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            T temp;\n            auto result = convertInto( arg, temp );\n            if( result )\n                m_ref.push_back( temp );\n            return result;\n        }\n    };\n\n    struct BoundFlagRef : BoundFlagRefBase {\n        bool &m_ref;\n\n        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            m_ref = flag;\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    template<typename ReturnType>\n    struct LambdaInvoker {\n        static_assert( std::is_same<ReturnType, ParserResult>::value, \"Lambda must return void or clara::ParserResult\" );\n\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            return lambda( arg );\n        }\n    };\n\n    template<>\n    struct LambdaInvoker<void> {\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            lambda( arg );\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    template<typename ArgType, typename L>\n    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {\n        ArgType temp{};\n        auto result = convertInto( arg, temp );\n        return !result\n           ? result\n           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );\n    }\n\n    template<typename L>\n    struct BoundLambda : BoundValueRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );\n        }\n    };\n\n    template<typename L>\n    struct BoundFlagLambda : BoundFlagRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, \"flags must be boolean\" );\n\n        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );\n        }\n    };\n\n    enum class Optionality { Optional, Required };\n\n    struct Parser;\n\n    class ParserBase {\n    public:\n        virtual ~ParserBase() = default;\n        virtual auto validate() const -> Result { return Result::ok(); }\n        virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;\n        virtual auto cardinality() const -> size_t { return 1; }\n\n        auto parse( Args const &args ) const -> InternalParseResult {\n            return parse( args.exeName(), TokenStream( args ) );\n        }\n    };\n\n    template<typename DerivedT>\n    class ComposableParserImpl : public ParserBase {\n    public:\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser;\n\n\t\ttemplate<typename T>\n        auto operator+( T const &other ) const -> Parser;\n    };\n\n    // Common code and state for Args and Opts\n    template<typename DerivedT>\n    class ParserRefImpl : public ComposableParserImpl<DerivedT> {\n    protected:\n        Optionality m_optionality = Optionality::Optional;\n        std::shared_ptr<BoundRef> m_ref;\n        std::string m_hint;\n        std::string m_description;\n\n        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}\n\n    public:\n        template<typename T>\n        ParserRefImpl( T &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\n            m_hint( hint )\n        {}\n\n        template<typename LambdaT>\n        ParserRefImpl( LambdaT const &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\n            m_hint(hint)\n        {}\n\n        auto operator()( std::string const &description ) -> DerivedT & {\n            m_description = description;\n            return static_cast<DerivedT &>( *this );\n        }\n\n        auto optional() -> DerivedT & {\n            m_optionality = Optionality::Optional;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto required() -> DerivedT & {\n            m_optionality = Optionality::Required;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto isOptional() const -> bool {\n            return m_optionality == Optionality::Optional;\n        }\n\n        auto cardinality() const -> size_t override {\n            if( m_ref->isContainer() )\n                return 0;\n            else\n                return 1;\n        }\n\n        auto hint() const -> std::string { return m_hint; }\n    };\n\n    class ExeName : public ComposableParserImpl<ExeName> {\n        std::shared_ptr<std::string> m_name;\n        std::shared_ptr<BoundValueRefBase> m_ref;\n\n        template<typename LambdaT>\n        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {\n            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;\n        }\n\n    public:\n        ExeName() : m_name( std::make_shared<std::string>( \"<executable>\" ) ) {}\n\n        explicit ExeName( std::string &ref ) : ExeName() {\n            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );\n        }\n\n        template<typename LambdaT>\n        explicit ExeName( LambdaT const& lambda ) : ExeName() {\n            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );\n        }\n\n        // The exe name is not parsed out of the normal tokens, but is handled specially\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n        }\n\n        auto name() const -> std::string { return *m_name; }\n        auto set( std::string const& newName ) -> ParserResult {\n\n            auto lastSlash = newName.find_last_of( \"\\\\/\" );\n            auto filename = ( lastSlash == std::string::npos )\n                    ? newName\n                    : newName.substr( lastSlash+1 );\n\n            *m_name = filename;\n            if( m_ref )\n                return m_ref->setValue( filename );\n            else\n                return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    class Arg : public ParserRefImpl<Arg> {\n    public:\n        using ParserRefImpl::ParserRefImpl;\n\n        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            auto const &token = *remainingTokens;\n            if( token.type != TokenType::Argument )\n                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n\n            assert( !m_ref->isFlag() );\n            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n\n            auto result = valueRef->setValue( remainingTokens->token );\n            if( !result )\n                return InternalParseResult( result );\n            else\n                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n        }\n    };\n\n    inline auto normaliseOpt( std::string const &optName ) -> std::string {\n#ifdef CATCH_PLATFORM_WINDOWS\n        if( optName[0] == '/' )\n            return \"-\" + optName.substr( 1 );\n        else\n#endif\n            return optName;\n    }\n\n    class Opt : public ParserRefImpl<Opt> {\n    protected:\n        std::vector<std::string> m_optNames;\n\n    public:\n        template<typename LambdaT>\n        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}\n\n        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}\n\n        template<typename LambdaT>\n        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        template<typename T>\n        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        auto operator[]( std::string const &optName ) -> Opt & {\n            m_optNames.push_back( optName );\n            return *this;\n        }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::ostringstream oss;\n            bool first = true;\n            for( auto const &opt : m_optNames ) {\n                if (first)\n                    first = false;\n                else\n                    oss << \", \";\n                oss << opt;\n            }\n            if( !m_hint.empty() )\n                oss << \" <\" << m_hint << \">\";\n            return { { oss.str(), m_description } };\n        }\n\n        auto isMatch( std::string const &optToken ) const -> bool {\n            auto normalisedToken = normaliseOpt( optToken );\n            for( auto const &name : m_optNames ) {\n                if( normaliseOpt( name ) == normalisedToken )\n                    return true;\n            }\n            return false;\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            if( remainingTokens && remainingTokens->type == TokenType::Option ) {\n                auto const &token = *remainingTokens;\n                if( isMatch(token.token ) ) {\n                    if( m_ref->isFlag() ) {\n                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );\n                        auto result = flagRef->setFlag( true );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    } else {\n                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n                        ++remainingTokens;\n                        if( !remainingTokens )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto const &argToken = *remainingTokens;\n                        if( argToken.type != TokenType::Argument )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto result = valueRef->setValue( argToken.token );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    }\n                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n                }\n            }\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n        }\n\n        auto validate() const -> Result override {\n            if( m_optNames.empty() )\n                return Result::logicError( \"No options supplied to Opt\" );\n            for( auto const &name : m_optNames ) {\n                if( name.empty() )\n                    return Result::logicError( \"Option name cannot be empty\" );\n#ifdef CATCH_PLATFORM_WINDOWS\n                if( name[0] != '-' && name[0] != '/' )\n                    return Result::logicError( \"Option name must begin with '-' or '/'\" );\n#else\n                if( name[0] != '-' )\n                    return Result::logicError( \"Option name must begin with '-'\" );\n#endif\n            }\n            return ParserRefImpl::validate();\n        }\n    };\n\n    struct Help : Opt {\n        Help( bool &showHelpFlag )\n        :   Opt([&]( bool flag ) {\n                showHelpFlag = flag;\n                return ParserResult::ok( ParseResultType::ShortCircuitAll );\n            })\n        {\n            static_cast<Opt &>( *this )\n                    (\"display usage information\")\n                    [\"-?\"][\"-h\"][\"--help\"]\n                    .optional();\n        }\n    };\n\n    struct Parser : ParserBase {\n\n        mutable ExeName m_exeName;\n        std::vector<Opt> m_options;\n        std::vector<Arg> m_args;\n\n        auto operator|=( ExeName const &exeName ) -> Parser & {\n            m_exeName = exeName;\n            return *this;\n        }\n\n        auto operator|=( Arg const &arg ) -> Parser & {\n            m_args.push_back(arg);\n            return *this;\n        }\n\n        auto operator|=( Opt const &opt ) -> Parser & {\n            m_options.push_back(opt);\n            return *this;\n        }\n\n        auto operator|=( Parser const &other ) -> Parser & {\n            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());\n            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());\n            return *this;\n        }\n\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser {\n            return Parser( *this ) |= other;\n        }\n\n        // Forward deprecated interface with '+' instead of '|'\n        template<typename T>\n        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }\n        template<typename T>\n        auto operator+( T const &other ) const -> Parser { return operator|( other ); }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::vector<HelpColumns> cols;\n            for (auto const &o : m_options) {\n                auto childCols = o.getHelpColumns();\n                cols.insert( cols.end(), childCols.begin(), childCols.end() );\n            }\n            return cols;\n        }\n\n        void writeToStream( std::ostream &os ) const {\n            if (!m_exeName.name().empty()) {\n                os << \"usage:\\n\" << \"  \" << m_exeName.name() << \" \";\n                bool required = true, first = true;\n                for( auto const &arg : m_args ) {\n                    if (first)\n                        first = false;\n                    else\n                        os << \" \";\n                    if( arg.isOptional() && required ) {\n                        os << \"[\";\n                        required = false;\n                    }\n                    os << \"<\" << arg.hint() << \">\";\n                    if( arg.cardinality() == 0 )\n                        os << \" ... \";\n                }\n                if( !required )\n                    os << \"]\";\n                if( !m_options.empty() )\n                    os << \" options\";\n                os << \"\\n\\nwhere options are:\" << std::endl;\n            }\n\n            auto rows = getHelpColumns();\n            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;\n            size_t optWidth = 0;\n            for( auto const &cols : rows )\n                optWidth = (std::max)(optWidth, cols.left.size() + 2);\n\n            optWidth = (std::min)(optWidth, consoleWidth/2);\n\n            for( auto const &cols : rows ) {\n                auto row =\n                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +\n                        TextFlow::Spacer(4) +\n                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );\n                os << row << std::endl;\n            }\n        }\n\n        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {\n            parser.writeToStream( os );\n            return os;\n        }\n\n        auto validate() const -> Result override {\n            for( auto const &opt : m_options ) {\n                auto result = opt.validate();\n                if( !result )\n                    return result;\n            }\n            for( auto const &arg : m_args ) {\n                auto result = arg.validate();\n                if( !result )\n                    return result;\n            }\n            return Result::ok();\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {\n\n            struct ParserInfo {\n                ParserBase const* parser = nullptr;\n                size_t count = 0;\n            };\n            const size_t totalParsers = m_options.size() + m_args.size();\n            assert( totalParsers < 512 );\n            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do\n            ParserInfo parseInfos[512];\n\n            {\n                size_t i = 0;\n                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;\n                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;\n            }\n\n            m_exeName.set( exeName );\n\n            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n            while( result.value().remainingTokens() ) {\n                bool tokenParsed = false;\n\n                for( size_t i = 0; i < totalParsers; ++i ) {\n                    auto&  parseInfo = parseInfos[i];\n                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {\n                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());\n                        if (!result)\n                            return result;\n                        if (result.value().type() != ParseResultType::NoMatch) {\n                            tokenParsed = true;\n                            ++parseInfo.count;\n                            break;\n                        }\n                    }\n                }\n\n                if( result.value().type() == ParseResultType::ShortCircuitAll )\n                    return result;\n                if( !tokenParsed )\n                    return InternalParseResult::runtimeError( \"Unrecognised token: \" + result.value().remainingTokens()->token );\n            }\n            // !TBD Check missing required options\n            return result;\n        }\n    };\n\n    template<typename DerivedT>\n    template<typename T>\n    auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {\n        return Parser() | static_cast<DerivedT const &>( *this ) | other;\n    }\n} // namespace detail\n\n// A Combined parser\nusing detail::Parser;\n\n// A parser for options\nusing detail::Opt;\n\n// A parser for arguments\nusing detail::Arg;\n\n// Wrapper for argc, argv from main()\nusing detail::Args;\n\n// Specifies the name of the executable\nusing detail::ExeName;\n\n// Convenience wrapper for option parser that specifies the help option\nusing detail::Help;\n\n// enum of result types from a parse\nusing detail::ParseResultType;\n\n// Result type for parser operation\nusing detail::ParserResult;\n\n}} // namespace Catch::clara\n"
    },
    {
        "begin_line": 5580,
        "end_line": 6454,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "clara",
        "snippet": "namespace Catch { namespace clara {\nnamespace detail {\n\n    // Traits for extracting arg and return type of lambdas (for single argument lambdas)\n    template<typename L>\n    struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};\n\n    template<typename ClassT, typename ReturnT, typename... Args>\n    struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {\n        static const bool isValid = false;\n    };\n\n    template<typename ClassT, typename ReturnT, typename ArgT>\n    struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {\n        static const bool isValid = true;\n        using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;\n        using ReturnType = ReturnT;\n    };\n\n    class TokenStream;\n\n    // Transport for raw args (copied from main args, or supplied via init list for testing)\n    class Args {\n        friend TokenStream;\n        std::string m_exeName;\n        std::vector<std::string> m_args;\n\n    public:\n        Args( int argc, char const* const* argv )\n            : m_exeName(argv[0]),\n              m_args(argv + 1, argv + argc) {}\n\n        Args( std::initializer_list<std::string> args )\n        :   m_exeName( *args.begin() ),\n            m_args( args.begin()+1, args.end() )\n        {}\n\n        auto exeName() const -> std::string {\n            return m_exeName;\n        }\n    };\n\n    // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string\n    // may encode an option + its argument if the : or = form is used\n    enum class TokenType {\n        Option, Argument\n    };\n    struct Token {\n        TokenType type;\n        std::string token;\n    };\n\n    inline auto isOptPrefix( char c ) -> bool {\n        return c == '-'\n#ifdef CATCH_PLATFORM_WINDOWS\n            || c == '/'\n#endif\n        ;\n    }\n\n    // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled\n    class TokenStream {\n        using Iterator = std::vector<std::string>::const_iterator;\n        Iterator it;\n        Iterator itEnd;\n        std::vector<Token> m_tokenBuffer;\n\n        void loadBuffer() {\n            m_tokenBuffer.resize( 0 );\n\n            // Skip any empty strings\n            while( it != itEnd && it->empty() )\n                ++it;\n\n            if( it != itEnd ) {\n                auto const &next = *it;\n                if( isOptPrefix( next[0] ) ) {\n                    auto delimiterPos = next.find_first_of( \" :=\" );\n                    if( delimiterPos != std::string::npos ) {\n                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );\n                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );\n                    } else {\n                        if( next[1] != '-' && next.size() > 2 ) {\n                            std::string opt = \"- \";\n                            for( size_t i = 1; i < next.size(); ++i ) {\n                                opt[1] = next[i];\n                                m_tokenBuffer.push_back( { TokenType::Option, opt } );\n                            }\n                        } else {\n                            m_tokenBuffer.push_back( { TokenType::Option, next } );\n                        }\n                    }\n                } else {\n                    m_tokenBuffer.push_back( { TokenType::Argument, next } );\n                }\n            }\n        }\n\n    public:\n        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}\n\n        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {\n            loadBuffer();\n        }\n\n        explicit operator bool() const {\n            return !m_tokenBuffer.empty() || it != itEnd;\n        }\n\n        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }\n\n        auto operator*() const -> Token {\n            assert( !m_tokenBuffer.empty() );\n            return m_tokenBuffer.front();\n        }\n\n        auto operator->() const -> Token const * {\n            assert( !m_tokenBuffer.empty() );\n            return &m_tokenBuffer.front();\n        }\n\n        auto operator++() -> TokenStream & {\n            if( m_tokenBuffer.size() >= 2 ) {\n                m_tokenBuffer.erase( m_tokenBuffer.begin() );\n            } else {\n                if( it != itEnd )\n                    ++it;\n                loadBuffer();\n            }\n            return *this;\n        }\n    };\n\n    class ResultBase {\n    public:\n        enum Type {\n            Ok, LogicError, RuntimeError\n        };\n\n    protected:\n        ResultBase( Type type ) : m_type( type ) {}\n        virtual ~ResultBase() = default;\n\n        virtual void enforceOk() const = 0;\n\n        Type m_type;\n    };\n\n    template<typename T>\n    class ResultValueBase : public ResultBase {\n    public:\n        auto value() const -> T const & {\n            enforceOk();\n            return m_value;\n        }\n\n    protected:\n        ResultValueBase( Type type ) : ResultBase( type ) {}\n\n        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n        }\n\n        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {\n            new( &m_value ) T( value );\n        }\n\n        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {\n            if( m_type == ResultBase::Ok )\n                m_value.~T();\n            ResultBase::operator=(other);\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n            return *this;\n        }\n\n        ~ResultValueBase() override {\n            if( m_type == Ok )\n                m_value.~T();\n        }\n\n        union {\n            T m_value;\n        };\n    };\n\n    template<>\n    class ResultValueBase<void> : public ResultBase {\n    protected:\n        using ResultBase::ResultBase;\n    };\n\n    template<typename T = void>\n    class BasicResult : public ResultValueBase<T> {\n    public:\n        template<typename U>\n        explicit BasicResult( BasicResult<U> const &other )\n        :   ResultValueBase<T>( other.type() ),\n            m_errorMessage( other.errorMessage() )\n        {\n            assert( type() != ResultBase::Ok );\n        }\n\n        template<typename U>\n        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }\n        static auto ok() -> BasicResult { return { ResultBase::Ok }; }\n        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }\n        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }\n\n        explicit operator bool() const { return m_type == ResultBase::Ok; }\n        auto type() const -> ResultBase::Type { return m_type; }\n        auto errorMessage() const -> std::string { return m_errorMessage; }\n\n    protected:\n        void enforceOk() const override {\n\n            // Errors shouldn't reach this point, but if they do\n            // the actual error message will be in m_errorMessage\n            assert( m_type != ResultBase::LogicError );\n            assert( m_type != ResultBase::RuntimeError );\n            if( m_type != ResultBase::Ok )\n                std::abort();\n        }\n\n        std::string m_errorMessage; // Only populated if resultType is an error\n\n        BasicResult( ResultBase::Type type, std::string const &message )\n        :   ResultValueBase<T>(type),\n            m_errorMessage(message)\n        {\n            assert( m_type != ResultBase::Ok );\n        }\n\n        using ResultValueBase<T>::ResultValueBase;\n        using ResultBase::m_type;\n    };\n\n    enum class ParseResultType {\n        Matched, NoMatch, ShortCircuitAll, ShortCircuitSame\n    };\n\n    class ParseState {\n    public:\n\n        ParseState( ParseResultType type, TokenStream const &remainingTokens )\n        : m_type(type),\n          m_remainingTokens( remainingTokens )\n        {}\n\n        auto type() const -> ParseResultType { return m_type; }\n        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }\n\n    private:\n        ParseResultType m_type;\n        TokenStream m_remainingTokens;\n    };\n\n    using Result = BasicResult<void>;\n    using ParserResult = BasicResult<ParseResultType>;\n    using InternalParseResult = BasicResult<ParseState>;\n\n    struct HelpColumns {\n        std::string left;\n        std::string right;\n    };\n\n    template<typename T>\n    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {\n        std::stringstream ss;\n        ss << source;\n        ss >> target;\n        if( ss.fail() )\n            return ParserResult::runtimeError( \"Unable to convert '\" + source + \"' to destination type\" );\n        else\n            return ParserResult::ok( ParseResultType::Matched );\n    }\n    inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {\n        target = source;\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n    inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {\n        std::string srcLC = source;\n        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( ::tolower(c) ); } );\n        if (srcLC == \"y\" || srcLC == \"1\" || srcLC == \"true\" || srcLC == \"yes\" || srcLC == \"on\")\n            target = true;\n        else if (srcLC == \"n\" || srcLC == \"0\" || srcLC == \"false\" || srcLC == \"no\" || srcLC == \"off\")\n            target = false;\n        else\n            return ParserResult::runtimeError( \"Expected a boolean value but did not recognise: '\" + source + \"'\" );\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n#ifdef CLARA_CONFIG_OPTIONAL_TYPE\n    template<typename T>\n    inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {\n        T temp;\n        auto result = convertInto( source, temp );\n        if( result )\n            target = std::move(temp);\n        return result;\n    }\n#endif // CLARA_CONFIG_OPTIONAL_TYPE\n\n    struct NonCopyable {\n        NonCopyable() = default;\n        NonCopyable( NonCopyable const & ) = delete;\n        NonCopyable( NonCopyable && ) = delete;\n        NonCopyable &operator=( NonCopyable const & ) = delete;\n        NonCopyable &operator=( NonCopyable && ) = delete;\n    };\n\n    struct BoundRef : NonCopyable {\n        virtual ~BoundRef() = default;\n        virtual auto isContainer() const -> bool { return false; }\n        virtual auto isFlag() const -> bool { return false; }\n    };\n    struct BoundValueRefBase : BoundRef {\n        virtual auto setValue( std::string const &arg ) -> ParserResult = 0;\n    };\n    struct BoundFlagRefBase : BoundRef {\n        virtual auto setFlag( bool flag ) -> ParserResult = 0;\n        virtual auto isFlag() const -> bool { return true; }\n    };\n\n    template<typename T>\n    struct BoundValueRef : BoundValueRefBase {\n        T &m_ref;\n\n        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return convertInto( arg, m_ref );\n        }\n    };\n\n    template<typename T>\n    struct BoundValueRef<std::vector<T>> : BoundValueRefBase {\n        std::vector<T> &m_ref;\n\n        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}\n\n        auto isContainer() const -> bool override { return true; }\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            T temp;\n            auto result = convertInto( arg, temp );\n            if( result )\n                m_ref.push_back( temp );\n            return result;\n        }\n    };\n\n    struct BoundFlagRef : BoundFlagRefBase {\n        bool &m_ref;\n\n        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            m_ref = flag;\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    template<typename ReturnType>\n    struct LambdaInvoker {\n        static_assert( std::is_same<ReturnType, ParserResult>::value, \"Lambda must return void or clara::ParserResult\" );\n\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            return lambda( arg );\n        }\n    };\n\n    template<>\n    struct LambdaInvoker<void> {\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            lambda( arg );\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    template<typename ArgType, typename L>\n    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {\n        ArgType temp{};\n        auto result = convertInto( arg, temp );\n        return !result\n           ? result\n           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );\n    }\n\n    template<typename L>\n    struct BoundLambda : BoundValueRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );\n        }\n    };\n\n    template<typename L>\n    struct BoundFlagLambda : BoundFlagRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, \"flags must be boolean\" );\n\n        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );\n        }\n    };\n\n    enum class Optionality { Optional, Required };\n\n    struct Parser;\n\n    class ParserBase {\n    public:\n        virtual ~ParserBase() = default;\n        virtual auto validate() const -> Result { return Result::ok(); }\n        virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;\n        virtual auto cardinality() const -> size_t { return 1; }\n\n        auto parse( Args const &args ) const -> InternalParseResult {\n            return parse( args.exeName(), TokenStream( args ) );\n        }\n    };\n\n    template<typename DerivedT>\n    class ComposableParserImpl : public ParserBase {\n    public:\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser;\n\n\t\ttemplate<typename T>\n        auto operator+( T const &other ) const -> Parser;\n    };\n\n    // Common code and state for Args and Opts\n    template<typename DerivedT>\n    class ParserRefImpl : public ComposableParserImpl<DerivedT> {\n    protected:\n        Optionality m_optionality = Optionality::Optional;\n        std::shared_ptr<BoundRef> m_ref;\n        std::string m_hint;\n        std::string m_description;\n\n        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}\n\n    public:\n        template<typename T>\n        ParserRefImpl( T &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\n            m_hint( hint )\n        {}\n\n        template<typename LambdaT>\n        ParserRefImpl( LambdaT const &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\n            m_hint(hint)\n        {}\n\n        auto operator()( std::string const &description ) -> DerivedT & {\n            m_description = description;\n            return static_cast<DerivedT &>( *this );\n        }\n\n        auto optional() -> DerivedT & {\n            m_optionality = Optionality::Optional;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto required() -> DerivedT & {\n            m_optionality = Optionality::Required;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto isOptional() const -> bool {\n            return m_optionality == Optionality::Optional;\n        }\n\n        auto cardinality() const -> size_t override {\n            if( m_ref->isContainer() )\n                return 0;\n            else\n                return 1;\n        }\n\n        auto hint() const -> std::string { return m_hint; }\n    };\n\n    class ExeName : public ComposableParserImpl<ExeName> {\n        std::shared_ptr<std::string> m_name;\n        std::shared_ptr<BoundValueRefBase> m_ref;\n\n        template<typename LambdaT>\n        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {\n            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;\n        }\n\n    public:\n        ExeName() : m_name( std::make_shared<std::string>( \"<executable>\" ) ) {}\n\n        explicit ExeName( std::string &ref ) : ExeName() {\n            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );\n        }\n\n        template<typename LambdaT>\n        explicit ExeName( LambdaT const& lambda ) : ExeName() {\n            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );\n        }\n\n        // The exe name is not parsed out of the normal tokens, but is handled specially\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n        }\n\n        auto name() const -> std::string { return *m_name; }\n        auto set( std::string const& newName ) -> ParserResult {\n\n            auto lastSlash = newName.find_last_of( \"\\\\/\" );\n            auto filename = ( lastSlash == std::string::npos )\n                    ? newName\n                    : newName.substr( lastSlash+1 );\n\n            *m_name = filename;\n            if( m_ref )\n                return m_ref->setValue( filename );\n            else\n                return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    class Arg : public ParserRefImpl<Arg> {\n    public:\n        using ParserRefImpl::ParserRefImpl;\n\n        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            auto const &token = *remainingTokens;\n            if( token.type != TokenType::Argument )\n                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n\n            assert( !m_ref->isFlag() );\n            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n\n            auto result = valueRef->setValue( remainingTokens->token );\n            if( !result )\n                return InternalParseResult( result );\n            else\n                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n        }\n    };\n\n    inline auto normaliseOpt( std::string const &optName ) -> std::string {\n#ifdef CATCH_PLATFORM_WINDOWS\n        if( optName[0] == '/' )\n            return \"-\" + optName.substr( 1 );\n        else\n#endif\n            return optName;\n    }\n\n    class Opt : public ParserRefImpl<Opt> {\n    protected:\n        std::vector<std::string> m_optNames;\n\n    public:\n        template<typename LambdaT>\n        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}\n\n        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}\n\n        template<typename LambdaT>\n        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        template<typename T>\n        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        auto operator[]( std::string const &optName ) -> Opt & {\n            m_optNames.push_back( optName );\n            return *this;\n        }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::ostringstream oss;\n            bool first = true;\n            for( auto const &opt : m_optNames ) {\n                if (first)\n                    first = false;\n                else\n                    oss << \", \";\n                oss << opt;\n            }\n            if( !m_hint.empty() )\n                oss << \" <\" << m_hint << \">\";\n            return { { oss.str(), m_description } };\n        }\n\n        auto isMatch( std::string const &optToken ) const -> bool {\n            auto normalisedToken = normaliseOpt( optToken );\n            for( auto const &name : m_optNames ) {\n                if( normaliseOpt( name ) == normalisedToken )\n                    return true;\n            }\n            return false;\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            if( remainingTokens && remainingTokens->type == TokenType::Option ) {\n                auto const &token = *remainingTokens;\n                if( isMatch(token.token ) ) {\n                    if( m_ref->isFlag() ) {\n                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );\n                        auto result = flagRef->setFlag( true );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    } else {\n                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n                        ++remainingTokens;\n                        if( !remainingTokens )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto const &argToken = *remainingTokens;\n                        if( argToken.type != TokenType::Argument )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto result = valueRef->setValue( argToken.token );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    }\n                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n                }\n            }\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n        }\n\n        auto validate() const -> Result override {\n            if( m_optNames.empty() )\n                return Result::logicError( \"No options supplied to Opt\" );\n            for( auto const &name : m_optNames ) {\n                if( name.empty() )\n                    return Result::logicError( \"Option name cannot be empty\" );\n#ifdef CATCH_PLATFORM_WINDOWS\n                if( name[0] != '-' && name[0] != '/' )\n                    return Result::logicError( \"Option name must begin with '-' or '/'\" );\n#else\n                if( name[0] != '-' )\n                    return Result::logicError( \"Option name must begin with '-'\" );\n#endif\n            }\n            return ParserRefImpl::validate();\n        }\n    };\n\n    struct Help : Opt {\n        Help( bool &showHelpFlag )\n        :   Opt([&]( bool flag ) {\n                showHelpFlag = flag;\n                return ParserResult::ok( ParseResultType::ShortCircuitAll );\n            })\n        {\n            static_cast<Opt &>( *this )\n                    (\"display usage information\")\n                    [\"-?\"][\"-h\"][\"--help\"]\n                    .optional();\n        }\n    };\n\n    struct Parser : ParserBase {\n\n        mutable ExeName m_exeName;\n        std::vector<Opt> m_options;\n        std::vector<Arg> m_args;\n\n        auto operator|=( ExeName const &exeName ) -> Parser & {\n            m_exeName = exeName;\n            return *this;\n        }\n\n        auto operator|=( Arg const &arg ) -> Parser & {\n            m_args.push_back(arg);\n            return *this;\n        }\n\n        auto operator|=( Opt const &opt ) -> Parser & {\n            m_options.push_back(opt);\n            return *this;\n        }\n\n        auto operator|=( Parser const &other ) -> Parser & {\n            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());\n            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());\n            return *this;\n        }\n\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser {\n            return Parser( *this ) |= other;\n        }\n\n        // Forward deprecated interface with '+' instead of '|'\n        template<typename T>\n        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }\n        template<typename T>\n        auto operator+( T const &other ) const -> Parser { return operator|( other ); }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::vector<HelpColumns> cols;\n            for (auto const &o : m_options) {\n                auto childCols = o.getHelpColumns();\n                cols.insert( cols.end(), childCols.begin(), childCols.end() );\n            }\n            return cols;\n        }\n\n        void writeToStream( std::ostream &os ) const {\n            if (!m_exeName.name().empty()) {\n                os << \"usage:\\n\" << \"  \" << m_exeName.name() << \" \";\n                bool required = true, first = true;\n                for( auto const &arg : m_args ) {\n                    if (first)\n                        first = false;\n                    else\n                        os << \" \";\n                    if( arg.isOptional() && required ) {\n                        os << \"[\";\n                        required = false;\n                    }\n                    os << \"<\" << arg.hint() << \">\";\n                    if( arg.cardinality() == 0 )\n                        os << \" ... \";\n                }\n                if( !required )\n                    os << \"]\";\n                if( !m_options.empty() )\n                    os << \" options\";\n                os << \"\\n\\nwhere options are:\" << std::endl;\n            }\n\n            auto rows = getHelpColumns();\n            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;\n            size_t optWidth = 0;\n            for( auto const &cols : rows )\n                optWidth = (std::max)(optWidth, cols.left.size() + 2);\n\n            optWidth = (std::min)(optWidth, consoleWidth/2);\n\n            for( auto const &cols : rows ) {\n                auto row =\n                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +\n                        TextFlow::Spacer(4) +\n                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );\n                os << row << std::endl;\n            }\n        }\n\n        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {\n            parser.writeToStream( os );\n            return os;\n        }\n\n        auto validate() const -> Result override {\n            for( auto const &opt : m_options ) {\n                auto result = opt.validate();\n                if( !result )\n                    return result;\n            }\n            for( auto const &arg : m_args ) {\n                auto result = arg.validate();\n                if( !result )\n                    return result;\n            }\n            return Result::ok();\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {\n\n            struct ParserInfo {\n                ParserBase const* parser = nullptr;\n                size_t count = 0;\n            };\n            const size_t totalParsers = m_options.size() + m_args.size();\n            assert( totalParsers < 512 );\n            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do\n            ParserInfo parseInfos[512];\n\n            {\n                size_t i = 0;\n                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;\n                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;\n            }\n\n            m_exeName.set( exeName );\n\n            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n            while( result.value().remainingTokens() ) {\n                bool tokenParsed = false;\n\n                for( size_t i = 0; i < totalParsers; ++i ) {\n                    auto&  parseInfo = parseInfos[i];\n                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {\n                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());\n                        if (!result)\n                            return result;\n                        if (result.value().type() != ParseResultType::NoMatch) {\n                            tokenParsed = true;\n                            ++parseInfo.count;\n                            break;\n                        }\n                    }\n                }\n\n                if( result.value().type() == ParseResultType::ShortCircuitAll )\n                    return result;\n                if( !tokenParsed )\n                    return InternalParseResult::runtimeError( \"Unrecognised token: \" + result.value().remainingTokens()->token );\n            }\n            // !TBD Check missing required options\n            return result;\n        }\n    };\n\n    template<typename DerivedT>\n    template<typename T>\n    auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {\n        return Parser() | static_cast<DerivedT const &>( *this ) | other;\n    }\n} // namespace detail\n\n// A Combined parser\nusing detail::Parser;\n\n// A parser for options\nusing detail::Opt;\n\n// A parser for arguments\nusing detail::Arg;\n\n// Wrapper for argc, argv from main()\nusing detail::Args;\n\n// Specifies the name of the executable\nusing detail::ExeName;\n\n// Convenience wrapper for option parser that specifies the help option\nusing detail::Help;\n\n// enum of result types from a parse\nusing detail::ParseResultType;\n\n// Result type for parser operation\nusing detail::ParserResult;\n\n}} // namespace Catch::clara\n"
    },
    {
        "begin_line": 5581,
        "end_line": 6428,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "detail",
        "snippet": "namespace detail {\n\n    // Traits for extracting arg and return type of lambdas (for single argument lambdas)\n    template<typename L>\n    struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};\n\n    template<typename ClassT, typename ReturnT, typename... Args>\n    struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {\n        static const bool isValid = false;\n    };\n\n    template<typename ClassT, typename ReturnT, typename ArgT>\n    struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {\n        static const bool isValid = true;\n        using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;\n        using ReturnType = ReturnT;\n    };\n\n    class TokenStream;\n\n    // Transport for raw args (copied from main args, or supplied via init list for testing)\n    class Args {\n        friend TokenStream;\n        std::string m_exeName;\n        std::vector<std::string> m_args;\n\n    public:\n        Args( int argc, char const* const* argv )\n            : m_exeName(argv[0]),\n              m_args(argv + 1, argv + argc) {}\n\n        Args( std::initializer_list<std::string> args )\n        :   m_exeName( *args.begin() ),\n            m_args( args.begin()+1, args.end() )\n        {}\n\n        auto exeName() const -> std::string {\n            return m_exeName;\n        }\n    };\n\n    // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string\n    // may encode an option + its argument if the : or = form is used\n    enum class TokenType {\n        Option, Argument\n    };\n    struct Token {\n        TokenType type;\n        std::string token;\n    };\n\n    inline auto isOptPrefix( char c ) -> bool {\n        return c == '-'\n#ifdef CATCH_PLATFORM_WINDOWS\n            || c == '/'\n#endif\n        ;\n    }\n\n    // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled\n    class TokenStream {\n        using Iterator = std::vector<std::string>::const_iterator;\n        Iterator it;\n        Iterator itEnd;\n        std::vector<Token> m_tokenBuffer;\n\n        void loadBuffer() {\n            m_tokenBuffer.resize( 0 );\n\n            // Skip any empty strings\n            while( it != itEnd && it->empty() )\n                ++it;\n\n            if( it != itEnd ) {\n                auto const &next = *it;\n                if( isOptPrefix( next[0] ) ) {\n                    auto delimiterPos = next.find_first_of( \" :=\" );\n                    if( delimiterPos != std::string::npos ) {\n                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );\n                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );\n                    } else {\n                        if( next[1] != '-' && next.size() > 2 ) {\n                            std::string opt = \"- \";\n                            for( size_t i = 1; i < next.size(); ++i ) {\n                                opt[1] = next[i];\n                                m_tokenBuffer.push_back( { TokenType::Option, opt } );\n                            }\n                        } else {\n                            m_tokenBuffer.push_back( { TokenType::Option, next } );\n                        }\n                    }\n                } else {\n                    m_tokenBuffer.push_back( { TokenType::Argument, next } );\n                }\n            }\n        }\n\n    public:\n        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}\n\n        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {\n            loadBuffer();\n        }\n\n        explicit operator bool() const {\n            return !m_tokenBuffer.empty() || it != itEnd;\n        }\n\n        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }\n\n        auto operator*() const -> Token {\n            assert( !m_tokenBuffer.empty() );\n            return m_tokenBuffer.front();\n        }\n\n        auto operator->() const -> Token const * {\n            assert( !m_tokenBuffer.empty() );\n            return &m_tokenBuffer.front();\n        }\n\n        auto operator++() -> TokenStream & {\n            if( m_tokenBuffer.size() >= 2 ) {\n                m_tokenBuffer.erase( m_tokenBuffer.begin() );\n            } else {\n                if( it != itEnd )\n                    ++it;\n                loadBuffer();\n            }\n            return *this;\n        }\n    };\n\n    class ResultBase {\n    public:\n        enum Type {\n            Ok, LogicError, RuntimeError\n        };\n\n    protected:\n        ResultBase( Type type ) : m_type( type ) {}\n        virtual ~ResultBase() = default;\n\n        virtual void enforceOk() const = 0;\n\n        Type m_type;\n    };\n\n    template<typename T>\n    class ResultValueBase : public ResultBase {\n    public:\n        auto value() const -> T const & {\n            enforceOk();\n            return m_value;\n        }\n\n    protected:\n        ResultValueBase( Type type ) : ResultBase( type ) {}\n\n        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n        }\n\n        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {\n            new( &m_value ) T( value );\n        }\n\n        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {\n            if( m_type == ResultBase::Ok )\n                m_value.~T();\n            ResultBase::operator=(other);\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n            return *this;\n        }\n\n        ~ResultValueBase() override {\n            if( m_type == Ok )\n                m_value.~T();\n        }\n\n        union {\n            T m_value;\n        };\n    };\n\n    template<>\n    class ResultValueBase<void> : public ResultBase {\n    protected:\n        using ResultBase::ResultBase;\n    };\n\n    template<typename T = void>\n    class BasicResult : public ResultValueBase<T> {\n    public:\n        template<typename U>\n        explicit BasicResult( BasicResult<U> const &other )\n        :   ResultValueBase<T>( other.type() ),\n            m_errorMessage( other.errorMessage() )\n        {\n            assert( type() != ResultBase::Ok );\n        }\n\n        template<typename U>\n        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }\n        static auto ok() -> BasicResult { return { ResultBase::Ok }; }\n        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }\n        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }\n\n        explicit operator bool() const { return m_type == ResultBase::Ok; }\n        auto type() const -> ResultBase::Type { return m_type; }\n        auto errorMessage() const -> std::string { return m_errorMessage; }\n\n    protected:\n        void enforceOk() const override {\n\n            // Errors shouldn't reach this point, but if they do\n            // the actual error message will be in m_errorMessage\n            assert( m_type != ResultBase::LogicError );\n            assert( m_type != ResultBase::RuntimeError );\n            if( m_type != ResultBase::Ok )\n                std::abort();\n        }\n\n        std::string m_errorMessage; // Only populated if resultType is an error\n\n        BasicResult( ResultBase::Type type, std::string const &message )\n        :   ResultValueBase<T>(type),\n            m_errorMessage(message)\n        {\n            assert( m_type != ResultBase::Ok );\n        }\n\n        using ResultValueBase<T>::ResultValueBase;\n        using ResultBase::m_type;\n    };\n\n    enum class ParseResultType {\n        Matched, NoMatch, ShortCircuitAll, ShortCircuitSame\n    };\n\n    class ParseState {\n    public:\n\n        ParseState( ParseResultType type, TokenStream const &remainingTokens )\n        : m_type(type),\n          m_remainingTokens( remainingTokens )\n        {}\n\n        auto type() const -> ParseResultType { return m_type; }\n        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }\n\n    private:\n        ParseResultType m_type;\n        TokenStream m_remainingTokens;\n    };\n\n    using Result = BasicResult<void>;\n    using ParserResult = BasicResult<ParseResultType>;\n    using InternalParseResult = BasicResult<ParseState>;\n\n    struct HelpColumns {\n        std::string left;\n        std::string right;\n    };\n\n    template<typename T>\n    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {\n        std::stringstream ss;\n        ss << source;\n        ss >> target;\n        if( ss.fail() )\n            return ParserResult::runtimeError( \"Unable to convert '\" + source + \"' to destination type\" );\n        else\n            return ParserResult::ok( ParseResultType::Matched );\n    }\n    inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {\n        target = source;\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n    inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {\n        std::string srcLC = source;\n        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( ::tolower(c) ); } );\n        if (srcLC == \"y\" || srcLC == \"1\" || srcLC == \"true\" || srcLC == \"yes\" || srcLC == \"on\")\n            target = true;\n        else if (srcLC == \"n\" || srcLC == \"0\" || srcLC == \"false\" || srcLC == \"no\" || srcLC == \"off\")\n            target = false;\n        else\n            return ParserResult::runtimeError( \"Expected a boolean value but did not recognise: '\" + source + \"'\" );\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n#ifdef CLARA_CONFIG_OPTIONAL_TYPE\n    template<typename T>\n    inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {\n        T temp;\n        auto result = convertInto( source, temp );\n        if( result )\n            target = std::move(temp);\n        return result;\n    }\n#endif // CLARA_CONFIG_OPTIONAL_TYPE\n\n    struct NonCopyable {\n        NonCopyable() = default;\n        NonCopyable( NonCopyable const & ) = delete;\n        NonCopyable( NonCopyable && ) = delete;\n        NonCopyable &operator=( NonCopyable const & ) = delete;\n        NonCopyable &operator=( NonCopyable && ) = delete;\n    };\n\n    struct BoundRef : NonCopyable {\n        virtual ~BoundRef() = default;\n        virtual auto isContainer() const -> bool { return false; }\n        virtual auto isFlag() const -> bool { return false; }\n    };\n    struct BoundValueRefBase : BoundRef {\n        virtual auto setValue( std::string const &arg ) -> ParserResult = 0;\n    };\n    struct BoundFlagRefBase : BoundRef {\n        virtual auto setFlag( bool flag ) -> ParserResult = 0;\n        virtual auto isFlag() const -> bool { return true; }\n    };\n\n    template<typename T>\n    struct BoundValueRef : BoundValueRefBase {\n        T &m_ref;\n\n        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return convertInto( arg, m_ref );\n        }\n    };\n\n    template<typename T>\n    struct BoundValueRef<std::vector<T>> : BoundValueRefBase {\n        std::vector<T> &m_ref;\n\n        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}\n\n        auto isContainer() const -> bool override { return true; }\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            T temp;\n            auto result = convertInto( arg, temp );\n            if( result )\n                m_ref.push_back( temp );\n            return result;\n        }\n    };\n\n    struct BoundFlagRef : BoundFlagRefBase {\n        bool &m_ref;\n\n        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            m_ref = flag;\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    template<typename ReturnType>\n    struct LambdaInvoker {\n        static_assert( std::is_same<ReturnType, ParserResult>::value, \"Lambda must return void or clara::ParserResult\" );\n\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            return lambda( arg );\n        }\n    };\n\n    template<>\n    struct LambdaInvoker<void> {\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            lambda( arg );\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    template<typename ArgType, typename L>\n    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {\n        ArgType temp{};\n        auto result = convertInto( arg, temp );\n        return !result\n           ? result\n           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );\n    }\n\n    template<typename L>\n    struct BoundLambda : BoundValueRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );\n        }\n    };\n\n    template<typename L>\n    struct BoundFlagLambda : BoundFlagRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, \"flags must be boolean\" );\n\n        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );\n        }\n    };\n\n    enum class Optionality { Optional, Required };\n\n    struct Parser;\n\n    class ParserBase {\n    public:\n        virtual ~ParserBase() = default;\n        virtual auto validate() const -> Result { return Result::ok(); }\n        virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;\n        virtual auto cardinality() const -> size_t { return 1; }\n\n        auto parse( Args const &args ) const -> InternalParseResult {\n            return parse( args.exeName(), TokenStream( args ) );\n        }\n    };\n\n    template<typename DerivedT>\n    class ComposableParserImpl : public ParserBase {\n    public:\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser;\n\n\t\ttemplate<typename T>\n        auto operator+( T const &other ) const -> Parser;\n    };\n\n    // Common code and state for Args and Opts\n    template<typename DerivedT>\n    class ParserRefImpl : public ComposableParserImpl<DerivedT> {\n    protected:\n        Optionality m_optionality = Optionality::Optional;\n        std::shared_ptr<BoundRef> m_ref;\n        std::string m_hint;\n        std::string m_description;\n\n        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}\n\n    public:\n        template<typename T>\n        ParserRefImpl( T &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\n            m_hint( hint )\n        {}\n\n        template<typename LambdaT>\n        ParserRefImpl( LambdaT const &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\n            m_hint(hint)\n        {}\n\n        auto operator()( std::string const &description ) -> DerivedT & {\n            m_description = description;\n            return static_cast<DerivedT &>( *this );\n        }\n\n        auto optional() -> DerivedT & {\n            m_optionality = Optionality::Optional;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto required() -> DerivedT & {\n            m_optionality = Optionality::Required;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto isOptional() const -> bool {\n            return m_optionality == Optionality::Optional;\n        }\n\n        auto cardinality() const -> size_t override {\n            if( m_ref->isContainer() )\n                return 0;\n            else\n                return 1;\n        }\n\n        auto hint() const -> std::string { return m_hint; }\n    };\n\n    class ExeName : public ComposableParserImpl<ExeName> {\n        std::shared_ptr<std::string> m_name;\n        std::shared_ptr<BoundValueRefBase> m_ref;\n\n        template<typename LambdaT>\n        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {\n            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;\n        }\n\n    public:\n        ExeName() : m_name( std::make_shared<std::string>( \"<executable>\" ) ) {}\n\n        explicit ExeName( std::string &ref ) : ExeName() {\n            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );\n        }\n\n        template<typename LambdaT>\n        explicit ExeName( LambdaT const& lambda ) : ExeName() {\n            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );\n        }\n\n        // The exe name is not parsed out of the normal tokens, but is handled specially\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n        }\n\n        auto name() const -> std::string { return *m_name; }\n        auto set( std::string const& newName ) -> ParserResult {\n\n            auto lastSlash = newName.find_last_of( \"\\\\/\" );\n            auto filename = ( lastSlash == std::string::npos )\n                    ? newName\n                    : newName.substr( lastSlash+1 );\n\n            *m_name = filename;\n            if( m_ref )\n                return m_ref->setValue( filename );\n            else\n                return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n\n    class Arg : public ParserRefImpl<Arg> {\n    public:\n        using ParserRefImpl::ParserRefImpl;\n\n        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            auto const &token = *remainingTokens;\n            if( token.type != TokenType::Argument )\n                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n\n            assert( !m_ref->isFlag() );\n            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n\n            auto result = valueRef->setValue( remainingTokens->token );\n            if( !result )\n                return InternalParseResult( result );\n            else\n                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n        }\n    };\n\n    inline auto normaliseOpt( std::string const &optName ) -> std::string {\n#ifdef CATCH_PLATFORM_WINDOWS\n        if( optName[0] == '/' )\n            return \"-\" + optName.substr( 1 );\n        else\n#endif\n            return optName;\n    }\n\n    class Opt : public ParserRefImpl<Opt> {\n    protected:\n        std::vector<std::string> m_optNames;\n\n    public:\n        template<typename LambdaT>\n        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}\n\n        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}\n\n        template<typename LambdaT>\n        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        template<typename T>\n        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        auto operator[]( std::string const &optName ) -> Opt & {\n            m_optNames.push_back( optName );\n            return *this;\n        }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::ostringstream oss;\n            bool first = true;\n            for( auto const &opt : m_optNames ) {\n                if (first)\n                    first = false;\n                else\n                    oss << \", \";\n                oss << opt;\n            }\n            if( !m_hint.empty() )\n                oss << \" <\" << m_hint << \">\";\n            return { { oss.str(), m_description } };\n        }\n\n        auto isMatch( std::string const &optToken ) const -> bool {\n            auto normalisedToken = normaliseOpt( optToken );\n            for( auto const &name : m_optNames ) {\n                if( normaliseOpt( name ) == normalisedToken )\n                    return true;\n            }\n            return false;\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            if( remainingTokens && remainingTokens->type == TokenType::Option ) {\n                auto const &token = *remainingTokens;\n                if( isMatch(token.token ) ) {\n                    if( m_ref->isFlag() ) {\n                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );\n                        auto result = flagRef->setFlag( true );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    } else {\n                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n                        ++remainingTokens;\n                        if( !remainingTokens )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto const &argToken = *remainingTokens;\n                        if( argToken.type != TokenType::Argument )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto result = valueRef->setValue( argToken.token );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    }\n                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n                }\n            }\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n        }\n\n        auto validate() const -> Result override {\n            if( m_optNames.empty() )\n                return Result::logicError( \"No options supplied to Opt\" );\n            for( auto const &name : m_optNames ) {\n                if( name.empty() )\n                    return Result::logicError( \"Option name cannot be empty\" );\n#ifdef CATCH_PLATFORM_WINDOWS\n                if( name[0] != '-' && name[0] != '/' )\n                    return Result::logicError( \"Option name must begin with '-' or '/'\" );\n#else\n                if( name[0] != '-' )\n                    return Result::logicError( \"Option name must begin with '-'\" );\n#endif\n            }\n            return ParserRefImpl::validate();\n        }\n    };\n\n    struct Help : Opt {\n        Help( bool &showHelpFlag )\n        :   Opt([&]( bool flag ) {\n                showHelpFlag = flag;\n                return ParserResult::ok( ParseResultType::ShortCircuitAll );\n            })\n        {\n            static_cast<Opt &>( *this )\n                    (\"display usage information\")\n                    [\"-?\"][\"-h\"][\"--help\"]\n                    .optional();\n        }\n    };\n\n    struct Parser : ParserBase {\n\n        mutable ExeName m_exeName;\n        std::vector<Opt> m_options;\n        std::vector<Arg> m_args;\n\n        auto operator|=( ExeName const &exeName ) -> Parser & {\n            m_exeName = exeName;\n            return *this;\n        }\n\n        auto operator|=( Arg const &arg ) -> Parser & {\n            m_args.push_back(arg);\n            return *this;\n        }\n\n        auto operator|=( Opt const &opt ) -> Parser & {\n            m_options.push_back(opt);\n            return *this;\n        }\n\n        auto operator|=( Parser const &other ) -> Parser & {\n            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());\n            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());\n            return *this;\n        }\n\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser {\n            return Parser( *this ) |= other;\n        }\n\n        // Forward deprecated interface with '+' instead of '|'\n        template<typename T>\n        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }\n        template<typename T>\n        auto operator+( T const &other ) const -> Parser { return operator|( other ); }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::vector<HelpColumns> cols;\n            for (auto const &o : m_options) {\n                auto childCols = o.getHelpColumns();\n                cols.insert( cols.end(), childCols.begin(), childCols.end() );\n            }\n            return cols;\n        }\n\n        void writeToStream( std::ostream &os ) const {\n            if (!m_exeName.name().empty()) {\n                os << \"usage:\\n\" << \"  \" << m_exeName.name() << \" \";\n                bool required = true, first = true;\n                for( auto const &arg : m_args ) {\n                    if (first)\n                        first = false;\n                    else\n                        os << \" \";\n                    if( arg.isOptional() && required ) {\n                        os << \"[\";\n                        required = false;\n                    }\n                    os << \"<\" << arg.hint() << \">\";\n                    if( arg.cardinality() == 0 )\n                        os << \" ... \";\n                }\n                if( !required )\n                    os << \"]\";\n                if( !m_options.empty() )\n                    os << \" options\";\n                os << \"\\n\\nwhere options are:\" << std::endl;\n            }\n\n            auto rows = getHelpColumns();\n            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;\n            size_t optWidth = 0;\n            for( auto const &cols : rows )\n                optWidth = (std::max)(optWidth, cols.left.size() + 2);\n\n            optWidth = (std::min)(optWidth, consoleWidth/2);\n\n            for( auto const &cols : rows ) {\n                auto row =\n                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +\n                        TextFlow::Spacer(4) +\n                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );\n                os << row << std::endl;\n            }\n        }\n\n        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {\n            parser.writeToStream( os );\n            return os;\n        }\n\n        auto validate() const -> Result override {\n            for( auto const &opt : m_options ) {\n                auto result = opt.validate();\n                if( !result )\n                    return result;\n            }\n            for( auto const &arg : m_args ) {\n                auto result = arg.validate();\n                if( !result )\n                    return result;\n            }\n            return Result::ok();\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {\n\n            struct ParserInfo {\n                ParserBase const* parser = nullptr;\n                size_t count = 0;\n            };\n            const size_t totalParsers = m_options.size() + m_args.size();\n            assert( totalParsers < 512 );\n            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do\n            ParserInfo parseInfos[512];\n\n            {\n                size_t i = 0;\n                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;\n                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;\n            }\n\n            m_exeName.set( exeName );\n\n            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n            while( result.value().remainingTokens() ) {\n                bool tokenParsed = false;\n\n                for( size_t i = 0; i < totalParsers; ++i ) {\n                    auto&  parseInfo = parseInfos[i];\n                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {\n                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());\n                        if (!result)\n                            return result;\n                        if (result.value().type() != ParseResultType::NoMatch) {\n                            tokenParsed = true;\n                            ++parseInfo.count;\n                            break;\n                        }\n                    }\n                }\n\n                if( result.value().type() == ParseResultType::ShortCircuitAll )\n                    return result;\n                if( !tokenParsed )\n                    return InternalParseResult::runtimeError( \"Unrecognised token: \" + result.value().remainingTokens()->token );\n            }\n            // !TBD Check missing required options\n            return result;\n        }\n    };\n\n    template<typename DerivedT>\n    template<typename T>\n    auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {\n        return Parser() | static_cast<DerivedT const &>( *this ) | other;\n    }\n} // namespace detail\n"
    },
    {
        "begin_line": 5585,
        "end_line": 5585,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnaryLambdaTraits",
        "snippet": "    struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};\n"
    },
    {
        "begin_line": 5588,
        "end_line": 5590,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnaryLambdaTraits",
        "snippet": "    struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {\n        static const bool isValid = false;\n    };\n"
    },
    {
        "begin_line": 5589,
        "end_line": 5589,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isValid",
        "snippet": "        static const bool isValid = false;\n"
    },
    {
        "begin_line": 5593,
        "end_line": 5597,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "UnaryLambdaTraits",
        "snippet": "    struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {\n        static const bool isValid = true;\n        using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;\n        using ReturnType = ReturnT;\n    };\n"
    },
    {
        "begin_line": 5594,
        "end_line": 5594,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isValid",
        "snippet": "        static const bool isValid = true;\n"
    },
    {
        "begin_line": 5602,
        "end_line": 5620,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Args",
        "snippet": "    class Args {\n        friend TokenStream;\n        std::string m_exeName;\n        std::vector<std::string> m_args;\n\n    public:\n        Args( int argc, char const* const* argv )\n            : m_exeName(argv[0]),\n              m_args(argv + 1, argv + argc) {}\n\n        Args( std::initializer_list<std::string> args )\n        :   m_exeName( *args.begin() ),\n            m_args( args.begin()+1, args.end() )\n        {}\n\n        auto exeName() const -> std::string {\n            return m_exeName;\n        }\n    };\n"
    },
    {
        "begin_line": 5604,
        "end_line": 5604,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_exeName",
        "snippet": "        std::string m_exeName;\n"
    },
    {
        "begin_line": 5605,
        "end_line": 5605,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_args",
        "snippet": "        std::vector<std::string> m_args;\n"
    },
    {
        "begin_line": 5608,
        "end_line": 5610,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Args",
        "snippet": "        Args( int argc, char const* const* argv )\n            : m_exeName(argv[0]),\n              m_args(argv + 1, argv + argc) {}\n"
    },
    {
        "begin_line": 5612,
        "end_line": 5615,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Args",
        "snippet": "        Args( std::initializer_list<std::string> args )\n        :   m_exeName( *args.begin() ),\n            m_args( args.begin()+1, args.end() )\n        {}\n"
    },
    {
        "begin_line": 5617,
        "end_line": 5619,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "exeName",
        "snippet": "        auto exeName() const -> std::string {\n            return m_exeName;\n        }\n"
    },
    {
        "begin_line": 5624,
        "end_line": 5626,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TokenType",
        "snippet": "    enum class TokenType {\n        Option, Argument\n    };\n"
    },
    {
        "begin_line": 5627,
        "end_line": 5630,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Token",
        "snippet": "    struct Token {\n        TokenType type;\n        std::string token;\n    };\n"
    },
    {
        "begin_line": 5628,
        "end_line": 5628,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "type",
        "snippet": "        TokenType type;\n"
    },
    {
        "begin_line": 5629,
        "end_line": 5629,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "token",
        "snippet": "        std::string token;\n"
    },
    {
        "begin_line": 5632,
        "end_line": 5638,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isOptPrefix",
        "snippet": "    inline auto isOptPrefix( char c ) -> bool {\n        return c == '-'\n#ifdef CATCH_PLATFORM_WINDOWS\n            || c == '/'\n#endif\n        ;\n    }\n"
    },
    {
        "begin_line": 5641,
        "end_line": 5711,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TokenStream",
        "snippet": "    class TokenStream {\n        using Iterator = std::vector<std::string>::const_iterator;\n        Iterator it;\n        Iterator itEnd;\n        std::vector<Token> m_tokenBuffer;\n\n        void loadBuffer() {\n            m_tokenBuffer.resize( 0 );\n\n            // Skip any empty strings\n            while( it != itEnd && it->empty() )\n                ++it;\n\n            if( it != itEnd ) {\n                auto const &next = *it;\n                if( isOptPrefix( next[0] ) ) {\n                    auto delimiterPos = next.find_first_of( \" :=\" );\n                    if( delimiterPos != std::string::npos ) {\n                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );\n                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );\n                    } else {\n                        if( next[1] != '-' && next.size() > 2 ) {\n                            std::string opt = \"- \";\n                            for( size_t i = 1; i < next.size(); ++i ) {\n                                opt[1] = next[i];\n                                m_tokenBuffer.push_back( { TokenType::Option, opt } );\n                            }\n                        } else {\n                            m_tokenBuffer.push_back( { TokenType::Option, next } );\n                        }\n                    }\n                } else {\n                    m_tokenBuffer.push_back( { TokenType::Argument, next } );\n                }\n            }\n        }\n\n    public:\n        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}\n\n        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {\n            loadBuffer();\n        }\n\n        explicit operator bool() const {\n            return !m_tokenBuffer.empty() || it != itEnd;\n        }\n\n        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }\n\n        auto operator*() const -> Token {\n            assert( !m_tokenBuffer.empty() );\n            return m_tokenBuffer.front();\n        }\n\n        auto operator->() const -> Token const * {\n            assert( !m_tokenBuffer.empty() );\n            return &m_tokenBuffer.front();\n        }\n\n        auto operator++() -> TokenStream & {\n            if( m_tokenBuffer.size() >= 2 ) {\n                m_tokenBuffer.erase( m_tokenBuffer.begin() );\n            } else {\n                if( it != itEnd )\n                    ++it;\n                loadBuffer();\n            }\n            return *this;\n        }\n    };\n"
    },
    {
        "begin_line": 5643,
        "end_line": 5643,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "it",
        "snippet": "        Iterator it;\n"
    },
    {
        "begin_line": 5644,
        "end_line": 5644,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "itEnd",
        "snippet": "        Iterator itEnd;\n"
    },
    {
        "begin_line": 5645,
        "end_line": 5645,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_tokenBuffer",
        "snippet": "        std::vector<Token> m_tokenBuffer;\n"
    },
    {
        "begin_line": 5647,
        "end_line": 5676,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "loadBuffer",
        "snippet": "        void loadBuffer() {\n            m_tokenBuffer.resize( 0 );\n\n            // Skip any empty strings\n            while( it != itEnd && it->empty() )\n                ++it;\n\n            if( it != itEnd ) {\n                auto const &next = *it;\n                if( isOptPrefix( next[0] ) ) {\n                    auto delimiterPos = next.find_first_of( \" :=\" );\n                    if( delimiterPos != std::string::npos ) {\n                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );\n                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );\n                    } else {\n                        if( next[1] != '-' && next.size() > 2 ) {\n                            std::string opt = \"- \";\n                            for( size_t i = 1; i < next.size(); ++i ) {\n                                opt[1] = next[i];\n                                m_tokenBuffer.push_back( { TokenType::Option, opt } );\n                            }\n                        } else {\n                            m_tokenBuffer.push_back( { TokenType::Option, next } );\n                        }\n                    }\n                } else {\n                    m_tokenBuffer.push_back( { TokenType::Argument, next } );\n                }\n            }\n        }\n"
    },
    {
        "begin_line": 5679,
        "end_line": 5679,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TokenStream",
        "snippet": "        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}\n"
    },
    {
        "begin_line": 5681,
        "end_line": 5683,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TokenStream",
        "snippet": "        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {\n            loadBuffer();\n        }\n"
    },
    {
        "begin_line": 5685,
        "end_line": 5687,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator bool",
        "snippet": "        explicit operator bool() const {\n            return !m_tokenBuffer.empty() || it != itEnd;\n        }\n"
    },
    {
        "begin_line": 5689,
        "end_line": 5689,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "count",
        "snippet": "        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }\n"
    },
    {
        "begin_line": 5691,
        "end_line": 5694,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator *",
        "snippet": "        auto operator*() const -> Token {\n            assert( !m_tokenBuffer.empty() );\n            return m_tokenBuffer.front();\n        }\n"
    },
    {
        "begin_line": 5696,
        "end_line": 5699,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ->",
        "snippet": "        auto operator->() const -> Token const * {\n            assert( !m_tokenBuffer.empty() );\n            return &m_tokenBuffer.front();\n        }\n"
    },
    {
        "begin_line": 5701,
        "end_line": 5710,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ++",
        "snippet": "        auto operator++() -> TokenStream & {\n            if( m_tokenBuffer.size() >= 2 ) {\n                m_tokenBuffer.erase( m_tokenBuffer.begin() );\n            } else {\n                if( it != itEnd )\n                    ++it;\n                loadBuffer();\n            }\n            return *this;\n        }\n"
    },
    {
        "begin_line": 5713,
        "end_line": 5726,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultBase",
        "snippet": "    class ResultBase {\n    public:\n        enum Type {\n            Ok, LogicError, RuntimeError\n        };\n\n    protected:\n        ResultBase( Type type ) : m_type( type ) {}\n        virtual ~ResultBase() = default;\n\n        virtual void enforceOk() const = 0;\n\n        Type m_type;\n    };\n"
    },
    {
        "begin_line": 5715,
        "end_line": 5717,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Type",
        "snippet": "        enum Type {\n            Ok, LogicError, RuntimeError\n        };\n"
    },
    {
        "begin_line": 5720,
        "end_line": 5720,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultBase",
        "snippet": "        ResultBase( Type type ) : m_type( type ) {}\n"
    },
    {
        "begin_line": 5725,
        "end_line": 5725,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_type",
        "snippet": "        Type m_type;\n"
    },
    {
        "begin_line": 5729,
        "end_line": 5765,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultValueBase",
        "snippet": "    class ResultValueBase : public ResultBase {\n    public:\n        auto value() const -> T const & {\n            enforceOk();\n            return m_value;\n        }\n\n    protected:\n        ResultValueBase( Type type ) : ResultBase( type ) {}\n\n        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n        }\n\n        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {\n            new( &m_value ) T( value );\n        }\n\n        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {\n            if( m_type == ResultBase::Ok )\n                m_value.~T();\n            ResultBase::operator=(other);\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n            return *this;\n        }\n\n        ~ResultValueBase() override {\n            if( m_type == Ok )\n                m_value.~T();\n        }\n\n        union {\n            T m_value;\n        };\n    };\n"
    },
    {
        "begin_line": 5731,
        "end_line": 5734,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "value",
        "snippet": "        auto value() const -> T const & {\n            enforceOk();\n            return m_value;\n        }\n"
    },
    {
        "begin_line": 5737,
        "end_line": 5737,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultValueBase",
        "snippet": "        ResultValueBase( Type type ) : ResultBase( type ) {}\n"
    },
    {
        "begin_line": 5739,
        "end_line": 5742,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultValueBase",
        "snippet": "        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n        }\n"
    },
    {
        "begin_line": 5744,
        "end_line": 5746,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultValueBase",
        "snippet": "        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {\n            new( &m_value ) T( value );\n        }\n"
    },
    {
        "begin_line": 5748,
        "end_line": 5755,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator =",
        "snippet": "        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {\n            if( m_type == ResultBase::Ok )\n                m_value.~T();\n            ResultBase::operator=(other);\n            if( m_type == ResultBase::Ok )\n                new( &m_value ) T( other.m_value );\n            return *this;\n        }\n"
    },
    {
        "begin_line": 5757,
        "end_line": 5760,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~ResultValueBase",
        "snippet": "        ~ResultValueBase() override {\n            if( m_type == Ok )\n                m_value.~T();\n        }\n"
    },
    {
        "begin_line": 5762,
        "end_line": 5764,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b020a",
        "snippet": "        union {\n            T m_value;\n        };\n"
    },
    {
        "begin_line": 5763,
        "end_line": 5763,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_value",
        "snippet": "            T m_value;\n"
    },
    {
        "begin_line": 5768,
        "end_line": 5771,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ResultValueBase",
        "snippet": "    class ResultValueBase<void> : public ResultBase {\n    protected:\n        using ResultBase::ResultBase;\n    };\n"
    },
    {
        "begin_line": 5774,
        "end_line": 5816,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BasicResult",
        "snippet": "    class BasicResult : public ResultValueBase<T> {\n    public:\n        template<typename U>\n        explicit BasicResult( BasicResult<U> const &other )\n        :   ResultValueBase<T>( other.type() ),\n            m_errorMessage( other.errorMessage() )\n        {\n            assert( type() != ResultBase::Ok );\n        }\n\n        template<typename U>\n        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }\n        static auto ok() -> BasicResult { return { ResultBase::Ok }; }\n        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }\n        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }\n\n        explicit operator bool() const { return m_type == ResultBase::Ok; }\n        auto type() const -> ResultBase::Type { return m_type; }\n        auto errorMessage() const -> std::string { return m_errorMessage; }\n\n    protected:\n        void enforceOk() const override {\n\n            // Errors shouldn't reach this point, but if they do\n            // the actual error message will be in m_errorMessage\n            assert( m_type != ResultBase::LogicError );\n            assert( m_type != ResultBase::RuntimeError );\n            if( m_type != ResultBase::Ok )\n                std::abort();\n        }\n\n        std::string m_errorMessage; // Only populated if resultType is an error\n\n        BasicResult( ResultBase::Type type, std::string const &message )\n        :   ResultValueBase<T>(type),\n            m_errorMessage(message)\n        {\n            assert( m_type != ResultBase::Ok );\n        }\n\n        using ResultValueBase<T>::ResultValueBase;\n        using ResultBase::m_type;\n    };\n"
    },
    {
        "begin_line": 5777,
        "end_line": 5782,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BasicResult",
        "snippet": "        explicit BasicResult( BasicResult<U> const &other )\n        :   ResultValueBase<T>( other.type() ),\n            m_errorMessage( other.errorMessage() )\n        {\n            assert( type() != ResultBase::Ok );\n        }\n"
    },
    {
        "begin_line": 5785,
        "end_line": 5785,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ok",
        "snippet": "        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }\n"
    },
    {
        "begin_line": 5786,
        "end_line": 5786,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ok",
        "snippet": "        static auto ok() -> BasicResult { return { ResultBase::Ok }; }\n"
    },
    {
        "begin_line": 5787,
        "end_line": 5787,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "logicError",
        "snippet": "        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }\n"
    },
    {
        "begin_line": 5788,
        "end_line": 5788,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runtimeError",
        "snippet": "        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }\n"
    },
    {
        "begin_line": 5790,
        "end_line": 5790,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator bool",
        "snippet": "        explicit operator bool() const { return m_type == ResultBase::Ok; }\n"
    },
    {
        "begin_line": 5791,
        "end_line": 5791,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "type",
        "snippet": "        auto type() const -> ResultBase::Type { return m_type; }\n"
    },
    {
        "begin_line": 5792,
        "end_line": 5792,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "errorMessage",
        "snippet": "        auto errorMessage() const -> std::string { return m_errorMessage; }\n"
    },
    {
        "begin_line": 5795,
        "end_line": 5803,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "enforceOk",
        "snippet": "        void enforceOk() const override {\n\n            // Errors shouldn't reach this point, but if they do\n            // the actual error message will be in m_errorMessage\n            assert( m_type != ResultBase::LogicError );\n            assert( m_type != ResultBase::RuntimeError );\n            if( m_type != ResultBase::Ok )\n                std::abort();\n        }\n"
    },
    {
        "begin_line": 5805,
        "end_line": 5805,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_errorMessage",
        "snippet": "        std::string m_errorMessage; // Only populated if resultType is an error\n"
    },
    {
        "begin_line": 5807,
        "end_line": 5812,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BasicResult",
        "snippet": "        BasicResult( ResultBase::Type type, std::string const &message )\n        :   ResultValueBase<T>(type),\n            m_errorMessage(message)\n        {\n            assert( m_type != ResultBase::Ok );\n        }\n"
    },
    {
        "begin_line": 5818,
        "end_line": 5820,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParseResultType",
        "snippet": "    enum class ParseResultType {\n        Matched, NoMatch, ShortCircuitAll, ShortCircuitSame\n    };\n"
    },
    {
        "begin_line": 5822,
        "end_line": 5836,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParseState",
        "snippet": "    class ParseState {\n    public:\n\n        ParseState( ParseResultType type, TokenStream const &remainingTokens )\n        : m_type(type),\n          m_remainingTokens( remainingTokens )\n        {}\n\n        auto type() const -> ParseResultType { return m_type; }\n        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }\n\n    private:\n        ParseResultType m_type;\n        TokenStream m_remainingTokens;\n    };\n"
    },
    {
        "begin_line": 5825,
        "end_line": 5828,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParseState",
        "snippet": "        ParseState( ParseResultType type, TokenStream const &remainingTokens )\n        : m_type(type),\n          m_remainingTokens( remainingTokens )\n        {}\n"
    },
    {
        "begin_line": 5830,
        "end_line": 5830,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "type",
        "snippet": "        auto type() const -> ParseResultType { return m_type; }\n"
    },
    {
        "begin_line": 5831,
        "end_line": 5831,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "remainingTokens",
        "snippet": "        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }\n"
    },
    {
        "begin_line": 5834,
        "end_line": 5834,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_type",
        "snippet": "        ParseResultType m_type;\n"
    },
    {
        "begin_line": 5835,
        "end_line": 5835,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_remainingTokens",
        "snippet": "        TokenStream m_remainingTokens;\n"
    },
    {
        "begin_line": 5842,
        "end_line": 5845,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "HelpColumns",
        "snippet": "    struct HelpColumns {\n        std::string left;\n        std::string right;\n    };\n"
    },
    {
        "begin_line": 5843,
        "end_line": 5843,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "left",
        "snippet": "        std::string left;\n"
    },
    {
        "begin_line": 5844,
        "end_line": 5844,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "right",
        "snippet": "        std::string right;\n"
    },
    {
        "begin_line": 5848,
        "end_line": 5856,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convertInto",
        "snippet": "    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {\n        std::stringstream ss;\n        ss << source;\n        ss >> target;\n        if( ss.fail() )\n            return ParserResult::runtimeError( \"Unable to convert '\" + source + \"' to destination type\" );\n        else\n            return ParserResult::ok( ParseResultType::Matched );\n    }\n"
    },
    {
        "begin_line": 5857,
        "end_line": 5860,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convertInto",
        "snippet": "    inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {\n        target = source;\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n"
    },
    {
        "begin_line": 5861,
        "end_line": 5871,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convertInto",
        "snippet": "    inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {\n        std::string srcLC = source;\n        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( ::tolower(c) ); } );\n        if (srcLC == \"y\" || srcLC == \"1\" || srcLC == \"true\" || srcLC == \"yes\" || srcLC == \"on\")\n            target = true;\n        else if (srcLC == \"n\" || srcLC == \"0\" || srcLC == \"false\" || srcLC == \"no\" || srcLC == \"off\")\n            target = false;\n        else\n            return ParserResult::runtimeError( \"Expected a boolean value but did not recognise: '\" + source + \"'\" );\n        return ParserResult::ok( ParseResultType::Matched );\n    }\n"
    },
    {
        "begin_line": 5863,
        "end_line": 5863,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0302",
        "snippet": "        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( ::tolower(c) ); } );\n"
    },
    {
        "begin_line": 5874,
        "end_line": 5880,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convertInto",
        "snippet": "    inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {\n        T temp;\n        auto result = convertInto( source, temp );\n        if( result )\n            target = std::move(temp);\n        return result;\n    }\n"
    },
    {
        "begin_line": 5883,
        "end_line": 5889,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NonCopyable",
        "snippet": "    struct NonCopyable {\n        NonCopyable() = default;\n        NonCopyable( NonCopyable const & ) = delete;\n        NonCopyable( NonCopyable && ) = delete;\n        NonCopyable &operator=( NonCopyable const & ) = delete;\n        NonCopyable &operator=( NonCopyable && ) = delete;\n    };\n"
    },
    {
        "begin_line": 5891,
        "end_line": 5895,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundRef",
        "snippet": "    struct BoundRef : NonCopyable {\n        virtual ~BoundRef() = default;\n        virtual auto isContainer() const -> bool { return false; }\n        virtual auto isFlag() const -> bool { return false; }\n    };\n"
    },
    {
        "begin_line": 5893,
        "end_line": 5893,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isContainer",
        "snippet": "        virtual auto isContainer() const -> bool { return false; }\n"
    },
    {
        "begin_line": 5894,
        "end_line": 5894,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isFlag",
        "snippet": "        virtual auto isFlag() const -> bool { return false; }\n"
    },
    {
        "begin_line": 5896,
        "end_line": 5898,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundValueRefBase",
        "snippet": "    struct BoundValueRefBase : BoundRef {\n        virtual auto setValue( std::string const &arg ) -> ParserResult = 0;\n    };\n"
    },
    {
        "begin_line": 5899,
        "end_line": 5902,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundFlagRefBase",
        "snippet": "    struct BoundFlagRefBase : BoundRef {\n        virtual auto setFlag( bool flag ) -> ParserResult = 0;\n        virtual auto isFlag() const -> bool { return true; }\n    };\n"
    },
    {
        "begin_line": 5901,
        "end_line": 5901,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isFlag",
        "snippet": "        virtual auto isFlag() const -> bool { return true; }\n"
    },
    {
        "begin_line": 5905,
        "end_line": 5913,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundValueRef",
        "snippet": "    struct BoundValueRef : BoundValueRefBase {\n        T &m_ref;\n\n        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return convertInto( arg, m_ref );\n        }\n    };\n"
    },
    {
        "begin_line": 5906,
        "end_line": 5906,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ref",
        "snippet": "        T &m_ref;\n"
    },
    {
        "begin_line": 5908,
        "end_line": 5908,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundValueRef",
        "snippet": "        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}\n"
    },
    {
        "begin_line": 5910,
        "end_line": 5912,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setValue",
        "snippet": "        auto setValue( std::string const &arg ) -> ParserResult override {\n            return convertInto( arg, m_ref );\n        }\n"
    },
    {
        "begin_line": 5916,
        "end_line": 5930,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundValueRef",
        "snippet": "    struct BoundValueRef<std::vector<T>> : BoundValueRefBase {\n        std::vector<T> &m_ref;\n\n        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}\n\n        auto isContainer() const -> bool override { return true; }\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            T temp;\n            auto result = convertInto( arg, temp );\n            if( result )\n                m_ref.push_back( temp );\n            return result;\n        }\n    };\n"
    },
    {
        "begin_line": 5917,
        "end_line": 5917,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ref",
        "snippet": "        std::vector<T> &m_ref;\n"
    },
    {
        "begin_line": 5919,
        "end_line": 5919,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundValueRef",
        "snippet": "        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}\n"
    },
    {
        "begin_line": 5921,
        "end_line": 5921,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isContainer",
        "snippet": "        auto isContainer() const -> bool override { return true; }\n"
    },
    {
        "begin_line": 5923,
        "end_line": 5929,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setValue",
        "snippet": "        auto setValue( std::string const &arg ) -> ParserResult override {\n            T temp;\n            auto result = convertInto( arg, temp );\n            if( result )\n                m_ref.push_back( temp );\n            return result;\n        }\n"
    },
    {
        "begin_line": 5932,
        "end_line": 5941,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundFlagRef",
        "snippet": "    struct BoundFlagRef : BoundFlagRefBase {\n        bool &m_ref;\n\n        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            m_ref = flag;\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n"
    },
    {
        "begin_line": 5933,
        "end_line": 5933,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ref",
        "snippet": "        bool &m_ref;\n"
    },
    {
        "begin_line": 5935,
        "end_line": 5935,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundFlagRef",
        "snippet": "        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}\n"
    },
    {
        "begin_line": 5937,
        "end_line": 5940,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setFlag",
        "snippet": "        auto setFlag( bool flag ) -> ParserResult override {\n            m_ref = flag;\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n"
    },
    {
        "begin_line": 5944,
        "end_line": 5951,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LambdaInvoker",
        "snippet": "    struct LambdaInvoker {\n        static_assert( std::is_same<ReturnType, ParserResult>::value, \"Lambda must return void or clara::ParserResult\" );\n\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            return lambda( arg );\n        }\n    };\n"
    },
    {
        "begin_line": 5948,
        "end_line": 5950,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invoke",
        "snippet": "        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            return lambda( arg );\n        }\n"
    },
    {
        "begin_line": 5954,
        "end_line": 5960,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LambdaInvoker",
        "snippet": "    struct LambdaInvoker<void> {\n        template<typename L, typename ArgType>\n        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            lambda( arg );\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n"
    },
    {
        "begin_line": 5956,
        "end_line": 5959,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invoke",
        "snippet": "        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {\n            lambda( arg );\n            return ParserResult::ok( ParseResultType::Matched );\n        }\n"
    },
    {
        "begin_line": 5963,
        "end_line": 5969,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invokeLambda",
        "snippet": "    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {\n        ArgType temp{};\n        auto result = convertInto( arg, temp );\n        return !result\n           ? result\n           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );\n    }\n"
    },
    {
        "begin_line": 5972,
        "end_line": 5981,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundLambda",
        "snippet": "    struct BoundLambda : BoundValueRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setValue( std::string const &arg ) -> ParserResult override {\n            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );\n        }\n    };\n"
    },
    {
        "begin_line": 5973,
        "end_line": 5973,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lambda",
        "snippet": "        L m_lambda;\n"
    },
    {
        "begin_line": 5976,
        "end_line": 5976,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundLambda",
        "snippet": "        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}\n"
    },
    {
        "begin_line": 5978,
        "end_line": 5980,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setValue",
        "snippet": "        auto setValue( std::string const &arg ) -> ParserResult override {\n            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );\n        }\n"
    },
    {
        "begin_line": 5984,
        "end_line": 5995,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundFlagLambda",
        "snippet": "    struct BoundFlagLambda : BoundFlagRefBase {\n        L m_lambda;\n\n        static_assert( UnaryLambdaTraits<L>::isValid, \"Supplied lambda must take exactly one argument\" );\n        static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, \"flags must be boolean\" );\n\n        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}\n\n        auto setFlag( bool flag ) -> ParserResult override {\n            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );\n        }\n    };\n"
    },
    {
        "begin_line": 5985,
        "end_line": 5985,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_lambda",
        "snippet": "        L m_lambda;\n"
    },
    {
        "begin_line": 5990,
        "end_line": 5990,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "BoundFlagLambda",
        "snippet": "        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}\n"
    },
    {
        "begin_line": 5992,
        "end_line": 5994,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setFlag",
        "snippet": "        auto setFlag( bool flag ) -> ParserResult override {\n            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );\n        }\n"
    },
    {
        "begin_line": 5997,
        "end_line": 5997,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Optionality",
        "snippet": "    enum class Optionality { Optional, Required };\n"
    },
    {
        "begin_line": 6001,
        "end_line": 6011,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParserBase",
        "snippet": "    class ParserBase {\n    public:\n        virtual ~ParserBase() = default;\n        virtual auto validate() const -> Result { return Result::ok(); }\n        virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;\n        virtual auto cardinality() const -> size_t { return 1; }\n\n        auto parse( Args const &args ) const -> InternalParseResult {\n            return parse( args.exeName(), TokenStream( args ) );\n        }\n    };\n"
    },
    {
        "begin_line": 6004,
        "end_line": 6004,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "validate",
        "snippet": "        virtual auto validate() const -> Result { return Result::ok(); }\n"
    },
    {
        "begin_line": 6006,
        "end_line": 6006,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cardinality",
        "snippet": "        virtual auto cardinality() const -> size_t { return 1; }\n"
    },
    {
        "begin_line": 6008,
        "end_line": 6010,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parse",
        "snippet": "        auto parse( Args const &args ) const -> InternalParseResult {\n            return parse( args.exeName(), TokenStream( args ) );\n        }\n"
    },
    {
        "begin_line": 6014,
        "end_line": 6021,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ComposableParserImpl",
        "snippet": "    class ComposableParserImpl : public ParserBase {\n    public:\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser;\n\n\t\ttemplate<typename T>\n        auto operator+( T const &other ) const -> Parser;\n    };\n"
    },
    {
        "begin_line": 6025,
        "end_line": 6074,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParserRefImpl",
        "snippet": "    class ParserRefImpl : public ComposableParserImpl<DerivedT> {\n    protected:\n        Optionality m_optionality = Optionality::Optional;\n        std::shared_ptr<BoundRef> m_ref;\n        std::string m_hint;\n        std::string m_description;\n\n        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}\n\n    public:\n        template<typename T>\n        ParserRefImpl( T &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\n            m_hint( hint )\n        {}\n\n        template<typename LambdaT>\n        ParserRefImpl( LambdaT const &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\n            m_hint(hint)\n        {}\n\n        auto operator()( std::string const &description ) -> DerivedT & {\n            m_description = description;\n            return static_cast<DerivedT &>( *this );\n        }\n\n        auto optional() -> DerivedT & {\n            m_optionality = Optionality::Optional;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto required() -> DerivedT & {\n            m_optionality = Optionality::Required;\n            return static_cast<DerivedT &>( *this );\n        };\n\n        auto isOptional() const -> bool {\n            return m_optionality == Optionality::Optional;\n        }\n\n        auto cardinality() const -> size_t override {\n            if( m_ref->isContainer() )\n                return 0;\n            else\n                return 1;\n        }\n\n        auto hint() const -> std::string { return m_hint; }\n    };\n"
    },
    {
        "begin_line": 6027,
        "end_line": 6027,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_optionality",
        "snippet": "        Optionality m_optionality = Optionality::Optional;\n"
    },
    {
        "begin_line": 6028,
        "end_line": 6028,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ref",
        "snippet": "        std::shared_ptr<BoundRef> m_ref;\n"
    },
    {
        "begin_line": 6029,
        "end_line": 6029,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_hint",
        "snippet": "        std::string m_hint;\n"
    },
    {
        "begin_line": 6030,
        "end_line": 6030,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_description",
        "snippet": "        std::string m_description;\n"
    },
    {
        "begin_line": 6032,
        "end_line": 6032,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParserRefImpl",
        "snippet": "        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}\n"
    },
    {
        "begin_line": 6036,
        "end_line": 6039,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParserRefImpl",
        "snippet": "        ParserRefImpl( T &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\n            m_hint( hint )\n        {}\n"
    },
    {
        "begin_line": 6042,
        "end_line": 6045,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParserRefImpl",
        "snippet": "        ParserRefImpl( LambdaT const &ref, std::string const &hint )\n        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\n            m_hint(hint)\n        {}\n"
    },
    {
        "begin_line": 6047,
        "end_line": 6050,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ()",
        "snippet": "        auto operator()( std::string const &description ) -> DerivedT & {\n            m_description = description;\n            return static_cast<DerivedT &>( *this );\n        }\n"
    },
    {
        "begin_line": 6052,
        "end_line": 6055,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "optional",
        "snippet": "        auto optional() -> DerivedT & {\n            m_optionality = Optionality::Optional;\n            return static_cast<DerivedT &>( *this );\n        };\n"
    },
    {
        "begin_line": 6057,
        "end_line": 6060,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "required",
        "snippet": "        auto required() -> DerivedT & {\n            m_optionality = Optionality::Required;\n            return static_cast<DerivedT &>( *this );\n        };\n"
    },
    {
        "begin_line": 6062,
        "end_line": 6064,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isOptional",
        "snippet": "        auto isOptional() const -> bool {\n            return m_optionality == Optionality::Optional;\n        }\n"
    },
    {
        "begin_line": 6066,
        "end_line": 6071,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cardinality",
        "snippet": "        auto cardinality() const -> size_t override {\n            if( m_ref->isContainer() )\n                return 0;\n            else\n                return 1;\n        }\n"
    },
    {
        "begin_line": 6073,
        "end_line": 6073,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hint",
        "snippet": "        auto hint() const -> std::string { return m_hint; }\n"
    },
    {
        "begin_line": 6076,
        "end_line": 6116,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExeName",
        "snippet": "    class ExeName : public ComposableParserImpl<ExeName> {\n        std::shared_ptr<std::string> m_name;\n        std::shared_ptr<BoundValueRefBase> m_ref;\n\n        template<typename LambdaT>\n        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {\n            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;\n        }\n\n    public:\n        ExeName() : m_name( std::make_shared<std::string>( \"<executable>\" ) ) {}\n\n        explicit ExeName( std::string &ref ) : ExeName() {\n            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );\n        }\n\n        template<typename LambdaT>\n        explicit ExeName( LambdaT const& lambda ) : ExeName() {\n            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );\n        }\n\n        // The exe name is not parsed out of the normal tokens, but is handled specially\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n        }\n\n        auto name() const -> std::string { return *m_name; }\n        auto set( std::string const& newName ) -> ParserResult {\n\n            auto lastSlash = newName.find_last_of( \"\\\\/\" );\n            auto filename = ( lastSlash == std::string::npos )\n                    ? newName\n                    : newName.substr( lastSlash+1 );\n\n            *m_name = filename;\n            if( m_ref )\n                return m_ref->setValue( filename );\n            else\n                return ParserResult::ok( ParseResultType::Matched );\n        }\n    };\n"
    },
    {
        "begin_line": 6077,
        "end_line": 6077,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_name",
        "snippet": "        std::shared_ptr<std::string> m_name;\n"
    },
    {
        "begin_line": 6078,
        "end_line": 6078,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ref",
        "snippet": "        std::shared_ptr<BoundValueRefBase> m_ref;\n"
    },
    {
        "begin_line": 6081,
        "end_line": 6083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeRef",
        "snippet": "        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {\n            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;\n        }\n"
    },
    {
        "begin_line": 6086,
        "end_line": 6086,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExeName",
        "snippet": "        ExeName() : m_name( std::make_shared<std::string>( \"<executable>\" ) ) {}\n"
    },
    {
        "begin_line": 6088,
        "end_line": 6090,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExeName",
        "snippet": "        explicit ExeName( std::string &ref ) : ExeName() {\n            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );\n        }\n"
    },
    {
        "begin_line": 6093,
        "end_line": 6095,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExeName",
        "snippet": "        explicit ExeName( LambdaT const& lambda ) : ExeName() {\n            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );\n        }\n"
    },
    {
        "begin_line": 6098,
        "end_line": 6100,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parse",
        "snippet": "        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n        }\n"
    },
    {
        "begin_line": 6102,
        "end_line": 6102,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        auto name() const -> std::string { return *m_name; }\n"
    },
    {
        "begin_line": 6103,
        "end_line": 6115,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "set",
        "snippet": "        auto set( std::string const& newName ) -> ParserResult {\n\n            auto lastSlash = newName.find_last_of( \"\\\\/\" );\n            auto filename = ( lastSlash == std::string::npos )\n                    ? newName\n                    : newName.substr( lastSlash+1 );\n\n            *m_name = filename;\n            if( m_ref )\n                return m_ref->setValue( filename );\n            else\n                return ParserResult::ok( ParseResultType::Matched );\n        }\n"
    },
    {
        "begin_line": 6118,
        "end_line": 6141,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Arg",
        "snippet": "    class Arg : public ParserRefImpl<Arg> {\n    public:\n        using ParserRefImpl::ParserRefImpl;\n\n        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            auto const &token = *remainingTokens;\n            if( token.type != TokenType::Argument )\n                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n\n            assert( !m_ref->isFlag() );\n            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n\n            auto result = valueRef->setValue( remainingTokens->token );\n            if( !result )\n                return InternalParseResult( result );\n            else\n                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n        }\n    };\n"
    },
    {
        "begin_line": 6122,
        "end_line": 6140,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parse",
        "snippet": "        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            auto const &token = *remainingTokens;\n            if( token.type != TokenType::Argument )\n                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n\n            assert( !m_ref->isFlag() );\n            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n\n            auto result = valueRef->setValue( remainingTokens->token );\n            if( !result )\n                return InternalParseResult( result );\n            else\n                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n        }\n"
    },
    {
        "begin_line": 6143,
        "end_line": 6150,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "normaliseOpt",
        "snippet": "    inline auto normaliseOpt( std::string const &optName ) -> std::string {\n#ifdef CATCH_PLATFORM_WINDOWS\n        if( optName[0] == '/' )\n            return \"-\" + optName.substr( 1 );\n        else\n#endif\n            return optName;\n    }\n"
    },
    {
        "begin_line": 6152,
        "end_line": 6251,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Opt",
        "snippet": "    class Opt : public ParserRefImpl<Opt> {\n    protected:\n        std::vector<std::string> m_optNames;\n\n    public:\n        template<typename LambdaT>\n        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}\n\n        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}\n\n        template<typename LambdaT>\n        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        template<typename T>\n        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n\n        auto operator[]( std::string const &optName ) -> Opt & {\n            m_optNames.push_back( optName );\n            return *this;\n        }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::ostringstream oss;\n            bool first = true;\n            for( auto const &opt : m_optNames ) {\n                if (first)\n                    first = false;\n                else\n                    oss << \", \";\n                oss << opt;\n            }\n            if( !m_hint.empty() )\n                oss << \" <\" << m_hint << \">\";\n            return { { oss.str(), m_description } };\n        }\n\n        auto isMatch( std::string const &optToken ) const -> bool {\n            auto normalisedToken = normaliseOpt( optToken );\n            for( auto const &name : m_optNames ) {\n                if( normaliseOpt( name ) == normalisedToken )\n                    return true;\n            }\n            return false;\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            if( remainingTokens && remainingTokens->type == TokenType::Option ) {\n                auto const &token = *remainingTokens;\n                if( isMatch(token.token ) ) {\n                    if( m_ref->isFlag() ) {\n                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );\n                        auto result = flagRef->setFlag( true );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    } else {\n                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n                        ++remainingTokens;\n                        if( !remainingTokens )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto const &argToken = *remainingTokens;\n                        if( argToken.type != TokenType::Argument )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto result = valueRef->setValue( argToken.token );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    }\n                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n                }\n            }\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n        }\n\n        auto validate() const -> Result override {\n            if( m_optNames.empty() )\n                return Result::logicError( \"No options supplied to Opt\" );\n            for( auto const &name : m_optNames ) {\n                if( name.empty() )\n                    return Result::logicError( \"Option name cannot be empty\" );\n#ifdef CATCH_PLATFORM_WINDOWS\n                if( name[0] != '-' && name[0] != '/' )\n                    return Result::logicError( \"Option name must begin with '-' or '/'\" );\n#else\n                if( name[0] != '-' )\n                    return Result::logicError( \"Option name must begin with '-'\" );\n#endif\n            }\n            return ParserRefImpl::validate();\n        }\n    };\n"
    },
    {
        "begin_line": 6154,
        "end_line": 6154,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_optNames",
        "snippet": "        std::vector<std::string> m_optNames;\n"
    },
    {
        "begin_line": 6158,
        "end_line": 6158,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Opt",
        "snippet": "        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}\n"
    },
    {
        "begin_line": 6160,
        "end_line": 6160,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Opt",
        "snippet": "        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}\n"
    },
    {
        "begin_line": 6163,
        "end_line": 6163,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Opt",
        "snippet": "        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n"
    },
    {
        "begin_line": 6166,
        "end_line": 6166,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Opt",
        "snippet": "        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}\n"
    },
    {
        "begin_line": 6168,
        "end_line": 6171,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator []",
        "snippet": "        auto operator[]( std::string const &optName ) -> Opt & {\n            m_optNames.push_back( optName );\n            return *this;\n        }\n"
    },
    {
        "begin_line": 6173,
        "end_line": 6186,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getHelpColumns",
        "snippet": "        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::ostringstream oss;\n            bool first = true;\n            for( auto const &opt : m_optNames ) {\n                if (first)\n                    first = false;\n                else\n                    oss << \", \";\n                oss << opt;\n            }\n            if( !m_hint.empty() )\n                oss << \" <\" << m_hint << \">\";\n            return { { oss.str(), m_description } };\n        }\n"
    },
    {
        "begin_line": 6188,
        "end_line": 6195,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isMatch",
        "snippet": "        auto isMatch( std::string const &optToken ) const -> bool {\n            auto normalisedToken = normaliseOpt( optToken );\n            for( auto const &name : m_optNames ) {\n                if( normaliseOpt( name ) == normalisedToken )\n                    return true;\n            }\n            return false;\n        }\n"
    },
    {
        "begin_line": 6199,
        "end_line": 6233,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parse",
        "snippet": "        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {\n            auto validationResult = validate();\n            if( !validationResult )\n                return InternalParseResult( validationResult );\n\n            auto remainingTokens = tokens;\n            if( remainingTokens && remainingTokens->type == TokenType::Option ) {\n                auto const &token = *remainingTokens;\n                if( isMatch(token.token ) ) {\n                    if( m_ref->isFlag() ) {\n                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );\n                        auto result = flagRef->setFlag( true );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    } else {\n                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );\n                        ++remainingTokens;\n                        if( !remainingTokens )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto const &argToken = *remainingTokens;\n                        if( argToken.type != TokenType::Argument )\n                            return InternalParseResult::runtimeError( \"Expected argument following \" + token.token );\n                        auto result = valueRef->setValue( argToken.token );\n                        if( !result )\n                            return InternalParseResult( result );\n                        if( result.value() == ParseResultType::ShortCircuitAll )\n                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\n                    }\n                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\n                }\n            }\n            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\n        }\n"
    },
    {
        "begin_line": 6235,
        "end_line": 6250,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "validate",
        "snippet": "        auto validate() const -> Result override {\n            if( m_optNames.empty() )\n                return Result::logicError( \"No options supplied to Opt\" );\n            for( auto const &name : m_optNames ) {\n                if( name.empty() )\n                    return Result::logicError( \"Option name cannot be empty\" );\n#ifdef CATCH_PLATFORM_WINDOWS\n                if( name[0] != '-' && name[0] != '/' )\n                    return Result::logicError( \"Option name must begin with '-' or '/'\" );\n#else\n                if( name[0] != '-' )\n                    return Result::logicError( \"Option name must begin with '-'\" );\n#endif\n            }\n            return ParserRefImpl::validate();\n        }\n"
    },
    {
        "begin_line": 6253,
        "end_line": 6265,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Help",
        "snippet": "    struct Help : Opt {\n        Help( bool &showHelpFlag )\n        :   Opt([&]( bool flag ) {\n                showHelpFlag = flag;\n                return ParserResult::ok( ParseResultType::ShortCircuitAll );\n            })\n        {\n            static_cast<Opt &>( *this )\n                    (\"display usage information\")\n                    [\"-?\"][\"-h\"][\"--help\"]\n                    .optional();\n        }\n    };\n"
    },
    {
        "begin_line": 6255,
        "end_line": 6258,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0402",
        "snippet": "        :   Opt([&]( bool flag ) {\n                showHelpFlag = flag;\n                return ParserResult::ok( ParseResultType::ShortCircuitAll );\n            })\n"
    },
    {
        "begin_line": 6254,
        "end_line": 6264,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Help",
        "snippet": "        Help( bool &showHelpFlag )\n        :   Opt([&]( bool flag ) {\n                showHelpFlag = flag;\n                return ParserResult::ok( ParseResultType::ShortCircuitAll );\n            })\n        {\n            static_cast<Opt &>( *this )\n                    (\"display usage information\")\n                    [\"-?\"][\"-h\"][\"--help\"]\n                    .optional();\n        }\n"
    },
    {
        "begin_line": 6267,
        "end_line": 6421,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Parser",
        "snippet": "    struct Parser : ParserBase {\n\n        mutable ExeName m_exeName;\n        std::vector<Opt> m_options;\n        std::vector<Arg> m_args;\n\n        auto operator|=( ExeName const &exeName ) -> Parser & {\n            m_exeName = exeName;\n            return *this;\n        }\n\n        auto operator|=( Arg const &arg ) -> Parser & {\n            m_args.push_back(arg);\n            return *this;\n        }\n\n        auto operator|=( Opt const &opt ) -> Parser & {\n            m_options.push_back(opt);\n            return *this;\n        }\n\n        auto operator|=( Parser const &other ) -> Parser & {\n            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());\n            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());\n            return *this;\n        }\n\n        template<typename T>\n        auto operator|( T const &other ) const -> Parser {\n            return Parser( *this ) |= other;\n        }\n\n        // Forward deprecated interface with '+' instead of '|'\n        template<typename T>\n        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }\n        template<typename T>\n        auto operator+( T const &other ) const -> Parser { return operator|( other ); }\n\n        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::vector<HelpColumns> cols;\n            for (auto const &o : m_options) {\n                auto childCols = o.getHelpColumns();\n                cols.insert( cols.end(), childCols.begin(), childCols.end() );\n            }\n            return cols;\n        }\n\n        void writeToStream( std::ostream &os ) const {\n            if (!m_exeName.name().empty()) {\n                os << \"usage:\\n\" << \"  \" << m_exeName.name() << \" \";\n                bool required = true, first = true;\n                for( auto const &arg : m_args ) {\n                    if (first)\n                        first = false;\n                    else\n                        os << \" \";\n                    if( arg.isOptional() && required ) {\n                        os << \"[\";\n                        required = false;\n                    }\n                    os << \"<\" << arg.hint() << \">\";\n                    if( arg.cardinality() == 0 )\n                        os << \" ... \";\n                }\n                if( !required )\n                    os << \"]\";\n                if( !m_options.empty() )\n                    os << \" options\";\n                os << \"\\n\\nwhere options are:\" << std::endl;\n            }\n\n            auto rows = getHelpColumns();\n            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;\n            size_t optWidth = 0;\n            for( auto const &cols : rows )\n                optWidth = (std::max)(optWidth, cols.left.size() + 2);\n\n            optWidth = (std::min)(optWidth, consoleWidth/2);\n\n            for( auto const &cols : rows ) {\n                auto row =\n                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +\n                        TextFlow::Spacer(4) +\n                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );\n                os << row << std::endl;\n            }\n        }\n\n        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {\n            parser.writeToStream( os );\n            return os;\n        }\n\n        auto validate() const -> Result override {\n            for( auto const &opt : m_options ) {\n                auto result = opt.validate();\n                if( !result )\n                    return result;\n            }\n            for( auto const &arg : m_args ) {\n                auto result = arg.validate();\n                if( !result )\n                    return result;\n            }\n            return Result::ok();\n        }\n\n        using ParserBase::parse;\n\n        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {\n\n            struct ParserInfo {\n                ParserBase const* parser = nullptr;\n                size_t count = 0;\n            };\n            const size_t totalParsers = m_options.size() + m_args.size();\n            assert( totalParsers < 512 );\n            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do\n            ParserInfo parseInfos[512];\n\n            {\n                size_t i = 0;\n                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;\n                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;\n            }\n\n            m_exeName.set( exeName );\n\n            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n            while( result.value().remainingTokens() ) {\n                bool tokenParsed = false;\n\n                for( size_t i = 0; i < totalParsers; ++i ) {\n                    auto&  parseInfo = parseInfos[i];\n                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {\n                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());\n                        if (!result)\n                            return result;\n                        if (result.value().type() != ParseResultType::NoMatch) {\n                            tokenParsed = true;\n                            ++parseInfo.count;\n                            break;\n                        }\n                    }\n                }\n\n                if( result.value().type() == ParseResultType::ShortCircuitAll )\n                    return result;\n                if( !tokenParsed )\n                    return InternalParseResult::runtimeError( \"Unrecognised token: \" + result.value().remainingTokens()->token );\n            }\n            // !TBD Check missing required options\n            return result;\n        }\n    };\n"
    },
    {
        "begin_line": 6269,
        "end_line": 6269,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_exeName",
        "snippet": "        mutable ExeName m_exeName;\n"
    },
    {
        "begin_line": 6270,
        "end_line": 6270,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_options",
        "snippet": "        std::vector<Opt> m_options;\n"
    },
    {
        "begin_line": 6271,
        "end_line": 6271,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_args",
        "snippet": "        std::vector<Arg> m_args;\n"
    },
    {
        "begin_line": 6273,
        "end_line": 6276,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator |=",
        "snippet": "        auto operator|=( ExeName const &exeName ) -> Parser & {\n            m_exeName = exeName;\n            return *this;\n        }\n"
    },
    {
        "begin_line": 6278,
        "end_line": 6281,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator |=",
        "snippet": "        auto operator|=( Arg const &arg ) -> Parser & {\n            m_args.push_back(arg);\n            return *this;\n        }\n"
    },
    {
        "begin_line": 6283,
        "end_line": 6286,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator |=",
        "snippet": "        auto operator|=( Opt const &opt ) -> Parser & {\n            m_options.push_back(opt);\n            return *this;\n        }\n"
    },
    {
        "begin_line": 6288,
        "end_line": 6292,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator |=",
        "snippet": "        auto operator|=( Parser const &other ) -> Parser & {\n            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());\n            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());\n            return *this;\n        }\n"
    },
    {
        "begin_line": 6295,
        "end_line": 6297,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator |",
        "snippet": "        auto operator|( T const &other ) const -> Parser {\n            return Parser( *this ) |= other;\n        }\n"
    },
    {
        "begin_line": 6301,
        "end_line": 6301,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +=",
        "snippet": "        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }\n"
    },
    {
        "begin_line": 6303,
        "end_line": 6303,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "        auto operator+( T const &other ) const -> Parser { return operator|( other ); }\n"
    },
    {
        "begin_line": 6305,
        "end_line": 6312,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getHelpColumns",
        "snippet": "        auto getHelpColumns() const -> std::vector<HelpColumns> {\n            std::vector<HelpColumns> cols;\n            for (auto const &o : m_options) {\n                auto childCols = o.getHelpColumns();\n                cols.insert( cols.end(), childCols.begin(), childCols.end() );\n            }\n            return cols;\n        }\n"
    },
    {
        "begin_line": 6314,
        "end_line": 6353,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeToStream",
        "snippet": "        void writeToStream( std::ostream &os ) const {\n            if (!m_exeName.name().empty()) {\n                os << \"usage:\\n\" << \"  \" << m_exeName.name() << \" \";\n                bool required = true, first = true;\n                for( auto const &arg : m_args ) {\n                    if (first)\n                        first = false;\n                    else\n                        os << \" \";\n                    if( arg.isOptional() && required ) {\n                        os << \"[\";\n                        required = false;\n                    }\n                    os << \"<\" << arg.hint() << \">\";\n                    if( arg.cardinality() == 0 )\n                        os << \" ... \";\n                }\n                if( !required )\n                    os << \"]\";\n                if( !m_options.empty() )\n                    os << \" options\";\n                os << \"\\n\\nwhere options are:\" << std::endl;\n            }\n\n            auto rows = getHelpColumns();\n            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;\n            size_t optWidth = 0;\n            for( auto const &cols : rows )\n                optWidth = (std::max)(optWidth, cols.left.size() + 2);\n\n            optWidth = (std::min)(optWidth, consoleWidth/2);\n\n            for( auto const &cols : rows ) {\n                auto row =\n                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +\n                        TextFlow::Spacer(4) +\n                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );\n                os << row << std::endl;\n            }\n        }\n"
    },
    {
        "begin_line": 6355,
        "end_line": 6358,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {\n            parser.writeToStream( os );\n            return os;\n        }\n"
    },
    {
        "begin_line": 6360,
        "end_line": 6372,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "validate",
        "snippet": "        auto validate() const -> Result override {\n            for( auto const &opt : m_options ) {\n                auto result = opt.validate();\n                if( !result )\n                    return result;\n            }\n            for( auto const &arg : m_args ) {\n                auto result = arg.validate();\n                if( !result )\n                    return result;\n            }\n            return Result::ok();\n        }\n"
    },
    {
        "begin_line": 6376,
        "end_line": 6420,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parse",
        "snippet": "        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {\n\n            struct ParserInfo {\n                ParserBase const* parser = nullptr;\n                size_t count = 0;\n            };\n            const size_t totalParsers = m_options.size() + m_args.size();\n            assert( totalParsers < 512 );\n            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do\n            ParserInfo parseInfos[512];\n\n            {\n                size_t i = 0;\n                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;\n                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;\n            }\n\n            m_exeName.set( exeName );\n\n            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\n            while( result.value().remainingTokens() ) {\n                bool tokenParsed = false;\n\n                for( size_t i = 0; i < totalParsers; ++i ) {\n                    auto&  parseInfo = parseInfos[i];\n                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {\n                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());\n                        if (!result)\n                            return result;\n                        if (result.value().type() != ParseResultType::NoMatch) {\n                            tokenParsed = true;\n                            ++parseInfo.count;\n                            break;\n                        }\n                    }\n                }\n\n                if( result.value().type() == ParseResultType::ShortCircuitAll )\n                    return result;\n                if( !tokenParsed )\n                    return InternalParseResult::runtimeError( \"Unrecognised token: \" + result.value().remainingTokens()->token );\n            }\n            // !TBD Check missing required options\n            return result;\n        }\n"
    },
    {
        "begin_line": 6378,
        "end_line": 6381,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ParserInfo",
        "snippet": "            struct ParserInfo {\n                ParserBase const* parser = nullptr;\n                size_t count = 0;\n            };\n"
    },
    {
        "begin_line": 6379,
        "end_line": 6379,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parser",
        "snippet": "                ParserBase const* parser = nullptr;\n"
    },
    {
        "begin_line": 6380,
        "end_line": 6380,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "count",
        "snippet": "                size_t count = 0;\n"
    },
    {
        "begin_line": 6425,
        "end_line": 6427,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator |",
        "snippet": "    auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {\n        return Parser() | static_cast<DerivedT const &>( *this ) | other;\n    }\n"
    },
    {
        "begin_line": 6463,
        "end_line": 6463,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH",
        "snippet": "#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH\n"
    },
    {
        "begin_line": 6468,
        "end_line": 6472,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    clara::Parser makeCommandLineParser( ConfigData& config );\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 6478,
        "end_line": 6656,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    clara::Parser makeCommandLineParser( ConfigData& config ) {\n\n        using namespace clara;\n\n        auto const setWarning = [&]( std::string const& warning ) {\n                auto warningSet = [&]() {\n                    if( warning == \"NoAssertions\" )\n                        return WarnAbout::NoAssertions;\n\n                    if ( warning == \"NoTests\" )\n                        return WarnAbout::NoTests;\n\n                    return WarnAbout::Nothing;\n                }();\n\n                if (warningSet == WarnAbout::Nothing)\n                    return ParserResult::runtimeError( \"Unrecognised warning: '\" + warning + \"'\" );\n                config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const loadTestNamesFromFile = [&]( std::string const& filename ) {\n                std::ifstream f( filename.c_str() );\n                if( !f.is_open() )\n                    return ParserResult::runtimeError( \"Unable to load input file: '\" + filename + \"'\" );\n\n                std::string line;\n                while( std::getline( f, line ) ) {\n                    line = trim(line);\n                    if( !line.empty() && !startsWith( line, '#' ) ) {\n                        if( !startsWith( line, '\"' ) )\n                            line = '\"' + line + '\"';\n                        config.testsOrTags.push_back( line + ',' );\n                    }\n                }\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setTestOrder = [&]( std::string const& order ) {\n                if( startsWith( \"declared\", order ) )\n                    config.runOrder = RunTests::InDeclarationOrder;\n                else if( startsWith( \"lexical\", order ) )\n                    config.runOrder = RunTests::InLexicographicalOrder;\n                else if( startsWith( \"random\", order ) )\n                    config.runOrder = RunTests::InRandomOrder;\n                else\n                    return clara::ParserResult::runtimeError( \"Unrecognised ordering: '\" + order + \"'\" );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setRngSeed = [&]( std::string const& seed ) {\n                if( seed != \"time\" )\n                    return clara::detail::convertInto( seed, config.rngSeed );\n                config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setColourUsage = [&]( std::string const& useColour ) {\n                    auto mode = toLower( useColour );\n\n                    if( mode == \"yes\" )\n                        config.useColour = UseColour::Yes;\n                    else if( mode == \"no\" )\n                        config.useColour = UseColour::No;\n                    else if( mode == \"auto\" )\n                        config.useColour = UseColour::Auto;\n                    else\n                        return ParserResult::runtimeError( \"colour mode must be one of: auto, yes or no. '\" + useColour + \"' not recognised\" );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setWaitForKeypress = [&]( std::string const& keypress ) {\n                auto keypressLc = toLower( keypress );\n                if( keypressLc == \"start\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeStart;\n                else if( keypressLc == \"exit\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeExit;\n                else if( keypressLc == \"both\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;\n                else\n                    return ParserResult::runtimeError( \"keypress argument must be one of: start, exit or both. '\" + keypress + \"' not recognised\" );\n            return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setVerbosity = [&]( std::string const& verbosity ) {\n            auto lcVerbosity = toLower( verbosity );\n            if( lcVerbosity == \"quiet\" )\n                config.verbosity = Verbosity::Quiet;\n            else if( lcVerbosity == \"normal\" )\n                config.verbosity = Verbosity::Normal;\n            else if( lcVerbosity == \"high\" )\n                config.verbosity = Verbosity::High;\n            else\n                return ParserResult::runtimeError( \"Unrecognised verbosity, '\" + verbosity + \"'\" );\n            return ParserResult::ok( ParseResultType::Matched );\n        };\n\n        auto cli\n            = ExeName( config.processName )\n            | Help( config.showHelp )\n            | Opt( config.listTests )\n                [\"-l\"][\"--list-tests\"]\n                ( \"list all/matching test cases\" )\n            | Opt( config.listTags )\n                [\"-t\"][\"--list-tags\"]\n                ( \"list all/matching tags\" )\n            | Opt( config.showSuccessfulTests )\n                [\"-s\"][\"--success\"]\n                ( \"include successful tests in output\" )\n            | Opt( config.shouldDebugBreak )\n                [\"-b\"][\"--break\"]\n                ( \"break into debugger on failure\" )\n            | Opt( config.noThrow )\n                [\"-e\"][\"--nothrow\"]\n                ( \"skip exception tests\" )\n            | Opt( config.showInvisibles )\n                [\"-i\"][\"--invisibles\"]\n                ( \"show invisibles (tabs, newlines)\" )\n            | Opt( config.outputFilename, \"filename\" )\n                [\"-o\"][\"--out\"]\n                ( \"output filename\" )\n            | Opt( config.reporterNames, \"name\" )\n                [\"-r\"][\"--reporter\"]\n                ( \"reporter to use (defaults to console)\" )\n            | Opt( config.name, \"name\" )\n                [\"-n\"][\"--name\"]\n                ( \"suite name\" )\n            | Opt( [&]( bool ){ config.abortAfter = 1; } )\n                [\"-a\"][\"--abort\"]\n                ( \"abort at first failure\" )\n            | Opt( [&]( int x ){ config.abortAfter = x; }, \"no. failures\" )\n                [\"-x\"][\"--abortx\"]\n                ( \"abort after x failures\" )\n            | Opt( setWarning, \"warning name\" )\n                [\"-w\"][\"--warn\"]\n                ( \"enable warnings\" )\n            | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, \"yes|no\" )\n                [\"-d\"][\"--durations\"]\n                ( \"show test durations\" )\n            | Opt( loadTestNamesFromFile, \"filename\" )\n                [\"-f\"][\"--input-file\"]\n                ( \"load test names to run from a file\" )\n            | Opt( config.filenamesAsTags )\n                [\"-#\"][\"--filenames-as-tags\"]\n                ( \"adds a tag for the filename\" )\n            | Opt( config.sectionsToRun, \"section name\" )\n                [\"-c\"][\"--section\"]\n                ( \"specify section to run\" )\n            | Opt( setVerbosity, \"quiet|normal|high\" )\n                [\"-v\"][\"--verbosity\"]\n                ( \"set output verbosity\" )\n            | Opt( config.listTestNamesOnly )\n                [\"--list-test-names-only\"]\n                ( \"list all/matching test cases names only\" )\n            | Opt( config.listReporters )\n                [\"--list-reporters\"]\n                ( \"list all reporters\" )\n            | Opt( setTestOrder, \"decl|lex|rand\" )\n                [\"--order\"]\n                ( \"test case order (defaults to decl)\" )\n            | Opt( setRngSeed, \"'time'|number\" )\n                [\"--rng-seed\"]\n                ( \"set a specific seed for random numbers\" )\n            | Opt( setColourUsage, \"yes|no\" )\n                [\"--use-colour\"]\n                ( \"should output be colourised\" )\n            | Opt( config.libIdentify )\n                [\"--libidentify\"]\n                ( \"report name and version according to libidentify standard\" )\n            | Opt( setWaitForKeypress, \"start|exit|both\" )\n                [\"--wait-for-keypress\"]\n                ( \"waits for a keypress before exiting\" )\n            | Opt( config.benchmarkResolutionMultiple, \"multiplier\" )\n                [\"--benchmark-resolution-multiple\"]\n                ( \"multiple of clock resolution to run benchmarks\" )\n\n            | Arg( config.testsOrTags, \"test name|pattern|tags\" )\n                ( \"which test or tests to use\" );\n\n        return cli;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 6480,
        "end_line": 6654,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeCommandLineParser",
        "snippet": "    clara::Parser makeCommandLineParser( ConfigData& config ) {\n\n        using namespace clara;\n\n        auto const setWarning = [&]( std::string const& warning ) {\n                auto warningSet = [&]() {\n                    if( warning == \"NoAssertions\" )\n                        return WarnAbout::NoAssertions;\n\n                    if ( warning == \"NoTests\" )\n                        return WarnAbout::NoTests;\n\n                    return WarnAbout::Nothing;\n                }();\n\n                if (warningSet == WarnAbout::Nothing)\n                    return ParserResult::runtimeError( \"Unrecognised warning: '\" + warning + \"'\" );\n                config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const loadTestNamesFromFile = [&]( std::string const& filename ) {\n                std::ifstream f( filename.c_str() );\n                if( !f.is_open() )\n                    return ParserResult::runtimeError( \"Unable to load input file: '\" + filename + \"'\" );\n\n                std::string line;\n                while( std::getline( f, line ) ) {\n                    line = trim(line);\n                    if( !line.empty() && !startsWith( line, '#' ) ) {\n                        if( !startsWith( line, '\"' ) )\n                            line = '\"' + line + '\"';\n                        config.testsOrTags.push_back( line + ',' );\n                    }\n                }\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setTestOrder = [&]( std::string const& order ) {\n                if( startsWith( \"declared\", order ) )\n                    config.runOrder = RunTests::InDeclarationOrder;\n                else if( startsWith( \"lexical\", order ) )\n                    config.runOrder = RunTests::InLexicographicalOrder;\n                else if( startsWith( \"random\", order ) )\n                    config.runOrder = RunTests::InRandomOrder;\n                else\n                    return clara::ParserResult::runtimeError( \"Unrecognised ordering: '\" + order + \"'\" );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setRngSeed = [&]( std::string const& seed ) {\n                if( seed != \"time\" )\n                    return clara::detail::convertInto( seed, config.rngSeed );\n                config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setColourUsage = [&]( std::string const& useColour ) {\n                    auto mode = toLower( useColour );\n\n                    if( mode == \"yes\" )\n                        config.useColour = UseColour::Yes;\n                    else if( mode == \"no\" )\n                        config.useColour = UseColour::No;\n                    else if( mode == \"auto\" )\n                        config.useColour = UseColour::Auto;\n                    else\n                        return ParserResult::runtimeError( \"colour mode must be one of: auto, yes or no. '\" + useColour + \"' not recognised\" );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setWaitForKeypress = [&]( std::string const& keypress ) {\n                auto keypressLc = toLower( keypress );\n                if( keypressLc == \"start\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeStart;\n                else if( keypressLc == \"exit\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeExit;\n                else if( keypressLc == \"both\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;\n                else\n                    return ParserResult::runtimeError( \"keypress argument must be one of: start, exit or both. '\" + keypress + \"' not recognised\" );\n            return ParserResult::ok( ParseResultType::Matched );\n            };\n        auto const setVerbosity = [&]( std::string const& verbosity ) {\n            auto lcVerbosity = toLower( verbosity );\n            if( lcVerbosity == \"quiet\" )\n                config.verbosity = Verbosity::Quiet;\n            else if( lcVerbosity == \"normal\" )\n                config.verbosity = Verbosity::Normal;\n            else if( lcVerbosity == \"high\" )\n                config.verbosity = Verbosity::High;\n            else\n                return ParserResult::runtimeError( \"Unrecognised verbosity, '\" + verbosity + \"'\" );\n            return ParserResult::ok( ParseResultType::Matched );\n        };\n\n        auto cli\n            = ExeName( config.processName )\n            | Help( config.showHelp )\n            | Opt( config.listTests )\n                [\"-l\"][\"--list-tests\"]\n                ( \"list all/matching test cases\" )\n            | Opt( config.listTags )\n                [\"-t\"][\"--list-tags\"]\n                ( \"list all/matching tags\" )\n            | Opt( config.showSuccessfulTests )\n                [\"-s\"][\"--success\"]\n                ( \"include successful tests in output\" )\n            | Opt( config.shouldDebugBreak )\n                [\"-b\"][\"--break\"]\n                ( \"break into debugger on failure\" )\n            | Opt( config.noThrow )\n                [\"-e\"][\"--nothrow\"]\n                ( \"skip exception tests\" )\n            | Opt( config.showInvisibles )\n                [\"-i\"][\"--invisibles\"]\n                ( \"show invisibles (tabs, newlines)\" )\n            | Opt( config.outputFilename, \"filename\" )\n                [\"-o\"][\"--out\"]\n                ( \"output filename\" )\n            | Opt( config.reporterNames, \"name\" )\n                [\"-r\"][\"--reporter\"]\n                ( \"reporter to use (defaults to console)\" )\n            | Opt( config.name, \"name\" )\n                [\"-n\"][\"--name\"]\n                ( \"suite name\" )\n            | Opt( [&]( bool ){ config.abortAfter = 1; } )\n                [\"-a\"][\"--abort\"]\n                ( \"abort at first failure\" )\n            | Opt( [&]( int x ){ config.abortAfter = x; }, \"no. failures\" )\n                [\"-x\"][\"--abortx\"]\n                ( \"abort after x failures\" )\n            | Opt( setWarning, \"warning name\" )\n                [\"-w\"][\"--warn\"]\n                ( \"enable warnings\" )\n            | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, \"yes|no\" )\n                [\"-d\"][\"--durations\"]\n                ( \"show test durations\" )\n            | Opt( loadTestNamesFromFile, \"filename\" )\n                [\"-f\"][\"--input-file\"]\n                ( \"load test names to run from a file\" )\n            | Opt( config.filenamesAsTags )\n                [\"-#\"][\"--filenames-as-tags\"]\n                ( \"adds a tag for the filename\" )\n            | Opt( config.sectionsToRun, \"section name\" )\n                [\"-c\"][\"--section\"]\n                ( \"specify section to run\" )\n            | Opt( setVerbosity, \"quiet|normal|high\" )\n                [\"-v\"][\"--verbosity\"]\n                ( \"set output verbosity\" )\n            | Opt( config.listTestNamesOnly )\n                [\"--list-test-names-only\"]\n                ( \"list all/matching test cases names only\" )\n            | Opt( config.listReporters )\n                [\"--list-reporters\"]\n                ( \"list all reporters\" )\n            | Opt( setTestOrder, \"decl|lex|rand\" )\n                [\"--order\"]\n                ( \"test case order (defaults to decl)\" )\n            | Opt( setRngSeed, \"'time'|number\" )\n                [\"--rng-seed\"]\n                ( \"set a specific seed for random numbers\" )\n            | Opt( setColourUsage, \"yes|no\" )\n                [\"--use-colour\"]\n                ( \"should output be colourised\" )\n            | Opt( config.libIdentify )\n                [\"--libidentify\"]\n                ( \"report name and version according to libidentify standard\" )\n            | Opt( setWaitForKeypress, \"start|exit|both\" )\n                [\"--wait-for-keypress\"]\n                ( \"waits for a keypress before exiting\" )\n            | Opt( config.benchmarkResolutionMultiple, \"multiplier\" )\n                [\"--benchmark-resolution-multiple\"]\n                ( \"multiple of clock resolution to run benchmarks\" )\n\n            | Arg( config.testsOrTags, \"test name|pattern|tags\" )\n                ( \"which test or tests to use\" );\n\n        return cli;\n    }\n"
    },
    {
        "begin_line": 6484,
        "end_line": 6499,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0502",
        "snippet": "        auto const setWarning = [&]( std::string const& warning ) {\n                auto warningSet = [&]() {\n                    if( warning == \"NoAssertions\" )\n                        return WarnAbout::NoAssertions;\n\n                    if ( warning == \"NoTests\" )\n                        return WarnAbout::NoTests;\n\n                    return WarnAbout::Nothing;\n                }();\n\n                if (warningSet == WarnAbout::Nothing)\n                    return ParserResult::runtimeError( \"Unrecognised warning: '\" + warning + \"'\" );\n                config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n"
    },
    {
        "begin_line": 6485,
        "end_line": 6493,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0602",
        "snippet": "                auto warningSet = [&]() {\n                    if( warning == \"NoAssertions\" )\n                        return WarnAbout::NoAssertions;\n\n                    if ( warning == \"NoTests\" )\n                        return WarnAbout::NoTests;\n\n                    return WarnAbout::Nothing;\n                }();\n"
    },
    {
        "begin_line": 6500,
        "end_line": 6515,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0702",
        "snippet": "        auto const loadTestNamesFromFile = [&]( std::string const& filename ) {\n                std::ifstream f( filename.c_str() );\n                if( !f.is_open() )\n                    return ParserResult::runtimeError( \"Unable to load input file: '\" + filename + \"'\" );\n\n                std::string line;\n                while( std::getline( f, line ) ) {\n                    line = trim(line);\n                    if( !line.empty() && !startsWith( line, '#' ) ) {\n                        if( !startsWith( line, '\"' ) )\n                            line = '\"' + line + '\"';\n                        config.testsOrTags.push_back( line + ',' );\n                    }\n                }\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n"
    },
    {
        "begin_line": 6516,
        "end_line": 6526,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0802",
        "snippet": "        auto const setTestOrder = [&]( std::string const& order ) {\n                if( startsWith( \"declared\", order ) )\n                    config.runOrder = RunTests::InDeclarationOrder;\n                else if( startsWith( \"lexical\", order ) )\n                    config.runOrder = RunTests::InLexicographicalOrder;\n                else if( startsWith( \"random\", order ) )\n                    config.runOrder = RunTests::InRandomOrder;\n                else\n                    return clara::ParserResult::runtimeError( \"Unrecognised ordering: '\" + order + \"'\" );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n"
    },
    {
        "begin_line": 6527,
        "end_line": 6532,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0902",
        "snippet": "        auto const setRngSeed = [&]( std::string const& seed ) {\n                if( seed != \"time\" )\n                    return clara::detail::convertInto( seed, config.rngSeed );\n                config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n"
    },
    {
        "begin_line": 6533,
        "end_line": 6545,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0a02",
        "snippet": "        auto const setColourUsage = [&]( std::string const& useColour ) {\n                    auto mode = toLower( useColour );\n\n                    if( mode == \"yes\" )\n                        config.useColour = UseColour::Yes;\n                    else if( mode == \"no\" )\n                        config.useColour = UseColour::No;\n                    else if( mode == \"auto\" )\n                        config.useColour = UseColour::Auto;\n                    else\n                        return ParserResult::runtimeError( \"colour mode must be one of: auto, yes or no. '\" + useColour + \"' not recognised\" );\n                return ParserResult::ok( ParseResultType::Matched );\n            };\n"
    },
    {
        "begin_line": 6546,
        "end_line": 6557,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0b02",
        "snippet": "        auto const setWaitForKeypress = [&]( std::string const& keypress ) {\n                auto keypressLc = toLower( keypress );\n                if( keypressLc == \"start\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeStart;\n                else if( keypressLc == \"exit\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeExit;\n                else if( keypressLc == \"both\" )\n                    config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;\n                else\n                    return ParserResult::runtimeError( \"keypress argument must be one of: start, exit or both. '\" + keypress + \"' not recognised\" );\n            return ParserResult::ok( ParseResultType::Matched );\n            };\n"
    },
    {
        "begin_line": 6558,
        "end_line": 6569,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0c02",
        "snippet": "        auto const setVerbosity = [&]( std::string const& verbosity ) {\n            auto lcVerbosity = toLower( verbosity );\n            if( lcVerbosity == \"quiet\" )\n                config.verbosity = Verbosity::Quiet;\n            else if( lcVerbosity == \"normal\" )\n                config.verbosity = Verbosity::Normal;\n            else if( lcVerbosity == \"high\" )\n                config.verbosity = Verbosity::High;\n            else\n                return ParserResult::runtimeError( \"Unrecognised verbosity, '\" + verbosity + \"'\" );\n            return ParserResult::ok( ParseResultType::Matched );\n        };\n"
    },
    {
        "begin_line": 6601,
        "end_line": 6601,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0d02",
        "snippet": "            | Opt( [&]( bool ){ config.abortAfter = 1; } )\n"
    },
    {
        "begin_line": 6604,
        "end_line": 6604,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0e02",
        "snippet": "            | Opt( [&]( int x ){ config.abortAfter = x; }, \"no. failures\" )\n"
    },
    {
        "begin_line": 6610,
        "end_line": 6610,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b0f02",
        "snippet": "            | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, \"yes|no\" )\n"
    },
    {
        "begin_line": 6663,
        "end_line": 6691,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    bool SourceLineInfo::empty() const noexcept {\n        return file[0] == '\\0';\n    }\n    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const noexcept {\n        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);\n    }\n    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const noexcept {\n        return line < other.line || ( line == other.line && (std::strcmp(file, other.file) < 0));\n    }\n\n    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {\n#ifndef __GNUG__\n        os << info.file << '(' << info.line << ')';\n#else\n        os << info.file << ':' << info.line;\n#endif\n        return os;\n    }\n\n    std::string StreamEndStop::operator+() const {\n        return std::string();\n    }\n\n    NonCopyable::NonCopyable() = default;\n    NonCopyable::~NonCopyable() = default;\n\n}\n"
    },
    {
        "begin_line": 6665,
        "end_line": 6667,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "empty",
        "snippet": "    bool SourceLineInfo::empty() const noexcept {\n        return file[0] == '\\0';\n    }\n"
    },
    {
        "begin_line": 6668,
        "end_line": 6670,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const noexcept {\n        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);\n    }\n"
    },
    {
        "begin_line": 6671,
        "end_line": 6673,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <",
        "snippet": "    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const noexcept {\n        return line < other.line || ( line == other.line && (std::strcmp(file, other.file) < 0));\n    }\n"
    },
    {
        "begin_line": 6675,
        "end_line": 6682,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {\n#ifndef __GNUG__\n        os << info.file << '(' << info.line << ')';\n#else\n        os << info.file << ':' << info.line;\n#endif\n        return os;\n    }\n"
    },
    {
        "begin_line": 6684,
        "end_line": 6686,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "    std::string StreamEndStop::operator+() const {\n        return std::string();\n    }\n"
    },
    {
        "begin_line": 6699,
        "end_line": 6700,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_PREPARE_EXCEPTION",
        "snippet": "#define CATCH_PREPARE_EXCEPTION( type, msg ) \\\n    type( ( Catch::ReusableStringStream() << msg ).str() )\n"
    },
    {
        "begin_line": 6701,
        "end_line": 6702,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INTERNAL_ERROR",
        "snippet": "#define CATCH_INTERNAL_ERROR( msg ) \\\n    throw CATCH_PREPARE_EXCEPTION( std::logic_error, CATCH_INTERNAL_LINEINFO << \": Internal Catch error: \" << msg);\n"
    },
    {
        "begin_line": 6703,
        "end_line": 6704,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ERROR",
        "snippet": "#define CATCH_ERROR( msg ) \\\n    throw CATCH_PREPARE_EXCEPTION( std::domain_error, msg )\n"
    },
    {
        "begin_line": 6705,
        "end_line": 6706,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ENFORCE",
        "snippet": "#define CATCH_ENFORCE( condition, msg ) \\\n    do{ if( !(condition) ) CATCH_ERROR( msg ); } while(false)\n"
    },
    {
        "begin_line": 6709,
        "end_line": 6768,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    Config::Config( ConfigData const& data )\n    :   m_data( data ),\n        m_stream( openStream() )\n    {\n        TestSpecParser parser(ITagAliasRegistry::get());\n        if (data.testsOrTags.empty()) {\n            parser.parse(\"~[.]\"); // All not hidden tests\n        }\n        else {\n            m_hasTestFilters = true;\n            for( auto const& testOrTags : data.testsOrTags )\n                parser.parse( testOrTags );\n        }\n        m_testSpec = parser.testSpec();\n    }\n\n    std::string const& Config::getFilename() const {\n        return m_data.outputFilename ;\n    }\n\n    bool Config::listTests() const          { return m_data.listTests; }\n    bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }\n    bool Config::listTags() const           { return m_data.listTags; }\n    bool Config::listReporters() const      { return m_data.listReporters; }\n\n    std::string Config::getProcessName() const { return m_data.processName; }\n\n    std::vector<std::string> const& Config::getReporterNames() const { return m_data.reporterNames; }\n    std::vector<std::string> const& Config::getTestsOrTags() const { return m_data.testsOrTags; }\n    std::vector<std::string> const& Config::getSectionsToRun() const { return m_data.sectionsToRun; }\n\n    TestSpec const& Config::testSpec() const { return m_testSpec; }\n    bool Config::hasTestFilters() const { return m_hasTestFilters; }\n\n    bool Config::showHelp() const { return m_data.showHelp; }\n\n    // IConfig interface\n    bool Config::allowThrows() const                   { return !m_data.noThrow; }\n    std::ostream& Config::stream() const               { return m_stream->stream(); }\n    std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }\n    bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }\n    bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings & WarnAbout::NoAssertions); }\n    bool Config::warnAboutNoTests() const              { return !!(m_data.warnings & WarnAbout::NoTests); }\n    ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }\n    RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }\n    unsigned int Config::rngSeed() const               { return m_data.rngSeed; }\n    int Config::benchmarkResolutionMultiple() const    { return m_data.benchmarkResolutionMultiple; }\n    UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }\n    bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }\n    int Config::abortAfter() const                     { return m_data.abortAfter; }\n    bool Config::showInvisibles() const                { return m_data.showInvisibles; }\n    Verbosity Config::verbosity() const                { return m_data.verbosity; }\n\n    IStream const* Config::openStream() {\n        return Catch::makeStream(m_data.outputFilename);\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 6711,
        "end_line": 6725,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Config",
        "snippet": "    Config::Config( ConfigData const& data )\n    :   m_data( data ),\n        m_stream( openStream() )\n    {\n        TestSpecParser parser(ITagAliasRegistry::get());\n        if (data.testsOrTags.empty()) {\n            parser.parse(\"~[.]\"); // All not hidden tests\n        }\n        else {\n            m_hasTestFilters = true;\n            for( auto const& testOrTags : data.testsOrTags )\n                parser.parse( testOrTags );\n        }\n        m_testSpec = parser.testSpec();\n    }\n"
    },
    {
        "begin_line": 6727,
        "end_line": 6729,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getFilename",
        "snippet": "    std::string const& Config::getFilename() const {\n        return m_data.outputFilename ;\n    }\n"
    },
    {
        "begin_line": 6731,
        "end_line": 6731,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTests",
        "snippet": "    bool Config::listTests() const          { return m_data.listTests; }\n"
    },
    {
        "begin_line": 6732,
        "end_line": 6732,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTestNamesOnly",
        "snippet": "    bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }\n"
    },
    {
        "begin_line": 6733,
        "end_line": 6733,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTags",
        "snippet": "    bool Config::listTags() const           { return m_data.listTags; }\n"
    },
    {
        "begin_line": 6734,
        "end_line": 6734,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listReporters",
        "snippet": "    bool Config::listReporters() const      { return m_data.listReporters; }\n"
    },
    {
        "begin_line": 6736,
        "end_line": 6736,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getProcessName",
        "snippet": "    std::string Config::getProcessName() const { return m_data.processName; }\n"
    },
    {
        "begin_line": 6738,
        "end_line": 6738,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getReporterNames",
        "snippet": "    std::vector<std::string> const& Config::getReporterNames() const { return m_data.reporterNames; }\n"
    },
    {
        "begin_line": 6739,
        "end_line": 6739,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getTestsOrTags",
        "snippet": "    std::vector<std::string> const& Config::getTestsOrTags() const { return m_data.testsOrTags; }\n"
    },
    {
        "begin_line": 6740,
        "end_line": 6740,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getSectionsToRun",
        "snippet": "    std::vector<std::string> const& Config::getSectionsToRun() const { return m_data.sectionsToRun; }\n"
    },
    {
        "begin_line": 6742,
        "end_line": 6742,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testSpec",
        "snippet": "    TestSpec const& Config::testSpec() const { return m_testSpec; }\n"
    },
    {
        "begin_line": 6743,
        "end_line": 6743,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hasTestFilters",
        "snippet": "    bool Config::hasTestFilters() const { return m_hasTestFilters; }\n"
    },
    {
        "begin_line": 6745,
        "end_line": 6745,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showHelp",
        "snippet": "    bool Config::showHelp() const { return m_data.showHelp; }\n"
    },
    {
        "begin_line": 6748,
        "end_line": 6748,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "allowThrows",
        "snippet": "    bool Config::allowThrows() const                   { return !m_data.noThrow; }\n"
    },
    {
        "begin_line": 6749,
        "end_line": 6749,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "    std::ostream& Config::stream() const               { return m_stream->stream(); }\n"
    },
    {
        "begin_line": 6750,
        "end_line": 6750,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "    std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }\n"
    },
    {
        "begin_line": 6751,
        "end_line": 6751,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "includeSuccessfulResults",
        "snippet": "    bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }\n"
    },
    {
        "begin_line": 6752,
        "end_line": 6752,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "warnAboutMissingAssertions",
        "snippet": "    bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings & WarnAbout::NoAssertions); }\n"
    },
    {
        "begin_line": 6753,
        "end_line": 6753,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "warnAboutNoTests",
        "snippet": "    bool Config::warnAboutNoTests() const              { return !!(m_data.warnings & WarnAbout::NoTests); }\n"
    },
    {
        "begin_line": 6754,
        "end_line": 6754,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showDurations",
        "snippet": "    ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }\n"
    },
    {
        "begin_line": 6755,
        "end_line": 6755,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runOrder",
        "snippet": "    RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }\n"
    },
    {
        "begin_line": 6756,
        "end_line": 6756,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rngSeed",
        "snippet": "    unsigned int Config::rngSeed() const               { return m_data.rngSeed; }\n"
    },
    {
        "begin_line": 6757,
        "end_line": 6757,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkResolutionMultiple",
        "snippet": "    int Config::benchmarkResolutionMultiple() const    { return m_data.benchmarkResolutionMultiple; }\n"
    },
    {
        "begin_line": 6758,
        "end_line": 6758,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "useColour",
        "snippet": "    UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }\n"
    },
    {
        "begin_line": 6759,
        "end_line": 6759,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shouldDebugBreak",
        "snippet": "    bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }\n"
    },
    {
        "begin_line": 6760,
        "end_line": 6760,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "abortAfter",
        "snippet": "    int Config::abortAfter() const                     { return m_data.abortAfter; }\n"
    },
    {
        "begin_line": 6761,
        "end_line": 6761,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showInvisibles",
        "snippet": "    bool Config::showInvisibles() const                { return m_data.showInvisibles; }\n"
    },
    {
        "begin_line": 6762,
        "end_line": 6762,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "verbosity",
        "snippet": "    Verbosity Config::verbosity() const                { return m_data.verbosity; }\n"
    },
    {
        "begin_line": 6764,
        "end_line": 6766,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "openStream",
        "snippet": "    IStream const* Config::openStream() {\n        return Catch::makeStream(m_data.outputFilename);\n    }\n"
    },
    {
        "begin_line": 6779,
        "end_line": 6789,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class ErrnoGuard {\n    public:\n        ErrnoGuard();\n        ~ErrnoGuard();\n    private:\n        int m_oldErrno;\n    };\n\n}\n"
    },
    {
        "begin_line": 6781,
        "end_line": 6787,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ErrnoGuard",
        "snippet": "    class ErrnoGuard {\n    public:\n        ErrnoGuard();\n        ~ErrnoGuard();\n    private:\n        int m_oldErrno;\n    };\n"
    },
    {
        "begin_line": 6786,
        "end_line": 6786,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_oldErrno",
        "snippet": "        int m_oldErrno;\n"
    },
    {
        "begin_line": 6794,
        "end_line": 6812,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    namespace {\n\n        struct IColourImpl {\n            virtual ~IColourImpl() = default;\n            virtual void use( Colour::Code _colourCode ) = 0;\n        };\n\n        struct NoColourImpl : IColourImpl {\n            void use( Colour::Code ) {}\n\n            static IColourImpl* instance() {\n                static NoColourImpl s_instance;\n                return &s_instance;\n            }\n        };\n\n    } // anon namespace\n} // namespace Catch\n"
    },
    {
        "begin_line": 6795,
        "end_line": 6811,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1011",
        "snippet": "    namespace {\n\n        struct IColourImpl {\n            virtual ~IColourImpl() = default;\n            virtual void use( Colour::Code _colourCode ) = 0;\n        };\n\n        struct NoColourImpl : IColourImpl {\n            void use( Colour::Code ) {}\n\n            static IColourImpl* instance() {\n                static NoColourImpl s_instance;\n                return &s_instance;\n            }\n        };\n\n    } // anon namespace\n"
    },
    {
        "begin_line": 6797,
        "end_line": 6800,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IColourImpl",
        "snippet": "        struct IColourImpl {\n            virtual ~IColourImpl() = default;\n            virtual void use( Colour::Code _colourCode ) = 0;\n        };\n"
    },
    {
        "begin_line": 6802,
        "end_line": 6809,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NoColourImpl",
        "snippet": "        struct NoColourImpl : IColourImpl {\n            void use( Colour::Code ) {}\n\n            static IColourImpl* instance() {\n                static NoColourImpl s_instance;\n                return &s_instance;\n            }\n        };\n"
    },
    {
        "begin_line": 6803,
        "end_line": 6803,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "use",
        "snippet": "            void use( Colour::Code ) {}\n"
    },
    {
        "begin_line": 6805,
        "end_line": 6808,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "instance",
        "snippet": "            static IColourImpl* instance() {\n                static NoColourImpl s_instance;\n                return &s_instance;\n            }\n"
    },
    {
        "begin_line": 6816,
        "end_line": 6816,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_COLOUR_WINDOWS",
        "snippet": "#       define CATCH_CONFIG_COLOUR_WINDOWS\n"
    },
    {
        "begin_line": 6818,
        "end_line": 6818,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_COLOUR_ANSI",
        "snippet": "#       define CATCH_CONFIG_COLOUR_ANSI\n"
    },
    {
        "begin_line": 6824,
        "end_line": 6885,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace {\n\n    class Win32ColourImpl : public IColourImpl {\n    public:\n        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )\n        {\n            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\n            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );\n            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\n            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\n        }\n\n        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:      return setTextAttribute( originalForegroundAttributes );\n                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );\n                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );\n                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );\n                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\n                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\n                case Colour::Grey:      return setTextAttribute( 0 );\n\n                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );\n                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\n                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\n                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n\n                default:\n                    CATCH_ERROR( \"Unknown colour requested\" );\n            }\n        }\n\n    private:\n        void setTextAttribute( WORD _textAttribute ) {\n            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );\n        }\n        HANDLE stdoutHandle;\n        WORD originalForegroundAttributes;\n        WORD originalBackgroundAttributes;\n    };\n\n    IColourImpl* platformColourInstance() {\n        static Win32ColourImpl s_instance;\n\n        IConfigPtr config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = UseColour::Yes;\n        return colourMode == UseColour::Yes\n            ? &s_instance\n            : NoColourImpl::instance();\n    }\n\n} // end anon namespace\n} // end namespace Catch\n"
    },
    {
        "begin_line": 6825,
        "end_line": 6884,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1111",
        "snippet": "namespace {\n\n    class Win32ColourImpl : public IColourImpl {\n    public:\n        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )\n        {\n            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\n            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );\n            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\n            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\n        }\n\n        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:      return setTextAttribute( originalForegroundAttributes );\n                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );\n                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );\n                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );\n                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\n                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\n                case Colour::Grey:      return setTextAttribute( 0 );\n\n                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );\n                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\n                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\n                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n\n                default:\n                    CATCH_ERROR( \"Unknown colour requested\" );\n            }\n        }\n\n    private:\n        void setTextAttribute( WORD _textAttribute ) {\n            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );\n        }\n        HANDLE stdoutHandle;\n        WORD originalForegroundAttributes;\n        WORD originalBackgroundAttributes;\n    };\n\n    IColourImpl* platformColourInstance() {\n        static Win32ColourImpl s_instance;\n\n        IConfigPtr config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = UseColour::Yes;\n        return colourMode == UseColour::Yes\n            ? &s_instance\n            : NoColourImpl::instance();\n    }\n\n} // end anon namespace\n"
    },
    {
        "begin_line": 6827,
        "end_line": 6868,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Win32ColourImpl",
        "snippet": "    class Win32ColourImpl : public IColourImpl {\n    public:\n        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )\n        {\n            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\n            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );\n            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\n            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\n        }\n\n        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:      return setTextAttribute( originalForegroundAttributes );\n                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );\n                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );\n                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );\n                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\n                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\n                case Colour::Grey:      return setTextAttribute( 0 );\n\n                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );\n                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\n                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\n                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n\n                default:\n                    CATCH_ERROR( \"Unknown colour requested\" );\n            }\n        }\n\n    private:\n        void setTextAttribute( WORD _textAttribute ) {\n            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );\n        }\n        HANDLE stdoutHandle;\n        WORD originalForegroundAttributes;\n        WORD originalBackgroundAttributes;\n    };\n"
    },
    {
        "begin_line": 6829,
        "end_line": 6835,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Win32ColourImpl",
        "snippet": "        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )\n        {\n            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\n            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );\n            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\n            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\n        }\n"
    },
    {
        "begin_line": 6837,
        "end_line": 6859,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "use",
        "snippet": "        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:      return setTextAttribute( originalForegroundAttributes );\n                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );\n                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );\n                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );\n                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\n                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\n                case Colour::Grey:      return setTextAttribute( 0 );\n\n                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );\n                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\n                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\n                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n\n                default:\n                    CATCH_ERROR( \"Unknown colour requested\" );\n            }\n        }\n"
    },
    {
        "begin_line": 6862,
        "end_line": 6864,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setTextAttribute",
        "snippet": "        void setTextAttribute( WORD _textAttribute ) {\n            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );\n        }\n"
    },
    {
        "begin_line": 6865,
        "end_line": 6865,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stdoutHandle",
        "snippet": "        HANDLE stdoutHandle;\n"
    },
    {
        "begin_line": 6866,
        "end_line": 6866,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "originalForegroundAttributes",
        "snippet": "        WORD originalForegroundAttributes;\n"
    },
    {
        "begin_line": 6867,
        "end_line": 6867,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "originalBackgroundAttributes",
        "snippet": "        WORD originalBackgroundAttributes;\n"
    },
    {
        "begin_line": 6870,
        "end_line": 6882,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "platformColourInstance",
        "snippet": "    IColourImpl* platformColourInstance() {\n        static Win32ColourImpl s_instance;\n\n        IConfigPtr config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = UseColour::Yes;\n        return colourMode == UseColour::Yes\n            ? &s_instance\n            : NoColourImpl::instance();\n    }\n"
    },
    {
        "begin_line": 6891,
        "end_line": 6960,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace {\n\n    // use POSIX/ ANSI console terminal codes\n    // Thanks to Adam Strzelecki for original contribution\n    // (http://github.com/nanoant)\n    // https://github.com/philsquared/Catch/pull/131\n    class PosixColourImpl : public IColourImpl {\n    public:\n        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:\n                case Colour::White:     return setColour( \"[0m\" );\n                case Colour::Red:       return setColour( \"[0;31m\" );\n                case Colour::Green:     return setColour( \"[0;32m\" );\n                case Colour::Blue:      return setColour( \"[0;34m\" );\n                case Colour::Cyan:      return setColour( \"[0;36m\" );\n                case Colour::Yellow:    return setColour( \"[0;33m\" );\n                case Colour::Grey:      return setColour( \"[1;30m\" );\n\n                case Colour::LightGrey:     return setColour( \"[0;37m\" );\n                case Colour::BrightRed:     return setColour( \"[1;31m\" );\n                case Colour::BrightGreen:   return setColour( \"[1;32m\" );\n                case Colour::BrightWhite:   return setColour( \"[1;37m\" );\n                case Colour::BrightYellow:  return setColour( \"[1;33m\" );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n                default: CATCH_INTERNAL_ERROR( \"Unknown colour requested\" );\n            }\n        }\n        static IColourImpl* instance() {\n            static PosixColourImpl s_instance;\n            return &s_instance;\n        }\n\n    private:\n        void setColour( const char* _escapeCode ) {\n            Catch::cout() << '\\033' << _escapeCode;\n        }\n    };\n\n    bool useColourOnPlatform() {\n        return\n#ifdef CATCH_PLATFORM_MAC\n            !isDebuggerActive() &&\n#endif\n#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))\n            isatty(STDOUT_FILENO)\n#else\n            false\n#endif\n            ;\n    }\n    IColourImpl* platformColourInstance() {\n        ErrnoGuard guard;\n        IConfigPtr config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = useColourOnPlatform()\n                ? UseColour::Yes\n                : UseColour::No;\n        return colourMode == UseColour::Yes\n            ? PosixColourImpl::instance()\n            : NoColourImpl::instance();\n    }\n\n} // end anon namespace\n} // end namespace Catch\n"
    },
    {
        "begin_line": 6892,
        "end_line": 6959,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1211",
        "snippet": "namespace {\n\n    // use POSIX/ ANSI console terminal codes\n    // Thanks to Adam Strzelecki for original contribution\n    // (http://github.com/nanoant)\n    // https://github.com/philsquared/Catch/pull/131\n    class PosixColourImpl : public IColourImpl {\n    public:\n        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:\n                case Colour::White:     return setColour( \"[0m\" );\n                case Colour::Red:       return setColour( \"[0;31m\" );\n                case Colour::Green:     return setColour( \"[0;32m\" );\n                case Colour::Blue:      return setColour( \"[0;34m\" );\n                case Colour::Cyan:      return setColour( \"[0;36m\" );\n                case Colour::Yellow:    return setColour( \"[0;33m\" );\n                case Colour::Grey:      return setColour( \"[1;30m\" );\n\n                case Colour::LightGrey:     return setColour( \"[0;37m\" );\n                case Colour::BrightRed:     return setColour( \"[1;31m\" );\n                case Colour::BrightGreen:   return setColour( \"[1;32m\" );\n                case Colour::BrightWhite:   return setColour( \"[1;37m\" );\n                case Colour::BrightYellow:  return setColour( \"[1;33m\" );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n                default: CATCH_INTERNAL_ERROR( \"Unknown colour requested\" );\n            }\n        }\n        static IColourImpl* instance() {\n            static PosixColourImpl s_instance;\n            return &s_instance;\n        }\n\n    private:\n        void setColour( const char* _escapeCode ) {\n            Catch::cout() << '\\033' << _escapeCode;\n        }\n    };\n\n    bool useColourOnPlatform() {\n        return\n#ifdef CATCH_PLATFORM_MAC\n            !isDebuggerActive() &&\n#endif\n#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))\n            isatty(STDOUT_FILENO)\n#else\n            false\n#endif\n            ;\n    }\n    IColourImpl* platformColourInstance() {\n        ErrnoGuard guard;\n        IConfigPtr config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = useColourOnPlatform()\n                ? UseColour::Yes\n                : UseColour::No;\n        return colourMode == UseColour::Yes\n            ? PosixColourImpl::instance()\n            : NoColourImpl::instance();\n    }\n\n} // end anon namespace\n"
    },
    {
        "begin_line": 6898,
        "end_line": 6930,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "PosixColourImpl",
        "snippet": "    class PosixColourImpl : public IColourImpl {\n    public:\n        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:\n                case Colour::White:     return setColour( \"[0m\" );\n                case Colour::Red:       return setColour( \"[0;31m\" );\n                case Colour::Green:     return setColour( \"[0;32m\" );\n                case Colour::Blue:      return setColour( \"[0;34m\" );\n                case Colour::Cyan:      return setColour( \"[0;36m\" );\n                case Colour::Yellow:    return setColour( \"[0;33m\" );\n                case Colour::Grey:      return setColour( \"[1;30m\" );\n\n                case Colour::LightGrey:     return setColour( \"[0;37m\" );\n                case Colour::BrightRed:     return setColour( \"[1;31m\" );\n                case Colour::BrightGreen:   return setColour( \"[1;32m\" );\n                case Colour::BrightWhite:   return setColour( \"[1;37m\" );\n                case Colour::BrightYellow:  return setColour( \"[1;33m\" );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n                default: CATCH_INTERNAL_ERROR( \"Unknown colour requested\" );\n            }\n        }\n        static IColourImpl* instance() {\n            static PosixColourImpl s_instance;\n            return &s_instance;\n        }\n\n    private:\n        void setColour( const char* _escapeCode ) {\n            Catch::cout() << '\\033' << _escapeCode;\n        }\n    };\n"
    },
    {
        "begin_line": 6900,
        "end_line": 6920,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "use",
        "snippet": "        virtual void use( Colour::Code _colourCode ) override {\n            switch( _colourCode ) {\n                case Colour::None:\n                case Colour::White:     return setColour( \"[0m\" );\n                case Colour::Red:       return setColour( \"[0;31m\" );\n                case Colour::Green:     return setColour( \"[0;32m\" );\n                case Colour::Blue:      return setColour( \"[0;34m\" );\n                case Colour::Cyan:      return setColour( \"[0;36m\" );\n                case Colour::Yellow:    return setColour( \"[0;33m\" );\n                case Colour::Grey:      return setColour( \"[1;30m\" );\n\n                case Colour::LightGrey:     return setColour( \"[0;37m\" );\n                case Colour::BrightRed:     return setColour( \"[1;31m\" );\n                case Colour::BrightGreen:   return setColour( \"[1;32m\" );\n                case Colour::BrightWhite:   return setColour( \"[1;37m\" );\n                case Colour::BrightYellow:  return setColour( \"[1;33m\" );\n\n                case Colour::Bright: CATCH_INTERNAL_ERROR( \"not a colour\" );\n                default: CATCH_INTERNAL_ERROR( \"Unknown colour requested\" );\n            }\n        }\n"
    },
    {
        "begin_line": 6921,
        "end_line": 6924,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "instance",
        "snippet": "        static IColourImpl* instance() {\n            static PosixColourImpl s_instance;\n            return &s_instance;\n        }\n"
    },
    {
        "begin_line": 6927,
        "end_line": 6929,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setColour",
        "snippet": "        void setColour( const char* _escapeCode ) {\n            Catch::cout() << '\\033' << _escapeCode;\n        }\n"
    },
    {
        "begin_line": 6932,
        "end_line": 6943,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "useColourOnPlatform",
        "snippet": "    bool useColourOnPlatform() {\n        return\n#ifdef CATCH_PLATFORM_MAC\n            !isDebuggerActive() &&\n#endif\n#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))\n            isatty(STDOUT_FILENO)\n#else\n            false\n#endif\n            ;\n    }\n"
    },
    {
        "begin_line": 6944,
        "end_line": 6957,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "platformColourInstance",
        "snippet": "    IColourImpl* platformColourInstance() {\n        ErrnoGuard guard;\n        IConfigPtr config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = useColourOnPlatform()\n                ? UseColour::Yes\n                : UseColour::No;\n        return colourMode == UseColour::Yes\n            ? PosixColourImpl::instance()\n            : NoColourImpl::instance();\n    }\n"
    },
    {
        "begin_line": 6964,
        "end_line": 6968,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 6966,
        "end_line": 6966,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "platformColourInstance",
        "snippet": "    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }\n"
    },
    {
        "begin_line": 6972,
        "end_line": 6996,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    Colour::Colour( Code _colourCode ) { use( _colourCode ); }\n    Colour::Colour( Colour&& rhs ) noexcept {\n        m_moved = rhs.m_moved;\n        rhs.m_moved = true;\n    }\n    Colour& Colour::operator=( Colour&& rhs ) noexcept {\n        m_moved = rhs.m_moved;\n        rhs.m_moved  = true;\n        return *this;\n    }\n\n    Colour::~Colour(){ if( !m_moved ) use( None ); }\n\n    void Colour::use( Code _colourCode ) {\n        static IColourImpl* impl = platformColourInstance();\n        impl->use( _colourCode );\n    }\n\n    std::ostream& operator << ( std::ostream& os, Colour const& ) {\n        return os;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 6974,
        "end_line": 6974,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Colour",
        "snippet": "    Colour::Colour( Code _colourCode ) { use( _colourCode ); }\n"
    },
    {
        "begin_line": 6975,
        "end_line": 6978,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Colour",
        "snippet": "    Colour::Colour( Colour&& rhs ) noexcept {\n        m_moved = rhs.m_moved;\n        rhs.m_moved = true;\n    }\n"
    },
    {
        "begin_line": 6979,
        "end_line": 6983,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator =",
        "snippet": "    Colour& Colour::operator=( Colour&& rhs ) noexcept {\n        m_moved = rhs.m_moved;\n        rhs.m_moved  = true;\n        return *this;\n    }\n"
    },
    {
        "begin_line": 6985,
        "end_line": 6985,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~Colour",
        "snippet": "    Colour::~Colour(){ if( !m_moved ) use( None ); }\n"
    },
    {
        "begin_line": 6987,
        "end_line": 6990,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "use",
        "snippet": "    void Colour::use( Code _colourCode ) {\n        static IColourImpl* impl = platformColourInstance();\n        impl->use( _colourCode );\n    }\n"
    },
    {
        "begin_line": 6992,
        "end_line": 6994,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    std::ostream& operator << ( std::ostream& os, Colour const& ) {\n        return os;\n    }\n"
    },
    {
        "begin_line": 7005,
        "end_line": 7056,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class Context : public IMutableContext, NonCopyable {\n\n    public: // IContext\n        virtual IResultCapture* getResultCapture() override {\n            return m_resultCapture;\n        }\n        virtual IRunner* getRunner() override {\n            return m_runner;\n        }\n\n        virtual IConfigPtr const& getConfig() const override {\n            return m_config;\n        }\n\n        virtual ~Context() override;\n\n    public: // IMutableContext\n        virtual void setResultCapture( IResultCapture* resultCapture ) override {\n            m_resultCapture = resultCapture;\n        }\n        virtual void setRunner( IRunner* runner ) override {\n            m_runner = runner;\n        }\n        virtual void setConfig( IConfigPtr const& config ) override {\n            m_config = config;\n        }\n\n        friend IMutableContext& getCurrentMutableContext();\n\n    private:\n        IConfigPtr m_config;\n        IRunner* m_runner = nullptr;\n        IResultCapture* m_resultCapture = nullptr;\n    };\n\n    IMutableContext *IMutableContext::currentContext = nullptr;\n\n    void IMutableContext::createContext()\n    {\n        currentContext = new Context();\n    }\n\n    void cleanUpContext() {\n        delete IMutableContext::currentContext;\n        IMutableContext::currentContext = nullptr;\n    }\n    IContext::~IContext() = default;\n    IMutableContext::~IMutableContext() = default;\n    Context::~Context() = default;\n}\n"
    },
    {
        "begin_line": 7007,
        "end_line": 7040,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Context",
        "snippet": "    class Context : public IMutableContext, NonCopyable {\n\n    public: // IContext\n        virtual IResultCapture* getResultCapture() override {\n            return m_resultCapture;\n        }\n        virtual IRunner* getRunner() override {\n            return m_runner;\n        }\n\n        virtual IConfigPtr const& getConfig() const override {\n            return m_config;\n        }\n\n        virtual ~Context() override;\n\n    public: // IMutableContext\n        virtual void setResultCapture( IResultCapture* resultCapture ) override {\n            m_resultCapture = resultCapture;\n        }\n        virtual void setRunner( IRunner* runner ) override {\n            m_runner = runner;\n        }\n        virtual void setConfig( IConfigPtr const& config ) override {\n            m_config = config;\n        }\n\n        friend IMutableContext& getCurrentMutableContext();\n\n    private:\n        IConfigPtr m_config;\n        IRunner* m_runner = nullptr;\n        IResultCapture* m_resultCapture = nullptr;\n    };\n"
    },
    {
        "begin_line": 7010,
        "end_line": 7012,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getResultCapture",
        "snippet": "        virtual IResultCapture* getResultCapture() override {\n            return m_resultCapture;\n        }\n"
    },
    {
        "begin_line": 7013,
        "end_line": 7015,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getRunner",
        "snippet": "        virtual IRunner* getRunner() override {\n            return m_runner;\n        }\n"
    },
    {
        "begin_line": 7017,
        "end_line": 7019,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getConfig",
        "snippet": "        virtual IConfigPtr const& getConfig() const override {\n            return m_config;\n        }\n"
    },
    {
        "begin_line": 7024,
        "end_line": 7026,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setResultCapture",
        "snippet": "        virtual void setResultCapture( IResultCapture* resultCapture ) override {\n            m_resultCapture = resultCapture;\n        }\n"
    },
    {
        "begin_line": 7027,
        "end_line": 7029,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setRunner",
        "snippet": "        virtual void setRunner( IRunner* runner ) override {\n            m_runner = runner;\n        }\n"
    },
    {
        "begin_line": 7030,
        "end_line": 7032,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setConfig",
        "snippet": "        virtual void setConfig( IConfigPtr const& config ) override {\n            m_config = config;\n        }\n"
    },
    {
        "begin_line": 7037,
        "end_line": 7037,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_config",
        "snippet": "        IConfigPtr m_config;\n"
    },
    {
        "begin_line": 7038,
        "end_line": 7038,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_runner",
        "snippet": "        IRunner* m_runner = nullptr;\n"
    },
    {
        "begin_line": 7039,
        "end_line": 7039,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_resultCapture",
        "snippet": "        IResultCapture* m_resultCapture = nullptr;\n"
    },
    {
        "begin_line": 7042,
        "end_line": 7042,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "currentContext",
        "snippet": "    IMutableContext *IMutableContext::currentContext = nullptr;\n"
    },
    {
        "begin_line": 7044,
        "end_line": 7047,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "createContext",
        "snippet": "    void IMutableContext::createContext()\n    {\n        currentContext = new Context();\n    }\n"
    },
    {
        "begin_line": 7049,
        "end_line": 7052,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cleanUpContext",
        "snippet": "    void cleanUpContext() {\n        delete IMutableContext::currentContext;\n        IMutableContext::currentContext = nullptr;\n    }\n"
    },
    {
        "begin_line": 7064,
        "end_line": 7066,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    void writeToDebugConsole( std::string const& text );\n}\n"
    },
    {
        "begin_line": 7071,
        "end_line": 7075,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "    namespace Catch {\n        void writeToDebugConsole( std::string const& text ) {\n            ::OutputDebugStringA( text.c_str() );\n        }\n    }\n"
    },
    {
        "begin_line": 7072,
        "end_line": 7074,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeToDebugConsole",
        "snippet": "        void writeToDebugConsole( std::string const& text ) {\n            ::OutputDebugStringA( text.c_str() );\n        }\n"
    },
    {
        "begin_line": 7079,
        "end_line": 7084,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "    namespace Catch {\n        void writeToDebugConsole( std::string const& text ) {\n            // !TBD: Need a version for Mac/ XCode and other IDEs\n            Catch::cout() << text;\n        }\n    }\n"
    },
    {
        "begin_line": 7080,
        "end_line": 7083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeToDebugConsole",
        "snippet": "        void writeToDebugConsole( std::string const& text ) {\n            // !TBD: Need a version for Mac/ XCode and other IDEs\n            Catch::cout() << text;\n        }\n"
    },
    {
        "begin_line": 7100,
        "end_line": 7138,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n        // The following function is taken directly from the following technical note:\n        // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html\n\n        // Returns true if the current process is being debugged (either\n        // running under the debugger or has a debugger attached post facto).\n        bool isDebuggerActive(){\n\n            int                 mib[4];\n            struct kinfo_proc   info;\n            std::size_t         size;\n\n            // Initialize the flags so that, if sysctl fails for some bizarre\n            // reason, we get a predictable result.\n\n            info.kp_proc.p_flag = 0;\n\n            // Initialize mib, which tells sysctl the info we want, in this case\n            // we're looking for information about a specific process ID.\n\n            mib[0] = CTL_KERN;\n            mib[1] = KERN_PROC;\n            mib[2] = KERN_PROC_PID;\n            mib[3] = getpid();\n\n            // Call sysctl.\n\n            size = sizeof(info);\n            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, nullptr, 0) != 0 ) {\n                Catch::cerr() << \"\\n** Call to sysctl failed - unable to determine if debugger is active **\\n\" << std::endl;\n                return false;\n            }\n\n            // We're being debugged if the P_TRACED flag is set.\n\n            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );\n        }\n    } // namespace Catch\n"
    },
    {
        "begin_line": 7107,
        "end_line": 7137,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isDebuggerActive",
        "snippet": "        bool isDebuggerActive(){\n\n            int                 mib[4];\n            struct kinfo_proc   info;\n            std::size_t         size;\n\n            // Initialize the flags so that, if sysctl fails for some bizarre\n            // reason, we get a predictable result.\n\n            info.kp_proc.p_flag = 0;\n\n            // Initialize mib, which tells sysctl the info we want, in this case\n            // we're looking for information about a specific process ID.\n\n            mib[0] = CTL_KERN;\n            mib[1] = KERN_PROC;\n            mib[2] = KERN_PROC_PID;\n            mib[3] = getpid();\n\n            // Call sysctl.\n\n            size = sizeof(info);\n            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, nullptr, 0) != 0 ) {\n                Catch::cerr() << \"\\n** Call to sysctl failed - unable to determine if debugger is active **\\n\" << std::endl;\n                return false;\n            }\n\n            // We're being debugged if the P_TRACED flag is set.\n\n            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );\n        }\n"
    },
    {
        "begin_line": 7144,
        "end_line": 7169,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "    namespace Catch{\n        // The standard POSIX way of detecting a debugger is to attempt to\n        // ptrace() the process, but this needs to be done from a child and not\n        // this process itself to still allow attaching to this process later\n        // if wanted, so is rather heavy. Under Linux we have the PID of the\n        // \"debugger\" (which doesn't need to be gdb, of course, it could also\n        // be strace, for example) in /proc/$PID/status, so just get it from\n        // there instead.\n        bool isDebuggerActive(){\n            // Libstdc++ has a bug, where std::ifstream sets errno to 0\n            // This way our users can properly assert over errno values\n            ErrnoGuard guard;\n            std::ifstream in(\"/proc/self/status\");\n            for( std::string line; std::getline(in, line); ) {\n                static const int PREFIX_LEN = 11;\n                if( line.compare(0, PREFIX_LEN, \"TracerPid:\\t\") == 0 ) {\n                    // We're traced if the PID is not 0 and no other PID starts\n                    // with 0 digit, so it's enough to check for just a single\n                    // character.\n                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';\n                }\n            }\n\n            return false;\n        }\n    } // namespace Catch\n"
    },
    {
        "begin_line": 7152,
        "end_line": 7168,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isDebuggerActive",
        "snippet": "        bool isDebuggerActive(){\n            // Libstdc++ has a bug, where std::ifstream sets errno to 0\n            // This way our users can properly assert over errno values\n            ErrnoGuard guard;\n            std::ifstream in(\"/proc/self/status\");\n            for( std::string line; std::getline(in, line); ) {\n                static const int PREFIX_LEN = 11;\n                if( line.compare(0, PREFIX_LEN, \"TracerPid:\\t\") == 0 ) {\n                    // We're traced if the PID is not 0 and no other PID starts\n                    // with 0 digit, so it's enough to check for just a single\n                    // character.\n                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';\n                }\n            }\n\n            return false;\n        }\n"
    },
    {
        "begin_line": 7172,
        "end_line": 7176,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "    namespace Catch {\n        bool isDebuggerActive() {\n            return IsDebuggerPresent() != 0;\n        }\n    }\n"
    },
    {
        "begin_line": 7173,
        "end_line": 7175,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isDebuggerActive",
        "snippet": "        bool isDebuggerActive() {\n            return IsDebuggerPresent() != 0;\n        }\n"
    },
    {
        "begin_line": 7179,
        "end_line": 7183,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "    namespace Catch {\n        bool isDebuggerActive() {\n            return IsDebuggerPresent() != 0;\n        }\n    }\n"
    },
    {
        "begin_line": 7180,
        "end_line": 7182,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isDebuggerActive",
        "snippet": "        bool isDebuggerActive() {\n            return IsDebuggerPresent() != 0;\n        }\n"
    },
    {
        "begin_line": 7185,
        "end_line": 7187,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "    namespace Catch {\n       bool isDebuggerActive() { return false; }\n    }\n"
    },
    {
        "begin_line": 7186,
        "end_line": 7186,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isDebuggerActive",
        "snippet": "       bool isDebuggerActive() { return false; }\n"
    },
    {
        "begin_line": 7192,
        "end_line": 7204,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    ITransientExpression::~ITransientExpression() = default;\n\n    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs ) {\n        if( lhs.size() + rhs.size() < 40 &&\n                lhs.find('\\n') == std::string::npos &&\n                rhs.find('\\n') == std::string::npos )\n            os << lhs << \" \" << op << \" \" << rhs;\n        else\n            os << lhs << \"\\n\" << op << \"\\n\" << rhs;\n    }\n}\n"
    },
    {
        "begin_line": 7196,
        "end_line": 7203,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "formatReconstructedExpression",
        "snippet": "    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs ) {\n        if( lhs.size() + rhs.size() < 40 &&\n                lhs.find('\\n') == std::string::npos &&\n                rhs.find('\\n') == std::string::npos )\n            os << lhs << \" \" << op << \" \" << rhs;\n        else\n            os << lhs << \"\\n\" << op << \"\\n\" << rhs;\n    }\n"
    },
    {
        "begin_line": 7210,
        "end_line": 7213,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n        ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}\n        ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }\n}\n"
    },
    {
        "begin_line": 7211,
        "end_line": 7211,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ErrnoGuard",
        "snippet": "        ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}\n"
    },
    {
        "begin_line": 7212,
        "end_line": 7212,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~ErrnoGuard",
        "snippet": "        ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }\n"
    },
    {
        "begin_line": 7223,
        "end_line": 7235,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {\n    public:\n        ~ExceptionTranslatorRegistry();\n        virtual void registerTranslator( const IExceptionTranslator* translator );\n        virtual std::string translateActiveException() const override;\n        std::string tryTranslators() const;\n\n    private:\n        std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;\n    };\n}\n"
    },
    {
        "begin_line": 7225,
        "end_line": 7234,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExceptionTranslatorRegistry",
        "snippet": "    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {\n    public:\n        ~ExceptionTranslatorRegistry();\n        virtual void registerTranslator( const IExceptionTranslator* translator );\n        virtual std::string translateActiveException() const override;\n        std::string tryTranslators() const;\n\n    private:\n        std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;\n    };\n"
    },
    {
        "begin_line": 7233,
        "end_line": 7233,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_translators",
        "snippet": "        std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;\n"
    },
    {
        "begin_line": 7242,
        "end_line": 7299,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {\n    }\n\n    void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {\n        m_translators.push_back( std::unique_ptr<const IExceptionTranslator>( translator ) );\n    }\n\n    std::string ExceptionTranslatorRegistry::translateActiveException() const {\n        try {\n#ifdef __OBJC__\n            // In Objective-C try objective-c exceptions first\n            @try {\n                return tryTranslators();\n            }\n            @catch (NSException *exception) {\n                return Catch::Detail::stringify( [exception description] );\n            }\n#else\n            // Compiling a mixed mode project with MSVC means that CLR\n            // exceptions will be caught in (...) as well. However, these\n            // do not fill-in std::current_exception and thus lead to crash\n            // when attempting rethrow.\n            // /EHa switch also causes structured exceptions to be caught\n            // here, but they fill-in current_exception properly, so\n            // at worst the output should be a little weird, instead of\n            // causing a crash.\n            if (std::current_exception() == nullptr) {\n                return \"Non C++ exception. Possibly a CLR exception.\";\n            }\n            return tryTranslators();\n#endif\n        }\n        catch( TestFailureException& ) {\n            std::rethrow_exception(std::current_exception());\n        }\n        catch( std::exception& ex ) {\n            return ex.what();\n        }\n        catch( std::string& msg ) {\n            return msg;\n        }\n        catch( const char* msg ) {\n            return msg;\n        }\n        catch(...) {\n            return \"Unknown exception\";\n        }\n    }\n\n    std::string ExceptionTranslatorRegistry::tryTranslators() const {\n        if( m_translators.empty() )\n            std::rethrow_exception(std::current_exception());\n        else\n            return m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );\n    }\n}\n"
    },
    {
        "begin_line": 7244,
        "end_line": 7245,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~ExceptionTranslatorRegistry",
        "snippet": "    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {\n    }\n"
    },
    {
        "begin_line": 7247,
        "end_line": 7249,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerTranslator",
        "snippet": "    void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {\n        m_translators.push_back( std::unique_ptr<const IExceptionTranslator>( translator ) );\n    }\n"
    },
    {
        "begin_line": 7251,
        "end_line": 7291,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "translateActiveException",
        "snippet": "    std::string ExceptionTranslatorRegistry::translateActiveException() const {\n        try {\n#ifdef __OBJC__\n            // In Objective-C try objective-c exceptions first\n            @try {\n                return tryTranslators();\n            }\n            @catch (NSException *exception) {\n                return Catch::Detail::stringify( [exception description] );\n            }\n#else\n            // Compiling a mixed mode project with MSVC means that CLR\n            // exceptions will be caught in (...) as well. However, these\n            // do not fill-in std::current_exception and thus lead to crash\n            // when attempting rethrow.\n            // /EHa switch also causes structured exceptions to be caught\n            // here, but they fill-in current_exception properly, so\n            // at worst the output should be a little weird, instead of\n            // causing a crash.\n            if (std::current_exception() == nullptr) {\n                return \"Non C++ exception. Possibly a CLR exception.\";\n            }\n            return tryTranslators();\n#endif\n        }\n        catch( TestFailureException& ) {\n            std::rethrow_exception(std::current_exception());\n        }\n        catch( std::exception& ex ) {\n            return ex.what();\n        }\n        catch( std::string& msg ) {\n            return msg;\n        }\n        catch( const char* msg ) {\n            return msg;\n        }\n        catch(...) {\n            return \"Unknown exception\";\n        }\n    }\n"
    },
    {
        "begin_line": 7293,
        "end_line": 7298,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "tryTranslators",
        "snippet": "    std::string ExceptionTranslatorRegistry::tryTranslators() const {\n        if( m_translators.empty() )\n            std::rethrow_exception(std::current_exception());\n        else\n            return m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );\n    }\n"
    },
    {
        "begin_line": 7310,
        "end_line": 7315,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1311",
        "snippet": "namespace {\n    // Report the error condition\n    void reportFatal( char const * const message ) {\n        Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );\n    }\n}\n"
    },
    {
        "begin_line": 7312,
        "end_line": 7314,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reportFatal",
        "snippet": "    void reportFatal( char const * const message ) {\n        Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );\n    }\n"
    },
    {
        "begin_line": 7321,
        "end_line": 7374,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    struct SignalDefs { DWORD id; const char* name; };\n\n    // There is no 1-1 mapping between signals and windows exceptions.\n    // Windows can easily distinguish between SO and SigSegV,\n    // but SigInt, SigTerm, etc are handled differently.\n    static SignalDefs signalDefs[] = {\n        { EXCEPTION_ILLEGAL_INSTRUCTION,  \"SIGILL - Illegal instruction signal\" },\n        { EXCEPTION_STACK_OVERFLOW, \"SIGSEGV - Stack overflow\" },\n        { EXCEPTION_ACCESS_VIOLATION, \"SIGSEGV - Segmentation violation signal\" },\n        { EXCEPTION_INT_DIVIDE_BY_ZERO, \"Divide by zero error\" },\n    };\n\n    LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {\n        for (auto const& def : signalDefs) {\n            if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {\n                reportFatal(def.name);\n            }\n        }\n        // If its not an exception we care about, pass it along.\n        // This stops us from eating debugger breaks etc.\n        return EXCEPTION_CONTINUE_SEARCH;\n    }\n\n    FatalConditionHandler::FatalConditionHandler() {\n        isSet = true;\n        // 32k seems enough for Catch to handle stack overflow,\n        // but the value was found experimentally, so there is no strong guarantee\n        guaranteeSize = 32 * 1024;\n        exceptionHandlerHandle = nullptr;\n        // Register as first handler in current chain\n        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\n        // Pass in guarantee size to be filled\n        SetThreadStackGuarantee(&guaranteeSize);\n    }\n\n    void FatalConditionHandler::reset() {\n        if (isSet) {\n            RemoveVectoredExceptionHandler(exceptionHandlerHandle);\n            SetThreadStackGuarantee(&guaranteeSize);\n            exceptionHandlerHandle = nullptr;\n            isSet = false;\n        }\n    }\n\n    FatalConditionHandler::~FatalConditionHandler() {\n        reset();\n    }\n\nbool FatalConditionHandler::isSet = false;\nULONG FatalConditionHandler::guaranteeSize = 0;\nPVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 7322,
        "end_line": 7322,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SignalDefs",
        "snippet": "    struct SignalDefs { DWORD id; const char* name; };\n"
    },
    {
        "begin_line": 7322,
        "end_line": 7322,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "id",
        "snippet": "    struct SignalDefs { DWORD id; const char* name; };\n"
    },
    {
        "begin_line": 7322,
        "end_line": 7322,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "    struct SignalDefs { DWORD id; const char* name; };\n"
    },
    {
        "begin_line": 7327,
        "end_line": 7332,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "signalDefs",
        "snippet": "    static SignalDefs signalDefs[] = {\n        { EXCEPTION_ILLEGAL_INSTRUCTION,  \"SIGILL - Illegal instruction signal\" },\n        { EXCEPTION_STACK_OVERFLOW, \"SIGSEGV - Stack overflow\" },\n        { EXCEPTION_ACCESS_VIOLATION, \"SIGSEGV - Segmentation violation signal\" },\n        { EXCEPTION_INT_DIVIDE_BY_ZERO, \"Divide by zero error\" },\n    };\n"
    },
    {
        "begin_line": 7334,
        "end_line": 7343,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleVectoredException",
        "snippet": "    LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {\n        for (auto const& def : signalDefs) {\n            if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {\n                reportFatal(def.name);\n            }\n        }\n        // If its not an exception we care about, pass it along.\n        // This stops us from eating debugger breaks etc.\n        return EXCEPTION_CONTINUE_SEARCH;\n    }\n"
    },
    {
        "begin_line": 7345,
        "end_line": 7355,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FatalConditionHandler",
        "snippet": "    FatalConditionHandler::FatalConditionHandler() {\n        isSet = true;\n        // 32k seems enough for Catch to handle stack overflow,\n        // but the value was found experimentally, so there is no strong guarantee\n        guaranteeSize = 32 * 1024;\n        exceptionHandlerHandle = nullptr;\n        // Register as first handler in current chain\n        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\n        // Pass in guarantee size to be filled\n        SetThreadStackGuarantee(&guaranteeSize);\n    }\n"
    },
    {
        "begin_line": 7357,
        "end_line": 7364,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reset",
        "snippet": "    void FatalConditionHandler::reset() {\n        if (isSet) {\n            RemoveVectoredExceptionHandler(exceptionHandlerHandle);\n            SetThreadStackGuarantee(&guaranteeSize);\n            exceptionHandlerHandle = nullptr;\n            isSet = false;\n        }\n    }\n"
    },
    {
        "begin_line": 7366,
        "end_line": 7368,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~FatalConditionHandler",
        "snippet": "    FatalConditionHandler::~FatalConditionHandler() {\n        reset();\n    }\n"
    },
    {
        "begin_line": 7370,
        "end_line": 7370,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSet",
        "snippet": "bool FatalConditionHandler::isSet = false;\n"
    },
    {
        "begin_line": 7371,
        "end_line": 7371,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "guaranteeSize",
        "snippet": "ULONG FatalConditionHandler::guaranteeSize = 0;\n"
    },
    {
        "begin_line": 7372,
        "end_line": 7372,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "exceptionHandlerHandle",
        "snippet": "PVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;\n"
    },
    {
        "begin_line": 7378,
        "end_line": 7443,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct SignalDefs {\n        int id;\n        const char* name;\n    };\n    static SignalDefs signalDefs[] = {\n        { SIGINT,  \"SIGINT - Terminal interrupt signal\" },\n        { SIGILL,  \"SIGILL - Illegal instruction signal\" },\n        { SIGFPE,  \"SIGFPE - Floating point error signal\" },\n        { SIGSEGV, \"SIGSEGV - Segmentation violation signal\" },\n        { SIGTERM, \"SIGTERM - Termination request signal\" },\n        { SIGABRT, \"SIGABRT - Abort (abnormal termination) signal\" }\n    };\n\n    void FatalConditionHandler::handleSignal( int sig ) {\n        char const * name = \"<unknown signal>\";\n        for (auto const& def : signalDefs) {\n            if (sig == def.id) {\n                name = def.name;\n                break;\n            }\n        }\n        reset();\n        reportFatal(name);\n        raise( sig );\n    }\n\n    FatalConditionHandler::FatalConditionHandler() {\n        isSet = true;\n        stack_t sigStack;\n        sigStack.ss_sp = altStackMem;\n        sigStack.ss_size = SIGSTKSZ;\n        sigStack.ss_flags = 0;\n        sigaltstack(&sigStack, &oldSigStack);\n        struct sigaction sa = { };\n\n        sa.sa_handler = handleSignal;\n        sa.sa_flags = SA_ONSTACK;\n        for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {\n            sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);\n        }\n    }\n\n    FatalConditionHandler::~FatalConditionHandler() {\n        reset();\n    }\n\n    void FatalConditionHandler::reset() {\n        if( isSet ) {\n            // Set signals back to previous values -- hopefully nobody overwrote them in the meantime\n            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {\n                sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);\n            }\n            // Return the old stack\n            sigaltstack(&oldSigStack, nullptr);\n            isSet = false;\n        }\n    }\n\n    bool FatalConditionHandler::isSet = false;\n    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};\n    stack_t FatalConditionHandler::oldSigStack = {};\n    char FatalConditionHandler::altStackMem[SIGSTKSZ] = {};\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 7380,
        "end_line": 7383,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SignalDefs",
        "snippet": "    struct SignalDefs {\n        int id;\n        const char* name;\n    };\n"
    },
    {
        "begin_line": 7381,
        "end_line": 7381,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "id",
        "snippet": "        int id;\n"
    },
    {
        "begin_line": 7382,
        "end_line": 7382,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "        const char* name;\n"
    },
    {
        "begin_line": 7384,
        "end_line": 7391,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "signalDefs",
        "snippet": "    static SignalDefs signalDefs[] = {\n        { SIGINT,  \"SIGINT - Terminal interrupt signal\" },\n        { SIGILL,  \"SIGILL - Illegal instruction signal\" },\n        { SIGFPE,  \"SIGFPE - Floating point error signal\" },\n        { SIGSEGV, \"SIGSEGV - Segmentation violation signal\" },\n        { SIGTERM, \"SIGTERM - Termination request signal\" },\n        { SIGABRT, \"SIGABRT - Abort (abnormal termination) signal\" }\n    };\n"
    },
    {
        "begin_line": 7393,
        "end_line": 7404,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleSignal",
        "snippet": "    void FatalConditionHandler::handleSignal( int sig ) {\n        char const * name = \"<unknown signal>\";\n        for (auto const& def : signalDefs) {\n            if (sig == def.id) {\n                name = def.name;\n                break;\n            }\n        }\n        reset();\n        reportFatal(name);\n        raise( sig );\n    }\n"
    },
    {
        "begin_line": 7406,
        "end_line": 7420,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FatalConditionHandler",
        "snippet": "    FatalConditionHandler::FatalConditionHandler() {\n        isSet = true;\n        stack_t sigStack;\n        sigStack.ss_sp = altStackMem;\n        sigStack.ss_size = SIGSTKSZ;\n        sigStack.ss_flags = 0;\n        sigaltstack(&sigStack, &oldSigStack);\n        struct sigaction sa = { };\n\n        sa.sa_handler = handleSignal;\n        sa.sa_flags = SA_ONSTACK;\n        for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {\n            sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);\n        }\n    }\n"
    },
    {
        "begin_line": 7422,
        "end_line": 7424,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~FatalConditionHandler",
        "snippet": "    FatalConditionHandler::~FatalConditionHandler() {\n        reset();\n    }\n"
    },
    {
        "begin_line": 7426,
        "end_line": 7436,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reset",
        "snippet": "    void FatalConditionHandler::reset() {\n        if( isSet ) {\n            // Set signals back to previous values -- hopefully nobody overwrote them in the meantime\n            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {\n                sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);\n            }\n            // Return the old stack\n            sigaltstack(&oldSigStack, nullptr);\n            isSet = false;\n        }\n    }\n"
    },
    {
        "begin_line": 7438,
        "end_line": 7438,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSet",
        "snippet": "    bool FatalConditionHandler::isSet = false;\n"
    },
    {
        "begin_line": 7439,
        "end_line": 7439,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "oldSigActions",
        "snippet": "    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};\n"
    },
    {
        "begin_line": 7440,
        "end_line": 7440,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "oldSigStack",
        "snippet": "    stack_t FatalConditionHandler::oldSigStack = {};\n"
    },
    {
        "begin_line": 7441,
        "end_line": 7441,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "altStackMem",
        "snippet": "    char FatalConditionHandler::altStackMem[SIGSTKSZ] = {};\n"
    },
    {
        "begin_line": 7447,
        "end_line": 7449,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    void FatalConditionHandler::reset() {}\n}\n"
    },
    {
        "begin_line": 7448,
        "end_line": 7448,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reset",
        "snippet": "    void FatalConditionHandler::reset() {}\n"
    },
    {
        "begin_line": 7459,
        "end_line": 7461,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    IResultCapture::~IResultCapture() = default;\n}\n"
    },
    {
        "begin_line": 7465,
        "end_line": 7467,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    IConfig::~IConfig() = default;\n}\n"
    },
    {
        "begin_line": 7471,
        "end_line": 7474,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    IExceptionTranslator::~IExceptionTranslator() = default;\n    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;\n}\n"
    },
    {
        "begin_line": 7478,
        "end_line": 7481,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    IRegistryHub::~IRegistryHub() = default;\n    IMutableRegistryHub::~IMutableRegistryHub() = default;\n}\n"
    },
    {
        "begin_line": 7487,
        "end_line": 7525,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class MultipleReporters : public IStreamingReporter {\n        using Reporters = std::vector<IStreamingReporterPtr>;\n        Reporters m_reporters;\n\n    public:\n        void add( IStreamingReporterPtr&& reporter );\n\n    public: // IStreamingReporter\n\n        ReporterPreferences getPreferences() const override;\n\n        void noMatchingTestCases( std::string const& spec ) override;\n\n        static std::set<Verbosity> getSupportedVerbosities();\n\n        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;\n        void benchmarkEnded( BenchmarkStats const& benchmarkStats ) override;\n\n        void testRunStarting( TestRunInfo const& testRunInfo ) override;\n        void testGroupStarting( GroupInfo const& groupInfo ) override;\n        void testCaseStarting( TestCaseInfo const& testInfo ) override;\n        void sectionStarting( SectionInfo const& sectionInfo ) override;\n        void assertionStarting( AssertionInfo const& assertionInfo ) override;\n\n        // The return value indicates if the messages buffer should be cleared:\n        bool assertionEnded( AssertionStats const& assertionStats ) override;\n        void sectionEnded( SectionStats const& sectionStats ) override;\n        void testCaseEnded( TestCaseStats const& testCaseStats ) override;\n        void testGroupEnded( TestGroupStats const& testGroupStats ) override;\n        void testRunEnded( TestRunStats const& testRunStats ) override;\n\n        void skipTest( TestCaseInfo const& testInfo ) override;\n        bool isMulti() const override;\n\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 7489,
        "end_line": 7523,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MultipleReporters",
        "snippet": "    class MultipleReporters : public IStreamingReporter {\n        using Reporters = std::vector<IStreamingReporterPtr>;\n        Reporters m_reporters;\n\n    public:\n        void add( IStreamingReporterPtr&& reporter );\n\n    public: // IStreamingReporter\n\n        ReporterPreferences getPreferences() const override;\n\n        void noMatchingTestCases( std::string const& spec ) override;\n\n        static std::set<Verbosity> getSupportedVerbosities();\n\n        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;\n        void benchmarkEnded( BenchmarkStats const& benchmarkStats ) override;\n\n        void testRunStarting( TestRunInfo const& testRunInfo ) override;\n        void testGroupStarting( GroupInfo const& groupInfo ) override;\n        void testCaseStarting( TestCaseInfo const& testInfo ) override;\n        void sectionStarting( SectionInfo const& sectionInfo ) override;\n        void assertionStarting( AssertionInfo const& assertionInfo ) override;\n\n        // The return value indicates if the messages buffer should be cleared:\n        bool assertionEnded( AssertionStats const& assertionStats ) override;\n        void sectionEnded( SectionStats const& sectionStats ) override;\n        void testCaseEnded( TestCaseStats const& testCaseStats ) override;\n        void testGroupEnded( TestGroupStats const& testGroupStats ) override;\n        void testRunEnded( TestRunStats const& testRunStats ) override;\n\n        void skipTest( TestCaseInfo const& testInfo ) override;\n        bool isMulti() const override;\n\n    };\n"
    },
    {
        "begin_line": 7491,
        "end_line": 7491,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_reporters",
        "snippet": "        Reporters m_reporters;\n"
    },
    {
        "begin_line": 7528,
        "end_line": 7649,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig )\n    :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}\n\n    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream )\n    :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}\n\n    std::ostream& ReporterConfig::stream() const { return *m_stream; }\n    IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }\n\n    TestRunInfo::TestRunInfo( std::string const& _name ) : name( _name ) {}\n\n    GroupInfo::GroupInfo(  std::string const& _name,\n                           std::size_t _groupIndex,\n                           std::size_t _groupsCount )\n    :   name( _name ),\n        groupIndex( _groupIndex ),\n        groupsCounts( _groupsCount )\n    {}\n\n     AssertionStats::AssertionStats( AssertionResult const& _assertionResult,\n                                     std::vector<MessageInfo> const& _infoMessages,\n                                     Totals const& _totals )\n    :   assertionResult( _assertionResult ),\n        infoMessages( _infoMessages ),\n        totals( _totals )\n    {\n        assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;\n\n        if( assertionResult.hasMessage() ) {\n            // Copy message into messages list.\n            // !TBD This should have been done earlier, somewhere\n            MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );\n            builder << assertionResult.getMessage();\n            builder.m_info.message = builder.m_stream.str();\n\n            infoMessages.push_back( builder.m_info );\n        }\n    }\n\n     AssertionStats::~AssertionStats() = default;\n\n    SectionStats::SectionStats(  SectionInfo const& _sectionInfo,\n                                 Counts const& _assertions,\n                                 double _durationInSeconds,\n                                 bool _missingAssertions )\n    :   sectionInfo( _sectionInfo ),\n        assertions( _assertions ),\n        durationInSeconds( _durationInSeconds ),\n        missingAssertions( _missingAssertions )\n    {}\n\n    SectionStats::~SectionStats() = default;\n\n    TestCaseStats::TestCaseStats(  TestCaseInfo const& _testInfo,\n                                   Totals const& _totals,\n                                   std::string const& _stdOut,\n                                   std::string const& _stdErr,\n                                   bool _aborting )\n    : testInfo( _testInfo ),\n        totals( _totals ),\n        stdOut( _stdOut ),\n        stdErr( _stdErr ),\n        aborting( _aborting )\n    {}\n\n    TestCaseStats::~TestCaseStats() = default;\n\n    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo,\n                                    Totals const& _totals,\n                                    bool _aborting )\n    :   groupInfo( _groupInfo ),\n        totals( _totals ),\n        aborting( _aborting )\n    {}\n\n    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo )\n    :   groupInfo( _groupInfo ),\n        aborting( false )\n    {}\n\n    TestGroupStats::~TestGroupStats() = default;\n\n    TestRunStats::TestRunStats(   TestRunInfo const& _runInfo,\n                    Totals const& _totals,\n                    bool _aborting )\n    :   runInfo( _runInfo ),\n        totals( _totals ),\n        aborting( _aborting )\n    {}\n\n    TestRunStats::~TestRunStats() = default;\n\n    void IStreamingReporter::fatalErrorEncountered( StringRef ) {}\n    bool IStreamingReporter::isMulti() const { return false; }\n\n    IReporterFactory::~IReporterFactory() = default;\n    IReporterRegistry::~IReporterRegistry() = default;\n\n    void addReporter( IStreamingReporterPtr& existingReporter, IStreamingReporterPtr&& additionalReporter ) {\n\n        if( !existingReporter ) {\n            existingReporter = std::move( additionalReporter );\n            return;\n        }\n\n        MultipleReporters* multi = nullptr;\n\n        if( existingReporter->isMulti() ) {\n            multi = static_cast<MultipleReporters*>( existingReporter.get() );\n        }\n        else {\n            auto newMulti = std::unique_ptr<MultipleReporters>( new MultipleReporters );\n            newMulti->add( std::move( existingReporter ) );\n            multi = newMulti.get();\n            existingReporter = std::move( newMulti );\n        }\n        multi->add( std::move( additionalReporter ) );\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 7530,
        "end_line": 7531,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterConfig",
        "snippet": "    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig )\n    :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}\n"
    },
    {
        "begin_line": 7533,
        "end_line": 7534,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterConfig",
        "snippet": "    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream )\n    :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}\n"
    },
    {
        "begin_line": 7536,
        "end_line": 7536,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "    std::ostream& ReporterConfig::stream() const { return *m_stream; }\n"
    },
    {
        "begin_line": 7537,
        "end_line": 7537,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "fullConfig",
        "snippet": "    IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }\n"
    },
    {
        "begin_line": 7539,
        "end_line": 7539,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestRunInfo",
        "snippet": "    TestRunInfo::TestRunInfo( std::string const& _name ) : name( _name ) {}\n"
    },
    {
        "begin_line": 7541,
        "end_line": 7547,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "GroupInfo",
        "snippet": "    GroupInfo::GroupInfo(  std::string const& _name,\n                           std::size_t _groupIndex,\n                           std::size_t _groupsCount )\n    :   name( _name ),\n        groupIndex( _groupIndex ),\n        groupsCounts( _groupsCount )\n    {}\n"
    },
    {
        "begin_line": 7549,
        "end_line": 7567,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionStats",
        "snippet": "     AssertionStats::AssertionStats( AssertionResult const& _assertionResult,\n                                     std::vector<MessageInfo> const& _infoMessages,\n                                     Totals const& _totals )\n    :   assertionResult( _assertionResult ),\n        infoMessages( _infoMessages ),\n        totals( _totals )\n    {\n        assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;\n\n        if( assertionResult.hasMessage() ) {\n            // Copy message into messages list.\n            // !TBD This should have been done earlier, somewhere\n            MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );\n            builder << assertionResult.getMessage();\n            builder.m_info.message = builder.m_stream.str();\n\n            infoMessages.push_back( builder.m_info );\n        }\n    }\n"
    },
    {
        "begin_line": 7571,
        "end_line": 7579,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionStats",
        "snippet": "    SectionStats::SectionStats(  SectionInfo const& _sectionInfo,\n                                 Counts const& _assertions,\n                                 double _durationInSeconds,\n                                 bool _missingAssertions )\n    :   sectionInfo( _sectionInfo ),\n        assertions( _assertions ),\n        durationInSeconds( _durationInSeconds ),\n        missingAssertions( _missingAssertions )\n    {}\n"
    },
    {
        "begin_line": 7583,
        "end_line": 7593,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCaseStats",
        "snippet": "    TestCaseStats::TestCaseStats(  TestCaseInfo const& _testInfo,\n                                   Totals const& _totals,\n                                   std::string const& _stdOut,\n                                   std::string const& _stdErr,\n                                   bool _aborting )\n    : testInfo( _testInfo ),\n        totals( _totals ),\n        stdOut( _stdOut ),\n        stdErr( _stdErr ),\n        aborting( _aborting )\n    {}\n"
    },
    {
        "begin_line": 7597,
        "end_line": 7603,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestGroupStats",
        "snippet": "    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo,\n                                    Totals const& _totals,\n                                    bool _aborting )\n    :   groupInfo( _groupInfo ),\n        totals( _totals ),\n        aborting( _aborting )\n    {}\n"
    },
    {
        "begin_line": 7605,
        "end_line": 7608,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestGroupStats",
        "snippet": "    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo )\n    :   groupInfo( _groupInfo ),\n        aborting( false )\n    {}\n"
    },
    {
        "begin_line": 7612,
        "end_line": 7618,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestRunStats",
        "snippet": "    TestRunStats::TestRunStats(   TestRunInfo const& _runInfo,\n                    Totals const& _totals,\n                    bool _aborting )\n    :   runInfo( _runInfo ),\n        totals( _totals ),\n        aborting( _aborting )\n    {}\n"
    },
    {
        "begin_line": 7622,
        "end_line": 7622,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "fatalErrorEncountered",
        "snippet": "    void IStreamingReporter::fatalErrorEncountered( StringRef ) {}\n"
    },
    {
        "begin_line": 7623,
        "end_line": 7623,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isMulti",
        "snippet": "    bool IStreamingReporter::isMulti() const { return false; }\n"
    },
    {
        "begin_line": 7628,
        "end_line": 7647,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addReporter",
        "snippet": "    void addReporter( IStreamingReporterPtr& existingReporter, IStreamingReporterPtr&& additionalReporter ) {\n\n        if( !existingReporter ) {\n            existingReporter = std::move( additionalReporter );\n            return;\n        }\n\n        MultipleReporters* multi = nullptr;\n\n        if( existingReporter->isMulti() ) {\n            multi = static_cast<MultipleReporters*>( existingReporter.get() );\n        }\n        else {\n            auto newMulti = std::unique_ptr<MultipleReporters>( new MultipleReporters );\n            newMulti->add( std::move( existingReporter ) );\n            multi = newMulti.get();\n            existingReporter = std::move( newMulti );\n        }\n        multi->add( std::move( additionalReporter ) );\n    }\n"
    },
    {
        "begin_line": 7653,
        "end_line": 7655,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    IRunner::~IRunner() = default;\n}\n"
    },
    {
        "begin_line": 7659,
        "end_line": 7662,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    ITestInvoker::~ITestInvoker() = default;\n    ITestCaseRegistry::~ITestCaseRegistry() = default;\n}\n"
    },
    {
        "begin_line": 7669,
        "end_line": 7681,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n\tLeakDetector::LeakDetector() {\n\t\tint flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\n\t\tflag |= _CRTDBG_LEAK_CHECK_DF;\n\t\tflag |= _CRTDBG_ALLOC_MEM_DF;\n\t\t_CrtSetDbgFlag(flag);\n\t\t_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\n\t\t_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n\t\t// Change this to leaking allocation's number to break there\n\t\t_CrtSetBreakAlloc(-1);\n\t}\n}\n"
    },
    {
        "begin_line": 7671,
        "end_line": 7680,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LeakDetector",
        "snippet": "\tLeakDetector::LeakDetector() {\n\t\tint flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\n\t\tflag |= _CRTDBG_LEAK_CHECK_DF;\n\t\tflag |= _CRTDBG_ALLOC_MEM_DF;\n\t\t_CrtSetDbgFlag(flag);\n\t\t_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\n\t\t_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n\t\t// Change this to leaking allocation's number to break there\n\t\t_CrtSetBreakAlloc(-1);\n\t}\n"
    },
    {
        "begin_line": 7685,
        "end_line": 7685,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "LeakDetector",
        "snippet": "    Catch::LeakDetector::LeakDetector() {}\n"
    },
    {
        "begin_line": 7695,
        "end_line": 7715,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    std::size_t listTests( Config const& config );\n\n    std::size_t listTestsNamesOnly( Config const& config );\n\n    struct TagInfo {\n        void add( std::string const& spelling );\n        std::string all() const;\n\n        std::set<std::string> spellings;\n        std::size_t count = 0;\n    };\n\n    std::size_t listTags( Config const& config );\n\n    std::size_t listReporters( Config const& /*config*/ );\n\n    Option<std::size_t> list( Config const& config );\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 7701,
        "end_line": 7707,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TagInfo",
        "snippet": "    struct TagInfo {\n        void add( std::string const& spelling );\n        std::string all() const;\n\n        std::set<std::string> spellings;\n        std::size_t count = 0;\n    };\n"
    },
    {
        "begin_line": 7705,
        "end_line": 7705,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "spellings",
        "snippet": "        std::set<std::string> spellings;\n"
    },
    {
        "begin_line": 7706,
        "end_line": 7706,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "count",
        "snippet": "        std::size_t count = 0;\n"
    },
    {
        "begin_line": 7720,
        "end_line": 7722,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    using namespace clara::TextFlow;\n}\n"
    },
    {
        "begin_line": 7729,
        "end_line": 7864,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    std::size_t listTests( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        if( config.hasTestFilters() )\n            Catch::cout() << \"Matching test cases:\\n\";\n        else {\n            Catch::cout() << \"All available test cases:\\n\";\n        }\n\n        auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( auto const& testCaseInfo : matchedTestCases ) {\n            Colour::Code colour = testCaseInfo.isHidden()\n                ? Colour::SecondaryText\n                : Colour::None;\n            Colour colourGuard( colour );\n\n            Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << \"\\n\";\n            if( config.verbosity() >= Verbosity::High ) {\n                Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;\n                std::string description = testCaseInfo.description;\n                if( description.empty() )\n                    description = \"(NO DESCRIPTION)\";\n                Catch::cout() << Column( description ).indent(4) << std::endl;\n            }\n            if( !testCaseInfo.tags.empty() )\n                Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << \"\\n\";\n        }\n\n        if( !config.hasTestFilters() )\n            Catch::cout() << pluralise( matchedTestCases.size(), \"test case\" ) << '\\n' << std::endl;\n        else\n            Catch::cout() << pluralise( matchedTestCases.size(), \"matching test case\" ) << '\\n' << std::endl;\n        return matchedTestCases.size();\n    }\n\n    std::size_t listTestsNamesOnly( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        std::size_t matchedTests = 0;\n        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( auto const& testCaseInfo : matchedTestCases ) {\n            matchedTests++;\n            if( startsWith( testCaseInfo.name, '#' ) )\n               Catch::cout() << '\"' << testCaseInfo.name << '\"';\n            else\n               Catch::cout() << testCaseInfo.name;\n            if ( config.verbosity() >= Verbosity::High )\n                Catch::cout() << \"\\t@\" << testCaseInfo.lineInfo;\n            Catch::cout() << std::endl;\n        }\n        return matchedTests;\n    }\n\n    void TagInfo::add( std::string const& spelling ) {\n        ++count;\n        spellings.insert( spelling );\n    }\n\n    std::string TagInfo::all() const {\n        std::string out;\n        for( auto const& spelling : spellings )\n            out += \"[\" + spelling + \"]\";\n        return out;\n    }\n\n    std::size_t listTags( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        if( config.hasTestFilters() )\n            Catch::cout() << \"Tags for matching test cases:\\n\";\n        else {\n            Catch::cout() << \"All available tags:\\n\";\n        }\n\n        std::map<std::string, TagInfo> tagCounts;\n\n        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( auto const& testCase : matchedTestCases ) {\n            for( auto const& tagName : testCase.getTestCaseInfo().tags ) {\n                std::string lcaseTagName = toLower( tagName );\n                auto countIt = tagCounts.find( lcaseTagName );\n                if( countIt == tagCounts.end() )\n                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;\n                countIt->second.add( tagName );\n            }\n        }\n\n        for( auto const& tagCount : tagCounts ) {\n            ReusableStringStream rss;\n            rss << \"  \" << std::setw(2) << tagCount.second.count << \"  \";\n            auto str = rss.str();\n            auto wrapper = Column( tagCount.second.all() )\n                                                    .initialIndent( 0 )\n                                                    .indent( str.size() )\n                                                    .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );\n            Catch::cout() << str << wrapper << '\\n';\n        }\n        Catch::cout() << pluralise( tagCounts.size(), \"tag\" ) << '\\n' << std::endl;\n        return tagCounts.size();\n    }\n\n    std::size_t listReporters( Config const& /*config*/ ) {\n        Catch::cout() << \"Available reporters:\\n\";\n        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n        std::size_t maxNameLen = 0;\n        for( auto const& factoryKvp : factories )\n            maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );\n\n        for( auto const& factoryKvp : factories ) {\n            Catch::cout()\n                    << Column( factoryKvp.first + \":\" )\n                            .indent(2)\n                            .width( 5+maxNameLen )\n                    +  Column( factoryKvp.second->getDescription() )\n                            .initialIndent(0)\n                            .indent(2)\n                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )\n                    << \"\\n\";\n        }\n        Catch::cout() << std::endl;\n        return factories.size();\n    }\n\n    Option<std::size_t> list( Config const& config ) {\n        Option<std::size_t> listedCount;\n        if( config.listTests() )\n            listedCount = listedCount.valueOr(0) + listTests( config );\n        if( config.listTestNamesOnly() )\n            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );\n        if( config.listTags() )\n            listedCount = listedCount.valueOr(0) + listTags( config );\n        if( config.listReporters() )\n            listedCount = listedCount.valueOr(0) + listReporters( config );\n        return listedCount;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 7731,
        "end_line": 7763,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTests",
        "snippet": "    std::size_t listTests( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        if( config.hasTestFilters() )\n            Catch::cout() << \"Matching test cases:\\n\";\n        else {\n            Catch::cout() << \"All available test cases:\\n\";\n        }\n\n        auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( auto const& testCaseInfo : matchedTestCases ) {\n            Colour::Code colour = testCaseInfo.isHidden()\n                ? Colour::SecondaryText\n                : Colour::None;\n            Colour colourGuard( colour );\n\n            Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << \"\\n\";\n            if( config.verbosity() >= Verbosity::High ) {\n                Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;\n                std::string description = testCaseInfo.description;\n                if( description.empty() )\n                    description = \"(NO DESCRIPTION)\";\n                Catch::cout() << Column( description ).indent(4) << std::endl;\n            }\n            if( !testCaseInfo.tags.empty() )\n                Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << \"\\n\";\n        }\n\n        if( !config.hasTestFilters() )\n            Catch::cout() << pluralise( matchedTestCases.size(), \"test case\" ) << '\\n' << std::endl;\n        else\n            Catch::cout() << pluralise( matchedTestCases.size(), \"matching test case\" ) << '\\n' << std::endl;\n        return matchedTestCases.size();\n    }\n"
    },
    {
        "begin_line": 7765,
        "end_line": 7780,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTestsNamesOnly",
        "snippet": "    std::size_t listTestsNamesOnly( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        std::size_t matchedTests = 0;\n        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( auto const& testCaseInfo : matchedTestCases ) {\n            matchedTests++;\n            if( startsWith( testCaseInfo.name, '#' ) )\n               Catch::cout() << '\"' << testCaseInfo.name << '\"';\n            else\n               Catch::cout() << testCaseInfo.name;\n            if ( config.verbosity() >= Verbosity::High )\n                Catch::cout() << \"\\t@\" << testCaseInfo.lineInfo;\n            Catch::cout() << std::endl;\n        }\n        return matchedTests;\n    }\n"
    },
    {
        "begin_line": 7782,
        "end_line": 7785,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "add",
        "snippet": "    void TagInfo::add( std::string const& spelling ) {\n        ++count;\n        spellings.insert( spelling );\n    }\n"
    },
    {
        "begin_line": 7787,
        "end_line": 7792,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "all",
        "snippet": "    std::string TagInfo::all() const {\n        std::string out;\n        for( auto const& spelling : spellings )\n            out += \"[\" + spelling + \"]\";\n        return out;\n    }\n"
    },
    {
        "begin_line": 7794,
        "end_line": 7827,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listTags",
        "snippet": "    std::size_t listTags( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        if( config.hasTestFilters() )\n            Catch::cout() << \"Tags for matching test cases:\\n\";\n        else {\n            Catch::cout() << \"All available tags:\\n\";\n        }\n\n        std::map<std::string, TagInfo> tagCounts;\n\n        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( auto const& testCase : matchedTestCases ) {\n            for( auto const& tagName : testCase.getTestCaseInfo().tags ) {\n                std::string lcaseTagName = toLower( tagName );\n                auto countIt = tagCounts.find( lcaseTagName );\n                if( countIt == tagCounts.end() )\n                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;\n                countIt->second.add( tagName );\n            }\n        }\n\n        for( auto const& tagCount : tagCounts ) {\n            ReusableStringStream rss;\n            rss << \"  \" << std::setw(2) << tagCount.second.count << \"  \";\n            auto str = rss.str();\n            auto wrapper = Column( tagCount.second.all() )\n                                                    .initialIndent( 0 )\n                                                    .indent( str.size() )\n                                                    .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );\n            Catch::cout() << str << wrapper << '\\n';\n        }\n        Catch::cout() << pluralise( tagCounts.size(), \"tag\" ) << '\\n' << std::endl;\n        return tagCounts.size();\n    }\n"
    },
    {
        "begin_line": 7829,
        "end_line": 7849,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "listReporters",
        "snippet": "    std::size_t listReporters( Config const& /*config*/ ) {\n        Catch::cout() << \"Available reporters:\\n\";\n        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n        std::size_t maxNameLen = 0;\n        for( auto const& factoryKvp : factories )\n            maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );\n\n        for( auto const& factoryKvp : factories ) {\n            Catch::cout()\n                    << Column( factoryKvp.first + \":\" )\n                            .indent(2)\n                            .width( 5+maxNameLen )\n                    +  Column( factoryKvp.second->getDescription() )\n                            .initialIndent(0)\n                            .indent(2)\n                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )\n                    << \"\\n\";\n        }\n        Catch::cout() << std::endl;\n        return factories.size();\n    }\n"
    },
    {
        "begin_line": 7851,
        "end_line": 7862,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "list",
        "snippet": "    Option<std::size_t> list( Config const& config ) {\n        Option<std::size_t> listedCount;\n        if( config.listTests() )\n            listedCount = listedCount.valueOr(0) + listTests( config );\n        if( config.listTestNamesOnly() )\n            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );\n        if( config.listTags() )\n            listedCount = listedCount.valueOr(0) + listTags( config );\n        if( config.listReporters() )\n            listedCount = listedCount.valueOr(0) + listReporters( config );\n        return listedCount;\n    }\n"
    },
    {
        "begin_line": 7868,
        "end_line": 7886,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\n    namespace Impl {\n\n        std::string MatcherUntypedBase::toString() const {\n            if( m_cachedToString.empty() )\n                m_cachedToString = describe();\n            return m_cachedToString;\n        }\n\n        MatcherUntypedBase::~MatcherUntypedBase() = default;\n\n    } // namespace Impl\n} // namespace Matchers\n\nusing namespace Matchers;\nusing Matchers::Impl::MatcherBase;\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 7869,
        "end_line": 7881,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\n    namespace Impl {\n\n        std::string MatcherUntypedBase::toString() const {\n            if( m_cachedToString.empty() )\n                m_cachedToString = describe();\n            return m_cachedToString;\n        }\n\n        MatcherUntypedBase::~MatcherUntypedBase() = default;\n\n    } // namespace Impl\n} // namespace Matchers\n"
    },
    {
        "begin_line": 7870,
        "end_line": 7880,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Impl",
        "snippet": "    namespace Impl {\n\n        std::string MatcherUntypedBase::toString() const {\n            if( m_cachedToString.empty() )\n                m_cachedToString = describe();\n            return m_cachedToString;\n        }\n\n        MatcherUntypedBase::~MatcherUntypedBase() = default;\n\n    } // namespace Impl\n"
    },
    {
        "begin_line": 7872,
        "end_line": 7876,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "toString",
        "snippet": "        std::string MatcherUntypedBase::toString() const {\n            if( m_cachedToString.empty() )\n                m_cachedToString = describe();\n            return m_cachedToString;\n        }\n"
    },
    {
        "begin_line": 7895,
        "end_line": 7904,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\nnamespace Floating {\nenum class FloatingPointKind : uint8_t {\n    Float,\n    Double\n};\n}\n}\n}\n"
    },
    {
        "begin_line": 7896,
        "end_line": 7903,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\nnamespace Floating {\nenum class FloatingPointKind : uint8_t {\n    Float,\n    Double\n};\n}\n}\n"
    },
    {
        "begin_line": 7897,
        "end_line": 7902,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Floating",
        "snippet": "namespace Floating {\nenum class FloatingPointKind : uint8_t {\n    Float,\n    Double\n};\n}\n"
    },
    {
        "begin_line": 7898,
        "end_line": 7901,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FloatingPointKind",
        "snippet": "enum class FloatingPointKind : uint8_t {\n    Float,\n    Double\n};\n"
    },
    {
        "begin_line": 7906,
        "end_line": 7954,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1411",
        "snippet": "namespace {\n\ntemplate <typename T>\nstruct Converter;\n\ntemplate <>\nstruct Converter<float> {\n    static_assert(sizeof(float) == sizeof(int32_t), \"Important ULP matcher assumption violated\");\n    Converter(float f) {\n        std::memcpy(&i, &f, sizeof(f));\n    }\n    int32_t i;\n};\n\ntemplate <>\nstruct Converter<double> {\n    static_assert(sizeof(double) == sizeof(int64_t), \"Important ULP matcher assumption violated\");\n    Converter(double d) {\n        std::memcpy(&i, &d, sizeof(d));\n    }\n    int64_t i;\n};\n\ntemplate <typename T>\nauto convert(T t) -> Converter<T> {\n    return Converter<T>(t);\n}\n\ntemplate <typename FP>\nbool almostEqualUlps(FP lhs, FP rhs, int maxUlpDiff) {\n    // Comparison with NaN should always be false.\n    // This way we can rule it out before getting into the ugly details\n    if (std::isnan(lhs) || std::isnan(rhs)) {\n        return false;\n    }\n\n    auto lc = convert(lhs);\n    auto rc = convert(rhs);\n\n    if ((lc.i < 0) != (rc.i < 0)) {\n        // Potentially we can have +0 and -0\n        return lhs == rhs;\n    }\n\n    auto ulpDiff = std::abs(lc.i - rc.i);\n    return ulpDiff <= maxUlpDiff;\n}\n\n}\n"
    },
    {
        "begin_line": 7912,
        "end_line": 7918,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Converter",
        "snippet": "struct Converter<float> {\n    static_assert(sizeof(float) == sizeof(int32_t), \"Important ULP matcher assumption violated\");\n    Converter(float f) {\n        std::memcpy(&i, &f, sizeof(f));\n    }\n    int32_t i;\n};\n"
    },
    {
        "begin_line": 7914,
        "end_line": 7916,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Converter",
        "snippet": "    Converter(float f) {\n        std::memcpy(&i, &f, sizeof(f));\n    }\n"
    },
    {
        "begin_line": 7917,
        "end_line": 7917,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "i",
        "snippet": "    int32_t i;\n"
    },
    {
        "begin_line": 7921,
        "end_line": 7927,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Converter",
        "snippet": "struct Converter<double> {\n    static_assert(sizeof(double) == sizeof(int64_t), \"Important ULP matcher assumption violated\");\n    Converter(double d) {\n        std::memcpy(&i, &d, sizeof(d));\n    }\n    int64_t i;\n};\n"
    },
    {
        "begin_line": 7923,
        "end_line": 7925,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Converter",
        "snippet": "    Converter(double d) {\n        std::memcpy(&i, &d, sizeof(d));\n    }\n"
    },
    {
        "begin_line": 7926,
        "end_line": 7926,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "i",
        "snippet": "    int64_t i;\n"
    },
    {
        "begin_line": 7930,
        "end_line": 7932,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "auto convert(T t) -> Converter<T> {\n    return Converter<T>(t);\n}\n"
    },
    {
        "begin_line": 7935,
        "end_line": 7952,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "almostEqualUlps",
        "snippet": "bool almostEqualUlps(FP lhs, FP rhs, int maxUlpDiff) {\n    // Comparison with NaN should always be false.\n    // This way we can rule it out before getting into the ugly details\n    if (std::isnan(lhs) || std::isnan(rhs)) {\n        return false;\n    }\n\n    auto lc = convert(lhs);\n    auto rc = convert(rhs);\n\n    if ((lc.i < 0) != (rc.i < 0)) {\n        // Potentially we can have +0 and -0\n        return lhs == rhs;\n    }\n\n    auto ulpDiff = std::abs(lc.i - rc.i);\n    return ulpDiff <= maxUlpDiff;\n}\n"
    },
    {
        "begin_line": 7956,
        "end_line": 8013,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\nnamespace Floating {\n    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)\n        :m_target{ target }, m_margin{ margin } {\n        if (m_margin < 0) {\n            throw std::domain_error(\"Allowed margin difference has to be >= 0\");\n        }\n    }\n\n    // Performs equivalent check of std::fabs(lhs - rhs) <= margin\n    // But without the subtraction to allow for INFINITY in comparison\n    bool WithinAbsMatcher::match(double const& matchee) const {\n        return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);\n    }\n\n    std::string WithinAbsMatcher::describe() const {\n        return \"is within \" + ::Catch::Detail::stringify(m_margin) + \" of \" + ::Catch::Detail::stringify(m_target);\n    }\n\n    WithinUlpsMatcher::WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType)\n        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {\n        if (m_ulps < 0) {\n            throw std::domain_error(\"Allowed ulp difference has to be >= 0\");\n        }\n    }\n\n    bool WithinUlpsMatcher::match(double const& matchee) const {\n        switch (m_type) {\n        case FloatingPointKind::Float:\n            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);\n        case FloatingPointKind::Double:\n            return almostEqualUlps<double>(matchee, m_target, m_ulps);\n        default:\n            throw std::domain_error(\"Unknown FloatingPointKind value\");\n        }\n    }\n\n    std::string WithinUlpsMatcher::describe() const {\n        return \"is within \" + std::to_string(m_ulps) + \" ULPs of \" + ::Catch::Detail::stringify(m_target) + ((m_type == FloatingPointKind::Float)? \"f\" : \"\");\n    }\n\n}// namespace Floating\n\nFloating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff) {\n    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);\n}\n\nFloating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff) {\n    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);\n}\n\nFloating::WithinAbsMatcher WithinAbs(double target, double margin) {\n    return Floating::WithinAbsMatcher(target, margin);\n}\n\n} // namespace Matchers\n} // namespace Catch\n"
    },
    {
        "begin_line": 7957,
        "end_line": 8012,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\nnamespace Floating {\n    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)\n        :m_target{ target }, m_margin{ margin } {\n        if (m_margin < 0) {\n            throw std::domain_error(\"Allowed margin difference has to be >= 0\");\n        }\n    }\n\n    // Performs equivalent check of std::fabs(lhs - rhs) <= margin\n    // But without the subtraction to allow for INFINITY in comparison\n    bool WithinAbsMatcher::match(double const& matchee) const {\n        return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);\n    }\n\n    std::string WithinAbsMatcher::describe() const {\n        return \"is within \" + ::Catch::Detail::stringify(m_margin) + \" of \" + ::Catch::Detail::stringify(m_target);\n    }\n\n    WithinUlpsMatcher::WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType)\n        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {\n        if (m_ulps < 0) {\n            throw std::domain_error(\"Allowed ulp difference has to be >= 0\");\n        }\n    }\n\n    bool WithinUlpsMatcher::match(double const& matchee) const {\n        switch (m_type) {\n        case FloatingPointKind::Float:\n            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);\n        case FloatingPointKind::Double:\n            return almostEqualUlps<double>(matchee, m_target, m_ulps);\n        default:\n            throw std::domain_error(\"Unknown FloatingPointKind value\");\n        }\n    }\n\n    std::string WithinUlpsMatcher::describe() const {\n        return \"is within \" + std::to_string(m_ulps) + \" ULPs of \" + ::Catch::Detail::stringify(m_target) + ((m_type == FloatingPointKind::Float)? \"f\" : \"\");\n    }\n\n}// namespace Floating\n\nFloating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff) {\n    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);\n}\n\nFloating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff) {\n    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);\n}\n\nFloating::WithinAbsMatcher WithinAbs(double target, double margin) {\n    return Floating::WithinAbsMatcher(target, margin);\n}\n\n} // namespace Matchers\n"
    },
    {
        "begin_line": 7958,
        "end_line": 7998,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Floating",
        "snippet": "namespace Floating {\n    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)\n        :m_target{ target }, m_margin{ margin } {\n        if (m_margin < 0) {\n            throw std::domain_error(\"Allowed margin difference has to be >= 0\");\n        }\n    }\n\n    // Performs equivalent check of std::fabs(lhs - rhs) <= margin\n    // But without the subtraction to allow for INFINITY in comparison\n    bool WithinAbsMatcher::match(double const& matchee) const {\n        return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);\n    }\n\n    std::string WithinAbsMatcher::describe() const {\n        return \"is within \" + ::Catch::Detail::stringify(m_margin) + \" of \" + ::Catch::Detail::stringify(m_target);\n    }\n\n    WithinUlpsMatcher::WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType)\n        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {\n        if (m_ulps < 0) {\n            throw std::domain_error(\"Allowed ulp difference has to be >= 0\");\n        }\n    }\n\n    bool WithinUlpsMatcher::match(double const& matchee) const {\n        switch (m_type) {\n        case FloatingPointKind::Float:\n            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);\n        case FloatingPointKind::Double:\n            return almostEqualUlps<double>(matchee, m_target, m_ulps);\n        default:\n            throw std::domain_error(\"Unknown FloatingPointKind value\");\n        }\n    }\n\n    std::string WithinUlpsMatcher::describe() const {\n        return \"is within \" + std::to_string(m_ulps) + \" ULPs of \" + ::Catch::Detail::stringify(m_target) + ((m_type == FloatingPointKind::Float)? \"f\" : \"\");\n    }\n\n}// namespace Floating\n"
    },
    {
        "begin_line": 7959,
        "end_line": 7964,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WithinAbsMatcher",
        "snippet": "    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)\n        :m_target{ target }, m_margin{ margin } {\n        if (m_margin < 0) {\n            throw std::domain_error(\"Allowed margin difference has to be >= 0\");\n        }\n    }\n"
    },
    {
        "begin_line": 7968,
        "end_line": 7970,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "    bool WithinAbsMatcher::match(double const& matchee) const {\n        return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);\n    }\n"
    },
    {
        "begin_line": 7972,
        "end_line": 7974,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "    std::string WithinAbsMatcher::describe() const {\n        return \"is within \" + ::Catch::Detail::stringify(m_margin) + \" of \" + ::Catch::Detail::stringify(m_target);\n    }\n"
    },
    {
        "begin_line": 7976,
        "end_line": 7981,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WithinUlpsMatcher",
        "snippet": "    WithinUlpsMatcher::WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType)\n        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {\n        if (m_ulps < 0) {\n            throw std::domain_error(\"Allowed ulp difference has to be >= 0\");\n        }\n    }\n"
    },
    {
        "begin_line": 7983,
        "end_line": 7992,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "    bool WithinUlpsMatcher::match(double const& matchee) const {\n        switch (m_type) {\n        case FloatingPointKind::Float:\n            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);\n        case FloatingPointKind::Double:\n            return almostEqualUlps<double>(matchee, m_target, m_ulps);\n        default:\n            throw std::domain_error(\"Unknown FloatingPointKind value\");\n        }\n    }\n"
    },
    {
        "begin_line": 7994,
        "end_line": 7996,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "    std::string WithinUlpsMatcher::describe() const {\n        return \"is within \" + std::to_string(m_ulps) + \" ULPs of \" + ::Catch::Detail::stringify(m_target) + ((m_type == FloatingPointKind::Float)? \"f\" : \"\");\n    }\n"
    },
    {
        "begin_line": 8000,
        "end_line": 8002,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WithinULP",
        "snippet": "Floating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff) {\n    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);\n}\n"
    },
    {
        "begin_line": 8004,
        "end_line": 8006,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WithinULP",
        "snippet": "Floating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff) {\n    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);\n}\n"
    },
    {
        "begin_line": 8008,
        "end_line": 8010,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WithinAbs",
        "snippet": "Floating::WithinAbsMatcher WithinAbs(double target, double margin) {\n    return Floating::WithinAbsMatcher(target, margin);\n}\n"
    },
    {
        "begin_line": 8018,
        "end_line": 8024,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "finalizeDescription",
        "snippet": "std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string& desc) {\n    if (desc.empty()) {\n        return \"matches undescribed predicate\";\n    } else {\n        return \"matches predicate: \\\"\" + desc + '\"';\n    }\n}\n"
    },
    {
        "begin_line": 8030,
        "end_line": 8126,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace Matchers {\n\n    namespace StdString {\n\n        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )\n        :   m_caseSensitivity( caseSensitivity ),\n            m_str( adjustString( str ) )\n        {}\n        std::string CasedString::adjustString( std::string const& str ) const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? toLower( str )\n                   : str;\n        }\n        std::string CasedString::caseSensitivitySuffix() const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? \" (case insensitive)\"\n                   : std::string();\n        }\n\n        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )\n        : m_comparator( comparator ),\n          m_operation( operation ) {\n        }\n\n        std::string StringMatcherBase::describe() const {\n            std::string description;\n            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\n                                        m_comparator.caseSensitivitySuffix().size());\n            description += m_operation;\n            description += \": \\\"\";\n            description += m_comparator.m_str;\n            description += \"\\\"\";\n            description += m_comparator.caseSensitivitySuffix();\n            return description;\n        }\n\n        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( \"equals\", comparator ) {}\n\n        bool EqualsMatcher::match( std::string const& source ) const {\n            return m_comparator.adjustString( source ) == m_comparator.m_str;\n        }\n\n        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( \"contains\", comparator ) {}\n\n        bool ContainsMatcher::match( std::string const& source ) const {\n            return contains( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"starts with\", comparator ) {}\n\n        bool StartsWithMatcher::match( std::string const& source ) const {\n            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"ends with\", comparator ) {}\n\n        bool EndsWithMatcher::match( std::string const& source ) const {\n            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}\n\n        bool RegexMatcher::match(std::string const& matchee) const {\n            auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway\n            if (m_caseSensitivity == CaseSensitive::Choice::No) {\n                flags |= std::regex::icase;\n            }\n            auto reg = std::regex(m_regex, flags);\n            return std::regex_match(matchee, reg);\n        }\n\n        std::string RegexMatcher::describe() const {\n            return \"matches \" + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? \" case sensitively\" : \" case insensitively\");\n        }\n\n    } // namespace StdString\n\n    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n\n    StdString::RegexMatcher Matches(std::string const& regex, CaseSensitive::Choice caseSensitivity) {\n        return StdString::RegexMatcher(regex, caseSensitivity);\n    }\n\n} // namespace Matchers\n} // namespace Catch\n"
    },
    {
        "begin_line": 8031,
        "end_line": 8125,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matchers",
        "snippet": "namespace Matchers {\n\n    namespace StdString {\n\n        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )\n        :   m_caseSensitivity( caseSensitivity ),\n            m_str( adjustString( str ) )\n        {}\n        std::string CasedString::adjustString( std::string const& str ) const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? toLower( str )\n                   : str;\n        }\n        std::string CasedString::caseSensitivitySuffix() const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? \" (case insensitive)\"\n                   : std::string();\n        }\n\n        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )\n        : m_comparator( comparator ),\n          m_operation( operation ) {\n        }\n\n        std::string StringMatcherBase::describe() const {\n            std::string description;\n            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\n                                        m_comparator.caseSensitivitySuffix().size());\n            description += m_operation;\n            description += \": \\\"\";\n            description += m_comparator.m_str;\n            description += \"\\\"\";\n            description += m_comparator.caseSensitivitySuffix();\n            return description;\n        }\n\n        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( \"equals\", comparator ) {}\n\n        bool EqualsMatcher::match( std::string const& source ) const {\n            return m_comparator.adjustString( source ) == m_comparator.m_str;\n        }\n\n        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( \"contains\", comparator ) {}\n\n        bool ContainsMatcher::match( std::string const& source ) const {\n            return contains( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"starts with\", comparator ) {}\n\n        bool StartsWithMatcher::match( std::string const& source ) const {\n            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"ends with\", comparator ) {}\n\n        bool EndsWithMatcher::match( std::string const& source ) const {\n            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}\n\n        bool RegexMatcher::match(std::string const& matchee) const {\n            auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway\n            if (m_caseSensitivity == CaseSensitive::Choice::No) {\n                flags |= std::regex::icase;\n            }\n            auto reg = std::regex(m_regex, flags);\n            return std::regex_match(matchee, reg);\n        }\n\n        std::string RegexMatcher::describe() const {\n            return \"matches \" + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? \" case sensitively\" : \" case insensitively\");\n        }\n\n    } // namespace StdString\n\n    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n\n    StdString::RegexMatcher Matches(std::string const& regex, CaseSensitive::Choice caseSensitivity) {\n        return StdString::RegexMatcher(regex, caseSensitivity);\n    }\n\n} // namespace Matchers\n"
    },
    {
        "begin_line": 8033,
        "end_line": 8106,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StdString",
        "snippet": "    namespace StdString {\n\n        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )\n        :   m_caseSensitivity( caseSensitivity ),\n            m_str( adjustString( str ) )\n        {}\n        std::string CasedString::adjustString( std::string const& str ) const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? toLower( str )\n                   : str;\n        }\n        std::string CasedString::caseSensitivitySuffix() const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? \" (case insensitive)\"\n                   : std::string();\n        }\n\n        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )\n        : m_comparator( comparator ),\n          m_operation( operation ) {\n        }\n\n        std::string StringMatcherBase::describe() const {\n            std::string description;\n            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\n                                        m_comparator.caseSensitivitySuffix().size());\n            description += m_operation;\n            description += \": \\\"\";\n            description += m_comparator.m_str;\n            description += \"\\\"\";\n            description += m_comparator.caseSensitivitySuffix();\n            return description;\n        }\n\n        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( \"equals\", comparator ) {}\n\n        bool EqualsMatcher::match( std::string const& source ) const {\n            return m_comparator.adjustString( source ) == m_comparator.m_str;\n        }\n\n        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( \"contains\", comparator ) {}\n\n        bool ContainsMatcher::match( std::string const& source ) const {\n            return contains( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"starts with\", comparator ) {}\n\n        bool StartsWithMatcher::match( std::string const& source ) const {\n            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"ends with\", comparator ) {}\n\n        bool EndsWithMatcher::match( std::string const& source ) const {\n            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}\n\n        bool RegexMatcher::match(std::string const& matchee) const {\n            auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway\n            if (m_caseSensitivity == CaseSensitive::Choice::No) {\n                flags |= std::regex::icase;\n            }\n            auto reg = std::regex(m_regex, flags);\n            return std::regex_match(matchee, reg);\n        }\n\n        std::string RegexMatcher::describe() const {\n            return \"matches \" + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? \" case sensitively\" : \" case insensitively\");\n        }\n\n    } // namespace StdString\n"
    },
    {
        "begin_line": 8035,
        "end_line": 8038,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CasedString",
        "snippet": "        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )\n        :   m_caseSensitivity( caseSensitivity ),\n            m_str( adjustString( str ) )\n        {}\n"
    },
    {
        "begin_line": 8039,
        "end_line": 8043,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "adjustString",
        "snippet": "        std::string CasedString::adjustString( std::string const& str ) const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? toLower( str )\n                   : str;\n        }\n"
    },
    {
        "begin_line": 8044,
        "end_line": 8048,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "caseSensitivitySuffix",
        "snippet": "        std::string CasedString::caseSensitivitySuffix() const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? \" (case insensitive)\"\n                   : std::string();\n        }\n"
    },
    {
        "begin_line": 8050,
        "end_line": 8053,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringMatcherBase",
        "snippet": "        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )\n        : m_comparator( comparator ),\n          m_operation( operation ) {\n        }\n"
    },
    {
        "begin_line": 8055,
        "end_line": 8065,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "        std::string StringMatcherBase::describe() const {\n            std::string description;\n            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\n                                        m_comparator.caseSensitivitySuffix().size());\n            description += m_operation;\n            description += \": \\\"\";\n            description += m_comparator.m_str;\n            description += \"\\\"\";\n            description += m_comparator.caseSensitivitySuffix();\n            return description;\n        }\n"
    },
    {
        "begin_line": 8067,
        "end_line": 8067,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EqualsMatcher",
        "snippet": "        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( \"equals\", comparator ) {}\n"
    },
    {
        "begin_line": 8069,
        "end_line": 8071,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "        bool EqualsMatcher::match( std::string const& source ) const {\n            return m_comparator.adjustString( source ) == m_comparator.m_str;\n        }\n"
    },
    {
        "begin_line": 8073,
        "end_line": 8073,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ContainsMatcher",
        "snippet": "        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( \"contains\", comparator ) {}\n"
    },
    {
        "begin_line": 8075,
        "end_line": 8077,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "        bool ContainsMatcher::match( std::string const& source ) const {\n            return contains( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n"
    },
    {
        "begin_line": 8079,
        "end_line": 8079,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StartsWithMatcher",
        "snippet": "        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"starts with\", comparator ) {}\n"
    },
    {
        "begin_line": 8081,
        "end_line": 8083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "        bool StartsWithMatcher::match( std::string const& source ) const {\n            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n"
    },
    {
        "begin_line": 8085,
        "end_line": 8085,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EndsWithMatcher",
        "snippet": "        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"ends with\", comparator ) {}\n"
    },
    {
        "begin_line": 8087,
        "end_line": 8089,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "        bool EndsWithMatcher::match( std::string const& source ) const {\n            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n"
    },
    {
        "begin_line": 8091,
        "end_line": 8091,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RegexMatcher",
        "snippet": "        RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}\n"
    },
    {
        "begin_line": 8093,
        "end_line": 8100,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "match",
        "snippet": "        bool RegexMatcher::match(std::string const& matchee) const {\n            auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway\n            if (m_caseSensitivity == CaseSensitive::Choice::No) {\n                flags |= std::regex::icase;\n            }\n            auto reg = std::regex(m_regex, flags);\n            return std::regex_match(matchee, reg);\n        }\n"
    },
    {
        "begin_line": 8102,
        "end_line": 8104,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "describe",
        "snippet": "        std::string RegexMatcher::describe() const {\n            return \"matches \" + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? \" case sensitively\" : \" case insensitively\");\n        }\n"
    },
    {
        "begin_line": 8108,
        "end_line": 8110,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Equals",
        "snippet": "    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n"
    },
    {
        "begin_line": 8111,
        "end_line": 8113,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Contains",
        "snippet": "    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n"
    },
    {
        "begin_line": 8114,
        "end_line": 8116,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "EndsWith",
        "snippet": "    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n"
    },
    {
        "begin_line": 8117,
        "end_line": 8119,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StartsWith",
        "snippet": "    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n"
    },
    {
        "begin_line": 8121,
        "end_line": 8123,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Matches",
        "snippet": "    StdString::RegexMatcher Matches(std::string const& regex, CaseSensitive::Choice caseSensitivity) {\n        return StdString::RegexMatcher(regex, caseSensitivity);\n    }\n"
    },
    {
        "begin_line": 8132,
        "end_line": 8134,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    bool uncaught_exceptions();\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8137,
        "end_line": 8180,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    MessageInfo::MessageInfo(   std::string const& _macroName,\n                                SourceLineInfo const& _lineInfo,\n                                ResultWas::OfType _type )\n    :   macroName( _macroName ),\n        lineInfo( _lineInfo ),\n        type( _type ),\n        sequence( ++globalCount )\n    {}\n\n    bool MessageInfo::operator==( MessageInfo const& other ) const {\n        return sequence == other.sequence;\n    }\n\n    bool MessageInfo::operator<( MessageInfo const& other ) const {\n        return sequence < other.sequence;\n    }\n\n    // This may need protecting if threading support is added\n    unsigned int MessageInfo::globalCount = 0;\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    Catch::MessageBuilder::MessageBuilder( std::string const& macroName,\n                                           SourceLineInfo const& lineInfo,\n                                           ResultWas::OfType type )\n        :m_info(macroName, lineInfo, type) {}\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    ScopedMessage::ScopedMessage( MessageBuilder const& builder )\n    : m_info( builder.m_info )\n    {\n        m_info.message = builder.m_stream.str();\n        getResultCapture().pushScopedMessage( m_info );\n    }\n\n    ScopedMessage::~ScopedMessage() {\n        if ( !uncaught_exceptions() ){\n            getResultCapture().popScopedMessage(m_info);\n        }\n    }\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8139,
        "end_line": 8146,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MessageInfo",
        "snippet": "    MessageInfo::MessageInfo(   std::string const& _macroName,\n                                SourceLineInfo const& _lineInfo,\n                                ResultWas::OfType _type )\n    :   macroName( _macroName ),\n        lineInfo( _lineInfo ),\n        type( _type ),\n        sequence( ++globalCount )\n    {}\n"
    },
    {
        "begin_line": 8148,
        "end_line": 8150,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "    bool MessageInfo::operator==( MessageInfo const& other ) const {\n        return sequence == other.sequence;\n    }\n"
    },
    {
        "begin_line": 8152,
        "end_line": 8154,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <",
        "snippet": "    bool MessageInfo::operator<( MessageInfo const& other ) const {\n        return sequence < other.sequence;\n    }\n"
    },
    {
        "begin_line": 8157,
        "end_line": 8157,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "globalCount",
        "snippet": "    unsigned int MessageInfo::globalCount = 0;\n"
    },
    {
        "begin_line": 8161,
        "end_line": 8164,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MessageBuilder",
        "snippet": "    Catch::MessageBuilder::MessageBuilder( std::string const& macroName,\n                                           SourceLineInfo const& lineInfo,\n                                           ResultWas::OfType type )\n        :m_info(macroName, lineInfo, type) {}\n"
    },
    {
        "begin_line": 8168,
        "end_line": 8173,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ScopedMessage",
        "snippet": "    ScopedMessage::ScopedMessage( MessageBuilder const& builder )\n    : m_info( builder.m_info )\n    {\n        m_info.message = builder.m_stream.str();\n        getResultCapture().pushScopedMessage( m_info );\n    }\n"
    },
    {
        "begin_line": 8175,
        "end_line": 8179,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~ScopedMessage",
        "snippet": "    ScopedMessage::~ScopedMessage() {\n        if ( !uncaught_exceptions() ){\n            getResultCapture().popScopedMessage(m_info);\n        }\n    }\n"
    },
    {
        "begin_line": 8188,
        "end_line": 8212,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct IConfig;\n\n    void seedRng( IConfig const& config );\n\n    unsigned int rngSeed();\n\n    struct RandomNumberGenerator {\n        using result_type = unsigned int;\n\n        static constexpr result_type (min)() { return 0; }\n        static constexpr result_type (max)() { return 1000000; }\n\n        result_type operator()( result_type n ) const;\n        result_type operator()() const;\n\n        template<typename V>\n        static void shuffle( V& vector ) {\n            RandomNumberGenerator rng;\n            std::shuffle( vector.begin(), vector.end(), rng );\n        }\n    };\n\n}\n"
    },
    {
        "begin_line": 8196,
        "end_line": 8210,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RandomNumberGenerator",
        "snippet": "    struct RandomNumberGenerator {\n        using result_type = unsigned int;\n\n        static constexpr result_type (min)() { return 0; }\n        static constexpr result_type (max)() { return 1000000; }\n\n        result_type operator()( result_type n ) const;\n        result_type operator()() const;\n\n        template<typename V>\n        static void shuffle( V& vector ) {\n            RandomNumberGenerator rng;\n            std::shuffle( vector.begin(), vector.end(), rng );\n        }\n    };\n"
    },
    {
        "begin_line": 8199,
        "end_line": 8199,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "result_type",
        "snippet": "        static constexpr result_type (min)() { return 0; }\n"
    },
    {
        "begin_line": 8200,
        "end_line": 8200,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "result_type",
        "snippet": "        static constexpr result_type (max)() { return 1000000; }\n"
    },
    {
        "begin_line": 8206,
        "end_line": 8209,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shuffle",
        "snippet": "        static void shuffle( V& vector ) {\n            RandomNumberGenerator rng;\n            std::shuffle( vector.begin(), vector.end(), rng );\n        }\n"
    },
    {
        "begin_line": 8217,
        "end_line": 8234,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    void seedRng( IConfig const& config ) {\n        if( config.rngSeed() != 0 )\n            std::srand( config.rngSeed() );\n    }\n    unsigned int rngSeed() {\n        return getCurrentContext().getConfig()->rngSeed();\n    }\n\n    RandomNumberGenerator::result_type RandomNumberGenerator::operator()( result_type n ) const {\n        return std::rand() % n;\n    }\n    RandomNumberGenerator::result_type RandomNumberGenerator::operator()() const {\n        return std::rand() % (max)();\n    }\n\n}\n"
    },
    {
        "begin_line": 8219,
        "end_line": 8222,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "seedRng",
        "snippet": "    void seedRng( IConfig const& config ) {\n        if( config.rngSeed() != 0 )\n            std::srand( config.rngSeed() );\n    }\n"
    },
    {
        "begin_line": 8223,
        "end_line": 8225,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rngSeed",
        "snippet": "    unsigned int rngSeed() {\n        return getCurrentContext().getConfig()->rngSeed();\n    }\n"
    },
    {
        "begin_line": 8227,
        "end_line": 8229,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ()",
        "snippet": "    RandomNumberGenerator::result_type RandomNumberGenerator::operator()( result_type n ) const {\n        return std::rand() % n;\n    }\n"
    },
    {
        "begin_line": 8230,
        "end_line": 8232,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ()",
        "snippet": "    RandomNumberGenerator::result_type RandomNumberGenerator::operator()() const {\n        return std::rand() % (max)();\n    }\n"
    },
    {
        "begin_line": 8245,
        "end_line": 8289,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class TestCase;\n    struct IConfig;\n\n    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );\n    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n\n    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );\n\n    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );\n    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );\n\n    class TestRegistry : public ITestCaseRegistry {\n    public:\n        virtual ~TestRegistry() = default;\n\n        virtual void registerTest( TestCase const& testCase );\n\n        std::vector<TestCase> const& getAllTests() const override;\n        std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const override;\n\n    private:\n        std::vector<TestCase> m_functions;\n        mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;\n        mutable std::vector<TestCase> m_sortedFunctions;\n        std::size_t m_unnamedCount = 0;\n        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    class TestInvokerAsFunction : public ITestInvoker {\n        void(*m_testAsFunction)();\n    public:\n        TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;\n\n        void invoke() const override;\n    };\n\n    std::string extractClassName( StringRef const& classOrQualifiedMethodName );\n\n    ///////////////////////////////////////////////////////////////////////////\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8258,
        "end_line": 8273,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestRegistry",
        "snippet": "    class TestRegistry : public ITestCaseRegistry {\n    public:\n        virtual ~TestRegistry() = default;\n\n        virtual void registerTest( TestCase const& testCase );\n\n        std::vector<TestCase> const& getAllTests() const override;\n        std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const override;\n\n    private:\n        std::vector<TestCase> m_functions;\n        mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;\n        mutable std::vector<TestCase> m_sortedFunctions;\n        std::size_t m_unnamedCount = 0;\n        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised\n    };\n"
    },
    {
        "begin_line": 8268,
        "end_line": 8268,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_functions",
        "snippet": "        std::vector<TestCase> m_functions;\n"
    },
    {
        "begin_line": 8269,
        "end_line": 8269,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_currentSortOrder",
        "snippet": "        mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;\n"
    },
    {
        "begin_line": 8270,
        "end_line": 8270,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_sortedFunctions",
        "snippet": "        mutable std::vector<TestCase> m_sortedFunctions;\n"
    },
    {
        "begin_line": 8271,
        "end_line": 8271,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_unnamedCount",
        "snippet": "        std::size_t m_unnamedCount = 0;\n"
    },
    {
        "begin_line": 8272,
        "end_line": 8272,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ostreamInit",
        "snippet": "        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised\n"
    },
    {
        "begin_line": 8277,
        "end_line": 8283,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestInvokerAsFunction",
        "snippet": "    class TestInvokerAsFunction : public ITestInvoker {\n        void(*m_testAsFunction)();\n    public:\n        TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;\n\n        void invoke() const override;\n    };\n"
    },
    {
        "begin_line": 8278,
        "end_line": 8278,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testAsFunction",
        "snippet": "        void(*m_testAsFunction)();\n"
    },
    {
        "begin_line": 8296,
        "end_line": 8316,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class ReporterRegistry : public IReporterRegistry {\n\n    public:\n\n        ~ReporterRegistry() override;\n\n        IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const override;\n\n        void registerReporter( std::string const& name, IReporterFactoryPtr const& factory );\n        void registerListener( IReporterFactoryPtr const& factory );\n\n        FactoryMap const& getFactories() const override;\n        Listeners const& getListeners() const override;\n\n    private:\n        FactoryMap m_factories;\n        Listeners m_listeners;\n    };\n}\n"
    },
    {
        "begin_line": 8298,
        "end_line": 8315,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReporterRegistry",
        "snippet": "    class ReporterRegistry : public IReporterRegistry {\n\n    public:\n\n        ~ReporterRegistry() override;\n\n        IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const override;\n\n        void registerReporter( std::string const& name, IReporterFactoryPtr const& factory );\n        void registerListener( IReporterFactoryPtr const& factory );\n\n        FactoryMap const& getFactories() const override;\n        Listeners const& getListeners() const override;\n\n    private:\n        FactoryMap m_factories;\n        Listeners m_listeners;\n    };\n"
    },
    {
        "begin_line": 8313,
        "end_line": 8313,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_factories",
        "snippet": "        FactoryMap m_factories;\n"
    },
    {
        "begin_line": 8314,
        "end_line": 8314,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_listeners",
        "snippet": "        Listeners m_listeners;\n"
    },
    {
        "begin_line": 8325,
        "end_line": 8334,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    struct TagAlias {\n        TagAlias(std::string const& _tag, SourceLineInfo _lineInfo);\n\n        std::string tag;\n        SourceLineInfo lineInfo;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8327,
        "end_line": 8332,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TagAlias",
        "snippet": "    struct TagAlias {\n        TagAlias(std::string const& _tag, SourceLineInfo _lineInfo);\n\n        std::string tag;\n        SourceLineInfo lineInfo;\n    };\n"
    },
    {
        "begin_line": 8330,
        "end_line": 8330,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "tag",
        "snippet": "        std::string tag;\n"
    },
    {
        "begin_line": 8331,
        "end_line": 8331,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lineInfo",
        "snippet": "        SourceLineInfo lineInfo;\n"
    },
    {
        "begin_line": 8339,
        "end_line": 8352,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class TagAliasRegistry : public ITagAliasRegistry {\n    public:\n        ~TagAliasRegistry() override;\n        TagAlias const* find( std::string const& alias ) const override;\n        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;\n        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );\n\n    private:\n        std::map<std::string, TagAlias> m_registry;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8341,
        "end_line": 8350,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TagAliasRegistry",
        "snippet": "    class TagAliasRegistry : public ITagAliasRegistry {\n    public:\n        ~TagAliasRegistry() override;\n        TagAlias const* find( std::string const& alias ) const override;\n        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;\n        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );\n\n    private:\n        std::map<std::string, TagAlias> m_registry;\n    };\n"
    },
    {
        "begin_line": 8349,
        "end_line": 8349,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_registry",
        "snippet": "        std::map<std::string, TagAlias> m_registry;\n"
    },
    {
        "begin_line": 8360,
        "end_line": 8370,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class StartupExceptionRegistry {\n    public:\n        void add(std::exception_ptr const& exception) noexcept;\n        std::vector<std::exception_ptr> const& getExceptions() const noexcept;\n    private:\n        std::vector<std::exception_ptr> m_exceptions;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8362,
        "end_line": 8368,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StartupExceptionRegistry",
        "snippet": "    class StartupExceptionRegistry {\n    public:\n        void add(std::exception_ptr const& exception) noexcept;\n        std::vector<std::exception_ptr> const& getExceptions() const noexcept;\n    private:\n        std::vector<std::exception_ptr> m_exceptions;\n    };\n"
    },
    {
        "begin_line": 8367,
        "end_line": 8367,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_exceptions",
        "snippet": "        std::vector<std::exception_ptr> m_exceptions;\n"
    },
    {
        "begin_line": 8373,
        "end_line": 8451,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    namespace {\n\n        class RegistryHub : public IRegistryHub, public IMutableRegistryHub,\n                            private NonCopyable {\n\n        public: // IRegistryHub\n            RegistryHub() = default;\n            IReporterRegistry const& getReporterRegistry() const override {\n                return m_reporterRegistry;\n            }\n            ITestCaseRegistry const& getTestCaseRegistry() const override {\n                return m_testCaseRegistry;\n            }\n            IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() override {\n                return m_exceptionTranslatorRegistry;\n            }\n            ITagAliasRegistry const& getTagAliasRegistry() const override {\n                return m_tagAliasRegistry;\n            }\n            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {\n                return m_exceptionRegistry;\n            }\n\n        public: // IMutableRegistryHub\n            void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerReporter( name, factory );\n            }\n            void registerListener( IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerListener( factory );\n            }\n            void registerTest( TestCase const& testInfo ) override {\n                m_testCaseRegistry.registerTest( testInfo );\n            }\n            void registerTranslator( const IExceptionTranslator* translator ) override {\n                m_exceptionTranslatorRegistry.registerTranslator( translator );\n            }\n            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {\n                m_tagAliasRegistry.add( alias, tag, lineInfo );\n            }\n            void registerStartupException() noexcept override {\n                m_exceptionRegistry.add(std::current_exception());\n            }\n\n        private:\n            TestRegistry m_testCaseRegistry;\n            ReporterRegistry m_reporterRegistry;\n            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\n            TagAliasRegistry m_tagAliasRegistry;\n            StartupExceptionRegistry m_exceptionRegistry;\n        };\n\n        // Single, global, instance\n        RegistryHub*& getTheRegistryHub() {\n            static RegistryHub* theRegistryHub = nullptr;\n            if( !theRegistryHub )\n                theRegistryHub = new RegistryHub();\n            return theRegistryHub;\n        }\n    }\n\n    IRegistryHub& getRegistryHub() {\n        return *getTheRegistryHub();\n    }\n    IMutableRegistryHub& getMutableRegistryHub() {\n        return *getTheRegistryHub();\n    }\n    void cleanUp() {\n        delete getTheRegistryHub();\n        getTheRegistryHub() = nullptr;\n        cleanUpContext();\n        ReusableStringStream::cleanup();\n    }\n    std::string translateActiveException() {\n        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8375,
        "end_line": 8433,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1511",
        "snippet": "    namespace {\n\n        class RegistryHub : public IRegistryHub, public IMutableRegistryHub,\n                            private NonCopyable {\n\n        public: // IRegistryHub\n            RegistryHub() = default;\n            IReporterRegistry const& getReporterRegistry() const override {\n                return m_reporterRegistry;\n            }\n            ITestCaseRegistry const& getTestCaseRegistry() const override {\n                return m_testCaseRegistry;\n            }\n            IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() override {\n                return m_exceptionTranslatorRegistry;\n            }\n            ITagAliasRegistry const& getTagAliasRegistry() const override {\n                return m_tagAliasRegistry;\n            }\n            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {\n                return m_exceptionRegistry;\n            }\n\n        public: // IMutableRegistryHub\n            void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerReporter( name, factory );\n            }\n            void registerListener( IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerListener( factory );\n            }\n            void registerTest( TestCase const& testInfo ) override {\n                m_testCaseRegistry.registerTest( testInfo );\n            }\n            void registerTranslator( const IExceptionTranslator* translator ) override {\n                m_exceptionTranslatorRegistry.registerTranslator( translator );\n            }\n            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {\n                m_tagAliasRegistry.add( alias, tag, lineInfo );\n            }\n            void registerStartupException() noexcept override {\n                m_exceptionRegistry.add(std::current_exception());\n            }\n\n        private:\n            TestRegistry m_testCaseRegistry;\n            ReporterRegistry m_reporterRegistry;\n            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\n            TagAliasRegistry m_tagAliasRegistry;\n            StartupExceptionRegistry m_exceptionRegistry;\n        };\n\n        // Single, global, instance\n        RegistryHub*& getTheRegistryHub() {\n            static RegistryHub* theRegistryHub = nullptr;\n            if( !theRegistryHub )\n                theRegistryHub = new RegistryHub();\n            return theRegistryHub;\n        }\n    }\n"
    },
    {
        "begin_line": 8377,
        "end_line": 8424,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RegistryHub",
        "snippet": "        class RegistryHub : public IRegistryHub, public IMutableRegistryHub,\n                            private NonCopyable {\n\n        public: // IRegistryHub\n            RegistryHub() = default;\n            IReporterRegistry const& getReporterRegistry() const override {\n                return m_reporterRegistry;\n            }\n            ITestCaseRegistry const& getTestCaseRegistry() const override {\n                return m_testCaseRegistry;\n            }\n            IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() override {\n                return m_exceptionTranslatorRegistry;\n            }\n            ITagAliasRegistry const& getTagAliasRegistry() const override {\n                return m_tagAliasRegistry;\n            }\n            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {\n                return m_exceptionRegistry;\n            }\n\n        public: // IMutableRegistryHub\n            void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerReporter( name, factory );\n            }\n            void registerListener( IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerListener( factory );\n            }\n            void registerTest( TestCase const& testInfo ) override {\n                m_testCaseRegistry.registerTest( testInfo );\n            }\n            void registerTranslator( const IExceptionTranslator* translator ) override {\n                m_exceptionTranslatorRegistry.registerTranslator( translator );\n            }\n            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {\n                m_tagAliasRegistry.add( alias, tag, lineInfo );\n            }\n            void registerStartupException() noexcept override {\n                m_exceptionRegistry.add(std::current_exception());\n            }\n\n        private:\n            TestRegistry m_testCaseRegistry;\n            ReporterRegistry m_reporterRegistry;\n            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\n            TagAliasRegistry m_tagAliasRegistry;\n            StartupExceptionRegistry m_exceptionRegistry;\n        };\n"
    },
    {
        "begin_line": 8382,
        "end_line": 8384,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getReporterRegistry",
        "snippet": "            IReporterRegistry const& getReporterRegistry() const override {\n                return m_reporterRegistry;\n            }\n"
    },
    {
        "begin_line": 8385,
        "end_line": 8387,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getTestCaseRegistry",
        "snippet": "            ITestCaseRegistry const& getTestCaseRegistry() const override {\n                return m_testCaseRegistry;\n            }\n"
    },
    {
        "begin_line": 8388,
        "end_line": 8390,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getExceptionTranslatorRegistry",
        "snippet": "            IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() override {\n                return m_exceptionTranslatorRegistry;\n            }\n"
    },
    {
        "begin_line": 8391,
        "end_line": 8393,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getTagAliasRegistry",
        "snippet": "            ITagAliasRegistry const& getTagAliasRegistry() const override {\n                return m_tagAliasRegistry;\n            }\n"
    },
    {
        "begin_line": 8394,
        "end_line": 8396,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getStartupExceptionRegistry",
        "snippet": "            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {\n                return m_exceptionRegistry;\n            }\n"
    },
    {
        "begin_line": 8399,
        "end_line": 8401,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerReporter",
        "snippet": "            void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerReporter( name, factory );\n            }\n"
    },
    {
        "begin_line": 8402,
        "end_line": 8404,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerListener",
        "snippet": "            void registerListener( IReporterFactoryPtr const& factory ) override {\n                m_reporterRegistry.registerListener( factory );\n            }\n"
    },
    {
        "begin_line": 8405,
        "end_line": 8407,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerTest",
        "snippet": "            void registerTest( TestCase const& testInfo ) override {\n                m_testCaseRegistry.registerTest( testInfo );\n            }\n"
    },
    {
        "begin_line": 8408,
        "end_line": 8410,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerTranslator",
        "snippet": "            void registerTranslator( const IExceptionTranslator* translator ) override {\n                m_exceptionTranslatorRegistry.registerTranslator( translator );\n            }\n"
    },
    {
        "begin_line": 8411,
        "end_line": 8413,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerTagAlias",
        "snippet": "            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {\n                m_tagAliasRegistry.add( alias, tag, lineInfo );\n            }\n"
    },
    {
        "begin_line": 8414,
        "end_line": 8416,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerStartupException",
        "snippet": "            void registerStartupException() noexcept override {\n                m_exceptionRegistry.add(std::current_exception());\n            }\n"
    },
    {
        "begin_line": 8419,
        "end_line": 8419,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_testCaseRegistry",
        "snippet": "            TestRegistry m_testCaseRegistry;\n"
    },
    {
        "begin_line": 8420,
        "end_line": 8420,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_reporterRegistry",
        "snippet": "            ReporterRegistry m_reporterRegistry;\n"
    },
    {
        "begin_line": 8421,
        "end_line": 8421,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_exceptionTranslatorRegistry",
        "snippet": "            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\n"
    },
    {
        "begin_line": 8422,
        "end_line": 8422,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_tagAliasRegistry",
        "snippet": "            TagAliasRegistry m_tagAliasRegistry;\n"
    },
    {
        "begin_line": 8423,
        "end_line": 8423,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_exceptionRegistry",
        "snippet": "            StartupExceptionRegistry m_exceptionRegistry;\n"
    },
    {
        "begin_line": 8427,
        "end_line": 8432,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getTheRegistryHub",
        "snippet": "        RegistryHub*& getTheRegistryHub() {\n            static RegistryHub* theRegistryHub = nullptr;\n            if( !theRegistryHub )\n                theRegistryHub = new RegistryHub();\n            return theRegistryHub;\n        }\n"
    },
    {
        "begin_line": 8435,
        "end_line": 8437,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getRegistryHub",
        "snippet": "    IRegistryHub& getRegistryHub() {\n        return *getTheRegistryHub();\n    }\n"
    },
    {
        "begin_line": 8438,
        "end_line": 8440,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getMutableRegistryHub",
        "snippet": "    IMutableRegistryHub& getMutableRegistryHub() {\n        return *getTheRegistryHub();\n    }\n"
    },
    {
        "begin_line": 8441,
        "end_line": 8446,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cleanUp",
        "snippet": "    void cleanUp() {\n        delete getTheRegistryHub();\n        getTheRegistryHub() = nullptr;\n        cleanUpContext();\n        ReusableStringStream::cleanup();\n    }\n"
    },
    {
        "begin_line": 8447,
        "end_line": 8449,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "translateActiveException",
        "snippet": "    std::string translateActiveException() {\n        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();\n    }\n"
    },
    {
        "begin_line": 8455,
        "end_line": 8480,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    ReporterRegistry::~ReporterRegistry() = default;\n\n    IStreamingReporterPtr ReporterRegistry::create( std::string const& name, IConfigPtr const& config ) const {\n        auto it =  m_factories.find( name );\n        if( it == m_factories.end() )\n            return nullptr;\n        return it->second->create( ReporterConfig( config ) );\n    }\n\n    void ReporterRegistry::registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) {\n        m_factories.emplace(name, factory);\n    }\n    void ReporterRegistry::registerListener( IReporterFactoryPtr const& factory ) {\n        m_listeners.push_back( factory );\n    }\n\n    IReporterRegistry::FactoryMap const& ReporterRegistry::getFactories() const {\n        return m_factories;\n    }\n    IReporterRegistry::Listeners const& ReporterRegistry::getListeners() const {\n        return m_listeners;\n    }\n\n}\n"
    },
    {
        "begin_line": 8459,
        "end_line": 8464,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "create",
        "snippet": "    IStreamingReporterPtr ReporterRegistry::create( std::string const& name, IConfigPtr const& config ) const {\n        auto it =  m_factories.find( name );\n        if( it == m_factories.end() )\n            return nullptr;\n        return it->second->create( ReporterConfig( config ) );\n    }\n"
    },
    {
        "begin_line": 8466,
        "end_line": 8468,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerReporter",
        "snippet": "    void ReporterRegistry::registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) {\n        m_factories.emplace(name, factory);\n    }\n"
    },
    {
        "begin_line": 8469,
        "end_line": 8471,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerListener",
        "snippet": "    void ReporterRegistry::registerListener( IReporterFactoryPtr const& factory ) {\n        m_listeners.push_back( factory );\n    }\n"
    },
    {
        "begin_line": 8473,
        "end_line": 8475,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getFactories",
        "snippet": "    IReporterRegistry::FactoryMap const& ReporterRegistry::getFactories() const {\n        return m_factories;\n    }\n"
    },
    {
        "begin_line": 8476,
        "end_line": 8478,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getListeners",
        "snippet": "    IReporterRegistry::Listeners const& ReporterRegistry::getListeners() const {\n        return m_listeners;\n    }\n"
    },
    {
        "begin_line": 8484,
        "end_line": 8500,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    bool isOk( ResultWas::OfType resultType ) {\n        return ( resultType & ResultWas::FailureBit ) == 0;\n    }\n    bool isJustInfo( int flags ) {\n        return flags == ResultWas::Info;\n    }\n\n    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {\n        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );\n    }\n\n    bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }\n    bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8486,
        "end_line": 8488,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isOk",
        "snippet": "    bool isOk( ResultWas::OfType resultType ) {\n        return ( resultType & ResultWas::FailureBit ) == 0;\n    }\n"
    },
    {
        "begin_line": 8489,
        "end_line": 8491,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isJustInfo",
        "snippet": "    bool isJustInfo( int flags ) {\n        return flags == ResultWas::Info;\n    }\n"
    },
    {
        "begin_line": 8493,
        "end_line": 8495,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator |",
        "snippet": "    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {\n        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );\n    }\n"
    },
    {
        "begin_line": 8497,
        "end_line": 8497,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shouldContinueOnFailure",
        "snippet": "    bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }\n"
    },
    {
        "begin_line": 8498,
        "end_line": 8498,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "shouldSuppressFailure",
        "snippet": "    bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }\n"
    },
    {
        "begin_line": 8508,
        "end_line": 8959,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class RedirectedStream {\n        std::ostream& m_originalStream;\n        std::ostream& m_redirectionStream;\n        std::streambuf* m_prevBuf;\n\n    public:\n        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )\n        :   m_originalStream( originalStream ),\n            m_redirectionStream( redirectionStream ),\n            m_prevBuf( m_originalStream.rdbuf() )\n        {\n            m_originalStream.rdbuf( m_redirectionStream.rdbuf() );\n        }\n        ~RedirectedStream() {\n            m_originalStream.rdbuf( m_prevBuf );\n        }\n    };\n\n    class RedirectedStdOut {\n        ReusableStringStream m_rss;\n        RedirectedStream m_cout;\n    public:\n        RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}\n        auto str() const -> std::string { return m_rss.str(); }\n    };\n\n    // StdErr has two constituent streams in C++, std::cerr and std::clog\n    // This means that we need to redirect 2 streams into 1 to keep proper\n    // order of writes\n    class RedirectedStdErr {\n        ReusableStringStream m_rss;\n        RedirectedStream m_cerr;\n        RedirectedStream m_clog;\n    public:\n        RedirectedStdErr()\n        :   m_cerr( Catch::cerr(), m_rss.get() ),\n            m_clog( Catch::clog(), m_rss.get() )\n        {}\n        auto str() const -> std::string { return m_rss.str(); }\n    };\n\n    RunContext::RunContext(IConfigPtr const& _config, IStreamingReporterPtr&& reporter)\n    :   m_runInfo(_config->name()),\n        m_context(getCurrentMutableContext()),\n        m_config(_config),\n        m_reporter(std::move(reporter)),\n        m_lastAssertionInfo{ StringRef(), SourceLineInfo(\"\",0), StringRef(), ResultDisposition::Normal },\n        m_includeSuccessfulResults( m_config->includeSuccessfulResults() )\n    {\n        m_context.setRunner(this);\n        m_context.setConfig(m_config);\n        m_context.setResultCapture(this);\n        m_reporter->testRunStarting(m_runInfo);\n    }\n\n    RunContext::~RunContext() {\n        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));\n    }\n\n    void RunContext::testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {\n        m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));\n    }\n\n    void RunContext::testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {\n        m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));\n    }\n\n    Totals RunContext::runTest(TestCase const& testCase) {\n        Totals prevTotals = m_totals;\n\n        std::string redirectedCout;\n        std::string redirectedCerr;\n\n        auto const& testInfo = testCase.getTestCaseInfo();\n\n        m_reporter->testCaseStarting(testInfo);\n\n        m_activeTestCase = &testCase;\n\n        ITracker& rootTracker = m_trackerContext.startRun();\n        assert(rootTracker.isSectionTracker());\n        static_cast<SectionTracker&>(rootTracker).addInitialFilters(m_config->getSectionsToRun());\n        do {\n            m_trackerContext.startCycle();\n            m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));\n            runCurrentTest(redirectedCout, redirectedCerr);\n        } while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());\n\n        Totals deltaTotals = m_totals.delta(prevTotals);\n        if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {\n            deltaTotals.assertions.failed++;\n            deltaTotals.testCases.passed--;\n            deltaTotals.testCases.failed++;\n        }\n        m_totals.testCases += deltaTotals.testCases;\n        m_reporter->testCaseEnded(TestCaseStats(testInfo,\n                                  deltaTotals,\n                                  redirectedCout,\n                                  redirectedCerr,\n                                  aborting()));\n\n        m_activeTestCase = nullptr;\n        m_testCaseTracker = nullptr;\n\n        return deltaTotals;\n    }\n\n    IConfigPtr RunContext::config() const {\n        return m_config;\n    }\n\n    IStreamingReporter& RunContext::reporter() const {\n        return *m_reporter;\n    }\n\n    void RunContext::assertionEnded(AssertionResult const & result) {\n        if (result.getResultType() == ResultWas::Ok) {\n            m_totals.assertions.passed++;\n            m_lastAssertionPassed = true;\n        } else if (!result.isOk()) {\n            m_lastAssertionPassed = false;\n            if( m_activeTestCase->getTestCaseInfo().okToFail() )\n                m_totals.assertions.failedButOk++;\n            else\n                m_totals.assertions.failed++;\n        }\n        else {\n            m_lastAssertionPassed = true;\n        }\n\n        // We have no use for the return value (whether messages should be cleared), because messages were made scoped\n        // and should be let to clear themselves out.\n        static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));\n\n        // Reset working state\n        resetAssertionInfo();\n        m_lastResult = result;\n    }\n    void RunContext::resetAssertionInfo() {\n        m_lastAssertionInfo.macroName = StringRef();\n        m_lastAssertionInfo.capturedExpression = \"{Unknown expression after the reported line}\"_sr;\n    }\n\n    bool RunContext::sectionStarted(SectionInfo const & sectionInfo, Counts & assertions) {\n        ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));\n        if (!sectionTracker.isOpen())\n            return false;\n        m_activeSections.push_back(&sectionTracker);\n\n        m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;\n\n        m_reporter->sectionStarting(sectionInfo);\n\n        assertions = m_totals.assertions;\n\n        return true;\n    }\n\n    bool RunContext::testForMissingAssertions(Counts& assertions) {\n        if (assertions.total() != 0)\n            return false;\n        if (!m_config->warnAboutMissingAssertions())\n            return false;\n        if (m_trackerContext.currentTracker().hasChildren())\n            return false;\n        m_totals.assertions.failed++;\n        assertions.failed++;\n        return true;\n    }\n\n    void RunContext::sectionEnded(SectionEndInfo const & endInfo) {\n        Counts assertions = m_totals.assertions - endInfo.prevAssertions;\n        bool missingAssertions = testForMissingAssertions(assertions);\n\n        if (!m_activeSections.empty()) {\n            m_activeSections.back()->close();\n            m_activeSections.pop_back();\n        }\n\n        m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));\n        m_messages.clear();\n    }\n\n    void RunContext::sectionEndedEarly(SectionEndInfo const & endInfo) {\n        if (m_unfinishedSections.empty())\n            m_activeSections.back()->fail();\n        else\n            m_activeSections.back()->close();\n        m_activeSections.pop_back();\n\n        m_unfinishedSections.push_back(endInfo);\n    }\n    void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {\n        m_reporter->benchmarkStarting( info );\n    }\n    void RunContext::benchmarkEnded( BenchmarkStats const& stats ) {\n        m_reporter->benchmarkEnded( stats );\n    }\n\n    void RunContext::pushScopedMessage(MessageInfo const & message) {\n        m_messages.push_back(message);\n    }\n\n    void RunContext::popScopedMessage(MessageInfo const & message) {\n        m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());\n    }\n\n    std::string RunContext::getCurrentTestName() const {\n        return m_activeTestCase\n            ? m_activeTestCase->getTestCaseInfo().name\n            : std::string();\n    }\n\n    const AssertionResult * RunContext::getLastResult() const {\n        return &(*m_lastResult);\n    }\n\n    void RunContext::exceptionEarlyReported() {\n        m_shouldReportUnexpected = false;\n    }\n\n    void RunContext::handleFatalErrorCondition( StringRef message ) {\n        // First notify reporter that bad things happened\n        m_reporter->fatalErrorEncountered(message);\n\n        // Don't rebuild the result -- the stringification itself can cause more fatal errors\n        // Instead, fake a result data.\n        AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );\n        tempResult.message = message;\n        AssertionResult result(m_lastAssertionInfo, tempResult);\n\n        assertionEnded(result);\n\n        handleUnfinishedSections();\n\n        // Recreate section for test case (as we will lose the one that was in scope)\n        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();\n        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);\n\n        Counts assertions;\n        assertions.failed = 1;\n        SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);\n        m_reporter->sectionEnded(testCaseSectionStats);\n\n        auto const& testInfo = m_activeTestCase->getTestCaseInfo();\n\n        Totals deltaTotals;\n        deltaTotals.testCases.failed = 1;\n        deltaTotals.assertions.failed = 1;\n        m_reporter->testCaseEnded(TestCaseStats(testInfo,\n                                  deltaTotals,\n                                  std::string(),\n                                  std::string(),\n                                  false));\n        m_totals.testCases.failed++;\n        testGroupEnded(std::string(), m_totals, 1, 1);\n        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));\n    }\n\n    bool RunContext::lastAssertionPassed() {\n         return m_lastAssertionPassed;\n    }\n\n    void RunContext::assertionPassed() {\n        m_lastAssertionPassed = true;\n        ++m_totals.assertions.passed;\n        resetAssertionInfo();\n    }\n\n    bool RunContext::aborting() const {\n        return m_totals.assertions.failed == static_cast<std::size_t>(m_config->abortAfter());\n    }\n\n    void RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) {\n        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();\n        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);\n        m_reporter->sectionStarting(testCaseSection);\n        Counts prevAssertions = m_totals.assertions;\n        double duration = 0;\n        m_shouldReportUnexpected = true;\n        m_lastAssertionInfo = { \"TEST_CASE\"_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };\n\n        seedRng(*m_config);\n\n        Timer timer;\n        try {\n            if (m_reporter->getPreferences().shouldRedirectStdOut) {\n                RedirectedStdOut redirectedStdOut;\n                RedirectedStdErr redirectedStdErr;\n                timer.start();\n                invokeActiveTestCase();\n                redirectedCout += redirectedStdOut.str();\n                redirectedCerr += redirectedStdErr.str();\n\n            } else {\n                timer.start();\n                invokeActiveTestCase();\n            }\n            duration = timer.getElapsedSeconds();\n        } catch (TestFailureException&) {\n            // This just means the test was aborted due to failure\n        } catch (...) {\n            // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions\n            // are reported without translation at the point of origin.\n            if( m_shouldReportUnexpected ) {\n                AssertionReaction dummyReaction;\n                handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );\n            }\n        }\n        Counts assertions = m_totals.assertions - prevAssertions;\n        bool missingAssertions = testForMissingAssertions(assertions);\n\n        m_testCaseTracker->close();\n        handleUnfinishedSections();\n        m_messages.clear();\n\n        SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);\n        m_reporter->sectionEnded(testCaseSectionStats);\n    }\n\n    void RunContext::invokeActiveTestCase() {\n        FatalConditionHandler fatalConditionHandler; // Handle signals\n        m_activeTestCase->invoke();\n        fatalConditionHandler.reset();\n    }\n\n    void RunContext::handleUnfinishedSections() {\n        // If sections ended prematurely due to an exception we stored their\n        // infos here so we can tear them down outside the unwind process.\n        for (auto it = m_unfinishedSections.rbegin(),\n             itEnd = m_unfinishedSections.rend();\n             it != itEnd;\n             ++it)\n            sectionEnded(*it);\n        m_unfinishedSections.clear();\n    }\n\n    void RunContext::handleExpr(\n        AssertionInfo const& info,\n        ITransientExpression const& expr,\n        AssertionReaction& reaction\n    ) {\n        m_reporter->assertionStarting( info );\n\n        bool negated = isFalseTest( info.resultDisposition );\n        bool result = expr.getResult() != negated;\n\n        if( result ) {\n            if (!m_includeSuccessfulResults) {\n                assertionPassed();\n            }\n            else {\n                reportExpr(info, ResultWas::Ok, &expr, negated);\n            }\n        }\n        else {\n            reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\n            populateReaction( reaction );\n        }\n    }\n    void RunContext::reportExpr(\n            AssertionInfo const &info,\n            ResultWas::OfType resultType,\n            ITransientExpression const *expr,\n            bool negated ) {\n\n        m_lastAssertionInfo = info;\n        AssertionResultData data( resultType, LazyExpression( negated ) );\n\n        AssertionResult assertionResult{ info, data };\n        assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;\n\n        assertionEnded( assertionResult );\n    }\n\n    void RunContext::handleMessage(\n            AssertionInfo const& info,\n            ResultWas::OfType resultType,\n            StringRef const& message,\n            AssertionReaction& reaction\n    ) {\n        m_reporter->assertionStarting( info );\n\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( resultType, LazyExpression( false ) );\n        data.message = message;\n        AssertionResult assertionResult{ m_lastAssertionInfo, data };\n        assertionEnded( assertionResult );\n        if( !assertionResult.isOk() )\n            populateReaction( reaction );\n    }\n    void RunContext::handleUnexpectedExceptionNotThrown(\n            AssertionInfo const& info,\n            AssertionReaction& reaction\n    ) {\n        handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);\n    }\n\n    void RunContext::handleUnexpectedInflightException(\n            AssertionInfo const& info,\n            std::string const& message,\n            AssertionReaction& reaction\n    ) {\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );\n        data.message = message;\n        AssertionResult assertionResult{ info, data };\n        assertionEnded( assertionResult );\n        populateReaction( reaction );\n    }\n\n    void RunContext::populateReaction( AssertionReaction& reaction ) {\n        reaction.shouldDebugBreak = m_config->shouldDebugBreak();\n        reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);\n    }\n\n    void RunContext::handleIncomplete(\n            AssertionInfo const& info\n    ) {\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );\n        data.message = \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\";\n        AssertionResult assertionResult{ info, data };\n        assertionEnded( assertionResult );\n    }\n    void RunContext::handleNonExpr(\n            AssertionInfo const &info,\n            ResultWas::OfType resultType,\n            AssertionReaction &reaction\n    ) {\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( resultType, LazyExpression( false ) );\n        AssertionResult assertionResult{ info, data };\n        assertionEnded( assertionResult );\n\n        if( !assertionResult.isOk() )\n            populateReaction( reaction );\n    }\n\n    IResultCapture& getResultCapture() {\n        if (auto* capture = getCurrentContext().getResultCapture())\n            return *capture;\n        else\n            CATCH_INTERNAL_ERROR(\"No result capture instance\");\n    }\n}\n"
    },
    {
        "begin_line": 8510,
        "end_line": 8526,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RedirectedStream",
        "snippet": "    class RedirectedStream {\n        std::ostream& m_originalStream;\n        std::ostream& m_redirectionStream;\n        std::streambuf* m_prevBuf;\n\n    public:\n        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )\n        :   m_originalStream( originalStream ),\n            m_redirectionStream( redirectionStream ),\n            m_prevBuf( m_originalStream.rdbuf() )\n        {\n            m_originalStream.rdbuf( m_redirectionStream.rdbuf() );\n        }\n        ~RedirectedStream() {\n            m_originalStream.rdbuf( m_prevBuf );\n        }\n    };\n"
    },
    {
        "begin_line": 8511,
        "end_line": 8511,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_originalStream",
        "snippet": "        std::ostream& m_originalStream;\n"
    },
    {
        "begin_line": 8512,
        "end_line": 8512,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_redirectionStream",
        "snippet": "        std::ostream& m_redirectionStream;\n"
    },
    {
        "begin_line": 8513,
        "end_line": 8513,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_prevBuf",
        "snippet": "        std::streambuf* m_prevBuf;\n"
    },
    {
        "begin_line": 8516,
        "end_line": 8522,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RedirectedStream",
        "snippet": "        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )\n        :   m_originalStream( originalStream ),\n            m_redirectionStream( redirectionStream ),\n            m_prevBuf( m_originalStream.rdbuf() )\n        {\n            m_originalStream.rdbuf( m_redirectionStream.rdbuf() );\n        }\n"
    },
    {
        "begin_line": 8523,
        "end_line": 8525,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~RedirectedStream",
        "snippet": "        ~RedirectedStream() {\n            m_originalStream.rdbuf( m_prevBuf );\n        }\n"
    },
    {
        "begin_line": 8528,
        "end_line": 8534,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RedirectedStdOut",
        "snippet": "    class RedirectedStdOut {\n        ReusableStringStream m_rss;\n        RedirectedStream m_cout;\n    public:\n        RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}\n        auto str() const -> std::string { return m_rss.str(); }\n    };\n"
    },
    {
        "begin_line": 8529,
        "end_line": 8529,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_rss",
        "snippet": "        ReusableStringStream m_rss;\n"
    },
    {
        "begin_line": 8530,
        "end_line": 8530,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_cout",
        "snippet": "        RedirectedStream m_cout;\n"
    },
    {
        "begin_line": 8532,
        "end_line": 8532,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RedirectedStdOut",
        "snippet": "        RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}\n"
    },
    {
        "begin_line": 8533,
        "end_line": 8533,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "str",
        "snippet": "        auto str() const -> std::string { return m_rss.str(); }\n"
    },
    {
        "begin_line": 8539,
        "end_line": 8549,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RedirectedStdErr",
        "snippet": "    class RedirectedStdErr {\n        ReusableStringStream m_rss;\n        RedirectedStream m_cerr;\n        RedirectedStream m_clog;\n    public:\n        RedirectedStdErr()\n        :   m_cerr( Catch::cerr(), m_rss.get() ),\n            m_clog( Catch::clog(), m_rss.get() )\n        {}\n        auto str() const -> std::string { return m_rss.str(); }\n    };\n"
    },
    {
        "begin_line": 8540,
        "end_line": 8540,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_rss",
        "snippet": "        ReusableStringStream m_rss;\n"
    },
    {
        "begin_line": 8541,
        "end_line": 8541,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_cerr",
        "snippet": "        RedirectedStream m_cerr;\n"
    },
    {
        "begin_line": 8542,
        "end_line": 8542,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_clog",
        "snippet": "        RedirectedStream m_clog;\n"
    },
    {
        "begin_line": 8544,
        "end_line": 8547,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RedirectedStdErr",
        "snippet": "        RedirectedStdErr()\n        :   m_cerr( Catch::cerr(), m_rss.get() ),\n            m_clog( Catch::clog(), m_rss.get() )\n        {}\n"
    },
    {
        "begin_line": 8548,
        "end_line": 8548,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "str",
        "snippet": "        auto str() const -> std::string { return m_rss.str(); }\n"
    },
    {
        "begin_line": 8551,
        "end_line": 8563,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RunContext",
        "snippet": "    RunContext::RunContext(IConfigPtr const& _config, IStreamingReporterPtr&& reporter)\n    :   m_runInfo(_config->name()),\n        m_context(getCurrentMutableContext()),\n        m_config(_config),\n        m_reporter(std::move(reporter)),\n        m_lastAssertionInfo{ StringRef(), SourceLineInfo(\"\",0), StringRef(), ResultDisposition::Normal },\n        m_includeSuccessfulResults( m_config->includeSuccessfulResults() )\n    {\n        m_context.setRunner(this);\n        m_context.setConfig(m_config);\n        m_context.setResultCapture(this);\n        m_reporter->testRunStarting(m_runInfo);\n    }\n"
    },
    {
        "begin_line": 8565,
        "end_line": 8567,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~RunContext",
        "snippet": "    RunContext::~RunContext() {\n        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));\n    }\n"
    },
    {
        "begin_line": 8569,
        "end_line": 8571,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupStarting",
        "snippet": "    void RunContext::testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {\n        m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));\n    }\n"
    },
    {
        "begin_line": 8573,
        "end_line": 8575,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupEnded",
        "snippet": "    void RunContext::testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {\n        m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));\n    }\n"
    },
    {
        "begin_line": 8577,
        "end_line": 8615,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runTest",
        "snippet": "    Totals RunContext::runTest(TestCase const& testCase) {\n        Totals prevTotals = m_totals;\n\n        std::string redirectedCout;\n        std::string redirectedCerr;\n\n        auto const& testInfo = testCase.getTestCaseInfo();\n\n        m_reporter->testCaseStarting(testInfo);\n\n        m_activeTestCase = &testCase;\n\n        ITracker& rootTracker = m_trackerContext.startRun();\n        assert(rootTracker.isSectionTracker());\n        static_cast<SectionTracker&>(rootTracker).addInitialFilters(m_config->getSectionsToRun());\n        do {\n            m_trackerContext.startCycle();\n            m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));\n            runCurrentTest(redirectedCout, redirectedCerr);\n        } while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());\n\n        Totals deltaTotals = m_totals.delta(prevTotals);\n        if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {\n            deltaTotals.assertions.failed++;\n            deltaTotals.testCases.passed--;\n            deltaTotals.testCases.failed++;\n        }\n        m_totals.testCases += deltaTotals.testCases;\n        m_reporter->testCaseEnded(TestCaseStats(testInfo,\n                                  deltaTotals,\n                                  redirectedCout,\n                                  redirectedCerr,\n                                  aborting()));\n\n        m_activeTestCase = nullptr;\n        m_testCaseTracker = nullptr;\n\n        return deltaTotals;\n    }\n"
    },
    {
        "begin_line": 8617,
        "end_line": 8619,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "config",
        "snippet": "    IConfigPtr RunContext::config() const {\n        return m_config;\n    }\n"
    },
    {
        "begin_line": 8621,
        "end_line": 8623,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reporter",
        "snippet": "    IStreamingReporter& RunContext::reporter() const {\n        return *m_reporter;\n    }\n"
    },
    {
        "begin_line": 8625,
        "end_line": 8647,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "    void RunContext::assertionEnded(AssertionResult const & result) {\n        if (result.getResultType() == ResultWas::Ok) {\n            m_totals.assertions.passed++;\n            m_lastAssertionPassed = true;\n        } else if (!result.isOk()) {\n            m_lastAssertionPassed = false;\n            if( m_activeTestCase->getTestCaseInfo().okToFail() )\n                m_totals.assertions.failedButOk++;\n            else\n                m_totals.assertions.failed++;\n        }\n        else {\n            m_lastAssertionPassed = true;\n        }\n\n        // We have no use for the return value (whether messages should be cleared), because messages were made scoped\n        // and should be let to clear themselves out.\n        static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));\n\n        // Reset working state\n        resetAssertionInfo();\n        m_lastResult = result;\n    }\n"
    },
    {
        "begin_line": 8648,
        "end_line": 8651,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "resetAssertionInfo",
        "snippet": "    void RunContext::resetAssertionInfo() {\n        m_lastAssertionInfo.macroName = StringRef();\n        m_lastAssertionInfo.capturedExpression = \"{Unknown expression after the reported line}\"_sr;\n    }\n"
    },
    {
        "begin_line": 8653,
        "end_line": 8666,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionStarted",
        "snippet": "    bool RunContext::sectionStarted(SectionInfo const & sectionInfo, Counts & assertions) {\n        ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));\n        if (!sectionTracker.isOpen())\n            return false;\n        m_activeSections.push_back(&sectionTracker);\n\n        m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;\n\n        m_reporter->sectionStarting(sectionInfo);\n\n        assertions = m_totals.assertions;\n\n        return true;\n    }\n"
    },
    {
        "begin_line": 8668,
        "end_line": 8678,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testForMissingAssertions",
        "snippet": "    bool RunContext::testForMissingAssertions(Counts& assertions) {\n        if (assertions.total() != 0)\n            return false;\n        if (!m_config->warnAboutMissingAssertions())\n            return false;\n        if (m_trackerContext.currentTracker().hasChildren())\n            return false;\n        m_totals.assertions.failed++;\n        assertions.failed++;\n        return true;\n    }\n"
    },
    {
        "begin_line": 8680,
        "end_line": 8691,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEnded",
        "snippet": "    void RunContext::sectionEnded(SectionEndInfo const & endInfo) {\n        Counts assertions = m_totals.assertions - endInfo.prevAssertions;\n        bool missingAssertions = testForMissingAssertions(assertions);\n\n        if (!m_activeSections.empty()) {\n            m_activeSections.back()->close();\n            m_activeSections.pop_back();\n        }\n\n        m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));\n        m_messages.clear();\n    }\n"
    },
    {
        "begin_line": 8693,
        "end_line": 8701,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEndedEarly",
        "snippet": "    void RunContext::sectionEndedEarly(SectionEndInfo const & endInfo) {\n        if (m_unfinishedSections.empty())\n            m_activeSections.back()->fail();\n        else\n            m_activeSections.back()->close();\n        m_activeSections.pop_back();\n\n        m_unfinishedSections.push_back(endInfo);\n    }\n"
    },
    {
        "begin_line": 8702,
        "end_line": 8704,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkStarting",
        "snippet": "    void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {\n        m_reporter->benchmarkStarting( info );\n    }\n"
    },
    {
        "begin_line": 8705,
        "end_line": 8707,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkEnded",
        "snippet": "    void RunContext::benchmarkEnded( BenchmarkStats const& stats ) {\n        m_reporter->benchmarkEnded( stats );\n    }\n"
    },
    {
        "begin_line": 8709,
        "end_line": 8711,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "pushScopedMessage",
        "snippet": "    void RunContext::pushScopedMessage(MessageInfo const & message) {\n        m_messages.push_back(message);\n    }\n"
    },
    {
        "begin_line": 8713,
        "end_line": 8715,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "popScopedMessage",
        "snippet": "    void RunContext::popScopedMessage(MessageInfo const & message) {\n        m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());\n    }\n"
    },
    {
        "begin_line": 8717,
        "end_line": 8721,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getCurrentTestName",
        "snippet": "    std::string RunContext::getCurrentTestName() const {\n        return m_activeTestCase\n            ? m_activeTestCase->getTestCaseInfo().name\n            : std::string();\n    }\n"
    },
    {
        "begin_line": 8723,
        "end_line": 8725,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getLastResult",
        "snippet": "    const AssertionResult * RunContext::getLastResult() const {\n        return &(*m_lastResult);\n    }\n"
    },
    {
        "begin_line": 8727,
        "end_line": 8729,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "exceptionEarlyReported",
        "snippet": "    void RunContext::exceptionEarlyReported() {\n        m_shouldReportUnexpected = false;\n    }\n"
    },
    {
        "begin_line": 8731,
        "end_line": 8767,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleFatalErrorCondition",
        "snippet": "    void RunContext::handleFatalErrorCondition( StringRef message ) {\n        // First notify reporter that bad things happened\n        m_reporter->fatalErrorEncountered(message);\n\n        // Don't rebuild the result -- the stringification itself can cause more fatal errors\n        // Instead, fake a result data.\n        AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );\n        tempResult.message = message;\n        AssertionResult result(m_lastAssertionInfo, tempResult);\n\n        assertionEnded(result);\n\n        handleUnfinishedSections();\n\n        // Recreate section for test case (as we will lose the one that was in scope)\n        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();\n        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);\n\n        Counts assertions;\n        assertions.failed = 1;\n        SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);\n        m_reporter->sectionEnded(testCaseSectionStats);\n\n        auto const& testInfo = m_activeTestCase->getTestCaseInfo();\n\n        Totals deltaTotals;\n        deltaTotals.testCases.failed = 1;\n        deltaTotals.assertions.failed = 1;\n        m_reporter->testCaseEnded(TestCaseStats(testInfo,\n                                  deltaTotals,\n                                  std::string(),\n                                  std::string(),\n                                  false));\n        m_totals.testCases.failed++;\n        testGroupEnded(std::string(), m_totals, 1, 1);\n        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));\n    }\n"
    },
    {
        "begin_line": 8769,
        "end_line": 8771,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lastAssertionPassed",
        "snippet": "    bool RunContext::lastAssertionPassed() {\n         return m_lastAssertionPassed;\n    }\n"
    },
    {
        "begin_line": 8773,
        "end_line": 8777,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionPassed",
        "snippet": "    void RunContext::assertionPassed() {\n        m_lastAssertionPassed = true;\n        ++m_totals.assertions.passed;\n        resetAssertionInfo();\n    }\n"
    },
    {
        "begin_line": 8779,
        "end_line": 8781,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "aborting",
        "snippet": "    bool RunContext::aborting() const {\n        return m_totals.assertions.failed == static_cast<std::size_t>(m_config->abortAfter());\n    }\n"
    },
    {
        "begin_line": 8783,
        "end_line": 8828,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runCurrentTest",
        "snippet": "    void RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) {\n        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();\n        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);\n        m_reporter->sectionStarting(testCaseSection);\n        Counts prevAssertions = m_totals.assertions;\n        double duration = 0;\n        m_shouldReportUnexpected = true;\n        m_lastAssertionInfo = { \"TEST_CASE\"_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };\n\n        seedRng(*m_config);\n\n        Timer timer;\n        try {\n            if (m_reporter->getPreferences().shouldRedirectStdOut) {\n                RedirectedStdOut redirectedStdOut;\n                RedirectedStdErr redirectedStdErr;\n                timer.start();\n                invokeActiveTestCase();\n                redirectedCout += redirectedStdOut.str();\n                redirectedCerr += redirectedStdErr.str();\n\n            } else {\n                timer.start();\n                invokeActiveTestCase();\n            }\n            duration = timer.getElapsedSeconds();\n        } catch (TestFailureException&) {\n            // This just means the test was aborted due to failure\n        } catch (...) {\n            // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions\n            // are reported without translation at the point of origin.\n            if( m_shouldReportUnexpected ) {\n                AssertionReaction dummyReaction;\n                handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );\n            }\n        }\n        Counts assertions = m_totals.assertions - prevAssertions;\n        bool missingAssertions = testForMissingAssertions(assertions);\n\n        m_testCaseTracker->close();\n        handleUnfinishedSections();\n        m_messages.clear();\n\n        SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);\n        m_reporter->sectionEnded(testCaseSectionStats);\n    }\n"
    },
    {
        "begin_line": 8830,
        "end_line": 8834,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invokeActiveTestCase",
        "snippet": "    void RunContext::invokeActiveTestCase() {\n        FatalConditionHandler fatalConditionHandler; // Handle signals\n        m_activeTestCase->invoke();\n        fatalConditionHandler.reset();\n    }\n"
    },
    {
        "begin_line": 8836,
        "end_line": 8845,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleUnfinishedSections",
        "snippet": "    void RunContext::handleUnfinishedSections() {\n        // If sections ended prematurely due to an exception we stored their\n        // infos here so we can tear them down outside the unwind process.\n        for (auto it = m_unfinishedSections.rbegin(),\n             itEnd = m_unfinishedSections.rend();\n             it != itEnd;\n             ++it)\n            sectionEnded(*it);\n        m_unfinishedSections.clear();\n    }\n"
    },
    {
        "begin_line": 8847,
        "end_line": 8869,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleExpr",
        "snippet": "    void RunContext::handleExpr(\n        AssertionInfo const& info,\n        ITransientExpression const& expr,\n        AssertionReaction& reaction\n    ) {\n        m_reporter->assertionStarting( info );\n\n        bool negated = isFalseTest( info.resultDisposition );\n        bool result = expr.getResult() != negated;\n\n        if( result ) {\n            if (!m_includeSuccessfulResults) {\n                assertionPassed();\n            }\n            else {\n                reportExpr(info, ResultWas::Ok, &expr, negated);\n            }\n        }\n        else {\n            reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\n            populateReaction( reaction );\n        }\n    }\n"
    },
    {
        "begin_line": 8870,
        "end_line": 8883,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "reportExpr",
        "snippet": "    void RunContext::reportExpr(\n            AssertionInfo const &info,\n            ResultWas::OfType resultType,\n            ITransientExpression const *expr,\n            bool negated ) {\n\n        m_lastAssertionInfo = info;\n        AssertionResultData data( resultType, LazyExpression( negated ) );\n\n        AssertionResult assertionResult{ info, data };\n        assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;\n\n        assertionEnded( assertionResult );\n    }\n"
    },
    {
        "begin_line": 8885,
        "end_line": 8901,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleMessage",
        "snippet": "    void RunContext::handleMessage(\n            AssertionInfo const& info,\n            ResultWas::OfType resultType,\n            StringRef const& message,\n            AssertionReaction& reaction\n    ) {\n        m_reporter->assertionStarting( info );\n\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( resultType, LazyExpression( false ) );\n        data.message = message;\n        AssertionResult assertionResult{ m_lastAssertionInfo, data };\n        assertionEnded( assertionResult );\n        if( !assertionResult.isOk() )\n            populateReaction( reaction );\n    }\n"
    },
    {
        "begin_line": 8902,
        "end_line": 8907,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleUnexpectedExceptionNotThrown",
        "snippet": "    void RunContext::handleUnexpectedExceptionNotThrown(\n            AssertionInfo const& info,\n            AssertionReaction& reaction\n    ) {\n        handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);\n    }\n"
    },
    {
        "begin_line": 8909,
        "end_line": 8921,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleUnexpectedInflightException",
        "snippet": "    void RunContext::handleUnexpectedInflightException(\n            AssertionInfo const& info,\n            std::string const& message,\n            AssertionReaction& reaction\n    ) {\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );\n        data.message = message;\n        AssertionResult assertionResult{ info, data };\n        assertionEnded( assertionResult );\n        populateReaction( reaction );\n    }\n"
    },
    {
        "begin_line": 8923,
        "end_line": 8926,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "populateReaction",
        "snippet": "    void RunContext::populateReaction( AssertionReaction& reaction ) {\n        reaction.shouldDebugBreak = m_config->shouldDebugBreak();\n        reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);\n    }\n"
    },
    {
        "begin_line": 8928,
        "end_line": 8937,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleIncomplete",
        "snippet": "    void RunContext::handleIncomplete(\n            AssertionInfo const& info\n    ) {\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );\n        data.message = \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\";\n        AssertionResult assertionResult{ info, data };\n        assertionEnded( assertionResult );\n    }\n"
    },
    {
        "begin_line": 8938,
        "end_line": 8951,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "handleNonExpr",
        "snippet": "    void RunContext::handleNonExpr(\n            AssertionInfo const &info,\n            ResultWas::OfType resultType,\n            AssertionReaction &reaction\n    ) {\n        m_lastAssertionInfo = info;\n\n        AssertionResultData data( resultType, LazyExpression( false ) );\n        AssertionResult assertionResult{ info, data };\n        assertionEnded( assertionResult );\n\n        if( !assertionResult.isOk() )\n            populateReaction( reaction );\n    }\n"
    },
    {
        "begin_line": 8953,
        "end_line": 8958,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getResultCapture",
        "snippet": "    IResultCapture& getResultCapture() {\n        if (auto* capture = getCurrentContext().getResultCapture())\n            return *capture;\n        else\n            CATCH_INTERNAL_ERROR(\"No result capture instance\");\n    }\n"
    },
    {
        "begin_line": 8963,
        "end_line": 8987,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    Section::Section( SectionInfo const& info )\n    :   m_info( info ),\n        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )\n    {\n        m_timer.start();\n    }\n\n    Section::~Section() {\n        if( m_sectionIncluded ) {\n            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );\n            if( uncaught_exceptions() )\n                getResultCapture().sectionEndedEarly( endInfo );\n            else\n                getResultCapture().sectionEnded( endInfo );\n        }\n    }\n\n    // This indicates whether the section should be executed or not\n    Section::operator bool() const {\n        return m_sectionIncluded;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8965,
        "end_line": 8970,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Section",
        "snippet": "    Section::Section( SectionInfo const& info )\n    :   m_info( info ),\n        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )\n    {\n        m_timer.start();\n    }\n"
    },
    {
        "begin_line": 8972,
        "end_line": 8980,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~Section",
        "snippet": "    Section::~Section() {\n        if( m_sectionIncluded ) {\n            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );\n            if( uncaught_exceptions() )\n                getResultCapture().sectionEndedEarly( endInfo );\n            else\n                getResultCapture().sectionEnded( endInfo );\n        }\n    }\n"
    },
    {
        "begin_line": 8983,
        "end_line": 8985,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator bool",
        "snippet": "    Section::operator bool() const {\n        return m_sectionIncluded;\n    }\n"
    },
    {
        "begin_line": 8991,
        "end_line": 9006,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    SectionInfo::SectionInfo\n        (   SourceLineInfo const& _lineInfo,\n            std::string const& _name,\n            std::string const& _description )\n    :   name( _name ),\n        description( _description ),\n        lineInfo( _lineInfo )\n    {}\n\n    SectionEndInfo::SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )\n    : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )\n    {}\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 8993,
        "end_line": 9000,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionInfo",
        "snippet": "    SectionInfo::SectionInfo\n        (   SourceLineInfo const& _lineInfo,\n            std::string const& _name,\n            std::string const& _description )\n    :   name( _name ),\n        description( _description ),\n        lineInfo( _lineInfo )\n    {}\n"
    },
    {
        "begin_line": 9002,
        "end_line": 9004,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionEndInfo",
        "snippet": "    SectionEndInfo::SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )\n    : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )\n    {}\n"
    },
    {
        "begin_line": 9014,
        "end_line": 9048,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    class Session : NonCopyable {\n    public:\n\n        Session();\n        ~Session() override;\n\n        void showHelp() const;\n        void libIdentify();\n\n        int applyCommandLine( int argc, char const * const * argv );\n\n        void useConfigData( ConfigData const& configData );\n\n        int run( int argc, char* argv[] );\n    #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)\n        int run( int argc, wchar_t* const argv[] );\n    #endif\n        int run();\n\n        clara::Parser const& cli() const;\n        void cli( clara::Parser const& newParser );\n        ConfigData& configData();\n        Config& config();\n    private:\n        int runInternal();\n\n        clara::Parser m_cli;\n        ConfigData m_configData;\n        std::shared_ptr<Config> m_config;\n        bool m_startupExceptions = false;\n    };\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 9016,
        "end_line": 9046,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Session",
        "snippet": "    class Session : NonCopyable {\n    public:\n\n        Session();\n        ~Session() override;\n\n        void showHelp() const;\n        void libIdentify();\n\n        int applyCommandLine( int argc, char const * const * argv );\n\n        void useConfigData( ConfigData const& configData );\n\n        int run( int argc, char* argv[] );\n    #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)\n        int run( int argc, wchar_t* const argv[] );\n    #endif\n        int run();\n\n        clara::Parser const& cli() const;\n        void cli( clara::Parser const& newParser );\n        ConfigData& configData();\n        Config& config();\n    private:\n        int runInternal();\n\n        clara::Parser m_cli;\n        ConfigData m_configData;\n        std::shared_ptr<Config> m_config;\n        bool m_startupExceptions = false;\n    };\n"
    },
    {
        "begin_line": 9042,
        "end_line": 9042,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_cli",
        "snippet": "        clara::Parser m_cli;\n"
    },
    {
        "begin_line": 9043,
        "end_line": 9043,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_configData",
        "snippet": "        ConfigData m_configData;\n"
    },
    {
        "begin_line": 9044,
        "end_line": 9044,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_config",
        "snippet": "        std::shared_ptr<Config> m_config;\n"
    },
    {
        "begin_line": 9045,
        "end_line": 9045,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_startupExceptions",
        "snippet": "        bool m_startupExceptions = false;\n"
    },
    {
        "begin_line": 9055,
        "end_line": 9079,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    // Versioning information\n    struct Version {\n        Version( Version const& ) = delete;\n        Version& operator=( Version const& ) = delete;\n        Version(    unsigned int _majorVersion,\n                    unsigned int _minorVersion,\n                    unsigned int _patchNumber,\n                    char const * const _branchName,\n                    unsigned int _buildNumber );\n\n        unsigned int const majorVersion;\n        unsigned int const minorVersion;\n        unsigned int const patchNumber;\n\n        // buildNumber is only used if branchName is not null\n        char const * const branchName;\n        unsigned int const buildNumber;\n\n        friend std::ostream& operator << ( std::ostream& os, Version const& version );\n    };\n\n    Version const& libraryVersion();\n}\n"
    },
    {
        "begin_line": 9058,
        "end_line": 9076,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Version",
        "snippet": "    struct Version {\n        Version( Version const& ) = delete;\n        Version& operator=( Version const& ) = delete;\n        Version(    unsigned int _majorVersion,\n                    unsigned int _minorVersion,\n                    unsigned int _patchNumber,\n                    char const * const _branchName,\n                    unsigned int _buildNumber );\n\n        unsigned int const majorVersion;\n        unsigned int const minorVersion;\n        unsigned int const patchNumber;\n\n        // buildNumber is only used if branchName is not null\n        char const * const branchName;\n        unsigned int const buildNumber;\n\n        friend std::ostream& operator << ( std::ostream& os, Version const& version );\n    };\n"
    },
    {
        "begin_line": 9067,
        "end_line": 9067,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "majorVersion",
        "snippet": "        unsigned int const majorVersion;\n"
    },
    {
        "begin_line": 9068,
        "end_line": 9068,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "minorVersion",
        "snippet": "        unsigned int const minorVersion;\n"
    },
    {
        "begin_line": 9069,
        "end_line": 9069,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "patchNumber",
        "snippet": "        unsigned int const patchNumber;\n"
    },
    {
        "begin_line": 9072,
        "end_line": 9072,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "branchName",
        "snippet": "        char const * const branchName;\n"
    },
    {
        "begin_line": 9073,
        "end_line": 9073,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "buildNumber",
        "snippet": "        unsigned int const buildNumber;\n"
    },
    {
        "begin_line": 9085,
        "end_line": 9345,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    namespace {\n        const int MaxExitCode = 255;\n\n        IStreamingReporterPtr createReporter(std::string const& reporterName, IConfigPtr const& config) {\n            auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);\n            CATCH_ENFORCE(reporter, \"No reporter registered with name: '\" << reporterName << \"'\");\n\n            return reporter;\n        }\n\n#ifndef CATCH_CONFIG_DEFAULT_REPORTER\n#define CATCH_CONFIG_DEFAULT_REPORTER \"console\"\n#endif\n\n        IStreamingReporterPtr makeReporter(std::shared_ptr<Config> const& config) {\n            auto const& reporterNames = config->getReporterNames();\n            if (reporterNames.empty())\n                return createReporter(CATCH_CONFIG_DEFAULT_REPORTER, config);\n\n            IStreamingReporterPtr reporter;\n            for (auto const& name : reporterNames)\n                addReporter(reporter, createReporter(name, config));\n            return reporter;\n        }\n\n#undef CATCH_CONFIG_DEFAULT_REPORTER\n\n        void addListeners(IStreamingReporterPtr& reporters, IConfigPtr const& config) {\n            auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\n            for (auto const& listener : listeners)\n                addReporter(reporters, listener->create(Catch::ReporterConfig(config)));\n        }\n\n        Catch::Totals runTests(std::shared_ptr<Config> const& config) {\n            IStreamingReporterPtr reporter = makeReporter(config);\n            addListeners(reporter, config);\n\n            RunContext context(config, std::move(reporter));\n\n            Totals totals;\n\n            context.testGroupStarting(config->name(), 1, 1);\n\n            TestSpec testSpec = config->testSpec();\n\n            auto const& allTestCases = getAllTestCasesSorted(*config);\n            for (auto const& testCase : allTestCases) {\n                if (!context.aborting() && matchTest(testCase, testSpec, *config))\n                    totals += context.runTest(testCase);\n                else\n                    context.reporter().skipTest(testCase);\n            }\n\n            if (config->warnAboutNoTests() && totals.testCases.total() == 0) {\n                ReusableStringStream testConfig;\n\n                bool first = true;\n                for (const auto& input : config->getTestsOrTags()) {\n                    if (!first) { testConfig << ' '; }\n                    first = false;\n                    testConfig << input;\n                }\n\n                context.reporter().noMatchingTestCases(testConfig.str());\n                totals.error = -1;\n            }\n\n            context.testGroupEnded(config->name(), totals, 1, 1);\n            return totals;\n        }\n\n        void applyFilenamesAsTags(Catch::IConfig const& config) {\n            auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\n            for (auto& testCase : tests) {\n                auto tags = testCase.tags;\n\n                std::string filename = testCase.lineInfo.file;\n                auto lastSlash = filename.find_last_of(\"\\\\/\");\n                if (lastSlash != std::string::npos) {\n                    filename.erase(0, lastSlash);\n                    filename[0] = '#';\n                }\n\n                auto lastDot = filename.find_last_of('.');\n                if (lastDot != std::string::npos) {\n                    filename.erase(lastDot);\n                }\n\n                tags.push_back(std::move(filename));\n                setTags(testCase, tags);\n            }\n        }\n\n    } // anon namespace\n\n    Session::Session() {\n        static bool alreadyInstantiated = false;\n        if( alreadyInstantiated ) {\n            try         { CATCH_INTERNAL_ERROR( \"Only one instance of Catch::Session can ever be used\" ); }\n            catch(...)  { getMutableRegistryHub().registerStartupException(); }\n        }\n\n        const auto& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();\n        if ( !exceptions.empty() ) {\n            m_startupExceptions = true;\n            Colour colourGuard( Colour::Red );\n            Catch::cerr() << \"Errors occurred during startup!\" << '\\n';\n            // iterate over all exceptions and notify user\n            for ( const auto& ex_ptr : exceptions ) {\n                try {\n                    std::rethrow_exception(ex_ptr);\n                } catch ( std::exception const& ex ) {\n                    Catch::cerr() << Column( ex.what() ).indent(2) << '\\n';\n                }\n            }\n        }\n\n        alreadyInstantiated = true;\n        m_cli = makeCommandLineParser( m_configData );\n    }\n    Session::~Session() {\n        Catch::cleanUp();\n    }\n\n    void Session::showHelp() const {\n        Catch::cout()\n                << \"\\nCatch v\" << libraryVersion() << \"\\n\"\n                << m_cli << std::endl\n                << \"For more detailed usage please see the project docs\\n\" << std::endl;\n    }\n    void Session::libIdentify() {\n        Catch::cout()\n                << std::left << std::setw(16) << \"description: \" << \"A Catch test executable\\n\"\n                << std::left << std::setw(16) << \"category: \" << \"testframework\\n\"\n                << std::left << std::setw(16) << \"framework: \" << \"Catch Test\\n\"\n                << std::left << std::setw(16) << \"version: \" << libraryVersion() << std::endl;\n    }\n\n    int Session::applyCommandLine( int argc, char const * const * argv ) {\n        if( m_startupExceptions )\n            return 1;\n\n        auto result = m_cli.parse( clara::Args( argc, argv ) );\n        if( !result ) {\n            Catch::cerr()\n                << Colour( Colour::Red )\n                << \"\\nError(s) in input:\\n\"\n                << Column( result.errorMessage() ).indent( 2 )\n                << \"\\n\\n\";\n            Catch::cerr() << \"Run with -? for usage\\n\" << std::endl;\n            return MaxExitCode;\n        }\n\n        if( m_configData.showHelp )\n            showHelp();\n        if( m_configData.libIdentify )\n            libIdentify();\n        m_config.reset();\n        return 0;\n    }\n\n    void Session::useConfigData( ConfigData const& configData ) {\n        m_configData = configData;\n        m_config.reset();\n    }\n\n    int Session::run( int argc, char* argv[] ) {\n        if( m_startupExceptions )\n            return 1;\n        int returnCode = applyCommandLine( argc, argv );\n        if( returnCode == 0 )\n            returnCode = run();\n        return returnCode;\n    }\n\n#if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)\n    int Session::run( int argc, wchar_t* const argv[] ) {\n\n        char **utf8Argv = new char *[ argc ];\n\n        for ( int i = 0; i < argc; ++i ) {\n            int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );\n\n            utf8Argv[ i ] = new char[ bufSize ];\n\n            WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );\n        }\n\n        int returnCode = run( argc, utf8Argv );\n\n        for ( int i = 0; i < argc; ++i )\n            delete [] utf8Argv[ i ];\n\n        delete [] utf8Argv;\n\n        return returnCode;\n    }\n#endif\n    int Session::run() {\n        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {\n            Catch::cout() << \"...waiting for enter/ return before starting\" << std::endl;\n            static_cast<void>(std::getchar());\n        }\n        int exitCode = runInternal();\n        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {\n            Catch::cout() << \"...waiting for enter/ return before exiting, with code: \" << exitCode << std::endl;\n            static_cast<void>(std::getchar());\n        }\n        return exitCode;\n    }\n\n    clara::Parser const& Session::cli() const {\n        return m_cli;\n    }\n    void Session::cli( clara::Parser const& newParser ) {\n        m_cli = newParser;\n    }\n    ConfigData& Session::configData() {\n        return m_configData;\n    }\n    Config& Session::config() {\n        if( !m_config )\n            m_config = std::make_shared<Config>( m_configData );\n        return *m_config;\n    }\n\n    int Session::runInternal() {\n        if( m_startupExceptions )\n            return 1;\n\n        if( m_configData.showHelp || m_configData.libIdentify )\n            return 0;\n\n        try\n        {\n            config(); // Force config to be constructed\n\n            seedRng( *m_config );\n\n            if( m_configData.filenamesAsTags )\n                applyFilenamesAsTags( *m_config );\n\n            // Handle list request\n            if( Option<std::size_t> listed = list( config() ) )\n                return static_cast<int>( *listed );\n\n            auto totals = runTests( m_config );\n            // Note that on unices only the lower 8 bits are usually used, clamping\n            // the return value to 255 prevents false negative when some multiple\n            // of 256 tests has failed\n            return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast<int>(totals.assertions.failed)));\n        }\n        catch( std::exception& ex ) {\n            Catch::cerr() << ex.what() << std::endl;\n            return MaxExitCode;\n        }\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 9087,
        "end_line": 9180,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1611",
        "snippet": "    namespace {\n        const int MaxExitCode = 255;\n\n        IStreamingReporterPtr createReporter(std::string const& reporterName, IConfigPtr const& config) {\n            auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);\n            CATCH_ENFORCE(reporter, \"No reporter registered with name: '\" << reporterName << \"'\");\n\n            return reporter;\n        }\n\n#ifndef CATCH_CONFIG_DEFAULT_REPORTER\n#define CATCH_CONFIG_DEFAULT_REPORTER \"console\"\n#endif\n\n        IStreamingReporterPtr makeReporter(std::shared_ptr<Config> const& config) {\n            auto const& reporterNames = config->getReporterNames();\n            if (reporterNames.empty())\n                return createReporter(CATCH_CONFIG_DEFAULT_REPORTER, config);\n\n            IStreamingReporterPtr reporter;\n            for (auto const& name : reporterNames)\n                addReporter(reporter, createReporter(name, config));\n            return reporter;\n        }\n\n#undef CATCH_CONFIG_DEFAULT_REPORTER\n\n        void addListeners(IStreamingReporterPtr& reporters, IConfigPtr const& config) {\n            auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\n            for (auto const& listener : listeners)\n                addReporter(reporters, listener->create(Catch::ReporterConfig(config)));\n        }\n\n        Catch::Totals runTests(std::shared_ptr<Config> const& config) {\n            IStreamingReporterPtr reporter = makeReporter(config);\n            addListeners(reporter, config);\n\n            RunContext context(config, std::move(reporter));\n\n            Totals totals;\n\n            context.testGroupStarting(config->name(), 1, 1);\n\n            TestSpec testSpec = config->testSpec();\n\n            auto const& allTestCases = getAllTestCasesSorted(*config);\n            for (auto const& testCase : allTestCases) {\n                if (!context.aborting() && matchTest(testCase, testSpec, *config))\n                    totals += context.runTest(testCase);\n                else\n                    context.reporter().skipTest(testCase);\n            }\n\n            if (config->warnAboutNoTests() && totals.testCases.total() == 0) {\n                ReusableStringStream testConfig;\n\n                bool first = true;\n                for (const auto& input : config->getTestsOrTags()) {\n                    if (!first) { testConfig << ' '; }\n                    first = false;\n                    testConfig << input;\n                }\n\n                context.reporter().noMatchingTestCases(testConfig.str());\n                totals.error = -1;\n            }\n\n            context.testGroupEnded(config->name(), totals, 1, 1);\n            return totals;\n        }\n\n        void applyFilenamesAsTags(Catch::IConfig const& config) {\n            auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\n            for (auto& testCase : tests) {\n                auto tags = testCase.tags;\n\n                std::string filename = testCase.lineInfo.file;\n                auto lastSlash = filename.find_last_of(\"\\\\/\");\n                if (lastSlash != std::string::npos) {\n                    filename.erase(0, lastSlash);\n                    filename[0] = '#';\n                }\n\n                auto lastDot = filename.find_last_of('.');\n                if (lastDot != std::string::npos) {\n                    filename.erase(lastDot);\n                }\n\n                tags.push_back(std::move(filename));\n                setTags(testCase, tags);\n            }\n        }\n\n    } // anon namespace\n"
    },
    {
        "begin_line": 9088,
        "end_line": 9088,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "MaxExitCode",
        "snippet": "        const int MaxExitCode = 255;\n"
    },
    {
        "begin_line": 9090,
        "end_line": 9095,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "createReporter",
        "snippet": "        IStreamingReporterPtr createReporter(std::string const& reporterName, IConfigPtr const& config) {\n            auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);\n            CATCH_ENFORCE(reporter, \"No reporter registered with name: '\" << reporterName << \"'\");\n\n            return reporter;\n        }\n"
    },
    {
        "begin_line": 9098,
        "end_line": 9098,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_DEFAULT_REPORTER",
        "snippet": "#define CATCH_CONFIG_DEFAULT_REPORTER \"console\"\n"
    },
    {
        "begin_line": 9101,
        "end_line": 9110,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeReporter",
        "snippet": "        IStreamingReporterPtr makeReporter(std::shared_ptr<Config> const& config) {\n            auto const& reporterNames = config->getReporterNames();\n            if (reporterNames.empty())\n                return createReporter(CATCH_CONFIG_DEFAULT_REPORTER, config);\n\n            IStreamingReporterPtr reporter;\n            for (auto const& name : reporterNames)\n                addReporter(reporter, createReporter(name, config));\n            return reporter;\n        }\n"
    },
    {
        "begin_line": 9114,
        "end_line": 9118,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addListeners",
        "snippet": "        void addListeners(IStreamingReporterPtr& reporters, IConfigPtr const& config) {\n            auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\n            for (auto const& listener : listeners)\n                addReporter(reporters, listener->create(Catch::ReporterConfig(config)));\n        }\n"
    },
    {
        "begin_line": 9120,
        "end_line": 9156,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runTests",
        "snippet": "        Catch::Totals runTests(std::shared_ptr<Config> const& config) {\n            IStreamingReporterPtr reporter = makeReporter(config);\n            addListeners(reporter, config);\n\n            RunContext context(config, std::move(reporter));\n\n            Totals totals;\n\n            context.testGroupStarting(config->name(), 1, 1);\n\n            TestSpec testSpec = config->testSpec();\n\n            auto const& allTestCases = getAllTestCasesSorted(*config);\n            for (auto const& testCase : allTestCases) {\n                if (!context.aborting() && matchTest(testCase, testSpec, *config))\n                    totals += context.runTest(testCase);\n                else\n                    context.reporter().skipTest(testCase);\n            }\n\n            if (config->warnAboutNoTests() && totals.testCases.total() == 0) {\n                ReusableStringStream testConfig;\n\n                bool first = true;\n                for (const auto& input : config->getTestsOrTags()) {\n                    if (!first) { testConfig << ' '; }\n                    first = false;\n                    testConfig << input;\n                }\n\n                context.reporter().noMatchingTestCases(testConfig.str());\n                totals.error = -1;\n            }\n\n            context.testGroupEnded(config->name(), totals, 1, 1);\n            return totals;\n        }\n"
    },
    {
        "begin_line": 9158,
        "end_line": 9178,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "applyFilenamesAsTags",
        "snippet": "        void applyFilenamesAsTags(Catch::IConfig const& config) {\n            auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\n            for (auto& testCase : tests) {\n                auto tags = testCase.tags;\n\n                std::string filename = testCase.lineInfo.file;\n                auto lastSlash = filename.find_last_of(\"\\\\/\");\n                if (lastSlash != std::string::npos) {\n                    filename.erase(0, lastSlash);\n                    filename[0] = '#';\n                }\n\n                auto lastDot = filename.find_last_of('.');\n                if (lastDot != std::string::npos) {\n                    filename.erase(lastDot);\n                }\n\n                tags.push_back(std::move(filename));\n                setTags(testCase, tags);\n            }\n        }\n"
    },
    {
        "begin_line": 9182,
        "end_line": 9206,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Session",
        "snippet": "    Session::Session() {\n        static bool alreadyInstantiated = false;\n        if( alreadyInstantiated ) {\n            try         { CATCH_INTERNAL_ERROR( \"Only one instance of Catch::Session can ever be used\" ); }\n            catch(...)  { getMutableRegistryHub().registerStartupException(); }\n        }\n\n        const auto& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();\n        if ( !exceptions.empty() ) {\n            m_startupExceptions = true;\n            Colour colourGuard( Colour::Red );\n            Catch::cerr() << \"Errors occurred during startup!\" << '\\n';\n            // iterate over all exceptions and notify user\n            for ( const auto& ex_ptr : exceptions ) {\n                try {\n                    std::rethrow_exception(ex_ptr);\n                } catch ( std::exception const& ex ) {\n                    Catch::cerr() << Column( ex.what() ).indent(2) << '\\n';\n                }\n            }\n        }\n\n        alreadyInstantiated = true;\n        m_cli = makeCommandLineParser( m_configData );\n    }\n"
    },
    {
        "begin_line": 9207,
        "end_line": 9209,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~Session",
        "snippet": "    Session::~Session() {\n        Catch::cleanUp();\n    }\n"
    },
    {
        "begin_line": 9211,
        "end_line": 9216,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "showHelp",
        "snippet": "    void Session::showHelp() const {\n        Catch::cout()\n                << \"\\nCatch v\" << libraryVersion() << \"\\n\"\n                << m_cli << std::endl\n                << \"For more detailed usage please see the project docs\\n\" << std::endl;\n    }\n"
    },
    {
        "begin_line": 9217,
        "end_line": 9223,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "libIdentify",
        "snippet": "    void Session::libIdentify() {\n        Catch::cout()\n                << std::left << std::setw(16) << \"description: \" << \"A Catch test executable\\n\"\n                << std::left << std::setw(16) << \"category: \" << \"testframework\\n\"\n                << std::left << std::setw(16) << \"framework: \" << \"Catch Test\\n\"\n                << std::left << std::setw(16) << \"version: \" << libraryVersion() << std::endl;\n    }\n"
    },
    {
        "begin_line": 9225,
        "end_line": 9246,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "applyCommandLine",
        "snippet": "    int Session::applyCommandLine( int argc, char const * const * argv ) {\n        if( m_startupExceptions )\n            return 1;\n\n        auto result = m_cli.parse( clara::Args( argc, argv ) );\n        if( !result ) {\n            Catch::cerr()\n                << Colour( Colour::Red )\n                << \"\\nError(s) in input:\\n\"\n                << Column( result.errorMessage() ).indent( 2 )\n                << \"\\n\\n\";\n            Catch::cerr() << \"Run with -? for usage\\n\" << std::endl;\n            return MaxExitCode;\n        }\n\n        if( m_configData.showHelp )\n            showHelp();\n        if( m_configData.libIdentify )\n            libIdentify();\n        m_config.reset();\n        return 0;\n    }\n"
    },
    {
        "begin_line": 9248,
        "end_line": 9251,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "useConfigData",
        "snippet": "    void Session::useConfigData( ConfigData const& configData ) {\n        m_configData = configData;\n        m_config.reset();\n    }\n"
    },
    {
        "begin_line": 9253,
        "end_line": 9260,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "run",
        "snippet": "    int Session::run( int argc, char* argv[] ) {\n        if( m_startupExceptions )\n            return 1;\n        int returnCode = applyCommandLine( argc, argv );\n        if( returnCode == 0 )\n            returnCode = run();\n        return returnCode;\n    }\n"
    },
    {
        "begin_line": 9263,
        "end_line": 9283,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "run",
        "snippet": "    int Session::run( int argc, wchar_t* const argv[] ) {\n\n        char **utf8Argv = new char *[ argc ];\n\n        for ( int i = 0; i < argc; ++i ) {\n            int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );\n\n            utf8Argv[ i ] = new char[ bufSize ];\n\n            WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );\n        }\n\n        int returnCode = run( argc, utf8Argv );\n\n        for ( int i = 0; i < argc; ++i )\n            delete [] utf8Argv[ i ];\n\n        delete [] utf8Argv;\n\n        return returnCode;\n    }\n"
    },
    {
        "begin_line": 9285,
        "end_line": 9296,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "run",
        "snippet": "    int Session::run() {\n        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {\n            Catch::cout() << \"...waiting for enter/ return before starting\" << std::endl;\n            static_cast<void>(std::getchar());\n        }\n        int exitCode = runInternal();\n        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {\n            Catch::cout() << \"...waiting for enter/ return before exiting, with code: \" << exitCode << std::endl;\n            static_cast<void>(std::getchar());\n        }\n        return exitCode;\n    }\n"
    },
    {
        "begin_line": 9298,
        "end_line": 9300,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cli",
        "snippet": "    clara::Parser const& Session::cli() const {\n        return m_cli;\n    }\n"
    },
    {
        "begin_line": 9301,
        "end_line": 9303,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cli",
        "snippet": "    void Session::cli( clara::Parser const& newParser ) {\n        m_cli = newParser;\n    }\n"
    },
    {
        "begin_line": 9304,
        "end_line": 9306,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "configData",
        "snippet": "    ConfigData& Session::configData() {\n        return m_configData;\n    }\n"
    },
    {
        "begin_line": 9307,
        "end_line": 9311,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "config",
        "snippet": "    Config& Session::config() {\n        if( !m_config )\n            m_config = std::make_shared<Config>( m_configData );\n        return *m_config;\n    }\n"
    },
    {
        "begin_line": 9313,
        "end_line": 9343,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "runInternal",
        "snippet": "    int Session::runInternal() {\n        if( m_startupExceptions )\n            return 1;\n\n        if( m_configData.showHelp || m_configData.libIdentify )\n            return 0;\n\n        try\n        {\n            config(); // Force config to be constructed\n\n            seedRng( *m_config );\n\n            if( m_configData.filenamesAsTags )\n                applyFilenamesAsTags( *m_config );\n\n            // Handle list request\n            if( Option<std::size_t> listed = list( config() ) )\n                return static_cast<int>( *listed );\n\n            auto totals = runTests( m_config );\n            // Note that on unices only the lower 8 bits are usually used, clamping\n            // the return value to 255 prevents false negative when some multiple\n            // of 256 tests has failed\n            return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast<int>(totals.assertions.failed)));\n        }\n        catch( std::exception& ex ) {\n            Catch::cerr() << ex.what() << std::endl;\n            return MaxExitCode;\n        }\n    }\n"
    },
    {
        "begin_line": 9349,
        "end_line": 9364,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    void StartupExceptionRegistry::add( std::exception_ptr const& exception ) noexcept {\n        try {\n            m_exceptions.push_back(exception);\n        }\n        catch(...) {\n            // If we run out of memory during start-up there's really not a lot more we can do about it\n            std::terminate();\n        }\n    }\n\n    std::vector<std::exception_ptr> const& StartupExceptionRegistry::getExceptions() const noexcept {\n        return m_exceptions;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 9350,
        "end_line": 9358,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "add",
        "snippet": "    void StartupExceptionRegistry::add( std::exception_ptr const& exception ) noexcept {\n        try {\n            m_exceptions.push_back(exception);\n        }\n        catch(...) {\n            // If we run out of memory during start-up there's really not a lot more we can do about it\n            std::terminate();\n        }\n    }\n"
    },
    {
        "begin_line": 9360,
        "end_line": 9362,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getExceptions",
        "snippet": "    std::vector<std::exception_ptr> const& StartupExceptionRegistry::getExceptions() const noexcept {\n        return m_exceptions;\n    }\n"
    },
    {
        "begin_line": 9380,
        "end_line": 9558,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    Catch::IStream::~IStream() = default;\n\n    namespace detail { namespace {\n        template<typename WriterF, std::size_t bufferSize=256>\n        class StreamBufImpl : public std::streambuf {\n            char data[bufferSize];\n            WriterF m_writer;\n\n        public:\n            StreamBufImpl() {\n                setp( data, data + sizeof(data) );\n            }\n\n            ~StreamBufImpl() noexcept {\n                StreamBufImpl::sync();\n            }\n\n        private:\n            int overflow( int c ) override {\n                sync();\n\n                if( c != EOF ) {\n                    if( pbase() == epptr() )\n                        m_writer( std::string( 1, static_cast<char>( c ) ) );\n                    else\n                        sputc( static_cast<char>( c ) );\n                }\n                return 0;\n            }\n\n            int sync() override {\n                if( pbase() != pptr() ) {\n                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );\n                    setp( pbase(), epptr() );\n                }\n                return 0;\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        struct OutputDebugWriter {\n\n            void operator()( std::string const&str ) {\n                writeToDebugConsole( str );\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class FileStream : public IStream {\n            mutable std::ofstream m_ofs;\n        public:\n            FileStream( StringRef filename ) {\n                m_ofs.open( filename.c_str() );\n                CATCH_ENFORCE( !m_ofs.fail(), \"Unable to open file: '\" << filename << \"'\" );\n            }\n            ~FileStream() override = default;\n        public: // IStream\n            std::ostream& stream() const override {\n                return m_ofs;\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class CoutStream : public IStream {\n            mutable std::ostream m_os;\n        public:\n            // Store the streambuf from cout up-front because\n            // cout may get redirected when running tests\n            CoutStream() : m_os( Catch::cout().rdbuf() ) {}\n            ~CoutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class DebugOutStream : public IStream {\n            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\n            mutable std::ostream m_os;\n        public:\n            DebugOutStream()\n            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),\n                m_os( m_streamBuf.get() )\n            {}\n\n            ~DebugOutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n\n    }} // namespace anon::detail\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    auto makeStream( StringRef const &filename ) -> IStream const* {\n        if( filename.empty() )\n            return new detail::CoutStream();\n        else if( filename[0] == '%' ) {\n            if( filename == \"%debug\" )\n                return new detail::DebugOutStream();\n            else\n                CATCH_ERROR( \"Unrecognised stream: '\" << filename << \"'\" );\n        }\n        else\n            return new detail::FileStream( filename );\n    }\n\n    // This class encapsulates the idea of a pool of ostringstreams that can be reused.\n    struct StringStreams {\n        std::vector<std::unique_ptr<std::ostringstream>> m_streams;\n        std::vector<std::size_t> m_unused;\n        std::ostringstream m_referenceStream; // Used for copy state/ flags from\n        static StringStreams* s_instance;\n\n        auto add() -> std::size_t {\n            if( m_unused.empty() ) {\n                m_streams.push_back( std::unique_ptr<std::ostringstream>( new std::ostringstream ) );\n                return m_streams.size()-1;\n            }\n            else {\n                auto index = m_unused.back();\n                m_unused.pop_back();\n                return index;\n            }\n        }\n\n        void release( std::size_t index ) {\n            m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state\n            m_unused.push_back(index);\n        }\n\n        // !TBD: put in TLS\n        static auto instance() -> StringStreams& {\n            if( !s_instance )\n                s_instance = new StringStreams();\n            return *s_instance;\n        }\n        static void cleanup() {\n            delete s_instance;\n            s_instance = nullptr;\n        }\n    };\n\n    StringStreams* StringStreams::s_instance = nullptr;\n\n    void ReusableStringStream::cleanup() {\n        StringStreams::cleanup();\n    }\n\n    ReusableStringStream::ReusableStringStream()\n    :   m_index( StringStreams::instance().add() ),\n        m_oss( StringStreams::instance().m_streams[m_index].get() )\n    {}\n\n    ReusableStringStream::~ReusableStringStream() {\n        static_cast<std::ostringstream*>( m_oss )->str(\"\");\n        m_oss->clear();\n        StringStreams::instance().release( m_index );\n    }\n\n    auto ReusableStringStream::str() const -> std::string {\n        return static_cast<std::ostringstream*>( m_oss )->str();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions\n    std::ostream& cout() { return std::cout; }\n    std::ostream& cerr() { return std::cerr; }\n    std::ostream& clog() { return std::clog; }\n#endif\n}\n"
    },
    {
        "begin_line": 9384,
        "end_line": 9477,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "detail",
        "snippet": "    namespace detail { namespace {\n        template<typename WriterF, std::size_t bufferSize=256>\n        class StreamBufImpl : public std::streambuf {\n            char data[bufferSize];\n            WriterF m_writer;\n\n        public:\n            StreamBufImpl() {\n                setp( data, data + sizeof(data) );\n            }\n\n            ~StreamBufImpl() noexcept {\n                StreamBufImpl::sync();\n            }\n\n        private:\n            int overflow( int c ) override {\n                sync();\n\n                if( c != EOF ) {\n                    if( pbase() == epptr() )\n                        m_writer( std::string( 1, static_cast<char>( c ) ) );\n                    else\n                        sputc( static_cast<char>( c ) );\n                }\n                return 0;\n            }\n\n            int sync() override {\n                if( pbase() != pptr() ) {\n                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );\n                    setp( pbase(), epptr() );\n                }\n                return 0;\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        struct OutputDebugWriter {\n\n            void operator()( std::string const&str ) {\n                writeToDebugConsole( str );\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class FileStream : public IStream {\n            mutable std::ofstream m_ofs;\n        public:\n            FileStream( StringRef filename ) {\n                m_ofs.open( filename.c_str() );\n                CATCH_ENFORCE( !m_ofs.fail(), \"Unable to open file: '\" << filename << \"'\" );\n            }\n            ~FileStream() override = default;\n        public: // IStream\n            std::ostream& stream() const override {\n                return m_ofs;\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class CoutStream : public IStream {\n            mutable std::ostream m_os;\n        public:\n            // Store the streambuf from cout up-front because\n            // cout may get redirected when running tests\n            CoutStream() : m_os( Catch::cout().rdbuf() ) {}\n            ~CoutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class DebugOutStream : public IStream {\n            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\n            mutable std::ostream m_os;\n        public:\n            DebugOutStream()\n            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),\n                m_os( m_streamBuf.get() )\n            {}\n\n            ~DebugOutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n\n    }} // namespace anon::detail\n"
    },
    {
        "begin_line": 9384,
        "end_line": 9477,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1711",
        "snippet": "    namespace detail { namespace {\n        template<typename WriterF, std::size_t bufferSize=256>\n        class StreamBufImpl : public std::streambuf {\n            char data[bufferSize];\n            WriterF m_writer;\n\n        public:\n            StreamBufImpl() {\n                setp( data, data + sizeof(data) );\n            }\n\n            ~StreamBufImpl() noexcept {\n                StreamBufImpl::sync();\n            }\n\n        private:\n            int overflow( int c ) override {\n                sync();\n\n                if( c != EOF ) {\n                    if( pbase() == epptr() )\n                        m_writer( std::string( 1, static_cast<char>( c ) ) );\n                    else\n                        sputc( static_cast<char>( c ) );\n                }\n                return 0;\n            }\n\n            int sync() override {\n                if( pbase() != pptr() ) {\n                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );\n                    setp( pbase(), epptr() );\n                }\n                return 0;\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        struct OutputDebugWriter {\n\n            void operator()( std::string const&str ) {\n                writeToDebugConsole( str );\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class FileStream : public IStream {\n            mutable std::ofstream m_ofs;\n        public:\n            FileStream( StringRef filename ) {\n                m_ofs.open( filename.c_str() );\n                CATCH_ENFORCE( !m_ofs.fail(), \"Unable to open file: '\" << filename << \"'\" );\n            }\n            ~FileStream() override = default;\n        public: // IStream\n            std::ostream& stream() const override {\n                return m_ofs;\n            }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class CoutStream : public IStream {\n            mutable std::ostream m_os;\n        public:\n            // Store the streambuf from cout up-front because\n            // cout may get redirected when running tests\n            CoutStream() : m_os( Catch::cout().rdbuf() ) {}\n            ~CoutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n\n        class DebugOutStream : public IStream {\n            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\n            mutable std::ostream m_os;\n        public:\n            DebugOutStream()\n            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),\n                m_os( m_streamBuf.get() )\n            {}\n\n            ~DebugOutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n\n    }} // namespace anon::detail\n"
    },
    {
        "begin_line": 9386,
        "end_line": 9419,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StreamBufImpl",
        "snippet": "        class StreamBufImpl : public std::streambuf {\n            char data[bufferSize];\n            WriterF m_writer;\n\n        public:\n            StreamBufImpl() {\n                setp( data, data + sizeof(data) );\n            }\n\n            ~StreamBufImpl() noexcept {\n                StreamBufImpl::sync();\n            }\n\n        private:\n            int overflow( int c ) override {\n                sync();\n\n                if( c != EOF ) {\n                    if( pbase() == epptr() )\n                        m_writer( std::string( 1, static_cast<char>( c ) ) );\n                    else\n                        sputc( static_cast<char>( c ) );\n                }\n                return 0;\n            }\n\n            int sync() override {\n                if( pbase() != pptr() ) {\n                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );\n                    setp( pbase(), epptr() );\n                }\n                return 0;\n            }\n        };\n"
    },
    {
        "begin_line": 9387,
        "end_line": 9387,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "data",
        "snippet": "            char data[bufferSize];\n"
    },
    {
        "begin_line": 9388,
        "end_line": 9388,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_writer",
        "snippet": "            WriterF m_writer;\n"
    },
    {
        "begin_line": 9391,
        "end_line": 9393,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StreamBufImpl",
        "snippet": "            StreamBufImpl() {\n                setp( data, data + sizeof(data) );\n            }\n"
    },
    {
        "begin_line": 9395,
        "end_line": 9397,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~StreamBufImpl",
        "snippet": "            ~StreamBufImpl() noexcept {\n                StreamBufImpl::sync();\n            }\n"
    },
    {
        "begin_line": 9400,
        "end_line": 9410,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "overflow",
        "snippet": "            int overflow( int c ) override {\n                sync();\n\n                if( c != EOF ) {\n                    if( pbase() == epptr() )\n                        m_writer( std::string( 1, static_cast<char>( c ) ) );\n                    else\n                        sputc( static_cast<char>( c ) );\n                }\n                return 0;\n            }\n"
    },
    {
        "begin_line": 9412,
        "end_line": 9418,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sync",
        "snippet": "            int sync() override {\n                if( pbase() != pptr() ) {\n                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );\n                    setp( pbase(), epptr() );\n                }\n                return 0;\n            }\n"
    },
    {
        "begin_line": 9423,
        "end_line": 9428,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "OutputDebugWriter",
        "snippet": "        struct OutputDebugWriter {\n\n            void operator()( std::string const&str ) {\n                writeToDebugConsole( str );\n            }\n        };\n"
    },
    {
        "begin_line": 9425,
        "end_line": 9427,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ()",
        "snippet": "            void operator()( std::string const&str ) {\n                writeToDebugConsole( str );\n            }\n"
    },
    {
        "begin_line": 9432,
        "end_line": 9444,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FileStream",
        "snippet": "        class FileStream : public IStream {\n            mutable std::ofstream m_ofs;\n        public:\n            FileStream( StringRef filename ) {\n                m_ofs.open( filename.c_str() );\n                CATCH_ENFORCE( !m_ofs.fail(), \"Unable to open file: '\" << filename << \"'\" );\n            }\n            ~FileStream() override = default;\n        public: // IStream\n            std::ostream& stream() const override {\n                return m_ofs;\n            }\n        };\n"
    },
    {
        "begin_line": 9433,
        "end_line": 9433,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_ofs",
        "snippet": "            mutable std::ofstream m_ofs;\n"
    },
    {
        "begin_line": 9435,
        "end_line": 9438,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FileStream",
        "snippet": "            FileStream( StringRef filename ) {\n                m_ofs.open( filename.c_str() );\n                CATCH_ENFORCE( !m_ofs.fail(), \"Unable to open file: '\" << filename << \"'\" );\n            }\n"
    },
    {
        "begin_line": 9441,
        "end_line": 9443,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "            std::ostream& stream() const override {\n                return m_ofs;\n            }\n"
    },
    {
        "begin_line": 9448,
        "end_line": 9458,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CoutStream",
        "snippet": "        class CoutStream : public IStream {\n            mutable std::ostream m_os;\n        public:\n            // Store the streambuf from cout up-front because\n            // cout may get redirected when running tests\n            CoutStream() : m_os( Catch::cout().rdbuf() ) {}\n            ~CoutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n"
    },
    {
        "begin_line": 9449,
        "end_line": 9449,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_os",
        "snippet": "            mutable std::ostream m_os;\n"
    },
    {
        "begin_line": 9453,
        "end_line": 9453,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CoutStream",
        "snippet": "            CoutStream() : m_os( Catch::cout().rdbuf() ) {}\n"
    },
    {
        "begin_line": 9457,
        "end_line": 9457,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "            std::ostream& stream() const override { return m_os; }\n"
    },
    {
        "begin_line": 9462,
        "end_line": 9475,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "DebugOutStream",
        "snippet": "        class DebugOutStream : public IStream {\n            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\n            mutable std::ostream m_os;\n        public:\n            DebugOutStream()\n            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),\n                m_os( m_streamBuf.get() )\n            {}\n\n            ~DebugOutStream() override = default;\n\n        public: // IStream\n            std::ostream& stream() const override { return m_os; }\n        };\n"
    },
    {
        "begin_line": 9463,
        "end_line": 9463,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_streamBuf",
        "snippet": "            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\n"
    },
    {
        "begin_line": 9464,
        "end_line": 9464,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_os",
        "snippet": "            mutable std::ostream m_os;\n"
    },
    {
        "begin_line": 9466,
        "end_line": 9469,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "DebugOutStream",
        "snippet": "            DebugOutStream()\n            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),\n                m_os( m_streamBuf.get() )\n            {}\n"
    },
    {
        "begin_line": 9474,
        "end_line": 9474,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "            std::ostream& stream() const override { return m_os; }\n"
    },
    {
        "begin_line": 9481,
        "end_line": 9492,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeStream",
        "snippet": "    auto makeStream( StringRef const &filename ) -> IStream const* {\n        if( filename.empty() )\n            return new detail::CoutStream();\n        else if( filename[0] == '%' ) {\n            if( filename == \"%debug\" )\n                return new detail::DebugOutStream();\n            else\n                CATCH_ERROR( \"Unrecognised stream: '\" << filename << \"'\" );\n        }\n        else\n            return new detail::FileStream( filename );\n    }\n"
    },
    {
        "begin_line": 9495,
        "end_line": 9528,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringStreams",
        "snippet": "    struct StringStreams {\n        std::vector<std::unique_ptr<std::ostringstream>> m_streams;\n        std::vector<std::size_t> m_unused;\n        std::ostringstream m_referenceStream; // Used for copy state/ flags from\n        static StringStreams* s_instance;\n\n        auto add() -> std::size_t {\n            if( m_unused.empty() ) {\n                m_streams.push_back( std::unique_ptr<std::ostringstream>( new std::ostringstream ) );\n                return m_streams.size()-1;\n            }\n            else {\n                auto index = m_unused.back();\n                m_unused.pop_back();\n                return index;\n            }\n        }\n\n        void release( std::size_t index ) {\n            m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state\n            m_unused.push_back(index);\n        }\n\n        // !TBD: put in TLS\n        static auto instance() -> StringStreams& {\n            if( !s_instance )\n                s_instance = new StringStreams();\n            return *s_instance;\n        }\n        static void cleanup() {\n            delete s_instance;\n            s_instance = nullptr;\n        }\n    };\n"
    },
    {
        "begin_line": 9496,
        "end_line": 9496,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_streams",
        "snippet": "        std::vector<std::unique_ptr<std::ostringstream>> m_streams;\n"
    },
    {
        "begin_line": 9497,
        "end_line": 9497,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_unused",
        "snippet": "        std::vector<std::size_t> m_unused;\n"
    },
    {
        "begin_line": 9498,
        "end_line": 9498,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_referenceStream",
        "snippet": "        std::ostringstream m_referenceStream; // Used for copy state/ flags from\n"
    },
    {
        "begin_line": 9499,
        "end_line": 9499,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "s_instance",
        "snippet": "        static StringStreams* s_instance;\n"
    },
    {
        "begin_line": 9501,
        "end_line": 9511,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "add",
        "snippet": "        auto add() -> std::size_t {\n            if( m_unused.empty() ) {\n                m_streams.push_back( std::unique_ptr<std::ostringstream>( new std::ostringstream ) );\n                return m_streams.size()-1;\n            }\n            else {\n                auto index = m_unused.back();\n                m_unused.pop_back();\n                return index;\n            }\n        }\n"
    },
    {
        "begin_line": 9513,
        "end_line": 9516,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "release",
        "snippet": "        void release( std::size_t index ) {\n            m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state\n            m_unused.push_back(index);\n        }\n"
    },
    {
        "begin_line": 9519,
        "end_line": 9523,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "instance",
        "snippet": "        static auto instance() -> StringStreams& {\n            if( !s_instance )\n                s_instance = new StringStreams();\n            return *s_instance;\n        }\n"
    },
    {
        "begin_line": 9524,
        "end_line": 9527,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cleanup",
        "snippet": "        static void cleanup() {\n            delete s_instance;\n            s_instance = nullptr;\n        }\n"
    },
    {
        "begin_line": 9530,
        "end_line": 9530,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "s_instance",
        "snippet": "    StringStreams* StringStreams::s_instance = nullptr;\n"
    },
    {
        "begin_line": 9532,
        "end_line": 9534,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cleanup",
        "snippet": "    void ReusableStringStream::cleanup() {\n        StringStreams::cleanup();\n    }\n"
    },
    {
        "begin_line": 9536,
        "end_line": 9539,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ReusableStringStream",
        "snippet": "    ReusableStringStream::ReusableStringStream()\n    :   m_index( StringStreams::instance().add() ),\n        m_oss( StringStreams::instance().m_streams[m_index].get() )\n    {}\n"
    },
    {
        "begin_line": 9541,
        "end_line": 9545,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~ReusableStringStream",
        "snippet": "    ReusableStringStream::~ReusableStringStream() {\n        static_cast<std::ostringstream*>( m_oss )->str(\"\");\n        m_oss->clear();\n        StringStreams::instance().release( m_index );\n    }\n"
    },
    {
        "begin_line": 9547,
        "end_line": 9549,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "str",
        "snippet": "    auto ReusableStringStream::str() const -> std::string {\n        return static_cast<std::ostringstream*>( m_oss )->str();\n    }\n"
    },
    {
        "begin_line": 9554,
        "end_line": 9554,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cout",
        "snippet": "    std::ostream& cout() { return std::cout; }\n"
    },
    {
        "begin_line": 9555,
        "end_line": 9555,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "cerr",
        "snippet": "    std::ostream& cerr() { return std::cerr; }\n"
    },
    {
        "begin_line": 9556,
        "end_line": 9556,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "clog",
        "snippet": "    std::ostream& clog() { return std::clog; }\n"
    },
    {
        "begin_line": 9571,
        "end_line": 9633,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    bool startsWith( std::string const& s, std::string const& prefix ) {\n        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\n    }\n    bool startsWith( std::string const& s, char prefix ) {\n        return !s.empty() && s[0] == prefix;\n    }\n    bool endsWith( std::string const& s, std::string const& suffix ) {\n        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\n    }\n    bool endsWith( std::string const& s, char suffix ) {\n        return !s.empty() && s[s.size()-1] == suffix;\n    }\n    bool contains( std::string const& s, std::string const& infix ) {\n        return s.find( infix ) != std::string::npos;\n    }\n    char toLowerCh(char c) {\n        return static_cast<char>( std::tolower( c ) );\n    }\n    void toLowerInPlace( std::string& s ) {\n        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );\n    }\n    std::string toLower( std::string const& s ) {\n        std::string lc = s;\n        toLowerInPlace( lc );\n        return lc;\n    }\n    std::string trim( std::string const& str ) {\n        static char const* whitespaceChars = \"\\n\\r\\t \";\n        std::string::size_type start = str.find_first_not_of( whitespaceChars );\n        std::string::size_type end = str.find_last_not_of( whitespaceChars );\n\n        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\n    }\n\n    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {\n        bool replaced = false;\n        std::size_t i = str.find( replaceThis );\n        while( i != std::string::npos ) {\n            replaced = true;\n            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\n            if( i < str.size()-withThis.size() )\n                i = str.find( replaceThis, i+withThis.size() );\n            else\n                i = std::string::npos;\n        }\n        return replaced;\n    }\n\n    pluralise::pluralise( std::size_t count, std::string const& label )\n    :   m_count( count ),\n        m_label( label )\n    {}\n\n    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {\n        os << pluraliser.m_count << ' ' << pluraliser.m_label;\n        if( pluraliser.m_count != 1 )\n            os << 's';\n        return os;\n    }\n\n}\n"
    },
    {
        "begin_line": 9573,
        "end_line": 9575,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "startsWith",
        "snippet": "    bool startsWith( std::string const& s, std::string const& prefix ) {\n        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\n    }\n"
    },
    {
        "begin_line": 9576,
        "end_line": 9578,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "startsWith",
        "snippet": "    bool startsWith( std::string const& s, char prefix ) {\n        return !s.empty() && s[0] == prefix;\n    }\n"
    },
    {
        "begin_line": 9579,
        "end_line": 9581,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "endsWith",
        "snippet": "    bool endsWith( std::string const& s, std::string const& suffix ) {\n        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\n    }\n"
    },
    {
        "begin_line": 9582,
        "end_line": 9584,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "endsWith",
        "snippet": "    bool endsWith( std::string const& s, char suffix ) {\n        return !s.empty() && s[s.size()-1] == suffix;\n    }\n"
    },
    {
        "begin_line": 9585,
        "end_line": 9587,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "contains",
        "snippet": "    bool contains( std::string const& s, std::string const& infix ) {\n        return s.find( infix ) != std::string::npos;\n    }\n"
    },
    {
        "begin_line": 9588,
        "end_line": 9590,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "toLowerCh",
        "snippet": "    char toLowerCh(char c) {\n        return static_cast<char>( std::tolower( c ) );\n    }\n"
    },
    {
        "begin_line": 9591,
        "end_line": 9593,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "toLowerInPlace",
        "snippet": "    void toLowerInPlace( std::string& s ) {\n        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );\n    }\n"
    },
    {
        "begin_line": 9594,
        "end_line": 9598,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "toLower",
        "snippet": "    std::string toLower( std::string const& s ) {\n        std::string lc = s;\n        toLowerInPlace( lc );\n        return lc;\n    }\n"
    },
    {
        "begin_line": 9599,
        "end_line": 9605,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "trim",
        "snippet": "    std::string trim( std::string const& str ) {\n        static char const* whitespaceChars = \"\\n\\r\\t \";\n        std::string::size_type start = str.find_first_not_of( whitespaceChars );\n        std::string::size_type end = str.find_last_not_of( whitespaceChars );\n\n        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\n    }\n"
    },
    {
        "begin_line": 9607,
        "end_line": 9619,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "replaceInPlace",
        "snippet": "    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {\n        bool replaced = false;\n        std::size_t i = str.find( replaceThis );\n        while( i != std::string::npos ) {\n            replaced = true;\n            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\n            if( i < str.size()-withThis.size() )\n                i = str.find( replaceThis, i+withThis.size() );\n            else\n                i = std::string::npos;\n        }\n        return replaced;\n    }\n"
    },
    {
        "begin_line": 9621,
        "end_line": 9624,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "pluralise",
        "snippet": "    pluralise::pluralise( std::size_t count, std::string const& label )\n    :   m_count( count ),\n        m_label( label )\n    {}\n"
    },
    {
        "begin_line": 9626,
        "end_line": 9631,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {\n        os << pluraliser.m_count << ' ' << pluraliser.m_label;\n        if( pluraliser.m_count != 1 )\n            os << 's';\n        return os;\n    }\n"
    },
    {
        "begin_line": 9646,
        "end_line": 9650,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1811",
        "snippet": "namespace {\n    const uint32_t byte_2_lead = 0xC0;\n    const uint32_t byte_3_lead = 0xE0;\n    const uint32_t byte_4_lead = 0xF0;\n}\n"
    },
    {
        "begin_line": 9647,
        "end_line": 9647,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "byte_2_lead",
        "snippet": "    const uint32_t byte_2_lead = 0xC0;\n"
    },
    {
        "begin_line": 9648,
        "end_line": 9648,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "byte_3_lead",
        "snippet": "    const uint32_t byte_3_lead = 0xE0;\n"
    },
    {
        "begin_line": 9649,
        "end_line": 9649,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "byte_4_lead",
        "snippet": "    const uint32_t byte_4_lead = 0xF0;\n"
    },
    {
        "begin_line": 9652,
        "end_line": 9749,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    StringRef::StringRef( char const* rawChars ) noexcept\n    : StringRef( rawChars, static_cast<StringRef::size_type>(std::strlen(rawChars) ) )\n    {}\n\n    StringRef::operator std::string() const {\n        return std::string( m_start, m_size );\n    }\n\n    void StringRef::swap( StringRef& other ) noexcept {\n        std::swap( m_start, other.m_start );\n        std::swap( m_size, other.m_size );\n        std::swap( m_data, other.m_data );\n    }\n\n    auto StringRef::c_str() const -> char const* {\n        if( isSubstring() )\n           const_cast<StringRef*>( this )->takeOwnership();\n        return m_start;\n    }\n    auto StringRef::currentData() const noexcept -> char const* {\n        return m_start;\n    }\n\n    auto StringRef::isOwned() const noexcept -> bool {\n        return m_data != nullptr;\n    }\n    auto StringRef::isSubstring() const noexcept -> bool {\n        return m_start[m_size] != '\\0';\n    }\n\n    void StringRef::takeOwnership() {\n        if( !isOwned() ) {\n            m_data = new char[m_size+1];\n            memcpy( m_data, m_start, m_size );\n            m_data[m_size] = '\\0';\n            m_start = m_data;\n        }\n    }\n    auto StringRef::substr( size_type start, size_type size ) const noexcept -> StringRef {\n        if( start < m_size )\n            return StringRef( m_start+start, size );\n        else\n            return StringRef();\n    }\n    auto StringRef::operator == ( StringRef const& other ) const noexcept -> bool {\n        return\n            size() == other.size() &&\n            (std::strncmp( m_start, other.m_start, size() ) == 0);\n    }\n    auto StringRef::operator != ( StringRef const& other ) const noexcept -> bool {\n        return !operator==( other );\n    }\n\n    auto StringRef::operator[](size_type index) const noexcept -> char {\n        return m_start[index];\n    }\n\n    auto StringRef::numberOfCharacters() const noexcept -> size_type {\n        size_type noChars = m_size;\n        // Make adjustments for uft encodings\n        for( size_type i=0; i < m_size; ++i ) {\n            char c = m_start[i];\n            if( ( c & byte_2_lead ) == byte_2_lead ) {\n                noChars--;\n                if (( c & byte_3_lead ) == byte_3_lead )\n                    noChars--;\n                if( ( c & byte_4_lead ) == byte_4_lead )\n                    noChars--;\n            }\n        }\n        return noChars;\n    }\n\n    auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::string {\n        std::string str;\n        str.reserve( lhs.size() + rhs.size() );\n        str += lhs;\n        str += rhs;\n        return str;\n    }\n    auto operator + ( StringRef const& lhs, const char* rhs ) -> std::string {\n        return std::string( lhs ) + std::string( rhs );\n    }\n    auto operator + ( char const* lhs, StringRef const& rhs ) -> std::string {\n        return std::string( lhs ) + std::string( rhs );\n    }\n\n    auto operator << ( std::ostream& os, StringRef const& str ) -> std::ostream& {\n        return os.write(str.currentData(), str.size());\n    }\n\n    auto operator+=( std::string& lhs, StringRef const& rhs ) -> std::string& {\n        lhs.append(rhs.currentData(), rhs.size());\n        return lhs;\n    }\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 9653,
        "end_line": 9655,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "StringRef",
        "snippet": "    StringRef::StringRef( char const* rawChars ) noexcept\n    : StringRef( rawChars, static_cast<StringRef::size_type>(std::strlen(rawChars) ) )\n    {}\n"
    },
    {
        "begin_line": 9657,
        "end_line": 9659,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator std::string",
        "snippet": "    StringRef::operator std::string() const {\n        return std::string( m_start, m_size );\n    }\n"
    },
    {
        "begin_line": 9661,
        "end_line": 9665,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "swap",
        "snippet": "    void StringRef::swap( StringRef& other ) noexcept {\n        std::swap( m_start, other.m_start );\n        std::swap( m_size, other.m_size );\n        std::swap( m_data, other.m_data );\n    }\n"
    },
    {
        "begin_line": 9667,
        "end_line": 9671,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "c_str",
        "snippet": "    auto StringRef::c_str() const -> char const* {\n        if( isSubstring() )\n           const_cast<StringRef*>( this )->takeOwnership();\n        return m_start;\n    }\n"
    },
    {
        "begin_line": 9672,
        "end_line": 9674,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "currentData",
        "snippet": "    auto StringRef::currentData() const noexcept -> char const* {\n        return m_start;\n    }\n"
    },
    {
        "begin_line": 9676,
        "end_line": 9678,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isOwned",
        "snippet": "    auto StringRef::isOwned() const noexcept -> bool {\n        return m_data != nullptr;\n    }\n"
    },
    {
        "begin_line": 9679,
        "end_line": 9681,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSubstring",
        "snippet": "    auto StringRef::isSubstring() const noexcept -> bool {\n        return m_start[m_size] != '\\0';\n    }\n"
    },
    {
        "begin_line": 9683,
        "end_line": 9690,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "takeOwnership",
        "snippet": "    void StringRef::takeOwnership() {\n        if( !isOwned() ) {\n            m_data = new char[m_size+1];\n            memcpy( m_data, m_start, m_size );\n            m_data[m_size] = '\\0';\n            m_start = m_data;\n        }\n    }\n"
    },
    {
        "begin_line": 9691,
        "end_line": 9696,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "substr",
        "snippet": "    auto StringRef::substr( size_type start, size_type size ) const noexcept -> StringRef {\n        if( start < m_size )\n            return StringRef( m_start+start, size );\n        else\n            return StringRef();\n    }\n"
    },
    {
        "begin_line": 9697,
        "end_line": 9701,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "    auto StringRef::operator == ( StringRef const& other ) const noexcept -> bool {\n        return\n            size() == other.size() &&\n            (std::strncmp( m_start, other.m_start, size() ) == 0);\n    }\n"
    },
    {
        "begin_line": 9702,
        "end_line": 9704,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator !=",
        "snippet": "    auto StringRef::operator != ( StringRef const& other ) const noexcept -> bool {\n        return !operator==( other );\n    }\n"
    },
    {
        "begin_line": 9706,
        "end_line": 9708,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator []",
        "snippet": "    auto StringRef::operator[](size_type index) const noexcept -> char {\n        return m_start[index];\n    }\n"
    },
    {
        "begin_line": 9710,
        "end_line": 9724,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "numberOfCharacters",
        "snippet": "    auto StringRef::numberOfCharacters() const noexcept -> size_type {\n        size_type noChars = m_size;\n        // Make adjustments for uft encodings\n        for( size_type i=0; i < m_size; ++i ) {\n            char c = m_start[i];\n            if( ( c & byte_2_lead ) == byte_2_lead ) {\n                noChars--;\n                if (( c & byte_3_lead ) == byte_3_lead )\n                    noChars--;\n                if( ( c & byte_4_lead ) == byte_4_lead )\n                    noChars--;\n            }\n        }\n        return noChars;\n    }\n"
    },
    {
        "begin_line": 9726,
        "end_line": 9732,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "    auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::string {\n        std::string str;\n        str.reserve( lhs.size() + rhs.size() );\n        str += lhs;\n        str += rhs;\n        return str;\n    }\n"
    },
    {
        "begin_line": 9733,
        "end_line": 9735,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "    auto operator + ( StringRef const& lhs, const char* rhs ) -> std::string {\n        return std::string( lhs ) + std::string( rhs );\n    }\n"
    },
    {
        "begin_line": 9736,
        "end_line": 9738,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +",
        "snippet": "    auto operator + ( char const* lhs, StringRef const& rhs ) -> std::string {\n        return std::string( lhs ) + std::string( rhs );\n    }\n"
    },
    {
        "begin_line": 9740,
        "end_line": 9742,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    auto operator << ( std::ostream& os, StringRef const& str ) -> std::ostream& {\n        return os.write(str.currentData(), str.size());\n    }\n"
    },
    {
        "begin_line": 9744,
        "end_line": 9747,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +=",
        "snippet": "    auto operator+=( std::string& lhs, StringRef const& rhs ) -> std::string& {\n        lhs.append(rhs.currentData(), rhs.size());\n        return lhs;\n    }\n"
    },
    {
        "begin_line": 9757,
        "end_line": 9759,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    TagAlias::TagAlias(std::string const & _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}\n}\n"
    },
    {
        "begin_line": 9758,
        "end_line": 9758,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TagAlias",
        "snippet": "    TagAlias::TagAlias(std::string const & _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}\n"
    },
    {
        "begin_line": 9763,
        "end_line": 9774,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {\n        try {\n            getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);\n        } catch (...) {\n            // Do not throw when constructing global objects, instead register the exception to be processed later\n            getMutableRegistryHub().registerStartupException();\n        }\n    }\n\n}\n"
    },
    {
        "begin_line": 9765,
        "end_line": 9772,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RegistrarForTagAliases",
        "snippet": "    RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {\n        try {\n            getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);\n        } catch (...) {\n            // Do not throw when constructing global objects, instead register the exception to be processed later\n            getMutableRegistryHub().registerStartupException();\n        }\n    }\n"
    },
    {
        "begin_line": 9780,
        "end_line": 9821,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    TagAliasRegistry::~TagAliasRegistry() {}\n\n    TagAlias const* TagAliasRegistry::find( std::string const& alias ) const {\n        auto it = m_registry.find( alias );\n        if( it != m_registry.end() )\n            return &(it->second);\n        else\n            return nullptr;\n    }\n\n    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {\n        std::string expandedTestSpec = unexpandedTestSpec;\n        for( auto const& registryKvp : m_registry ) {\n            std::size_t pos = expandedTestSpec.find( registryKvp.first );\n            if( pos != std::string::npos ) {\n                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +\n                                    registryKvp.second.tag +\n                                    expandedTestSpec.substr( pos + registryKvp.first.size() );\n            }\n        }\n        return expandedTestSpec;\n    }\n\n    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {\n        CATCH_ENFORCE( startsWith(alias, \"[@\") && endsWith(alias, ']'),\n                      \"error: tag alias, '\" << alias << \"' is not of the form [@alias name].\\n\" << lineInfo );\n\n        CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,\n                      \"error: tag alias, '\" << alias << \"' already registered.\\n\"\n                      << \"\\tFirst seen at: \" << find(alias)->lineInfo << \"\\n\"\n                      << \"\\tRedefined at: \" << lineInfo );\n    }\n\n    ITagAliasRegistry::~ITagAliasRegistry() {}\n\n    ITagAliasRegistry const& ITagAliasRegistry::get() {\n        return getRegistryHub().getTagAliasRegistry();\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 9782,
        "end_line": 9782,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~TagAliasRegistry",
        "snippet": "    TagAliasRegistry::~TagAliasRegistry() {}\n"
    },
    {
        "begin_line": 9784,
        "end_line": 9790,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "find",
        "snippet": "    TagAlias const* TagAliasRegistry::find( std::string const& alias ) const {\n        auto it = m_registry.find( alias );\n        if( it != m_registry.end() )\n            return &(it->second);\n        else\n            return nullptr;\n    }\n"
    },
    {
        "begin_line": 9792,
        "end_line": 9803,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "expandAliases",
        "snippet": "    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {\n        std::string expandedTestSpec = unexpandedTestSpec;\n        for( auto const& registryKvp : m_registry ) {\n            std::size_t pos = expandedTestSpec.find( registryKvp.first );\n            if( pos != std::string::npos ) {\n                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +\n                                    registryKvp.second.tag +\n                                    expandedTestSpec.substr( pos + registryKvp.first.size() );\n            }\n        }\n        return expandedTestSpec;\n    }\n"
    },
    {
        "begin_line": 9805,
        "end_line": 9813,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "add",
        "snippet": "    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {\n        CATCH_ENFORCE( startsWith(alias, \"[@\") && endsWith(alias, ']'),\n                      \"error: tag alias, '\" << alias << \"' is not of the form [@alias name].\\n\" << lineInfo );\n\n        CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,\n                      \"error: tag alias, '\" << alias << \"' already registered.\\n\"\n                      << \"\\tFirst seen at: \" << find(alias)->lineInfo << \"\\n\"\n                      << \"\\tRedefined at: \" << lineInfo );\n    }\n"
    },
    {
        "begin_line": 9815,
        "end_line": 9815,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~ITagAliasRegistry",
        "snippet": "    ITagAliasRegistry::~ITagAliasRegistry() {}\n"
    },
    {
        "begin_line": 9817,
        "end_line": 9819,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "get",
        "snippet": "    ITagAliasRegistry const& ITagAliasRegistry::get() {\n        return getRegistryHub().getTagAliasRegistry();\n    }\n"
    },
    {
        "begin_line": 9830,
        "end_line": 9986,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {\n        if( startsWith( tag, '.' ) ||\n            tag == \"!hide\" )\n            return TestCaseInfo::IsHidden;\n        else if( tag == \"!throws\" )\n            return TestCaseInfo::Throws;\n        else if( tag == \"!shouldfail\" )\n            return TestCaseInfo::ShouldFail;\n        else if( tag == \"!mayfail\" )\n            return TestCaseInfo::MayFail;\n        else if( tag == \"!nonportable\" )\n            return TestCaseInfo::NonPortable;\n        else if( tag == \"!benchmark\" )\n            return static_cast<TestCaseInfo::SpecialProperties>( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );\n        else\n            return TestCaseInfo::None;\n    }\n    bool isReservedTag( std::string const& tag ) {\n        return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( tag[0] );\n    }\n    void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {\n        CATCH_ENFORCE( !isReservedTag(tag),\n                      \"Tag name: [\" << tag << \"] is not allowed.\\n\"\n                      << \"Tag names starting with non alpha-numeric characters are reserved\\n\"\n                      << _lineInfo );\n    }\n\n    TestCase makeTestCase(  ITestInvoker* _testCase,\n                            std::string const& _className,\n                            NameAndTags const& nameAndTags,\n                            SourceLineInfo const& _lineInfo )\n    {\n        bool isHidden = false;\n\n        // Parse out tags\n        std::vector<std::string> tags;\n        std::string desc, tag;\n        bool inTag = false;\n        std::string _descOrTags = nameAndTags.tags;\n        for (char c : _descOrTags) {\n            if( !inTag ) {\n                if( c == '[' )\n                    inTag = true;\n                else\n                    desc += c;\n            }\n            else {\n                if( c == ']' ) {\n                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );\n                    if( ( prop & TestCaseInfo::IsHidden ) != 0 )\n                        isHidden = true;\n                    else if( prop == TestCaseInfo::None )\n                        enforceNotReservedTag( tag, _lineInfo );\n\n                    tags.push_back( tag );\n                    tag.clear();\n                    inTag = false;\n                }\n                else\n                    tag += c;\n            }\n        }\n        if( isHidden ) {\n            tags.push_back( \".\" );\n        }\n\n        TestCaseInfo info( nameAndTags.name, _className, desc, tags, _lineInfo );\n        return TestCase( _testCase, std::move(info) );\n    }\n\n    void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags ) {\n        std::sort(begin(tags), end(tags));\n        tags.erase(std::unique(begin(tags), end(tags)), end(tags));\n        testCaseInfo.lcaseTags.clear();\n\n        for( auto const& tag : tags ) {\n            std::string lcaseTag = toLower( tag );\n            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );\n            testCaseInfo.lcaseTags.push_back( lcaseTag );\n        }\n        testCaseInfo.tags = std::move(tags);\n    }\n\n    TestCaseInfo::TestCaseInfo( std::string const& _name,\n                                std::string const& _className,\n                                std::string const& _description,\n                                std::vector<std::string> const& _tags,\n                                SourceLineInfo const& _lineInfo )\n    :   name( _name ),\n        className( _className ),\n        description( _description ),\n        lineInfo( _lineInfo ),\n        properties( None )\n    {\n        setTags( *this, _tags );\n    }\n\n    bool TestCaseInfo::isHidden() const {\n        return ( properties & IsHidden ) != 0;\n    }\n    bool TestCaseInfo::throws() const {\n        return ( properties & Throws ) != 0;\n    }\n    bool TestCaseInfo::okToFail() const {\n        return ( properties & (ShouldFail | MayFail ) ) != 0;\n    }\n    bool TestCaseInfo::expectedToFail() const {\n        return ( properties & (ShouldFail ) ) != 0;\n    }\n\n    std::string TestCaseInfo::tagsAsString() const {\n        std::string ret;\n        // '[' and ']' per tag\n        std::size_t full_size = 2 * tags.size();\n        for (const auto& tag : tags) {\n            full_size += tag.size();\n        }\n        ret.reserve(full_size);\n        for (const auto& tag : tags) {\n            ret.push_back('[');\n            ret.append(tag);\n            ret.push_back(']');\n        }\n\n        return ret;\n    }\n\n    TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&& info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}\n\n    TestCase TestCase::withName( std::string const& _newName ) const {\n        TestCase other( *this );\n        other.name = _newName;\n        return other;\n    }\n\n    void TestCase::invoke() const {\n        test->invoke();\n    }\n\n    bool TestCase::operator == ( TestCase const& other ) const {\n        return  test.get() == other.test.get() &&\n                name == other.name &&\n                className == other.className;\n    }\n\n    bool TestCase::operator < ( TestCase const& other ) const {\n        return name < other.name;\n    }\n\n    TestCaseInfo const& TestCase::getTestCaseInfo() const\n    {\n        return *this;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 9832,
        "end_line": 9848,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parseSpecialTag",
        "snippet": "    TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {\n        if( startsWith( tag, '.' ) ||\n            tag == \"!hide\" )\n            return TestCaseInfo::IsHidden;\n        else if( tag == \"!throws\" )\n            return TestCaseInfo::Throws;\n        else if( tag == \"!shouldfail\" )\n            return TestCaseInfo::ShouldFail;\n        else if( tag == \"!mayfail\" )\n            return TestCaseInfo::MayFail;\n        else if( tag == \"!nonportable\" )\n            return TestCaseInfo::NonPortable;\n        else if( tag == \"!benchmark\" )\n            return static_cast<TestCaseInfo::SpecialProperties>( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );\n        else\n            return TestCaseInfo::None;\n    }\n"
    },
    {
        "begin_line": 9849,
        "end_line": 9851,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isReservedTag",
        "snippet": "    bool isReservedTag( std::string const& tag ) {\n        return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( tag[0] );\n    }\n"
    },
    {
        "begin_line": 9852,
        "end_line": 9857,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "enforceNotReservedTag",
        "snippet": "    void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {\n        CATCH_ENFORCE( !isReservedTag(tag),\n                      \"Tag name: [\" << tag << \"] is not allowed.\\n\"\n                      << \"Tag names starting with non alpha-numeric characters are reserved\\n\"\n                      << _lineInfo );\n    }\n"
    },
    {
        "begin_line": 9859,
        "end_line": 9900,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeTestCase",
        "snippet": "    TestCase makeTestCase(  ITestInvoker* _testCase,\n                            std::string const& _className,\n                            NameAndTags const& nameAndTags,\n                            SourceLineInfo const& _lineInfo )\n    {\n        bool isHidden = false;\n\n        // Parse out tags\n        std::vector<std::string> tags;\n        std::string desc, tag;\n        bool inTag = false;\n        std::string _descOrTags = nameAndTags.tags;\n        for (char c : _descOrTags) {\n            if( !inTag ) {\n                if( c == '[' )\n                    inTag = true;\n                else\n                    desc += c;\n            }\n            else {\n                if( c == ']' ) {\n                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );\n                    if( ( prop & TestCaseInfo::IsHidden ) != 0 )\n                        isHidden = true;\n                    else if( prop == TestCaseInfo::None )\n                        enforceNotReservedTag( tag, _lineInfo );\n\n                    tags.push_back( tag );\n                    tag.clear();\n                    inTag = false;\n                }\n                else\n                    tag += c;\n            }\n        }\n        if( isHidden ) {\n            tags.push_back( \".\" );\n        }\n\n        TestCaseInfo info( nameAndTags.name, _className, desc, tags, _lineInfo );\n        return TestCase( _testCase, std::move(info) );\n    }\n"
    },
    {
        "begin_line": 9902,
        "end_line": 9913,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setTags",
        "snippet": "    void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags ) {\n        std::sort(begin(tags), end(tags));\n        tags.erase(std::unique(begin(tags), end(tags)), end(tags));\n        testCaseInfo.lcaseTags.clear();\n\n        for( auto const& tag : tags ) {\n            std::string lcaseTag = toLower( tag );\n            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );\n            testCaseInfo.lcaseTags.push_back( lcaseTag );\n        }\n        testCaseInfo.tags = std::move(tags);\n    }\n"
    },
    {
        "begin_line": 9915,
        "end_line": 9927,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCaseInfo",
        "snippet": "    TestCaseInfo::TestCaseInfo( std::string const& _name,\n                                std::string const& _className,\n                                std::string const& _description,\n                                std::vector<std::string> const& _tags,\n                                SourceLineInfo const& _lineInfo )\n    :   name( _name ),\n        className( _className ),\n        description( _description ),\n        lineInfo( _lineInfo ),\n        properties( None )\n    {\n        setTags( *this, _tags );\n    }\n"
    },
    {
        "begin_line": 9929,
        "end_line": 9931,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isHidden",
        "snippet": "    bool TestCaseInfo::isHidden() const {\n        return ( properties & IsHidden ) != 0;\n    }\n"
    },
    {
        "begin_line": 9932,
        "end_line": 9934,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "throws",
        "snippet": "    bool TestCaseInfo::throws() const {\n        return ( properties & Throws ) != 0;\n    }\n"
    },
    {
        "begin_line": 9935,
        "end_line": 9937,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "okToFail",
        "snippet": "    bool TestCaseInfo::okToFail() const {\n        return ( properties & (ShouldFail | MayFail ) ) != 0;\n    }\n"
    },
    {
        "begin_line": 9938,
        "end_line": 9940,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "expectedToFail",
        "snippet": "    bool TestCaseInfo::expectedToFail() const {\n        return ( properties & (ShouldFail ) ) != 0;\n    }\n"
    },
    {
        "begin_line": 9942,
        "end_line": 9957,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "tagsAsString",
        "snippet": "    std::string TestCaseInfo::tagsAsString() const {\n        std::string ret;\n        // '[' and ']' per tag\n        std::size_t full_size = 2 * tags.size();\n        for (const auto& tag : tags) {\n            full_size += tag.size();\n        }\n        ret.reserve(full_size);\n        for (const auto& tag : tags) {\n            ret.push_back('[');\n            ret.append(tag);\n            ret.push_back(']');\n        }\n\n        return ret;\n    }\n"
    },
    {
        "begin_line": 9959,
        "end_line": 9959,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCase",
        "snippet": "    TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&& info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}\n"
    },
    {
        "begin_line": 9961,
        "end_line": 9965,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "withName",
        "snippet": "    TestCase TestCase::withName( std::string const& _newName ) const {\n        TestCase other( *this );\n        other.name = _newName;\n        return other;\n    }\n"
    },
    {
        "begin_line": 9967,
        "end_line": 9969,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invoke",
        "snippet": "    void TestCase::invoke() const {\n        test->invoke();\n    }\n"
    },
    {
        "begin_line": 9971,
        "end_line": 9975,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ==",
        "snippet": "    bool TestCase::operator == ( TestCase const& other ) const {\n        return  test.get() == other.test.get() &&\n                name == other.name &&\n                className == other.className;\n    }\n"
    },
    {
        "begin_line": 9977,
        "end_line": 9979,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <",
        "snippet": "    bool TestCase::operator < ( TestCase const& other ) const {\n        return name < other.name;\n    }\n"
    },
    {
        "begin_line": 9981,
        "end_line": 9984,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getTestCaseInfo",
        "snippet": "    TestCaseInfo const& TestCase::getTestCaseInfo() const\n    {\n        return *this;\n    }\n"
    },
    {
        "begin_line": 9992,
        "end_line": 10083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {\n\n        std::vector<TestCase> sorted = unsortedTestCases;\n\n        switch( config.runOrder() ) {\n            case RunTests::InLexicographicalOrder:\n                std::sort( sorted.begin(), sorted.end() );\n                break;\n            case RunTests::InRandomOrder:\n                seedRng( config );\n                RandomNumberGenerator::shuffle( sorted );\n                break;\n            case RunTests::InDeclarationOrder:\n                // already in declaration order\n                break;\n        }\n        return sorted;\n    }\n    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {\n        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );\n    }\n\n    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {\n        std::set<TestCase> seenFunctions;\n        for( auto const& function : functions ) {\n            auto prev = seenFunctions.insert( function );\n            CATCH_ENFORCE( prev.second,\n                    \"error: TEST_CASE( \\\"\" << function.name << \"\\\" ) already defined.\\n\"\n                    << \"\\tFirst seen at \" << prev.first->getTestCaseInfo().lineInfo << \"\\n\"\n                    << \"\\tRedefined at \" << function.getTestCaseInfo().lineInfo );\n        }\n    }\n\n    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {\n        std::vector<TestCase> filtered;\n        filtered.reserve( testCases.size() );\n        for( auto const& testCase : testCases )\n            if( matchTest( testCase, testSpec, config ) )\n                filtered.push_back( testCase );\n        return filtered;\n    }\n    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {\n        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );\n    }\n\n    void TestRegistry::registerTest( TestCase const& testCase ) {\n        std::string name = testCase.getTestCaseInfo().name;\n        if( name.empty() ) {\n            ReusableStringStream rss;\n            rss << \"Anonymous test case \" << ++m_unnamedCount;\n            return registerTest( testCase.withName( rss.str() ) );\n        }\n        m_functions.push_back( testCase );\n    }\n\n    std::vector<TestCase> const& TestRegistry::getAllTests() const {\n        return m_functions;\n    }\n    std::vector<TestCase> const& TestRegistry::getAllTestsSorted( IConfig const& config ) const {\n        if( m_sortedFunctions.empty() )\n            enforceNoDuplicateTestCases( m_functions );\n\n        if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {\n            m_sortedFunctions = sortTests( config, m_functions );\n            m_currentSortOrder = config.runOrder();\n        }\n        return m_sortedFunctions;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}\n\n    void TestInvokerAsFunction::invoke() const {\n        m_testAsFunction();\n    }\n\n    std::string extractClassName( StringRef const& classOrQualifiedMethodName ) {\n        std::string className = classOrQualifiedMethodName;\n        if( startsWith( className, '&' ) )\n        {\n            std::size_t lastColons = className.rfind( \"::\" );\n            std::size_t penultimateColons = className.rfind( \"::\", lastColons-1 );\n            if( penultimateColons == std::string::npos )\n                penultimateColons = 1;\n            className = className.substr( penultimateColons, lastColons-penultimateColons );\n        }\n        return className;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 9994,
        "end_line": 10011,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sortTests",
        "snippet": "    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {\n\n        std::vector<TestCase> sorted = unsortedTestCases;\n\n        switch( config.runOrder() ) {\n            case RunTests::InLexicographicalOrder:\n                std::sort( sorted.begin(), sorted.end() );\n                break;\n            case RunTests::InRandomOrder:\n                seedRng( config );\n                RandomNumberGenerator::shuffle( sorted );\n                break;\n            case RunTests::InDeclarationOrder:\n                // already in declaration order\n                break;\n        }\n        return sorted;\n    }\n"
    },
    {
        "begin_line": 10012,
        "end_line": 10014,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "matchTest",
        "snippet": "    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {\n        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );\n    }\n"
    },
    {
        "begin_line": 10016,
        "end_line": 10025,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "enforceNoDuplicateTestCases",
        "snippet": "    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {\n        std::set<TestCase> seenFunctions;\n        for( auto const& function : functions ) {\n            auto prev = seenFunctions.insert( function );\n            CATCH_ENFORCE( prev.second,\n                    \"error: TEST_CASE( \\\"\" << function.name << \"\\\" ) already defined.\\n\"\n                    << \"\\tFirst seen at \" << prev.first->getTestCaseInfo().lineInfo << \"\\n\"\n                    << \"\\tRedefined at \" << function.getTestCaseInfo().lineInfo );\n        }\n    }\n"
    },
    {
        "begin_line": 10027,
        "end_line": 10034,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "filterTests",
        "snippet": "    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {\n        std::vector<TestCase> filtered;\n        filtered.reserve( testCases.size() );\n        for( auto const& testCase : testCases )\n            if( matchTest( testCase, testSpec, config ) )\n                filtered.push_back( testCase );\n        return filtered;\n    }\n"
    },
    {
        "begin_line": 10035,
        "end_line": 10037,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getAllTestCasesSorted",
        "snippet": "    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {\n        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );\n    }\n"
    },
    {
        "begin_line": 10039,
        "end_line": 10047,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "registerTest",
        "snippet": "    void TestRegistry::registerTest( TestCase const& testCase ) {\n        std::string name = testCase.getTestCaseInfo().name;\n        if( name.empty() ) {\n            ReusableStringStream rss;\n            rss << \"Anonymous test case \" << ++m_unnamedCount;\n            return registerTest( testCase.withName( rss.str() ) );\n        }\n        m_functions.push_back( testCase );\n    }\n"
    },
    {
        "begin_line": 10049,
        "end_line": 10051,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getAllTests",
        "snippet": "    std::vector<TestCase> const& TestRegistry::getAllTests() const {\n        return m_functions;\n    }\n"
    },
    {
        "begin_line": 10052,
        "end_line": 10061,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getAllTestsSorted",
        "snippet": "    std::vector<TestCase> const& TestRegistry::getAllTestsSorted( IConfig const& config ) const {\n        if( m_sortedFunctions.empty() )\n            enforceNoDuplicateTestCases( m_functions );\n\n        if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {\n            m_sortedFunctions = sortTests( config, m_functions );\n            m_currentSortOrder = config.runOrder();\n        }\n        return m_sortedFunctions;\n    }\n"
    },
    {
        "begin_line": 10064,
        "end_line": 10064,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestInvokerAsFunction",
        "snippet": "    TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}\n"
    },
    {
        "begin_line": 10066,
        "end_line": 10068,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "invoke",
        "snippet": "    void TestInvokerAsFunction::invoke() const {\n        m_testAsFunction();\n    }\n"
    },
    {
        "begin_line": 10070,
        "end_line": 10081,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "extractClassName",
        "snippet": "    std::string extractClassName( StringRef const& classOrQualifiedMethodName ) {\n        std::string className = classOrQualifiedMethodName;\n        if( startsWith( className, '&' ) )\n        {\n            std::size_t lastColons = className.rfind( \"::\" );\n            std::size_t penultimateColons = className.rfind( \"::\", lastColons-1 );\n            if( penultimateColons == std::string::npos )\n                penultimateColons = 1;\n            className = className.substr( penultimateColons, lastColons-penultimateColons );\n        }\n        return className;\n    }\n"
    },
    {
        "begin_line": 10098,
        "end_line": 10353,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace TestCaseTracking {\n\n    NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )\n    :   name( _name ),\n        location( _location )\n    {}\n\n    ITracker::~ITracker() = default;\n\n    TrackerContext& TrackerContext::instance() {\n        static TrackerContext s_instance;\n        return s_instance;\n    }\n\n    ITracker& TrackerContext::startRun() {\n        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( \"{root}\", CATCH_INTERNAL_LINEINFO ), *this, nullptr );\n        m_currentTracker = nullptr;\n        m_runState = Executing;\n        return *m_rootTracker;\n    }\n\n    void TrackerContext::endRun() {\n        m_rootTracker.reset();\n        m_currentTracker = nullptr;\n        m_runState = NotStarted;\n    }\n\n    void TrackerContext::startCycle() {\n        m_currentTracker = m_rootTracker.get();\n        m_runState = Executing;\n    }\n    void TrackerContext::completeCycle() {\n        m_runState = CompletedCycle;\n    }\n\n    bool TrackerContext::completedCycle() const {\n        return m_runState == CompletedCycle;\n    }\n    ITracker& TrackerContext::currentTracker() {\n        return *m_currentTracker;\n    }\n    void TrackerContext::setCurrentTracker( ITracker* tracker ) {\n        m_currentTracker = tracker;\n    }\n\n    TrackerBase::TrackerHasName::TrackerHasName( NameAndLocation const& nameAndLocation ) : m_nameAndLocation( nameAndLocation ) {}\n    bool TrackerBase::TrackerHasName::operator ()( ITrackerPtr const& tracker ) const {\n        return\n            tracker->nameAndLocation().name == m_nameAndLocation.name &&\n            tracker->nameAndLocation().location == m_nameAndLocation.location;\n    }\n\n    TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n    :   m_nameAndLocation( nameAndLocation ),\n        m_ctx( ctx ),\n        m_parent( parent )\n    {}\n\n    NameAndLocation const& TrackerBase::nameAndLocation() const {\n        return m_nameAndLocation;\n    }\n    bool TrackerBase::isComplete() const {\n        return m_runState == CompletedSuccessfully || m_runState == Failed;\n    }\n    bool TrackerBase::isSuccessfullyCompleted() const {\n        return m_runState == CompletedSuccessfully;\n    }\n    bool TrackerBase::isOpen() const {\n        return m_runState != NotStarted && !isComplete();\n    }\n    bool TrackerBase::hasChildren() const {\n        return !m_children.empty();\n    }\n\n    void TrackerBase::addChild( ITrackerPtr const& child ) {\n        m_children.push_back( child );\n    }\n\n    ITrackerPtr TrackerBase::findChild( NameAndLocation const& nameAndLocation ) {\n        auto it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( nameAndLocation ) );\n        return( it != m_children.end() )\n            ? *it\n            : nullptr;\n    }\n    ITracker& TrackerBase::parent() {\n        assert( m_parent ); // Should always be non-null except for root\n        return *m_parent;\n    }\n\n    void TrackerBase::openChild() {\n        if( m_runState != ExecutingChildren ) {\n            m_runState = ExecutingChildren;\n            if( m_parent )\n                m_parent->openChild();\n        }\n    }\n\n    bool TrackerBase::isSectionTracker() const { return false; }\n    bool TrackerBase::isIndexTracker() const { return false; }\n\n    void TrackerBase::open() {\n        m_runState = Executing;\n        moveToThis();\n        if( m_parent )\n            m_parent->openChild();\n    }\n\n    void TrackerBase::close() {\n\n        // Close any still open children (e.g. generators)\n        while( &m_ctx.currentTracker() != this )\n            m_ctx.currentTracker().close();\n\n        switch( m_runState ) {\n            case NeedsAnotherRun:\n                break;\n\n            case Executing:\n                m_runState = CompletedSuccessfully;\n                break;\n            case ExecutingChildren:\n                if( m_children.empty() || m_children.back()->isComplete() )\n                    m_runState = CompletedSuccessfully;\n                break;\n\n            case NotStarted:\n            case CompletedSuccessfully:\n            case Failed:\n                CATCH_INTERNAL_ERROR( \"Illogical state: \" << m_runState );\n\n            default:\n                CATCH_INTERNAL_ERROR( \"Unknown state: \" << m_runState );\n        }\n        moveToParent();\n        m_ctx.completeCycle();\n    }\n    void TrackerBase::fail() {\n        m_runState = Failed;\n        if( m_parent )\n            m_parent->markAsNeedingAnotherRun();\n        moveToParent();\n        m_ctx.completeCycle();\n    }\n    void TrackerBase::markAsNeedingAnotherRun() {\n        m_runState = NeedsAnotherRun;\n    }\n\n    void TrackerBase::moveToParent() {\n        assert( m_parent );\n        m_ctx.setCurrentTracker( m_parent );\n    }\n    void TrackerBase::moveToThis() {\n        m_ctx.setCurrentTracker( this );\n    }\n\n    SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n    :   TrackerBase( nameAndLocation, ctx, parent )\n    {\n        if( parent ) {\n            while( !parent->isSectionTracker() )\n                parent = &parent->parent();\n\n            SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );\n            addNextFilters( parentSection.m_filters );\n        }\n    }\n\n    bool SectionTracker::isSectionTracker() const { return true; }\n\n    SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\n        std::shared_ptr<SectionTracker> section;\n\n        ITracker& currentTracker = ctx.currentTracker();\n        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {\n            assert( childTracker );\n            assert( childTracker->isSectionTracker() );\n            section = std::static_pointer_cast<SectionTracker>( childTracker );\n        }\n        else {\n            section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );\n            currentTracker.addChild( section );\n        }\n        if( !ctx.completedCycle() )\n            section->tryOpen();\n        return *section;\n    }\n\n    void SectionTracker::tryOpen() {\n        if( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )\n            open();\n    }\n\n    void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {\n        if( !filters.empty() ) {\n            m_filters.push_back(\"\"); // Root - should never be consulted\n            m_filters.push_back(\"\"); // Test Case - not a section filter\n            m_filters.insert( m_filters.end(), filters.begin(), filters.end() );\n        }\n    }\n    void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {\n        if( filters.size() > 1 )\n            m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );\n    }\n\n    IndexTracker::IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size )\n    :   TrackerBase( nameAndLocation, ctx, parent ),\n        m_size( size )\n    {}\n\n    bool IndexTracker::isIndexTracker() const { return true; }\n\n    IndexTracker& IndexTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size ) {\n        std::shared_ptr<IndexTracker> tracker;\n\n        ITracker& currentTracker = ctx.currentTracker();\n        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {\n            assert( childTracker );\n            assert( childTracker->isIndexTracker() );\n            tracker = std::static_pointer_cast<IndexTracker>( childTracker );\n        }\n        else {\n            tracker = std::make_shared<IndexTracker>( nameAndLocation, ctx, &currentTracker, size );\n            currentTracker.addChild( tracker );\n        }\n\n        if( !ctx.completedCycle() && !tracker->isComplete() ) {\n            if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )\n                tracker->moveNext();\n            tracker->open();\n        }\n\n        return *tracker;\n    }\n\n    int IndexTracker::index() const { return m_index; }\n\n    void IndexTracker::moveNext() {\n        m_index++;\n        m_children.clear();\n    }\n\n    void IndexTracker::close() {\n        TrackerBase::close();\n        if( m_runState == CompletedSuccessfully && m_index < m_size-1 )\n            m_runState = Executing;\n    }\n\n} // namespace TestCaseTracking\n\nusing TestCaseTracking::ITracker;\nusing TestCaseTracking::TrackerContext;\nusing TestCaseTracking::SectionTracker;\nusing TestCaseTracking::IndexTracker;\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 10099,
        "end_line": 10346,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestCaseTracking",
        "snippet": "namespace TestCaseTracking {\n\n    NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )\n    :   name( _name ),\n        location( _location )\n    {}\n\n    ITracker::~ITracker() = default;\n\n    TrackerContext& TrackerContext::instance() {\n        static TrackerContext s_instance;\n        return s_instance;\n    }\n\n    ITracker& TrackerContext::startRun() {\n        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( \"{root}\", CATCH_INTERNAL_LINEINFO ), *this, nullptr );\n        m_currentTracker = nullptr;\n        m_runState = Executing;\n        return *m_rootTracker;\n    }\n\n    void TrackerContext::endRun() {\n        m_rootTracker.reset();\n        m_currentTracker = nullptr;\n        m_runState = NotStarted;\n    }\n\n    void TrackerContext::startCycle() {\n        m_currentTracker = m_rootTracker.get();\n        m_runState = Executing;\n    }\n    void TrackerContext::completeCycle() {\n        m_runState = CompletedCycle;\n    }\n\n    bool TrackerContext::completedCycle() const {\n        return m_runState == CompletedCycle;\n    }\n    ITracker& TrackerContext::currentTracker() {\n        return *m_currentTracker;\n    }\n    void TrackerContext::setCurrentTracker( ITracker* tracker ) {\n        m_currentTracker = tracker;\n    }\n\n    TrackerBase::TrackerHasName::TrackerHasName( NameAndLocation const& nameAndLocation ) : m_nameAndLocation( nameAndLocation ) {}\n    bool TrackerBase::TrackerHasName::operator ()( ITrackerPtr const& tracker ) const {\n        return\n            tracker->nameAndLocation().name == m_nameAndLocation.name &&\n            tracker->nameAndLocation().location == m_nameAndLocation.location;\n    }\n\n    TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n    :   m_nameAndLocation( nameAndLocation ),\n        m_ctx( ctx ),\n        m_parent( parent )\n    {}\n\n    NameAndLocation const& TrackerBase::nameAndLocation() const {\n        return m_nameAndLocation;\n    }\n    bool TrackerBase::isComplete() const {\n        return m_runState == CompletedSuccessfully || m_runState == Failed;\n    }\n    bool TrackerBase::isSuccessfullyCompleted() const {\n        return m_runState == CompletedSuccessfully;\n    }\n    bool TrackerBase::isOpen() const {\n        return m_runState != NotStarted && !isComplete();\n    }\n    bool TrackerBase::hasChildren() const {\n        return !m_children.empty();\n    }\n\n    void TrackerBase::addChild( ITrackerPtr const& child ) {\n        m_children.push_back( child );\n    }\n\n    ITrackerPtr TrackerBase::findChild( NameAndLocation const& nameAndLocation ) {\n        auto it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( nameAndLocation ) );\n        return( it != m_children.end() )\n            ? *it\n            : nullptr;\n    }\n    ITracker& TrackerBase::parent() {\n        assert( m_parent ); // Should always be non-null except for root\n        return *m_parent;\n    }\n\n    void TrackerBase::openChild() {\n        if( m_runState != ExecutingChildren ) {\n            m_runState = ExecutingChildren;\n            if( m_parent )\n                m_parent->openChild();\n        }\n    }\n\n    bool TrackerBase::isSectionTracker() const { return false; }\n    bool TrackerBase::isIndexTracker() const { return false; }\n\n    void TrackerBase::open() {\n        m_runState = Executing;\n        moveToThis();\n        if( m_parent )\n            m_parent->openChild();\n    }\n\n    void TrackerBase::close() {\n\n        // Close any still open children (e.g. generators)\n        while( &m_ctx.currentTracker() != this )\n            m_ctx.currentTracker().close();\n\n        switch( m_runState ) {\n            case NeedsAnotherRun:\n                break;\n\n            case Executing:\n                m_runState = CompletedSuccessfully;\n                break;\n            case ExecutingChildren:\n                if( m_children.empty() || m_children.back()->isComplete() )\n                    m_runState = CompletedSuccessfully;\n                break;\n\n            case NotStarted:\n            case CompletedSuccessfully:\n            case Failed:\n                CATCH_INTERNAL_ERROR( \"Illogical state: \" << m_runState );\n\n            default:\n                CATCH_INTERNAL_ERROR( \"Unknown state: \" << m_runState );\n        }\n        moveToParent();\n        m_ctx.completeCycle();\n    }\n    void TrackerBase::fail() {\n        m_runState = Failed;\n        if( m_parent )\n            m_parent->markAsNeedingAnotherRun();\n        moveToParent();\n        m_ctx.completeCycle();\n    }\n    void TrackerBase::markAsNeedingAnotherRun() {\n        m_runState = NeedsAnotherRun;\n    }\n\n    void TrackerBase::moveToParent() {\n        assert( m_parent );\n        m_ctx.setCurrentTracker( m_parent );\n    }\n    void TrackerBase::moveToThis() {\n        m_ctx.setCurrentTracker( this );\n    }\n\n    SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n    :   TrackerBase( nameAndLocation, ctx, parent )\n    {\n        if( parent ) {\n            while( !parent->isSectionTracker() )\n                parent = &parent->parent();\n\n            SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );\n            addNextFilters( parentSection.m_filters );\n        }\n    }\n\n    bool SectionTracker::isSectionTracker() const { return true; }\n\n    SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\n        std::shared_ptr<SectionTracker> section;\n\n        ITracker& currentTracker = ctx.currentTracker();\n        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {\n            assert( childTracker );\n            assert( childTracker->isSectionTracker() );\n            section = std::static_pointer_cast<SectionTracker>( childTracker );\n        }\n        else {\n            section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );\n            currentTracker.addChild( section );\n        }\n        if( !ctx.completedCycle() )\n            section->tryOpen();\n        return *section;\n    }\n\n    void SectionTracker::tryOpen() {\n        if( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )\n            open();\n    }\n\n    void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {\n        if( !filters.empty() ) {\n            m_filters.push_back(\"\"); // Root - should never be consulted\n            m_filters.push_back(\"\"); // Test Case - not a section filter\n            m_filters.insert( m_filters.end(), filters.begin(), filters.end() );\n        }\n    }\n    void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {\n        if( filters.size() > 1 )\n            m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );\n    }\n\n    IndexTracker::IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size )\n    :   TrackerBase( nameAndLocation, ctx, parent ),\n        m_size( size )\n    {}\n\n    bool IndexTracker::isIndexTracker() const { return true; }\n\n    IndexTracker& IndexTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size ) {\n        std::shared_ptr<IndexTracker> tracker;\n\n        ITracker& currentTracker = ctx.currentTracker();\n        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {\n            assert( childTracker );\n            assert( childTracker->isIndexTracker() );\n            tracker = std::static_pointer_cast<IndexTracker>( childTracker );\n        }\n        else {\n            tracker = std::make_shared<IndexTracker>( nameAndLocation, ctx, &currentTracker, size );\n            currentTracker.addChild( tracker );\n        }\n\n        if( !ctx.completedCycle() && !tracker->isComplete() ) {\n            if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )\n                tracker->moveNext();\n            tracker->open();\n        }\n\n        return *tracker;\n    }\n\n    int IndexTracker::index() const { return m_index; }\n\n    void IndexTracker::moveNext() {\n        m_index++;\n        m_children.clear();\n    }\n\n    void IndexTracker::close() {\n        TrackerBase::close();\n        if( m_runState == CompletedSuccessfully && m_index < m_size-1 )\n            m_runState = Executing;\n    }\n\n} // namespace TestCaseTracking\n"
    },
    {
        "begin_line": 10101,
        "end_line": 10104,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NameAndLocation",
        "snippet": "    NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )\n    :   name( _name ),\n        location( _location )\n    {}\n"
    },
    {
        "begin_line": 10108,
        "end_line": 10111,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "instance",
        "snippet": "    TrackerContext& TrackerContext::instance() {\n        static TrackerContext s_instance;\n        return s_instance;\n    }\n"
    },
    {
        "begin_line": 10113,
        "end_line": 10118,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "startRun",
        "snippet": "    ITracker& TrackerContext::startRun() {\n        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( \"{root}\", CATCH_INTERNAL_LINEINFO ), *this, nullptr );\n        m_currentTracker = nullptr;\n        m_runState = Executing;\n        return *m_rootTracker;\n    }\n"
    },
    {
        "begin_line": 10120,
        "end_line": 10124,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "endRun",
        "snippet": "    void TrackerContext::endRun() {\n        m_rootTracker.reset();\n        m_currentTracker = nullptr;\n        m_runState = NotStarted;\n    }\n"
    },
    {
        "begin_line": 10126,
        "end_line": 10129,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "startCycle",
        "snippet": "    void TrackerContext::startCycle() {\n        m_currentTracker = m_rootTracker.get();\n        m_runState = Executing;\n    }\n"
    },
    {
        "begin_line": 10130,
        "end_line": 10132,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "completeCycle",
        "snippet": "    void TrackerContext::completeCycle() {\n        m_runState = CompletedCycle;\n    }\n"
    },
    {
        "begin_line": 10134,
        "end_line": 10136,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "completedCycle",
        "snippet": "    bool TrackerContext::completedCycle() const {\n        return m_runState == CompletedCycle;\n    }\n"
    },
    {
        "begin_line": 10137,
        "end_line": 10139,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "currentTracker",
        "snippet": "    ITracker& TrackerContext::currentTracker() {\n        return *m_currentTracker;\n    }\n"
    },
    {
        "begin_line": 10140,
        "end_line": 10142,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "setCurrentTracker",
        "snippet": "    void TrackerContext::setCurrentTracker( ITracker* tracker ) {\n        m_currentTracker = tracker;\n    }\n"
    },
    {
        "begin_line": 10144,
        "end_line": 10144,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TrackerHasName",
        "snippet": "    TrackerBase::TrackerHasName::TrackerHasName( NameAndLocation const& nameAndLocation ) : m_nameAndLocation( nameAndLocation ) {}\n"
    },
    {
        "begin_line": 10145,
        "end_line": 10149,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator ()",
        "snippet": "    bool TrackerBase::TrackerHasName::operator ()( ITrackerPtr const& tracker ) const {\n        return\n            tracker->nameAndLocation().name == m_nameAndLocation.name &&\n            tracker->nameAndLocation().location == m_nameAndLocation.location;\n    }\n"
    },
    {
        "begin_line": 10151,
        "end_line": 10155,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TrackerBase",
        "snippet": "    TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n    :   m_nameAndLocation( nameAndLocation ),\n        m_ctx( ctx ),\n        m_parent( parent )\n    {}\n"
    },
    {
        "begin_line": 10157,
        "end_line": 10159,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "nameAndLocation",
        "snippet": "    NameAndLocation const& TrackerBase::nameAndLocation() const {\n        return m_nameAndLocation;\n    }\n"
    },
    {
        "begin_line": 10160,
        "end_line": 10162,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isComplete",
        "snippet": "    bool TrackerBase::isComplete() const {\n        return m_runState == CompletedSuccessfully || m_runState == Failed;\n    }\n"
    },
    {
        "begin_line": 10163,
        "end_line": 10165,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSuccessfullyCompleted",
        "snippet": "    bool TrackerBase::isSuccessfullyCompleted() const {\n        return m_runState == CompletedSuccessfully;\n    }\n"
    },
    {
        "begin_line": 10166,
        "end_line": 10168,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isOpen",
        "snippet": "    bool TrackerBase::isOpen() const {\n        return m_runState != NotStarted && !isComplete();\n    }\n"
    },
    {
        "begin_line": 10169,
        "end_line": 10171,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hasChildren",
        "snippet": "    bool TrackerBase::hasChildren() const {\n        return !m_children.empty();\n    }\n"
    },
    {
        "begin_line": 10173,
        "end_line": 10175,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addChild",
        "snippet": "    void TrackerBase::addChild( ITrackerPtr const& child ) {\n        m_children.push_back( child );\n    }\n"
    },
    {
        "begin_line": 10177,
        "end_line": 10182,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "findChild",
        "snippet": "    ITrackerPtr TrackerBase::findChild( NameAndLocation const& nameAndLocation ) {\n        auto it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( nameAndLocation ) );\n        return( it != m_children.end() )\n            ? *it\n            : nullptr;\n    }\n"
    },
    {
        "begin_line": 10183,
        "end_line": 10186,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parent",
        "snippet": "    ITracker& TrackerBase::parent() {\n        assert( m_parent ); // Should always be non-null except for root\n        return *m_parent;\n    }\n"
    },
    {
        "begin_line": 10188,
        "end_line": 10194,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "openChild",
        "snippet": "    void TrackerBase::openChild() {\n        if( m_runState != ExecutingChildren ) {\n            m_runState = ExecutingChildren;\n            if( m_parent )\n                m_parent->openChild();\n        }\n    }\n"
    },
    {
        "begin_line": 10196,
        "end_line": 10196,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSectionTracker",
        "snippet": "    bool TrackerBase::isSectionTracker() const { return false; }\n"
    },
    {
        "begin_line": 10197,
        "end_line": 10197,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isIndexTracker",
        "snippet": "    bool TrackerBase::isIndexTracker() const { return false; }\n"
    },
    {
        "begin_line": 10199,
        "end_line": 10204,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "open",
        "snippet": "    void TrackerBase::open() {\n        m_runState = Executing;\n        moveToThis();\n        if( m_parent )\n            m_parent->openChild();\n    }\n"
    },
    {
        "begin_line": 10206,
        "end_line": 10234,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "close",
        "snippet": "    void TrackerBase::close() {\n\n        // Close any still open children (e.g. generators)\n        while( &m_ctx.currentTracker() != this )\n            m_ctx.currentTracker().close();\n\n        switch( m_runState ) {\n            case NeedsAnotherRun:\n                break;\n\n            case Executing:\n                m_runState = CompletedSuccessfully;\n                break;\n            case ExecutingChildren:\n                if( m_children.empty() || m_children.back()->isComplete() )\n                    m_runState = CompletedSuccessfully;\n                break;\n\n            case NotStarted:\n            case CompletedSuccessfully:\n            case Failed:\n                CATCH_INTERNAL_ERROR( \"Illogical state: \" << m_runState );\n\n            default:\n                CATCH_INTERNAL_ERROR( \"Unknown state: \" << m_runState );\n        }\n        moveToParent();\n        m_ctx.completeCycle();\n    }\n"
    },
    {
        "begin_line": 10235,
        "end_line": 10241,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "fail",
        "snippet": "    void TrackerBase::fail() {\n        m_runState = Failed;\n        if( m_parent )\n            m_parent->markAsNeedingAnotherRun();\n        moveToParent();\n        m_ctx.completeCycle();\n    }\n"
    },
    {
        "begin_line": 10242,
        "end_line": 10244,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "markAsNeedingAnotherRun",
        "snippet": "    void TrackerBase::markAsNeedingAnotherRun() {\n        m_runState = NeedsAnotherRun;\n    }\n"
    },
    {
        "begin_line": 10246,
        "end_line": 10249,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "moveToParent",
        "snippet": "    void TrackerBase::moveToParent() {\n        assert( m_parent );\n        m_ctx.setCurrentTracker( m_parent );\n    }\n"
    },
    {
        "begin_line": 10250,
        "end_line": 10252,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "moveToThis",
        "snippet": "    void TrackerBase::moveToThis() {\n        m_ctx.setCurrentTracker( this );\n    }\n"
    },
    {
        "begin_line": 10254,
        "end_line": 10264,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SectionTracker",
        "snippet": "    SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n    :   TrackerBase( nameAndLocation, ctx, parent )\n    {\n        if( parent ) {\n            while( !parent->isSectionTracker() )\n                parent = &parent->parent();\n\n            SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );\n            addNextFilters( parentSection.m_filters );\n        }\n    }\n"
    },
    {
        "begin_line": 10266,
        "end_line": 10266,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isSectionTracker",
        "snippet": "    bool SectionTracker::isSectionTracker() const { return true; }\n"
    },
    {
        "begin_line": 10268,
        "end_line": 10284,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "acquire",
        "snippet": "    SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\n        std::shared_ptr<SectionTracker> section;\n\n        ITracker& currentTracker = ctx.currentTracker();\n        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {\n            assert( childTracker );\n            assert( childTracker->isSectionTracker() );\n            section = std::static_pointer_cast<SectionTracker>( childTracker );\n        }\n        else {\n            section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );\n            currentTracker.addChild( section );\n        }\n        if( !ctx.completedCycle() )\n            section->tryOpen();\n        return *section;\n    }\n"
    },
    {
        "begin_line": 10286,
        "end_line": 10289,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "tryOpen",
        "snippet": "    void SectionTracker::tryOpen() {\n        if( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )\n            open();\n    }\n"
    },
    {
        "begin_line": 10291,
        "end_line": 10297,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addInitialFilters",
        "snippet": "    void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {\n        if( !filters.empty() ) {\n            m_filters.push_back(\"\"); // Root - should never be consulted\n            m_filters.push_back(\"\"); // Test Case - not a section filter\n            m_filters.insert( m_filters.end(), filters.begin(), filters.end() );\n        }\n    }\n"
    },
    {
        "begin_line": 10298,
        "end_line": 10301,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addNextFilters",
        "snippet": "    void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {\n        if( filters.size() > 1 )\n            m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );\n    }\n"
    },
    {
        "begin_line": 10303,
        "end_line": 10306,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "IndexTracker",
        "snippet": "    IndexTracker::IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size )\n    :   TrackerBase( nameAndLocation, ctx, parent ),\n        m_size( size )\n    {}\n"
    },
    {
        "begin_line": 10308,
        "end_line": 10308,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isIndexTracker",
        "snippet": "    bool IndexTracker::isIndexTracker() const { return true; }\n"
    },
    {
        "begin_line": 10310,
        "end_line": 10331,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "acquire",
        "snippet": "    IndexTracker& IndexTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size ) {\n        std::shared_ptr<IndexTracker> tracker;\n\n        ITracker& currentTracker = ctx.currentTracker();\n        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {\n            assert( childTracker );\n            assert( childTracker->isIndexTracker() );\n            tracker = std::static_pointer_cast<IndexTracker>( childTracker );\n        }\n        else {\n            tracker = std::make_shared<IndexTracker>( nameAndLocation, ctx, &currentTracker, size );\n            currentTracker.addChild( tracker );\n        }\n\n        if( !ctx.completedCycle() && !tracker->isComplete() ) {\n            if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )\n                tracker->moveNext();\n            tracker->open();\n        }\n\n        return *tracker;\n    }\n"
    },
    {
        "begin_line": 10333,
        "end_line": 10333,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "index",
        "snippet": "    int IndexTracker::index() const { return m_index; }\n"
    },
    {
        "begin_line": 10335,
        "end_line": 10338,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "moveNext",
        "snippet": "    void IndexTracker::moveNext() {\n        m_index++;\n        m_children.clear();\n    }\n"
    },
    {
        "begin_line": 10340,
        "end_line": 10344,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "close",
        "snippet": "    void IndexTracker::close() {\n        TrackerBase::close();\n        if( m_runState == CompletedSuccessfully && m_index < m_size-1 )\n            m_runState = Executing;\n    }\n"
    },
    {
        "begin_line": 10361,
        "end_line": 10385,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker* {\n        return new(std::nothrow) TestInvokerAsFunction( testAsFunction );\n    }\n\n    NameAndTags::NameAndTags( StringRef const& name_ , StringRef const& tags_ ) noexcept : name( name_ ), tags( tags_ ) {}\n\n    AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept {\n        try {\n            getMutableRegistryHub()\n                    .registerTest(\n                        makeTestCase(\n                            invoker,\n                            extractClassName( classOrMethod ),\n                            nameAndTags,\n                            lineInfo));\n        } catch (...) {\n            // Do not throw when constructing global objects, instead register the exception to be processed later\n            getMutableRegistryHub().registerStartupException();\n        }\n    }\n\n    AutoReg::~AutoReg() = default;\n}\n"
    },
    {
        "begin_line": 10363,
        "end_line": 10365,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeTestInvoker",
        "snippet": "    auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker* {\n        return new(std::nothrow) TestInvokerAsFunction( testAsFunction );\n    }\n"
    },
    {
        "begin_line": 10367,
        "end_line": 10367,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NameAndTags",
        "snippet": "    NameAndTags::NameAndTags( StringRef const& name_ , StringRef const& tags_ ) noexcept : name( name_ ), tags( tags_ ) {}\n"
    },
    {
        "begin_line": 10369,
        "end_line": 10382,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AutoReg",
        "snippet": "    AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept {\n        try {\n            getMutableRegistryHub()\n                    .registerTest(\n                        makeTestCase(\n                            invoker,\n                            extractClassName( classOrMethod ),\n                            nameAndTags,\n                            lineInfo));\n        } catch (...) {\n            // Do not throw when constructing global objects, instead register the exception to be processed later\n            getMutableRegistryHub().registerStartupException();\n        }\n    }\n"
    },
    {
        "begin_line": 10394,
        "end_line": 10437,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    TestSpec::Pattern::~Pattern() = default;\n    TestSpec::NamePattern::~NamePattern() = default;\n    TestSpec::TagPattern::~TagPattern() = default;\n    TestSpec::ExcludedPattern::~ExcludedPattern() = default;\n\n    TestSpec::NamePattern::NamePattern( std::string const& name )\n    : m_wildcardPattern( toLower( name ), CaseSensitive::No )\n    {}\n    bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {\n        return m_wildcardPattern.matches( toLower( testCase.name ) );\n    }\n\n    TestSpec::TagPattern::TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}\n    bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {\n        return std::find(begin(testCase.lcaseTags),\n                         end(testCase.lcaseTags),\n                         m_tag) != end(testCase.lcaseTags);\n    }\n\n    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}\n    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }\n\n    bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {\n        // All patterns in a filter must match for the filter to be a match\n        for( auto const& pattern : m_patterns ) {\n            if( !pattern->matches( testCase ) )\n                return false;\n        }\n        return true;\n    }\n\n    bool TestSpec::hasFilters() const {\n        return !m_filters.empty();\n    }\n    bool TestSpec::matches( TestCaseInfo const& testCase ) const {\n        // A TestSpec matches if any filter matches\n        for( auto const& filter : m_filters )\n            if( filter.matches( testCase ) )\n                return true;\n        return false;\n    }\n}\n"
    },
    {
        "begin_line": 10401,
        "end_line": 10403,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "NamePattern",
        "snippet": "    TestSpec::NamePattern::NamePattern( std::string const& name )\n    : m_wildcardPattern( toLower( name ), CaseSensitive::No )\n    {}\n"
    },
    {
        "begin_line": 10404,
        "end_line": 10406,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "matches",
        "snippet": "    bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {\n        return m_wildcardPattern.matches( toLower( testCase.name ) );\n    }\n"
    },
    {
        "begin_line": 10408,
        "end_line": 10408,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TagPattern",
        "snippet": "    TestSpec::TagPattern::TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}\n"
    },
    {
        "begin_line": 10409,
        "end_line": 10413,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "matches",
        "snippet": "    bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {\n        return std::find(begin(testCase.lcaseTags),\n                         end(testCase.lcaseTags),\n                         m_tag) != end(testCase.lcaseTags);\n    }\n"
    },
    {
        "begin_line": 10415,
        "end_line": 10415,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ExcludedPattern",
        "snippet": "    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}\n"
    },
    {
        "begin_line": 10416,
        "end_line": 10416,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "matches",
        "snippet": "    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }\n"
    },
    {
        "begin_line": 10418,
        "end_line": 10425,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "matches",
        "snippet": "    bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {\n        // All patterns in a filter must match for the filter to be a match\n        for( auto const& pattern : m_patterns ) {\n            if( !pattern->matches( testCase ) )\n                return false;\n        }\n        return true;\n    }\n"
    },
    {
        "begin_line": 10427,
        "end_line": 10429,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hasFilters",
        "snippet": "    bool TestSpec::hasFilters() const {\n        return !m_filters.empty();\n    }\n"
    },
    {
        "begin_line": 10430,
        "end_line": 10436,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "matches",
        "snippet": "    bool TestSpec::matches( TestCaseInfo const& testCase ) const {\n        // A TestSpec matches if any filter matches\n        for( auto const& filter : m_filters )\n            if( filter.matches( testCase ) )\n                return true;\n        return false;\n    }\n"
    },
    {
        "begin_line": 10441,
        "end_line": 10518,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    TestSpecParser::TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}\n\n    TestSpecParser& TestSpecParser::parse( std::string const& arg ) {\n        m_mode = None;\n        m_exclusion = false;\n        m_start = std::string::npos;\n        m_arg = m_tagAliases->expandAliases( arg );\n        m_escapeChars.clear();\n        for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n            visitChar( m_arg[m_pos] );\n        if( m_mode == Name )\n            addPattern<TestSpec::NamePattern>();\n        return *this;\n    }\n    TestSpec TestSpecParser::testSpec() {\n        addFilter();\n        return m_testSpec;\n    }\n\n    void TestSpecParser::visitChar( char c ) {\n        if( m_mode == None ) {\n            switch( c ) {\n            case ' ': return;\n            case '~': m_exclusion = true; return;\n            case '[': return startNewMode( Tag, ++m_pos );\n            case '\"': return startNewMode( QuotedName, ++m_pos );\n            case '\\\\': return escape();\n            default: startNewMode( Name, m_pos ); break;\n            }\n        }\n        if( m_mode == Name ) {\n            if( c == ',' ) {\n                addPattern<TestSpec::NamePattern>();\n                addFilter();\n            }\n            else if( c == '[' ) {\n                if( subString() == \"exclude:\" )\n                    m_exclusion = true;\n                else\n                    addPattern<TestSpec::NamePattern>();\n                startNewMode( Tag, ++m_pos );\n            }\n            else if( c == '\\\\' )\n                escape();\n        }\n        else if( m_mode == EscapedName )\n            m_mode = Name;\n        else if( m_mode == QuotedName && c == '\"' )\n            addPattern<TestSpec::NamePattern>();\n        else if( m_mode == Tag && c == ']' )\n            addPattern<TestSpec::TagPattern>();\n    }\n    void TestSpecParser::startNewMode( Mode mode, std::size_t start ) {\n        m_mode = mode;\n        m_start = start;\n    }\n    void TestSpecParser::escape() {\n        if( m_mode == None )\n            m_start = m_pos;\n        m_mode = EscapedName;\n        m_escapeChars.push_back( m_pos );\n    }\n    std::string TestSpecParser::subString() const { return m_arg.substr( m_start, m_pos - m_start ); }\n\n    void TestSpecParser::addFilter() {\n        if( !m_currentFilter.m_patterns.empty() ) {\n            m_testSpec.m_filters.push_back( m_currentFilter );\n            m_currentFilter = TestSpec::Filter();\n        }\n    }\n\n    TestSpec parseTestSpec( std::string const& arg ) {\n        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();\n    }\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 10443,
        "end_line": 10443,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestSpecParser",
        "snippet": "    TestSpecParser::TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}\n"
    },
    {
        "begin_line": 10445,
        "end_line": 10456,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parse",
        "snippet": "    TestSpecParser& TestSpecParser::parse( std::string const& arg ) {\n        m_mode = None;\n        m_exclusion = false;\n        m_start = std::string::npos;\n        m_arg = m_tagAliases->expandAliases( arg );\n        m_escapeChars.clear();\n        for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n            visitChar( m_arg[m_pos] );\n        if( m_mode == Name )\n            addPattern<TestSpec::NamePattern>();\n        return *this;\n    }\n"
    },
    {
        "begin_line": 10457,
        "end_line": 10460,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testSpec",
        "snippet": "    TestSpec TestSpecParser::testSpec() {\n        addFilter();\n        return m_testSpec;\n    }\n"
    },
    {
        "begin_line": 10462,
        "end_line": 10494,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "visitChar",
        "snippet": "    void TestSpecParser::visitChar( char c ) {\n        if( m_mode == None ) {\n            switch( c ) {\n            case ' ': return;\n            case '~': m_exclusion = true; return;\n            case '[': return startNewMode( Tag, ++m_pos );\n            case '\"': return startNewMode( QuotedName, ++m_pos );\n            case '\\\\': return escape();\n            default: startNewMode( Name, m_pos ); break;\n            }\n        }\n        if( m_mode == Name ) {\n            if( c == ',' ) {\n                addPattern<TestSpec::NamePattern>();\n                addFilter();\n            }\n            else if( c == '[' ) {\n                if( subString() == \"exclude:\" )\n                    m_exclusion = true;\n                else\n                    addPattern<TestSpec::NamePattern>();\n                startNewMode( Tag, ++m_pos );\n            }\n            else if( c == '\\\\' )\n                escape();\n        }\n        else if( m_mode == EscapedName )\n            m_mode = Name;\n        else if( m_mode == QuotedName && c == '\"' )\n            addPattern<TestSpec::NamePattern>();\n        else if( m_mode == Tag && c == ']' )\n            addPattern<TestSpec::TagPattern>();\n    }\n"
    },
    {
        "begin_line": 10495,
        "end_line": 10498,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "startNewMode",
        "snippet": "    void TestSpecParser::startNewMode( Mode mode, std::size_t start ) {\n        m_mode = mode;\n        m_start = start;\n    }\n"
    },
    {
        "begin_line": 10499,
        "end_line": 10504,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "escape",
        "snippet": "    void TestSpecParser::escape() {\n        if( m_mode == None )\n            m_start = m_pos;\n        m_mode = EscapedName;\n        m_escapeChars.push_back( m_pos );\n    }\n"
    },
    {
        "begin_line": 10505,
        "end_line": 10505,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "subString",
        "snippet": "    std::string TestSpecParser::subString() const { return m_arg.substr( m_start, m_pos - m_start ); }\n"
    },
    {
        "begin_line": 10507,
        "end_line": 10512,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addFilter",
        "snippet": "    void TestSpecParser::addFilter() {\n        if( !m_currentFilter.m_patterns.empty() ) {\n            m_testSpec.m_filters.push_back( m_currentFilter );\n            m_currentFilter = TestSpec::Filter();\n        }\n    }\n"
    },
    {
        "begin_line": 10514,
        "end_line": 10516,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "parseTestSpec",
        "snippet": "    TestSpec parseTestSpec( std::string const& arg ) {\n        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();\n    }\n"
    },
    {
        "begin_line": 10524,
        "end_line": 10524,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "nanosecondsInSecond",
        "snippet": "static const uint64_t nanosecondsInSecond = 1000000000;\n"
    },
    {
        "begin_line": 10526,
        "end_line": 10582,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    auto getCurrentNanosecondsSinceEpoch() -> uint64_t {\n        return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();\n    }\n\n    auto estimateClockResolution() -> uint64_t {\n        uint64_t sum = 0;\n        static const uint64_t iterations = 1000000;\n\n        auto startTime = getCurrentNanosecondsSinceEpoch();\n\n        for( std::size_t i = 0; i < iterations; ++i ) {\n\n            uint64_t ticks;\n            uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();\n            do {\n                ticks = getCurrentNanosecondsSinceEpoch();\n            } while( ticks == baseTicks );\n\n            auto delta = ticks - baseTicks;\n            sum += delta;\n\n            // If we have been calibrating for over 3 seconds -- the clock\n            // is terrible and we should move on.\n            // TBD: How to signal that the measured resolution is probably wrong?\n            if (ticks > startTime + 3 * nanosecondsInSecond) {\n                return sum / i;\n            }\n        }\n\n        // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers\n        // - and potentially do more iterations if there's a high variance.\n        return sum/iterations;\n    }\n    auto getEstimatedClockResolution() -> uint64_t {\n        static auto s_resolution = estimateClockResolution();\n        return s_resolution;\n    }\n\n    void Timer::start() {\n       m_nanoseconds = getCurrentNanosecondsSinceEpoch();\n    }\n    auto Timer::getElapsedNanoseconds() const -> uint64_t {\n        return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;\n    }\n    auto Timer::getElapsedMicroseconds() const -> uint64_t {\n        return getElapsedNanoseconds()/1000;\n    }\n    auto Timer::getElapsedMilliseconds() const -> unsigned int {\n        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);\n    }\n    auto Timer::getElapsedSeconds() const -> double {\n        return getElapsedMicroseconds()/1000000.0;\n    }\n\n} // namespace Catch\n"
    },
    {
        "begin_line": 10528,
        "end_line": 10530,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getCurrentNanosecondsSinceEpoch",
        "snippet": "    auto getCurrentNanosecondsSinceEpoch() -> uint64_t {\n        return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();\n    }\n"
    },
    {
        "begin_line": 10532,
        "end_line": 10560,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "estimateClockResolution",
        "snippet": "    auto estimateClockResolution() -> uint64_t {\n        uint64_t sum = 0;\n        static const uint64_t iterations = 1000000;\n\n        auto startTime = getCurrentNanosecondsSinceEpoch();\n\n        for( std::size_t i = 0; i < iterations; ++i ) {\n\n            uint64_t ticks;\n            uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();\n            do {\n                ticks = getCurrentNanosecondsSinceEpoch();\n            } while( ticks == baseTicks );\n\n            auto delta = ticks - baseTicks;\n            sum += delta;\n\n            // If we have been calibrating for over 3 seconds -- the clock\n            // is terrible and we should move on.\n            // TBD: How to signal that the measured resolution is probably wrong?\n            if (ticks > startTime + 3 * nanosecondsInSecond) {\n                return sum / i;\n            }\n        }\n\n        // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers\n        // - and potentially do more iterations if there's a high variance.\n        return sum/iterations;\n    }\n"
    },
    {
        "begin_line": 10561,
        "end_line": 10564,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getEstimatedClockResolution",
        "snippet": "    auto getEstimatedClockResolution() -> uint64_t {\n        static auto s_resolution = estimateClockResolution();\n        return s_resolution;\n    }\n"
    },
    {
        "begin_line": 10566,
        "end_line": 10568,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "start",
        "snippet": "    void Timer::start() {\n       m_nanoseconds = getCurrentNanosecondsSinceEpoch();\n    }\n"
    },
    {
        "begin_line": 10569,
        "end_line": 10571,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getElapsedNanoseconds",
        "snippet": "    auto Timer::getElapsedNanoseconds() const -> uint64_t {\n        return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;\n    }\n"
    },
    {
        "begin_line": 10572,
        "end_line": 10574,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getElapsedMicroseconds",
        "snippet": "    auto Timer::getElapsedMicroseconds() const -> uint64_t {\n        return getElapsedNanoseconds()/1000;\n    }\n"
    },
    {
        "begin_line": 10575,
        "end_line": 10577,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getElapsedMilliseconds",
        "snippet": "    auto Timer::getElapsedMilliseconds() const -> unsigned int {\n        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);\n    }\n"
    },
    {
        "begin_line": 10578,
        "end_line": 10580,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getElapsedSeconds",
        "snippet": "    auto Timer::getElapsedSeconds() const -> double {\n        return getElapsedMicroseconds()/1000000.0;\n    }\n"
    },
    {
        "begin_line": 10594,
        "end_line": 10594,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER",
        "snippet": "#define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER\n"
    },
    {
        "begin_line": 10600,
        "end_line": 10808,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\nnamespace Detail {\n\n    const std::string unprintableString = \"{?}\";\n\n    namespace {\n        const int hexThreshold = 255;\n\n        struct Endianness {\n            enum Arch { Big, Little };\n\n            static Arch which() {\n                union _{\n                    int asInt;\n                    char asChar[sizeof (int)];\n                } u;\n\n                u.asInt = 1;\n                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;\n            }\n        };\n    }\n\n    std::string rawMemoryToString( const void *object, std::size_t size ) {\n        // Reverse order for little endian architectures\n        int i = 0, end = static_cast<int>( size ), inc = 1;\n        if( Endianness::which() == Endianness::Little ) {\n            i = end-1;\n            end = inc = -1;\n        }\n\n        unsigned char const *bytes = static_cast<unsigned char const *>(object);\n        ReusableStringStream rss;\n        rss << \"0x\" << std::setfill('0') << std::hex;\n        for( ; i != end; i += inc )\n             rss << std::setw(2) << static_cast<unsigned>(bytes[i]);\n       return rss.str();\n    }\n}\n\ntemplate<typename T>\nstd::string fpToString( T value, int precision ) {\n    if (std::isnan(value)) {\n        return \"nan\";\n    }\n\n    ReusableStringStream rss;\n    rss << std::setprecision( precision )\n        << std::fixed\n        << value;\n    std::string d = rss.str();\n    std::size_t i = d.find_last_not_of( '0' );\n    if( i != std::string::npos && i != d.size()-1 ) {\n        if( d[i] == '.' )\n            i++;\n        d = d.substr( 0, i+1 );\n    }\n    return d;\n}\n\n//// ======================================================= ////\n//\n//   Out-of-line defs for full specialization of StringMaker\n//\n//// ======================================================= ////\n\nstd::string StringMaker<std::string>::convert(const std::string& str) {\n    if (!getCurrentContext().getConfig()->showInvisibles()) {\n        return '\"' + str + '\"';\n    }\n\n    std::string s(\"\\\"\");\n    for (char c : str) {\n        switch (c) {\n        case '\\n':\n            s.append(\"\\\\n\");\n            break;\n        case '\\t':\n            s.append(\"\\\\t\");\n            break;\n        default:\n            s.push_back(c);\n            break;\n        }\n    }\n    s.append(\"\\\"\");\n    return s;\n}\n\n#ifdef CATCH_CONFIG_WCHAR\nstd::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {\n    std::string s;\n    s.reserve(wstr.size());\n    for (auto c : wstr) {\n        s += (c <= 0xff) ? static_cast<char>(c) : '?';\n    }\n    return ::Catch::Detail::stringify(s);\n}\n#endif\n\nstd::string StringMaker<char const*>::convert(char const* str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::string{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\nstd::string StringMaker<char*>::convert(char* str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::string{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\n#ifdef CATCH_CONFIG_WCHAR\nstd::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::wstring{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\nstd::string StringMaker<wchar_t *>::convert(wchar_t * str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::wstring{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\n#endif\n\nstd::string StringMaker<int>::convert(int value) {\n    return ::Catch::Detail::stringify(static_cast<long long>(value));\n}\nstd::string StringMaker<long>::convert(long value) {\n    return ::Catch::Detail::stringify(static_cast<long long>(value));\n}\nstd::string StringMaker<long long>::convert(long long value) {\n    ReusableStringStream rss;\n    rss << value;\n    if (value > Detail::hexThreshold) {\n        rss << \" (0x\" << std::hex << value << ')';\n    }\n    return rss.str();\n}\n\nstd::string StringMaker<unsigned int>::convert(unsigned int value) {\n    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));\n}\nstd::string StringMaker<unsigned long>::convert(unsigned long value) {\n    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));\n}\nstd::string StringMaker<unsigned long long>::convert(unsigned long long value) {\n    ReusableStringStream rss;\n    rss << value;\n    if (value > Detail::hexThreshold) {\n        rss << \" (0x\" << std::hex << value << ')';\n    }\n    return rss.str();\n}\n\nstd::string StringMaker<bool>::convert(bool b) {\n    return b ? \"true\" : \"false\";\n}\n\nstd::string StringMaker<char>::convert(char value) {\n    if (value == '\\r') {\n        return \"'\\\\r'\";\n    } else if (value == '\\f') {\n        return \"'\\\\f'\";\n    } else if (value == '\\n') {\n        return \"'\\\\n'\";\n    } else if (value == '\\t') {\n        return \"'\\\\t'\";\n    } else if ('\\0' <= value && value < ' ') {\n        return ::Catch::Detail::stringify(static_cast<unsigned int>(value));\n    } else {\n        char chstr[] = \"' '\";\n        chstr[1] = value;\n        return chstr;\n    }\n}\nstd::string StringMaker<signed char>::convert(signed char c) {\n    return ::Catch::Detail::stringify(static_cast<char>(c));\n}\nstd::string StringMaker<unsigned char>::convert(unsigned char c) {\n    return ::Catch::Detail::stringify(static_cast<char>(c));\n}\n\nstd::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {\n    return \"nullptr\";\n}\n\nstd::string StringMaker<float>::convert(float value) {\n    return fpToString(value, 5) + 'f';\n}\nstd::string StringMaker<double>::convert(double value) {\n    return fpToString(value, 10);\n}\n\nstd::string ratio_string<std::atto>::symbol() { return \"a\"; }\nstd::string ratio_string<std::femto>::symbol() { return \"f\"; }\nstd::string  ratio_string<std::pico>::symbol() { return \"p\"; }\nstd::string  ratio_string<std::nano>::symbol() { return \"n\"; }\nstd::string ratio_string<std::micro>::symbol() { return \"u\"; }\nstd::string ratio_string<std::milli>::symbol() { return \"m\"; }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 10602,
        "end_line": 10639,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Detail",
        "snippet": "namespace Detail {\n\n    const std::string unprintableString = \"{?}\";\n\n    namespace {\n        const int hexThreshold = 255;\n\n        struct Endianness {\n            enum Arch { Big, Little };\n\n            static Arch which() {\n                union _{\n                    int asInt;\n                    char asChar[sizeof (int)];\n                } u;\n\n                u.asInt = 1;\n                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;\n            }\n        };\n    }\n\n    std::string rawMemoryToString( const void *object, std::size_t size ) {\n        // Reverse order for little endian architectures\n        int i = 0, end = static_cast<int>( size ), inc = 1;\n        if( Endianness::which() == Endianness::Little ) {\n            i = end-1;\n            end = inc = -1;\n        }\n\n        unsigned char const *bytes = static_cast<unsigned char const *>(object);\n        ReusableStringStream rss;\n        rss << \"0x\" << std::setfill('0') << std::hex;\n        for( ; i != end; i += inc )\n             rss << std::setw(2) << static_cast<unsigned>(bytes[i]);\n       return rss.str();\n    }\n}\n"
    },
    {
        "begin_line": 10604,
        "end_line": 10604,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "unprintableString",
        "snippet": "    const std::string unprintableString = \"{?}\";\n"
    },
    {
        "begin_line": 10606,
        "end_line": 10622,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1911",
        "snippet": "    namespace {\n        const int hexThreshold = 255;\n\n        struct Endianness {\n            enum Arch { Big, Little };\n\n            static Arch which() {\n                union _{\n                    int asInt;\n                    char asChar[sizeof (int)];\n                } u;\n\n                u.asInt = 1;\n                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;\n            }\n        };\n    }\n"
    },
    {
        "begin_line": 10607,
        "end_line": 10607,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hexThreshold",
        "snippet": "        const int hexThreshold = 255;\n"
    },
    {
        "begin_line": 10609,
        "end_line": 10621,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Endianness",
        "snippet": "        struct Endianness {\n            enum Arch { Big, Little };\n\n            static Arch which() {\n                union _{\n                    int asInt;\n                    char asChar[sizeof (int)];\n                } u;\n\n                u.asInt = 1;\n                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;\n            }\n        };\n"
    },
    {
        "begin_line": 10610,
        "end_line": 10610,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Arch",
        "snippet": "            enum Arch { Big, Little };\n"
    },
    {
        "begin_line": 10612,
        "end_line": 10620,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "which",
        "snippet": "            static Arch which() {\n                union _{\n                    int asInt;\n                    char asChar[sizeof (int)];\n                } u;\n\n                u.asInt = 1;\n                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;\n            }\n"
    },
    {
        "begin_line": 10613,
        "end_line": 10616,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "_",
        "snippet": "                union _{\n                    int asInt;\n                    char asChar[sizeof (int)];\n                } u;\n"
    },
    {
        "begin_line": 10614,
        "end_line": 10614,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "asInt",
        "snippet": "                    int asInt;\n"
    },
    {
        "begin_line": 10615,
        "end_line": 10615,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "asChar",
        "snippet": "                    char asChar[sizeof (int)];\n"
    },
    {
        "begin_line": 10624,
        "end_line": 10638,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rawMemoryToString",
        "snippet": "    std::string rawMemoryToString( const void *object, std::size_t size ) {\n        // Reverse order for little endian architectures\n        int i = 0, end = static_cast<int>( size ), inc = 1;\n        if( Endianness::which() == Endianness::Little ) {\n            i = end-1;\n            end = inc = -1;\n        }\n\n        unsigned char const *bytes = static_cast<unsigned char const *>(object);\n        ReusableStringStream rss;\n        rss << \"0x\" << std::setfill('0') << std::hex;\n        for( ; i != end; i += inc )\n             rss << std::setw(2) << static_cast<unsigned>(bytes[i]);\n       return rss.str();\n    }\n"
    },
    {
        "begin_line": 10642,
        "end_line": 10659,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "fpToString",
        "snippet": "std::string fpToString( T value, int precision ) {\n    if (std::isnan(value)) {\n        return \"nan\";\n    }\n\n    ReusableStringStream rss;\n    rss << std::setprecision( precision )\n        << std::fixed\n        << value;\n    std::string d = rss.str();\n    std::size_t i = d.find_last_not_of( '0' );\n    if( i != std::string::npos && i != d.size()-1 ) {\n        if( d[i] == '.' )\n            i++;\n        d = d.substr( 0, i+1 );\n    }\n    return d;\n}\n"
    },
    {
        "begin_line": 10667,
        "end_line": 10688,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<std::string>::convert(const std::string& str) {\n    if (!getCurrentContext().getConfig()->showInvisibles()) {\n        return '\"' + str + '\"';\n    }\n\n    std::string s(\"\\\"\");\n    for (char c : str) {\n        switch (c) {\n        case '\\n':\n            s.append(\"\\\\n\");\n            break;\n        case '\\t':\n            s.append(\"\\\\t\");\n            break;\n        default:\n            s.push_back(c);\n            break;\n        }\n    }\n    s.append(\"\\\"\");\n    return s;\n}\n"
    },
    {
        "begin_line": 10691,
        "end_line": 10698,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {\n    std::string s;\n    s.reserve(wstr.size());\n    for (auto c : wstr) {\n        s += (c <= 0xff) ? static_cast<char>(c) : '?';\n    }\n    return ::Catch::Detail::stringify(s);\n}\n"
    },
    {
        "begin_line": 10701,
        "end_line": 10707,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<char const*>::convert(char const* str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::string{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\n"
    },
    {
        "begin_line": 10708,
        "end_line": 10714,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<char*>::convert(char* str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::string{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\n"
    },
    {
        "begin_line": 10716,
        "end_line": 10722,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::wstring{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\n"
    },
    {
        "begin_line": 10723,
        "end_line": 10729,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<wchar_t *>::convert(wchar_t * str) {\n    if (str) {\n        return ::Catch::Detail::stringify(std::wstring{ str });\n    } else {\n        return{ \"{null string}\" };\n    }\n}\n"
    },
    {
        "begin_line": 10732,
        "end_line": 10734,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<int>::convert(int value) {\n    return ::Catch::Detail::stringify(static_cast<long long>(value));\n}\n"
    },
    {
        "begin_line": 10735,
        "end_line": 10737,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<long>::convert(long value) {\n    return ::Catch::Detail::stringify(static_cast<long long>(value));\n}\n"
    },
    {
        "begin_line": 10738,
        "end_line": 10745,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<long long>::convert(long long value) {\n    ReusableStringStream rss;\n    rss << value;\n    if (value > Detail::hexThreshold) {\n        rss << \" (0x\" << std::hex << value << ')';\n    }\n    return rss.str();\n}\n"
    },
    {
        "begin_line": 10747,
        "end_line": 10749,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<unsigned int>::convert(unsigned int value) {\n    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));\n}\n"
    },
    {
        "begin_line": 10750,
        "end_line": 10752,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<unsigned long>::convert(unsigned long value) {\n    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));\n}\n"
    },
    {
        "begin_line": 10753,
        "end_line": 10760,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<unsigned long long>::convert(unsigned long long value) {\n    ReusableStringStream rss;\n    rss << value;\n    if (value > Detail::hexThreshold) {\n        rss << \" (0x\" << std::hex << value << ')';\n    }\n    return rss.str();\n}\n"
    },
    {
        "begin_line": 10762,
        "end_line": 10764,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<bool>::convert(bool b) {\n    return b ? \"true\" : \"false\";\n}\n"
    },
    {
        "begin_line": 10766,
        "end_line": 10782,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<char>::convert(char value) {\n    if (value == '\\r') {\n        return \"'\\\\r'\";\n    } else if (value == '\\f') {\n        return \"'\\\\f'\";\n    } else if (value == '\\n') {\n        return \"'\\\\n'\";\n    } else if (value == '\\t') {\n        return \"'\\\\t'\";\n    } else if ('\\0' <= value && value < ' ') {\n        return ::Catch::Detail::stringify(static_cast<unsigned int>(value));\n    } else {\n        char chstr[] = \"' '\";\n        chstr[1] = value;\n        return chstr;\n    }\n}\n"
    },
    {
        "begin_line": 10783,
        "end_line": 10785,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<signed char>::convert(signed char c) {\n    return ::Catch::Detail::stringify(static_cast<char>(c));\n}\n"
    },
    {
        "begin_line": 10786,
        "end_line": 10788,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<unsigned char>::convert(unsigned char c) {\n    return ::Catch::Detail::stringify(static_cast<char>(c));\n}\n"
    },
    {
        "begin_line": 10790,
        "end_line": 10792,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {\n    return \"nullptr\";\n}\n"
    },
    {
        "begin_line": 10794,
        "end_line": 10796,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<float>::convert(float value) {\n    return fpToString(value, 5) + 'f';\n}\n"
    },
    {
        "begin_line": 10797,
        "end_line": 10799,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "convert",
        "snippet": "std::string StringMaker<double>::convert(double value) {\n    return fpToString(value, 10);\n}\n"
    },
    {
        "begin_line": 10801,
        "end_line": 10801,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "symbol",
        "snippet": "std::string ratio_string<std::atto>::symbol() { return \"a\"; }\n"
    },
    {
        "begin_line": 10802,
        "end_line": 10802,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "symbol",
        "snippet": "std::string ratio_string<std::femto>::symbol() { return \"f\"; }\n"
    },
    {
        "begin_line": 10803,
        "end_line": 10803,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "symbol",
        "snippet": "std::string  ratio_string<std::pico>::symbol() { return \"p\"; }\n"
    },
    {
        "begin_line": 10804,
        "end_line": 10804,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "symbol",
        "snippet": "std::string  ratio_string<std::nano>::symbol() { return \"n\"; }\n"
    },
    {
        "begin_line": 10805,
        "end_line": 10805,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "symbol",
        "snippet": "std::string ratio_string<std::micro>::symbol() { return \"u\"; }\n"
    },
    {
        "begin_line": 10806,
        "end_line": 10806,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "symbol",
        "snippet": "std::string ratio_string<std::milli>::symbol() { return \"m\"; }\n"
    },
    {
        "begin_line": 10817,
        "end_line": 10868,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    Counts Counts::operator - ( Counts const& other ) const {\n        Counts diff;\n        diff.passed = passed - other.passed;\n        diff.failed = failed - other.failed;\n        diff.failedButOk = failedButOk - other.failedButOk;\n        return diff;\n    }\n\n    Counts& Counts::operator += ( Counts const& other ) {\n        passed += other.passed;\n        failed += other.failed;\n        failedButOk += other.failedButOk;\n        return *this;\n    }\n\n    std::size_t Counts::total() const {\n        return passed + failed + failedButOk;\n    }\n    bool Counts::allPassed() const {\n        return failed == 0 && failedButOk == 0;\n    }\n    bool Counts::allOk() const {\n        return failed == 0;\n    }\n\n    Totals Totals::operator - ( Totals const& other ) const {\n        Totals diff;\n        diff.assertions = assertions - other.assertions;\n        diff.testCases = testCases - other.testCases;\n        return diff;\n    }\n\n    Totals& Totals::operator += ( Totals const& other ) {\n        assertions += other.assertions;\n        testCases += other.testCases;\n        return *this;\n    }\n\n    Totals Totals::delta( Totals const& prevTotals ) const {\n        Totals diff = *this - prevTotals;\n        if( diff.assertions.failed > 0 )\n            ++diff.testCases.failed;\n        else if( diff.assertions.failedButOk > 0 )\n            ++diff.testCases.failedButOk;\n        else\n            ++diff.testCases.passed;\n        return diff;\n    }\n\n}\n"
    },
    {
        "begin_line": 10819,
        "end_line": 10825,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator -",
        "snippet": "    Counts Counts::operator - ( Counts const& other ) const {\n        Counts diff;\n        diff.passed = passed - other.passed;\n        diff.failed = failed - other.failed;\n        diff.failedButOk = failedButOk - other.failedButOk;\n        return diff;\n    }\n"
    },
    {
        "begin_line": 10827,
        "end_line": 10832,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +=",
        "snippet": "    Counts& Counts::operator += ( Counts const& other ) {\n        passed += other.passed;\n        failed += other.failed;\n        failedButOk += other.failedButOk;\n        return *this;\n    }\n"
    },
    {
        "begin_line": 10834,
        "end_line": 10836,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "total",
        "snippet": "    std::size_t Counts::total() const {\n        return passed + failed + failedButOk;\n    }\n"
    },
    {
        "begin_line": 10837,
        "end_line": 10839,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "allPassed",
        "snippet": "    bool Counts::allPassed() const {\n        return failed == 0 && failedButOk == 0;\n    }\n"
    },
    {
        "begin_line": 10840,
        "end_line": 10842,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "allOk",
        "snippet": "    bool Counts::allOk() const {\n        return failed == 0;\n    }\n"
    },
    {
        "begin_line": 10844,
        "end_line": 10849,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator -",
        "snippet": "    Totals Totals::operator - ( Totals const& other ) const {\n        Totals diff;\n        diff.assertions = assertions - other.assertions;\n        diff.testCases = testCases - other.testCases;\n        return diff;\n    }\n"
    },
    {
        "begin_line": 10851,
        "end_line": 10855,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator +=",
        "snippet": "    Totals& Totals::operator += ( Totals const& other ) {\n        assertions += other.assertions;\n        testCases += other.testCases;\n        return *this;\n    }\n"
    },
    {
        "begin_line": 10857,
        "end_line": 10866,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "delta",
        "snippet": "    Totals Totals::delta( Totals const& prevTotals ) const {\n        Totals diff = *this - prevTotals;\n        if( diff.assertions.failed > 0 )\n            ++diff.testCases.failed;\n        else if( diff.assertions.failedButOk > 0 )\n            ++diff.testCases.failedButOk;\n        else\n            ++diff.testCases.passed;\n        return diff;\n    }\n"
    },
    {
        "begin_line": 10874,
        "end_line": 10882,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    bool uncaught_exceptions() {\n#if defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)\n        return std::uncaught_exceptions() > 0;\n#else\n        return std::uncaught_exception();\n#endif\n  }\n} // end namespace Catch\n"
    },
    {
        "begin_line": 10875,
        "end_line": 10881,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "uncaught_exceptions",
        "snippet": "    bool uncaught_exceptions() {\n#if defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)\n        return std::uncaught_exceptions() > 0;\n#else\n        return std::uncaught_exception();\n#endif\n  }\n"
    },
    {
        "begin_line": 10888,
        "end_line": 10920,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    Version::Version\n        (   unsigned int _majorVersion,\n            unsigned int _minorVersion,\n            unsigned int _patchNumber,\n            char const * const _branchName,\n            unsigned int _buildNumber )\n    :   majorVersion( _majorVersion ),\n        minorVersion( _minorVersion ),\n        patchNumber( _patchNumber ),\n        branchName( _branchName ),\n        buildNumber( _buildNumber )\n    {}\n\n    std::ostream& operator << ( std::ostream& os, Version const& version ) {\n        os  << version.majorVersion << '.'\n            << version.minorVersion << '.'\n            << version.patchNumber;\n        // branchName is never null -> 0th char is \\0 if it is empty\n        if (version.branchName[0]) {\n            os << '-' << version.branchName\n               << '.' << version.buildNumber;\n        }\n        return os;\n    }\n\n    Version const& libraryVersion() {\n        static Version version( 2, 2, 2, \"\", 0 );\n        return version;\n    }\n\n}\n"
    },
    {
        "begin_line": 10890,
        "end_line": 10901,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Version",
        "snippet": "    Version::Version\n        (   unsigned int _majorVersion,\n            unsigned int _minorVersion,\n            unsigned int _patchNumber,\n            char const * const _branchName,\n            unsigned int _buildNumber )\n    :   majorVersion( _majorVersion ),\n        minorVersion( _minorVersion ),\n        patchNumber( _patchNumber ),\n        branchName( _branchName ),\n        buildNumber( _buildNumber )\n    {}\n"
    },
    {
        "begin_line": 10903,
        "end_line": 10913,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    std::ostream& operator << ( std::ostream& os, Version const& version ) {\n        os  << version.majorVersion << '.'\n            << version.minorVersion << '.'\n            << version.patchNumber;\n        // branchName is never null -> 0th char is \\0 if it is empty\n        if (version.branchName[0]) {\n            os << '-' << version.branchName\n               << '.' << version.buildNumber;\n        }\n        return os;\n    }\n"
    },
    {
        "begin_line": 10915,
        "end_line": 10918,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "libraryVersion",
        "snippet": "    Version const& libraryVersion() {\n        static Version version( 2, 2, 2, \"\", 0 );\n        return version;\n    }\n"
    },
    {
        "begin_line": 10926,
        "end_line": 10961,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    WildcardPattern::WildcardPattern( std::string const& pattern,\n                                      CaseSensitive::Choice caseSensitivity )\n    :   m_caseSensitivity( caseSensitivity ),\n        m_pattern( adjustCase( pattern ) )\n    {\n        if( startsWith( m_pattern, '*' ) ) {\n            m_pattern = m_pattern.substr( 1 );\n            m_wildcard = WildcardAtStart;\n        }\n        if( endsWith( m_pattern, '*' ) ) {\n            m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );\n            m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );\n        }\n    }\n\n    bool WildcardPattern::matches( std::string const& str ) const {\n        switch( m_wildcard ) {\n            case NoWildcard:\n                return m_pattern == adjustCase( str );\n            case WildcardAtStart:\n                return endsWith( adjustCase( str ), m_pattern );\n            case WildcardAtEnd:\n                return startsWith( adjustCase( str ), m_pattern );\n            case WildcardAtBothEnds:\n                return contains( adjustCase( str ), m_pattern );\n            default:\n                CATCH_INTERNAL_ERROR( \"Unknown enum\" );\n        }\n    }\n\n    std::string WildcardPattern::adjustCase( std::string const& str ) const {\n        return m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;\n    }\n}\n"
    },
    {
        "begin_line": 10928,
        "end_line": 10941,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WildcardPattern",
        "snippet": "    WildcardPattern::WildcardPattern( std::string const& pattern,\n                                      CaseSensitive::Choice caseSensitivity )\n    :   m_caseSensitivity( caseSensitivity ),\n        m_pattern( adjustCase( pattern ) )\n    {\n        if( startsWith( m_pattern, '*' ) ) {\n            m_pattern = m_pattern.substr( 1 );\n            m_wildcard = WildcardAtStart;\n        }\n        if( endsWith( m_pattern, '*' ) ) {\n            m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );\n            m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );\n        }\n    }\n"
    },
    {
        "begin_line": 10943,
        "end_line": 10956,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "matches",
        "snippet": "    bool WildcardPattern::matches( std::string const& str ) const {\n        switch( m_wildcard ) {\n            case NoWildcard:\n                return m_pattern == adjustCase( str );\n            case WildcardAtStart:\n                return endsWith( adjustCase( str ), m_pattern );\n            case WildcardAtEnd:\n                return startsWith( adjustCase( str ), m_pattern );\n            case WildcardAtBothEnds:\n                return contains( adjustCase( str ), m_pattern );\n            default:\n                CATCH_INTERNAL_ERROR( \"Unknown enum\" );\n        }\n    }\n"
    },
    {
        "begin_line": 10958,
        "end_line": 10960,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "adjustCase",
        "snippet": "    std::string WildcardPattern::adjustCase( std::string const& str ) const {\n        return m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;\n    }\n"
    },
    {
        "begin_line": 10969,
        "end_line": 11236,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\nnamespace {\n\n    size_t trailingBytes(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return 2;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return 3;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return 4;\n        }\n        CATCH_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n\n    uint32_t headerValue(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return c & 0x1F;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return c & 0x0F;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return c & 0x07;\n        }\n        CATCH_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n\n    void hexEscapeChar(std::ostream& os, unsigned char c) {\n        os << \"\\\\x\"\n            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)\n            << static_cast<int>(c);\n    }\n\n} // anonymous namespace\n\n    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )\n    :   m_str( str ),\n        m_forWhat( forWhat )\n    {}\n\n    void XmlEncode::encodeTo( std::ostream& os ) const {\n        // Apostrophe escaping not necessary if we always use \" to write attributes\n        // (see: http://www.w3.org/TR/xml/#syntax)\n\n        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {\n            uchar c = m_str[idx];\n            switch (c) {\n            case '<':   os << \"&lt;\"; break;\n            case '&':   os << \"&amp;\"; break;\n\n            case '>':\n                // See: http://www.w3.org/TR/xml/#syntax\n                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')\n                    os << \"&gt;\";\n                else\n                    os << c;\n                break;\n\n            case '\\\"':\n                if (m_forWhat == ForAttributes)\n                    os << \"&quot;\";\n                else\n                    os << c;\n                break;\n\n            default:\n                // Check for control characters and invalid utf-8\n\n                // Escape control characters in standard ascii\n                // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0\n                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                // Plain ASCII: Write it to stream\n                if (c < 0x7F) {\n                    os << c;\n                    break;\n                }\n\n                // UTF-8 territory\n                // Check if the encoding is valid and if it is not, hex escape bytes.\n                // Important: We do not check the exact decoded values for validity, only the encoding format\n                // First check that this bytes is a valid lead byte:\n                // This means that it is not encoded as 1111 1XXX\n                // Or as 10XX XXXX\n                if (c <  0xC0 ||\n                    c >= 0xF8) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                auto encBytes = trailingBytes(c);\n                // Are there enough bytes left to avoid accessing out-of-bounds memory?\n                if (idx + encBytes - 1 >= m_str.size()) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n                // The header is valid, check data\n                // The next encBytes bytes must together be a valid utf-8\n                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)\n                bool valid = true;\n                uint32_t value = headerValue(c);\n                for (std::size_t n = 1; n < encBytes; ++n) {\n                    uchar nc = m_str[idx + n];\n                    valid &= ((nc & 0xC0) == 0x80);\n                    value = (value << 6) | (nc & 0x3F);\n                }\n\n                if (\n                    // Wrong bit pattern of following bytes\n                    (!valid) ||\n                    // Overlong encodings\n                    (value < 0x80) ||\n                    (0x80 <= value && value < 0x800   && encBytes > 2) ||\n                    (0x800 < value && value < 0x10000 && encBytes > 3) ||\n                    // Encoded value out of range\n                    (value >= 0x110000)\n                    ) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                // If we got here, this is in fact a valid(ish) utf-8 sequence\n                for (std::size_t n = 0; n < encBytes; ++n) {\n                    os << m_str[idx + n];\n                }\n                idx += encBytes - 1;\n                break;\n            }\n        }\n    }\n\n    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {\n        xmlEncode.encodeTo( os );\n        return os;\n    }\n\n    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )\n    :   m_writer( writer )\n    {}\n\n    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept\n    :   m_writer( other.m_writer ){\n        other.m_writer = nullptr;\n    }\n    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) noexcept {\n        if ( m_writer ) {\n            m_writer->endElement();\n        }\n        m_writer = other.m_writer;\n        other.m_writer = nullptr;\n        return *this;\n    }\n\n    XmlWriter::ScopedElement::~ScopedElement() {\n        if( m_writer )\n            m_writer->endElement();\n    }\n\n    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, bool indent ) {\n        m_writer->writeText( text, indent );\n        return *this;\n    }\n\n    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )\n    {\n        writeDeclaration();\n    }\n\n    XmlWriter::~XmlWriter() {\n        while( !m_tags.empty() )\n            endElement();\n    }\n\n    XmlWriter& XmlWriter::startElement( std::string const& name ) {\n        ensureTagClosed();\n        newlineIfNecessary();\n        m_os << m_indent << '<' << name;\n        m_tags.push_back( name );\n        m_indent += \"  \";\n        m_tagIsOpen = true;\n        return *this;\n    }\n\n    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name ) {\n        ScopedElement scoped( this );\n        startElement( name );\n        return scoped;\n    }\n\n    XmlWriter& XmlWriter::endElement() {\n        newlineIfNecessary();\n        m_indent = m_indent.substr( 0, m_indent.size()-2 );\n        if( m_tagIsOpen ) {\n            m_os << \"/>\";\n            m_tagIsOpen = false;\n        }\n        else {\n            m_os << m_indent << \"</\" << m_tags.back() << \">\";\n        }\n        m_os << std::endl;\n        m_tags.pop_back();\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {\n        if( !name.empty() && !attribute.empty() )\n            m_os << ' ' << name << \"=\\\"\" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '\"';\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {\n        m_os << ' ' << name << \"=\\\"\" << ( attribute ? \"true\" : \"false\" ) << '\"';\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeText( std::string const& text, bool indent ) {\n        if( !text.empty() ){\n            bool tagWasOpen = m_tagIsOpen;\n            ensureTagClosed();\n            if( tagWasOpen && indent )\n                m_os << m_indent;\n            m_os << XmlEncode( text );\n            m_needsNewline = true;\n        }\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeComment( std::string const& text ) {\n        ensureTagClosed();\n        m_os << m_indent << \"<!--\" << text << \"-->\";\n        m_needsNewline = true;\n        return *this;\n    }\n\n    void XmlWriter::writeStylesheetRef( std::string const& url ) {\n        m_os << \"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\" << url << \"\\\"?>\\n\";\n    }\n\n    XmlWriter& XmlWriter::writeBlankLine() {\n        ensureTagClosed();\n        m_os << '\\n';\n        return *this;\n    }\n\n    void XmlWriter::ensureTagClosed() {\n        if( m_tagIsOpen ) {\n            m_os << \">\" << std::endl;\n            m_tagIsOpen = false;\n        }\n    }\n\n    void XmlWriter::writeDeclaration() {\n        m_os << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n    }\n\n    void XmlWriter::newlineIfNecessary() {\n        if( m_needsNewline ) {\n            m_os << std::endl;\n            m_needsNewline = false;\n        }\n    }\n}\n"
    },
    {
        "begin_line": 10971,
        "end_line": 11005,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1a11",
        "snippet": "namespace {\n\n    size_t trailingBytes(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return 2;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return 3;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return 4;\n        }\n        CATCH_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n\n    uint32_t headerValue(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return c & 0x1F;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return c & 0x0F;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return c & 0x07;\n        }\n        CATCH_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n\n    void hexEscapeChar(std::ostream& os, unsigned char c) {\n        os << \"\\\\x\"\n            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)\n            << static_cast<int>(c);\n    }\n\n} // anonymous namespace\n"
    },
    {
        "begin_line": 10973,
        "end_line": 10984,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "trailingBytes",
        "snippet": "    size_t trailingBytes(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return 2;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return 3;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return 4;\n        }\n        CATCH_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n"
    },
    {
        "begin_line": 10986,
        "end_line": 10997,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "headerValue",
        "snippet": "    uint32_t headerValue(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return c & 0x1F;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return c & 0x0F;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return c & 0x07;\n        }\n        CATCH_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n"
    },
    {
        "begin_line": 10999,
        "end_line": 11003,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "hexEscapeChar",
        "snippet": "    void hexEscapeChar(std::ostream& os, unsigned char c) {\n        os << \"\\\\x\"\n            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)\n            << static_cast<int>(c);\n    }\n"
    },
    {
        "begin_line": 11007,
        "end_line": 11010,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "XmlEncode",
        "snippet": "    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )\n    :   m_str( str ),\n        m_forWhat( forWhat )\n    {}\n"
    },
    {
        "begin_line": 11012,
        "end_line": 11104,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "encodeTo",
        "snippet": "    void XmlEncode::encodeTo( std::ostream& os ) const {\n        // Apostrophe escaping not necessary if we always use \" to write attributes\n        // (see: http://www.w3.org/TR/xml/#syntax)\n\n        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {\n            uchar c = m_str[idx];\n            switch (c) {\n            case '<':   os << \"&lt;\"; break;\n            case '&':   os << \"&amp;\"; break;\n\n            case '>':\n                // See: http://www.w3.org/TR/xml/#syntax\n                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')\n                    os << \"&gt;\";\n                else\n                    os << c;\n                break;\n\n            case '\\\"':\n                if (m_forWhat == ForAttributes)\n                    os << \"&quot;\";\n                else\n                    os << c;\n                break;\n\n            default:\n                // Check for control characters and invalid utf-8\n\n                // Escape control characters in standard ascii\n                // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0\n                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                // Plain ASCII: Write it to stream\n                if (c < 0x7F) {\n                    os << c;\n                    break;\n                }\n\n                // UTF-8 territory\n                // Check if the encoding is valid and if it is not, hex escape bytes.\n                // Important: We do not check the exact decoded values for validity, only the encoding format\n                // First check that this bytes is a valid lead byte:\n                // This means that it is not encoded as 1111 1XXX\n                // Or as 10XX XXXX\n                if (c <  0xC0 ||\n                    c >= 0xF8) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                auto encBytes = trailingBytes(c);\n                // Are there enough bytes left to avoid accessing out-of-bounds memory?\n                if (idx + encBytes - 1 >= m_str.size()) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n                // The header is valid, check data\n                // The next encBytes bytes must together be a valid utf-8\n                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)\n                bool valid = true;\n                uint32_t value = headerValue(c);\n                for (std::size_t n = 1; n < encBytes; ++n) {\n                    uchar nc = m_str[idx + n];\n                    valid &= ((nc & 0xC0) == 0x80);\n                    value = (value << 6) | (nc & 0x3F);\n                }\n\n                if (\n                    // Wrong bit pattern of following bytes\n                    (!valid) ||\n                    // Overlong encodings\n                    (value < 0x80) ||\n                    (0x80 <= value && value < 0x800   && encBytes > 2) ||\n                    (0x800 < value && value < 0x10000 && encBytes > 3) ||\n                    // Encoded value out of range\n                    (value >= 0x110000)\n                    ) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                // If we got here, this is in fact a valid(ish) utf-8 sequence\n                for (std::size_t n = 0; n < encBytes; ++n) {\n                    os << m_str[idx + n];\n                }\n                idx += encBytes - 1;\n                break;\n            }\n        }\n    }\n"
    },
    {
        "begin_line": 11106,
        "end_line": 11109,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {\n        xmlEncode.encodeTo( os );\n        return os;\n    }\n"
    },
    {
        "begin_line": 11111,
        "end_line": 11113,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ScopedElement",
        "snippet": "    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )\n    :   m_writer( writer )\n    {}\n"
    },
    {
        "begin_line": 11115,
        "end_line": 11118,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ScopedElement",
        "snippet": "    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept\n    :   m_writer( other.m_writer ){\n        other.m_writer = nullptr;\n    }\n"
    },
    {
        "begin_line": 11119,
        "end_line": 11126,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator =",
        "snippet": "    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) noexcept {\n        if ( m_writer ) {\n            m_writer->endElement();\n        }\n        m_writer = other.m_writer;\n        other.m_writer = nullptr;\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11128,
        "end_line": 11131,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~ScopedElement",
        "snippet": "    XmlWriter::ScopedElement::~ScopedElement() {\n        if( m_writer )\n            m_writer->endElement();\n    }\n"
    },
    {
        "begin_line": 11133,
        "end_line": 11136,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeText",
        "snippet": "    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, bool indent ) {\n        m_writer->writeText( text, indent );\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11138,
        "end_line": 11141,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "XmlWriter",
        "snippet": "    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )\n    {\n        writeDeclaration();\n    }\n"
    },
    {
        "begin_line": 11143,
        "end_line": 11146,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~XmlWriter",
        "snippet": "    XmlWriter::~XmlWriter() {\n        while( !m_tags.empty() )\n            endElement();\n    }\n"
    },
    {
        "begin_line": 11148,
        "end_line": 11156,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "startElement",
        "snippet": "    XmlWriter& XmlWriter::startElement( std::string const& name ) {\n        ensureTagClosed();\n        newlineIfNecessary();\n        m_os << m_indent << '<' << name;\n        m_tags.push_back( name );\n        m_indent += \"  \";\n        m_tagIsOpen = true;\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11158,
        "end_line": 11162,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "scopedElement",
        "snippet": "    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name ) {\n        ScopedElement scoped( this );\n        startElement( name );\n        return scoped;\n    }\n"
    },
    {
        "begin_line": 11164,
        "end_line": 11177,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "endElement",
        "snippet": "    XmlWriter& XmlWriter::endElement() {\n        newlineIfNecessary();\n        m_indent = m_indent.substr( 0, m_indent.size()-2 );\n        if( m_tagIsOpen ) {\n            m_os << \"/>\";\n            m_tagIsOpen = false;\n        }\n        else {\n            m_os << m_indent << \"</\" << m_tags.back() << \">\";\n        }\n        m_os << std::endl;\n        m_tags.pop_back();\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11179,
        "end_line": 11183,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeAttribute",
        "snippet": "    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {\n        if( !name.empty() && !attribute.empty() )\n            m_os << ' ' << name << \"=\\\"\" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '\"';\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11185,
        "end_line": 11188,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeAttribute",
        "snippet": "    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {\n        m_os << ' ' << name << \"=\\\"\" << ( attribute ? \"true\" : \"false\" ) << '\"';\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11190,
        "end_line": 11200,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeText",
        "snippet": "    XmlWriter& XmlWriter::writeText( std::string const& text, bool indent ) {\n        if( !text.empty() ){\n            bool tagWasOpen = m_tagIsOpen;\n            ensureTagClosed();\n            if( tagWasOpen && indent )\n                m_os << m_indent;\n            m_os << XmlEncode( text );\n            m_needsNewline = true;\n        }\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11202,
        "end_line": 11207,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeComment",
        "snippet": "    XmlWriter& XmlWriter::writeComment( std::string const& text ) {\n        ensureTagClosed();\n        m_os << m_indent << \"<!--\" << text << \"-->\";\n        m_needsNewline = true;\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11209,
        "end_line": 11211,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeStylesheetRef",
        "snippet": "    void XmlWriter::writeStylesheetRef( std::string const& url ) {\n        m_os << \"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\" << url << \"\\\"?>\\n\";\n    }\n"
    },
    {
        "begin_line": 11213,
        "end_line": 11217,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeBlankLine",
        "snippet": "    XmlWriter& XmlWriter::writeBlankLine() {\n        ensureTagClosed();\n        m_os << '\\n';\n        return *this;\n    }\n"
    },
    {
        "begin_line": 11219,
        "end_line": 11224,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ensureTagClosed",
        "snippet": "    void XmlWriter::ensureTagClosed() {\n        if( m_tagIsOpen ) {\n            m_os << \">\" << std::endl;\n            m_tagIsOpen = false;\n        }\n    }\n"
    },
    {
        "begin_line": 11226,
        "end_line": 11228,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeDeclaration",
        "snippet": "    void XmlWriter::writeDeclaration() {\n        m_os << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n    }\n"
    },
    {
        "begin_line": 11230,
        "end_line": 11235,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "newlineIfNecessary",
        "snippet": "    void XmlWriter::newlineIfNecessary() {\n        if( m_needsNewline ) {\n            m_os << std::endl;\n            m_needsNewline = false;\n        }\n    }\n"
    },
    {
        "begin_line": 11246,
        "end_line": 11280,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    void prepareExpandedExpression(AssertionResult& result) {\n        result.getExpandedExpression();\n    }\n\n    // Because formatting using c++ streams is stateful, drop down to C is required\n    // Alternatively we could use stringstream, but its performance is... not good.\n    std::string getFormattedDuration( double duration ) {\n        // Max exponent + 1 is required to represent the whole part\n        // + 1 for decimal point\n        // + 3 for the 3 decimal places\n        // + 1 for null terminator\n        const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\n        char buffer[maxDoubleSize];\n\n        // Save previous errno, to prevent sprintf from overwriting it\n        ErrnoGuard guard;\n#ifdef _MSC_VER\n        sprintf_s(buffer, \"%.3f\", duration);\n#else\n        sprintf(buffer, \"%.3f\", duration);\n#endif\n        return std::string(buffer);\n    }\n\n    TestEventListenerBase::TestEventListenerBase(ReporterConfig const & _config)\n        :StreamingReporterBase(_config) {}\n\n    void TestEventListenerBase::assertionStarting(AssertionInfo const &) {}\n\n    bool TestEventListenerBase::assertionEnded(AssertionStats const &) {\n        return false;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 11247,
        "end_line": 11249,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "prepareExpandedExpression",
        "snippet": "    void prepareExpandedExpression(AssertionResult& result) {\n        result.getExpandedExpression();\n    }\n"
    },
    {
        "begin_line": 11253,
        "end_line": 11269,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getFormattedDuration",
        "snippet": "    std::string getFormattedDuration( double duration ) {\n        // Max exponent + 1 is required to represent the whole part\n        // + 1 for decimal point\n        // + 3 for the 3 decimal places\n        // + 1 for null terminator\n        const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\n        char buffer[maxDoubleSize];\n\n        // Save previous errno, to prevent sprintf from overwriting it\n        ErrnoGuard guard;\n#ifdef _MSC_VER\n        sprintf_s(buffer, \"%.3f\", duration);\n#else\n        sprintf(buffer, \"%.3f\", duration);\n#endif\n        return std::string(buffer);\n    }\n"
    },
    {
        "begin_line": 11271,
        "end_line": 11272,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TestEventListenerBase",
        "snippet": "    TestEventListenerBase::TestEventListenerBase(ReporterConfig const & _config)\n        :StreamingReporterBase(_config) {}\n"
    },
    {
        "begin_line": 11274,
        "end_line": 11274,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionStarting",
        "snippet": "    void TestEventListenerBase::assertionStarting(AssertionInfo const &) {}\n"
    },
    {
        "begin_line": 11276,
        "end_line": 11278,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "    bool TestEventListenerBase::assertionEnded(AssertionStats const &) {\n        return false;\n    }\n"
    },
    {
        "begin_line": 11284,
        "end_line": 11302,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1b11",
        "snippet": "namespace {\n\n#ifdef CATCH_PLATFORM_MAC\n    const char* failedString() { return \"FAILED\"; }\n    const char* passedString() { return \"PASSED\"; }\n#else\n    const char* failedString() { return \"failed\"; }\n    const char* passedString() { return \"passed\"; }\n#endif\n\n    // Colour::LightGrey\n    Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }\n\n    std::string bothOrAll( std::size_t count ) {\n        return count == 1 ? std::string() :\n               count == 2 ? \"both \" : \"all \" ;\n    }\n\n} // anon namespace\n"
    },
    {
        "begin_line": 11287,
        "end_line": 11287,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "failedString",
        "snippet": "    const char* failedString() { return \"FAILED\"; }\n"
    },
    {
        "begin_line": 11288,
        "end_line": 11288,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "passedString",
        "snippet": "    const char* passedString() { return \"PASSED\"; }\n"
    },
    {
        "begin_line": 11295,
        "end_line": 11295,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "dimColour",
        "snippet": "    Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }\n"
    },
    {
        "begin_line": 11297,
        "end_line": 11300,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "bothOrAll",
        "snippet": "    std::string bothOrAll( std::size_t count ) {\n        return count == 1 ? std::string() :\n               count == 2 ? \"both \" : \"all \" ;\n    }\n"
    },
    {
        "begin_line": 11304,
        "end_line": 11564,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\nnamespace {\n// Colour, message variants:\n// - white: No tests ran.\n// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.\n// - white: Passed [both/all] N test cases (no assertions).\n// -   red: Failed N tests cases, failed M assertions.\n// - green: Passed [both/all] N tests cases with M assertions.\nvoid printTotals(std::ostream& out, const Totals& totals) {\n    if (totals.testCases.total() == 0) {\n        out << \"No tests ran.\";\n    } else if (totals.testCases.failed == totals.testCases.total()) {\n        Colour colour(Colour::ResultError);\n        const std::string qualify_assertions_failed =\n            totals.assertions.failed == totals.assertions.total() ?\n            bothOrAll(totals.assertions.failed) : std::string();\n        out <<\n            \"Failed \" << bothOrAll(totals.testCases.failed)\n            << pluralise(totals.testCases.failed, \"test case\") << \", \"\n            \"failed \" << qualify_assertions_failed <<\n            pluralise(totals.assertions.failed, \"assertion\") << '.';\n    } else if (totals.assertions.total() == 0) {\n        out <<\n            \"Passed \" << bothOrAll(totals.testCases.total())\n            << pluralise(totals.testCases.total(), \"test case\")\n            << \" (no assertions).\";\n    } else if (totals.assertions.failed) {\n        Colour colour(Colour::ResultError);\n        out <<\n            \"Failed \" << pluralise(totals.testCases.failed, \"test case\") << \", \"\n            \"failed \" << pluralise(totals.assertions.failed, \"assertion\") << '.';\n    } else {\n        Colour colour(Colour::ResultSuccess);\n        out <<\n            \"Passed \" << bothOrAll(totals.testCases.passed)\n            << pluralise(totals.testCases.passed, \"test case\") <<\n            \" with \" << pluralise(totals.assertions.passed, \"assertion\") << '.';\n    }\n}\n\n// Implementation of CompactReporter formatting\nclass AssertionPrinter {\npublic:\n    AssertionPrinter& operator= (AssertionPrinter const&) = delete;\n    AssertionPrinter(AssertionPrinter const&) = delete;\n    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream)\n        , result(_stats.assertionResult)\n        , messages(_stats.infoMessages)\n        , itMessage(_stats.infoMessages.begin())\n        , printInfoMessages(_printInfoMessages) {}\n\n    void print() {\n        printSourceInfo();\n\n        itMessage = messages.begin();\n\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            printResultType(Colour::ResultSuccess, passedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            if (!result.hasExpression())\n                printRemainingMessages(Colour::None);\n            else\n                printRemainingMessages();\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk())\n                printResultType(Colour::ResultSuccess, failedString() + std::string(\" - but was ok\"));\n            else\n                printResultType(Colour::Error, failedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            printRemainingMessages();\n            break;\n        case ResultWas::ThrewException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"unexpected exception with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::FatalErrorCondition:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"fatal error condition with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::DidntThrowException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"expected exception, got none\");\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::Info:\n            printResultType(Colour::None, \"info\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::Warning:\n            printResultType(Colour::None, \"warning\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::ExplicitFailure:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"explicitly\");\n            printRemainingMessages(Colour::None);\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            printResultType(Colour::Error, \"** internal error **\");\n            break;\n        }\n    }\n\nprivate:\n    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << ':';\n    }\n\n    void printResultType(Colour::Code colour, std::string const& passOrFail) const {\n        if (!passOrFail.empty()) {\n            {\n                Colour colourGuard(colour);\n                stream << ' ' << passOrFail;\n            }\n            stream << ':';\n        }\n    }\n\n    void printIssue(std::string const& issue) const {\n        stream << ' ' << issue;\n    }\n\n    void printExpressionWas() {\n        if (result.hasExpression()) {\n            stream << ';';\n            {\n                Colour colour(dimColour());\n                stream << \" expression was:\";\n            }\n            printOriginalExpression();\n        }\n    }\n\n    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            stream << ' ' << result.getExpression();\n        }\n    }\n\n    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            {\n                Colour colour(dimColour());\n                stream << \" for: \";\n            }\n            stream << result.getExpandedExpression();\n        }\n    }\n\n    void printMessage() {\n        if (itMessage != messages.end()) {\n            stream << \" '\" << itMessage->message << '\\'';\n            ++itMessage;\n        }\n    }\n\n    void printRemainingMessages(Colour::Code colour = dimColour()) {\n        if (itMessage == messages.end())\n            return;\n\n        // using messages.end() directly yields (or auto) compilation error:\n        std::vector<MessageInfo>::const_iterator itEnd = messages.end();\n        const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));\n\n        {\n            Colour colourGuard(colour);\n            stream << \" with \" << pluralise(N, \"message\") << ':';\n        }\n\n        for (; itMessage != itEnd; ) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || itMessage->type != ResultWas::Info) {\n                stream << \" '\" << itMessage->message << '\\'';\n                if (++itMessage != itEnd) {\n                    Colour colourGuard(dimColour());\n                    stream << \" and\";\n                }\n            }\n        }\n    }\n\nprivate:\n    std::ostream& stream;\n    AssertionResult const& result;\n    std::vector<MessageInfo> messages;\n    std::vector<MessageInfo>::const_iterator itMessage;\n    bool printInfoMessages;\n};\n\n} // anon namespace\n\n        std::string CompactReporter::getDescription() {\n            return \"Reports test results on a single line, suitable for IDEs\";\n        }\n\n        ReporterPreferences CompactReporter::getPreferences() const {\n            ReporterPreferences prefs;\n            prefs.shouldRedirectStdOut = false;\n            return prefs;\n        }\n\n        void CompactReporter::noMatchingTestCases( std::string const& spec ) {\n            stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n        }\n\n        void CompactReporter::assertionStarting( AssertionInfo const& ) {}\n\n        bool CompactReporter::assertionEnded( AssertionStats const& _assertionStats ) {\n            AssertionResult const& result = _assertionStats.assertionResult;\n\n            bool printInfoMessages = true;\n\n            // Drop out if result was successful and we're not printing those\n            if( !m_config->includeSuccessfulResults() && result.isOk() ) {\n                if( result.getResultType() != ResultWas::Warning )\n                    return false;\n                printInfoMessages = false;\n            }\n\n            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );\n            printer.print();\n\n            stream << std::endl;\n            return true;\n        }\n\n        void CompactReporter::sectionEnded(SectionStats const& _sectionStats) {\n            if (m_config->showDurations() == ShowDurations::Always) {\n                stream << getFormattedDuration(_sectionStats.durationInSeconds) << \" s: \" << _sectionStats.sectionInfo.name << std::endl;\n            }\n        }\n\n        void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {\n            printTotals( stream, _testRunStats.totals );\n            stream << '\\n' << std::endl;\n            StreamingReporterBase::testRunEnded( _testRunStats );\n        }\n\n        CompactReporter::~CompactReporter() {}\n\n    CATCH_REGISTER_REPORTER( \"compact\", CompactReporter )\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 11305,
        "end_line": 11511,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1c11",
        "snippet": "namespace {\n// Colour, message variants:\n// - white: No tests ran.\n// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.\n// - white: Passed [both/all] N test cases (no assertions).\n// -   red: Failed N tests cases, failed M assertions.\n// - green: Passed [both/all] N tests cases with M assertions.\nvoid printTotals(std::ostream& out, const Totals& totals) {\n    if (totals.testCases.total() == 0) {\n        out << \"No tests ran.\";\n    } else if (totals.testCases.failed == totals.testCases.total()) {\n        Colour colour(Colour::ResultError);\n        const std::string qualify_assertions_failed =\n            totals.assertions.failed == totals.assertions.total() ?\n            bothOrAll(totals.assertions.failed) : std::string();\n        out <<\n            \"Failed \" << bothOrAll(totals.testCases.failed)\n            << pluralise(totals.testCases.failed, \"test case\") << \", \"\n            \"failed \" << qualify_assertions_failed <<\n            pluralise(totals.assertions.failed, \"assertion\") << '.';\n    } else if (totals.assertions.total() == 0) {\n        out <<\n            \"Passed \" << bothOrAll(totals.testCases.total())\n            << pluralise(totals.testCases.total(), \"test case\")\n            << \" (no assertions).\";\n    } else if (totals.assertions.failed) {\n        Colour colour(Colour::ResultError);\n        out <<\n            \"Failed \" << pluralise(totals.testCases.failed, \"test case\") << \", \"\n            \"failed \" << pluralise(totals.assertions.failed, \"assertion\") << '.';\n    } else {\n        Colour colour(Colour::ResultSuccess);\n        out <<\n            \"Passed \" << bothOrAll(totals.testCases.passed)\n            << pluralise(totals.testCases.passed, \"test case\") <<\n            \" with \" << pluralise(totals.assertions.passed, \"assertion\") << '.';\n    }\n}\n\n// Implementation of CompactReporter formatting\nclass AssertionPrinter {\npublic:\n    AssertionPrinter& operator= (AssertionPrinter const&) = delete;\n    AssertionPrinter(AssertionPrinter const&) = delete;\n    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream)\n        , result(_stats.assertionResult)\n        , messages(_stats.infoMessages)\n        , itMessage(_stats.infoMessages.begin())\n        , printInfoMessages(_printInfoMessages) {}\n\n    void print() {\n        printSourceInfo();\n\n        itMessage = messages.begin();\n\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            printResultType(Colour::ResultSuccess, passedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            if (!result.hasExpression())\n                printRemainingMessages(Colour::None);\n            else\n                printRemainingMessages();\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk())\n                printResultType(Colour::ResultSuccess, failedString() + std::string(\" - but was ok\"));\n            else\n                printResultType(Colour::Error, failedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            printRemainingMessages();\n            break;\n        case ResultWas::ThrewException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"unexpected exception with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::FatalErrorCondition:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"fatal error condition with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::DidntThrowException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"expected exception, got none\");\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::Info:\n            printResultType(Colour::None, \"info\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::Warning:\n            printResultType(Colour::None, \"warning\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::ExplicitFailure:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"explicitly\");\n            printRemainingMessages(Colour::None);\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            printResultType(Colour::Error, \"** internal error **\");\n            break;\n        }\n    }\n\nprivate:\n    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << ':';\n    }\n\n    void printResultType(Colour::Code colour, std::string const& passOrFail) const {\n        if (!passOrFail.empty()) {\n            {\n                Colour colourGuard(colour);\n                stream << ' ' << passOrFail;\n            }\n            stream << ':';\n        }\n    }\n\n    void printIssue(std::string const& issue) const {\n        stream << ' ' << issue;\n    }\n\n    void printExpressionWas() {\n        if (result.hasExpression()) {\n            stream << ';';\n            {\n                Colour colour(dimColour());\n                stream << \" expression was:\";\n            }\n            printOriginalExpression();\n        }\n    }\n\n    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            stream << ' ' << result.getExpression();\n        }\n    }\n\n    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            {\n                Colour colour(dimColour());\n                stream << \" for: \";\n            }\n            stream << result.getExpandedExpression();\n        }\n    }\n\n    void printMessage() {\n        if (itMessage != messages.end()) {\n            stream << \" '\" << itMessage->message << '\\'';\n            ++itMessage;\n        }\n    }\n\n    void printRemainingMessages(Colour::Code colour = dimColour()) {\n        if (itMessage == messages.end())\n            return;\n\n        // using messages.end() directly yields (or auto) compilation error:\n        std::vector<MessageInfo>::const_iterator itEnd = messages.end();\n        const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));\n\n        {\n            Colour colourGuard(colour);\n            stream << \" with \" << pluralise(N, \"message\") << ':';\n        }\n\n        for (; itMessage != itEnd; ) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || itMessage->type != ResultWas::Info) {\n                stream << \" '\" << itMessage->message << '\\'';\n                if (++itMessage != itEnd) {\n                    Colour colourGuard(dimColour());\n                    stream << \" and\";\n                }\n            }\n        }\n    }\n\nprivate:\n    std::ostream& stream;\n    AssertionResult const& result;\n    std::vector<MessageInfo> messages;\n    std::vector<MessageInfo>::const_iterator itMessage;\n    bool printInfoMessages;\n};\n\n} // anon namespace\n"
    },
    {
        "begin_line": 11312,
        "end_line": 11342,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printTotals",
        "snippet": "void printTotals(std::ostream& out, const Totals& totals) {\n    if (totals.testCases.total() == 0) {\n        out << \"No tests ran.\";\n    } else if (totals.testCases.failed == totals.testCases.total()) {\n        Colour colour(Colour::ResultError);\n        const std::string qualify_assertions_failed =\n            totals.assertions.failed == totals.assertions.total() ?\n            bothOrAll(totals.assertions.failed) : std::string();\n        out <<\n            \"Failed \" << bothOrAll(totals.testCases.failed)\n            << pluralise(totals.testCases.failed, \"test case\") << \", \"\n            \"failed \" << qualify_assertions_failed <<\n            pluralise(totals.assertions.failed, \"assertion\") << '.';\n    } else if (totals.assertions.total() == 0) {\n        out <<\n            \"Passed \" << bothOrAll(totals.testCases.total())\n            << pluralise(totals.testCases.total(), \"test case\")\n            << \" (no assertions).\";\n    } else if (totals.assertions.failed) {\n        Colour colour(Colour::ResultError);\n        out <<\n            \"Failed \" << pluralise(totals.testCases.failed, \"test case\") << \", \"\n            \"failed \" << pluralise(totals.assertions.failed, \"assertion\") << '.';\n    } else {\n        Colour colour(Colour::ResultSuccess);\n        out <<\n            \"Passed \" << bothOrAll(totals.testCases.passed)\n            << pluralise(totals.testCases.passed, \"test case\") <<\n            \" with \" << pluralise(totals.assertions.passed, \"assertion\") << '.';\n    }\n}\n"
    },
    {
        "begin_line": 11345,
        "end_line": 11509,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionPrinter",
        "snippet": "class AssertionPrinter {\npublic:\n    AssertionPrinter& operator= (AssertionPrinter const&) = delete;\n    AssertionPrinter(AssertionPrinter const&) = delete;\n    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream)\n        , result(_stats.assertionResult)\n        , messages(_stats.infoMessages)\n        , itMessage(_stats.infoMessages.begin())\n        , printInfoMessages(_printInfoMessages) {}\n\n    void print() {\n        printSourceInfo();\n\n        itMessage = messages.begin();\n\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            printResultType(Colour::ResultSuccess, passedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            if (!result.hasExpression())\n                printRemainingMessages(Colour::None);\n            else\n                printRemainingMessages();\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk())\n                printResultType(Colour::ResultSuccess, failedString() + std::string(\" - but was ok\"));\n            else\n                printResultType(Colour::Error, failedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            printRemainingMessages();\n            break;\n        case ResultWas::ThrewException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"unexpected exception with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::FatalErrorCondition:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"fatal error condition with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::DidntThrowException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"expected exception, got none\");\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::Info:\n            printResultType(Colour::None, \"info\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::Warning:\n            printResultType(Colour::None, \"warning\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::ExplicitFailure:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"explicitly\");\n            printRemainingMessages(Colour::None);\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            printResultType(Colour::Error, \"** internal error **\");\n            break;\n        }\n    }\n\nprivate:\n    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << ':';\n    }\n\n    void printResultType(Colour::Code colour, std::string const& passOrFail) const {\n        if (!passOrFail.empty()) {\n            {\n                Colour colourGuard(colour);\n                stream << ' ' << passOrFail;\n            }\n            stream << ':';\n        }\n    }\n\n    void printIssue(std::string const& issue) const {\n        stream << ' ' << issue;\n    }\n\n    void printExpressionWas() {\n        if (result.hasExpression()) {\n            stream << ';';\n            {\n                Colour colour(dimColour());\n                stream << \" expression was:\";\n            }\n            printOriginalExpression();\n        }\n    }\n\n    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            stream << ' ' << result.getExpression();\n        }\n    }\n\n    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            {\n                Colour colour(dimColour());\n                stream << \" for: \";\n            }\n            stream << result.getExpandedExpression();\n        }\n    }\n\n    void printMessage() {\n        if (itMessage != messages.end()) {\n            stream << \" '\" << itMessage->message << '\\'';\n            ++itMessage;\n        }\n    }\n\n    void printRemainingMessages(Colour::Code colour = dimColour()) {\n        if (itMessage == messages.end())\n            return;\n\n        // using messages.end() directly yields (or auto) compilation error:\n        std::vector<MessageInfo>::const_iterator itEnd = messages.end();\n        const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));\n\n        {\n            Colour colourGuard(colour);\n            stream << \" with \" << pluralise(N, \"message\") << ':';\n        }\n\n        for (; itMessage != itEnd; ) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || itMessage->type != ResultWas::Info) {\n                stream << \" '\" << itMessage->message << '\\'';\n                if (++itMessage != itEnd) {\n                    Colour colourGuard(dimColour());\n                    stream << \" and\";\n                }\n            }\n        }\n    }\n\nprivate:\n    std::ostream& stream;\n    AssertionResult const& result;\n    std::vector<MessageInfo> messages;\n    std::vector<MessageInfo>::const_iterator itMessage;\n    bool printInfoMessages;\n};\n"
    },
    {
        "begin_line": 11349,
        "end_line": 11354,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AssertionPrinter",
        "snippet": "    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream)\n        , result(_stats.assertionResult)\n        , messages(_stats.infoMessages)\n        , itMessage(_stats.infoMessages.begin())\n        , printInfoMessages(_printInfoMessages) {}\n"
    },
    {
        "begin_line": 11356,
        "end_line": 11422,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "print",
        "snippet": "    void print() {\n        printSourceInfo();\n\n        itMessage = messages.begin();\n\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            printResultType(Colour::ResultSuccess, passedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            if (!result.hasExpression())\n                printRemainingMessages(Colour::None);\n            else\n                printRemainingMessages();\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk())\n                printResultType(Colour::ResultSuccess, failedString() + std::string(\" - but was ok\"));\n            else\n                printResultType(Colour::Error, failedString());\n            printOriginalExpression();\n            printReconstructedExpression();\n            printRemainingMessages();\n            break;\n        case ResultWas::ThrewException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"unexpected exception with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::FatalErrorCondition:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"fatal error condition with message:\");\n            printMessage();\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::DidntThrowException:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"expected exception, got none\");\n            printExpressionWas();\n            printRemainingMessages();\n            break;\n        case ResultWas::Info:\n            printResultType(Colour::None, \"info\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::Warning:\n            printResultType(Colour::None, \"warning\");\n            printMessage();\n            printRemainingMessages();\n            break;\n        case ResultWas::ExplicitFailure:\n            printResultType(Colour::Error, failedString());\n            printIssue(\"explicitly\");\n            printRemainingMessages(Colour::None);\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            printResultType(Colour::Error, \"** internal error **\");\n            break;\n        }\n    }\n"
    },
    {
        "begin_line": 11425,
        "end_line": 11428,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printSourceInfo",
        "snippet": "    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << ':';\n    }\n"
    },
    {
        "begin_line": 11430,
        "end_line": 11438,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printResultType",
        "snippet": "    void printResultType(Colour::Code colour, std::string const& passOrFail) const {\n        if (!passOrFail.empty()) {\n            {\n                Colour colourGuard(colour);\n                stream << ' ' << passOrFail;\n            }\n            stream << ':';\n        }\n    }\n"
    },
    {
        "begin_line": 11440,
        "end_line": 11442,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printIssue",
        "snippet": "    void printIssue(std::string const& issue) const {\n        stream << ' ' << issue;\n    }\n"
    },
    {
        "begin_line": 11444,
        "end_line": 11453,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printExpressionWas",
        "snippet": "    void printExpressionWas() {\n        if (result.hasExpression()) {\n            stream << ';';\n            {\n                Colour colour(dimColour());\n                stream << \" expression was:\";\n            }\n            printOriginalExpression();\n        }\n    }\n"
    },
    {
        "begin_line": 11455,
        "end_line": 11459,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printOriginalExpression",
        "snippet": "    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            stream << ' ' << result.getExpression();\n        }\n    }\n"
    },
    {
        "begin_line": 11461,
        "end_line": 11469,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printReconstructedExpression",
        "snippet": "    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            {\n                Colour colour(dimColour());\n                stream << \" for: \";\n            }\n            stream << result.getExpandedExpression();\n        }\n    }\n"
    },
    {
        "begin_line": 11471,
        "end_line": 11476,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printMessage",
        "snippet": "    void printMessage() {\n        if (itMessage != messages.end()) {\n            stream << \" '\" << itMessage->message << '\\'';\n            ++itMessage;\n        }\n    }\n"
    },
    {
        "begin_line": 11478,
        "end_line": 11501,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printRemainingMessages",
        "snippet": "    void printRemainingMessages(Colour::Code colour = dimColour()) {\n        if (itMessage == messages.end())\n            return;\n\n        // using messages.end() directly yields (or auto) compilation error:\n        std::vector<MessageInfo>::const_iterator itEnd = messages.end();\n        const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));\n\n        {\n            Colour colourGuard(colour);\n            stream << \" with \" << pluralise(N, \"message\") << ':';\n        }\n\n        for (; itMessage != itEnd; ) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || itMessage->type != ResultWas::Info) {\n                stream << \" '\" << itMessage->message << '\\'';\n                if (++itMessage != itEnd) {\n                    Colour colourGuard(dimColour());\n                    stream << \" and\";\n                }\n            }\n        }\n    }\n"
    },
    {
        "begin_line": 11504,
        "end_line": 11504,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "    std::ostream& stream;\n"
    },
    {
        "begin_line": 11505,
        "end_line": 11505,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "result",
        "snippet": "    AssertionResult const& result;\n"
    },
    {
        "begin_line": 11506,
        "end_line": 11506,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "messages",
        "snippet": "    std::vector<MessageInfo> messages;\n"
    },
    {
        "begin_line": 11507,
        "end_line": 11507,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "itMessage",
        "snippet": "    std::vector<MessageInfo>::const_iterator itMessage;\n"
    },
    {
        "begin_line": 11508,
        "end_line": 11508,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printInfoMessages",
        "snippet": "    bool printInfoMessages;\n"
    },
    {
        "begin_line": 11513,
        "end_line": 11515,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getDescription",
        "snippet": "        std::string CompactReporter::getDescription() {\n            return \"Reports test results on a single line, suitable for IDEs\";\n        }\n"
    },
    {
        "begin_line": 11517,
        "end_line": 11521,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getPreferences",
        "snippet": "        ReporterPreferences CompactReporter::getPreferences() const {\n            ReporterPreferences prefs;\n            prefs.shouldRedirectStdOut = false;\n            return prefs;\n        }\n"
    },
    {
        "begin_line": 11523,
        "end_line": 11525,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "noMatchingTestCases",
        "snippet": "        void CompactReporter::noMatchingTestCases( std::string const& spec ) {\n            stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n        }\n"
    },
    {
        "begin_line": 11527,
        "end_line": 11527,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionStarting",
        "snippet": "        void CompactReporter::assertionStarting( AssertionInfo const& ) {}\n"
    },
    {
        "begin_line": 11529,
        "end_line": 11546,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "        bool CompactReporter::assertionEnded( AssertionStats const& _assertionStats ) {\n            AssertionResult const& result = _assertionStats.assertionResult;\n\n            bool printInfoMessages = true;\n\n            // Drop out if result was successful and we're not printing those\n            if( !m_config->includeSuccessfulResults() && result.isOk() ) {\n                if( result.getResultType() != ResultWas::Warning )\n                    return false;\n                printInfoMessages = false;\n            }\n\n            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );\n            printer.print();\n\n            stream << std::endl;\n            return true;\n        }\n"
    },
    {
        "begin_line": 11548,
        "end_line": 11552,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEnded",
        "snippet": "        void CompactReporter::sectionEnded(SectionStats const& _sectionStats) {\n            if (m_config->showDurations() == ShowDurations::Always) {\n                stream << getFormattedDuration(_sectionStats.durationInSeconds) << \" s: \" << _sectionStats.sectionInfo.name << std::endl;\n            }\n        }\n"
    },
    {
        "begin_line": 11554,
        "end_line": 11558,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunEnded",
        "snippet": "        void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {\n            printTotals( stream, _testRunStats.totals );\n            stream << '\\n' << std::endl;\n            StreamingReporterBase::testRunEnded( _testRunStats );\n        }\n"
    },
    {
        "begin_line": 11560,
        "end_line": 11560,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~CompactReporter",
        "snippet": "        CompactReporter::~CompactReporter() {}\n"
    },
    {
        "begin_line": 11578,
        "end_line": 12178,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\nnamespace {\n\n// Formatter impl for ConsoleReporter\nclass ConsoleAssertionPrinter {\npublic:\n    ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;\n    ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;\n    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream),\n        stats(_stats),\n        result(_stats.assertionResult),\n        colour(Colour::None),\n        message(result.getMessage()),\n        messages(_stats.infoMessages),\n        printInfoMessages(_printInfoMessages) {\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            colour = Colour::Success;\n            passOrFail = \"PASSED\";\n            //if( result.hasMessage() )\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk()) {\n                colour = Colour::Success;\n                passOrFail = \"FAILED - but was ok\";\n            } else {\n                colour = Colour::Error;\n                passOrFail = \"FAILED\";\n            }\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ThrewException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to unexpected exception with \";\n            if (_stats.infoMessages.size() == 1)\n                messageLabel += \"message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel += \"messages\";\n            break;\n        case ResultWas::FatalErrorCondition:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to a fatal error condition\";\n            break;\n        case ResultWas::DidntThrowException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"because no exception was thrown where one was expected\";\n            break;\n        case ResultWas::Info:\n            messageLabel = \"info\";\n            break;\n        case ResultWas::Warning:\n            messageLabel = \"warning\";\n            break;\n        case ResultWas::ExplicitFailure:\n            passOrFail = \"FAILED\";\n            colour = Colour::Error;\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"explicitly with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"explicitly with messages\";\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            passOrFail = \"** internal error **\";\n            colour = Colour::Error;\n            break;\n        }\n    }\n\n    void print() const {\n        printSourceInfo();\n        if (stats.totals.assertions.total() > 0) {\n            if (result.isOk())\n                stream << '\\n';\n            printResultType();\n            printOriginalExpression();\n            printReconstructedExpression();\n        } else {\n            stream << '\\n';\n        }\n        printMessage();\n    }\n\nprivate:\n    void printResultType() const {\n        if (!passOrFail.empty()) {\n            Colour colourGuard(colour);\n            stream << passOrFail << \":\\n\";\n        }\n    }\n    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            Colour colourGuard(Colour::OriginalExpression);\n            stream << \"  \";\n            stream << result.getExpressionInMacro();\n            stream << '\\n';\n        }\n    }\n    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            stream << \"with expansion:\\n\";\n            Colour colourGuard(Colour::ReconstructedExpression);\n            stream << Column(result.getExpandedExpression()).indent(2) << '\\n';\n        }\n    }\n    void printMessage() const {\n        if (!messageLabel.empty())\n            stream << messageLabel << ':' << '\\n';\n        for (auto const& msg : messages) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || msg.type != ResultWas::Info)\n                stream << Column(msg.message).indent(2) << '\\n';\n        }\n    }\n    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << \": \";\n    }\n\n    std::ostream& stream;\n    AssertionStats const& stats;\n    AssertionResult const& result;\n    Colour::Code colour;\n    std::string passOrFail;\n    std::string messageLabel;\n    std::string message;\n    std::vector<MessageInfo> messages;\n    bool printInfoMessages;\n};\n\nstd::size_t makeRatio(std::size_t number, std::size_t total) {\n    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;\n    return (ratio == 0 && number > 0) ? 1 : ratio;\n}\n\nstd::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {\n    if (i > j && i > k)\n        return i;\n    else if (j > k)\n        return j;\n    else\n        return k;\n}\n\nstruct ColumnInfo {\n    enum Justification { Left, Right };\n    std::string name;\n    int width;\n    Justification justification;\n};\nstruct ColumnBreak {};\nstruct RowBreak {};\n\nclass Duration {\n    enum class Unit {\n        Auto,\n        Nanoseconds,\n        Microseconds,\n        Milliseconds,\n        Seconds,\n        Minutes\n    };\n    static const uint64_t s_nanosecondsInAMicrosecond = 1000;\n    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;\n    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;\n    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;\n\n    uint64_t m_inNanoseconds;\n    Unit m_units;\n\npublic:\n    explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\n        : m_inNanoseconds(inNanoseconds),\n        m_units(units) {\n        if (m_units == Unit::Auto) {\n            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)\n                m_units = Unit::Nanoseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)\n                m_units = Unit::Microseconds;\n            else if (m_inNanoseconds < s_nanosecondsInASecond)\n                m_units = Unit::Milliseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMinute)\n                m_units = Unit::Seconds;\n            else\n                m_units = Unit::Minutes;\n        }\n\n    }\n\n    auto value() const -> double {\n        switch (m_units) {\n        case Unit::Microseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);\n        case Unit::Milliseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);\n        case Unit::Seconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);\n        case Unit::Minutes:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);\n        default:\n            return static_cast<double>(m_inNanoseconds);\n        }\n    }\n    auto unitsAsString() const -> std::string {\n        switch (m_units) {\n        case Unit::Nanoseconds:\n            return \"ns\";\n        case Unit::Microseconds:\n            return \"\u00b5s\";\n        case Unit::Milliseconds:\n            return \"ms\";\n        case Unit::Seconds:\n            return \"s\";\n        case Unit::Minutes:\n            return \"m\";\n        default:\n            return \"** internal error **\";\n        }\n\n    }\n    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {\n        return os << duration.value() << \" \" << duration.unitsAsString();\n    }\n};\n} // end anon namespace\n\nclass TablePrinter {\n    std::ostream& m_os;\n    std::vector<ColumnInfo> m_columnInfos;\n    std::ostringstream m_oss;\n    int m_currentColumn = -1;\n    bool m_isOpen = false;\n\npublic:\n    TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )\n    :   m_os( os ),\n        m_columnInfos( std::move( columnInfos ) ) {}\n\n    auto columnInfos() const -> std::vector<ColumnInfo> const& {\n        return m_columnInfos;\n    }\n\n    void open() {\n        if (!m_isOpen) {\n            m_isOpen = true;\n            *this << RowBreak();\n            for (auto const& info : m_columnInfos)\n                *this << info.name << ColumnBreak();\n            *this << RowBreak();\n            m_os << Catch::getLineOfChars<'-'>() << \"\\n\";\n        }\n    }\n    void close() {\n        if (m_isOpen) {\n            *this << RowBreak();\n            m_os << std::endl;\n            m_isOpen = false;\n        }\n    }\n\n    template<typename T>\n    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {\n        tp.m_oss << value;\n        return tp;\n    }\n\n    friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {\n        auto colStr = tp.m_oss.str();\n        // This takes account of utf8 encodings\n        auto strSize = Catch::StringRef(colStr).numberOfCharacters();\n        tp.m_oss.str(\"\");\n        tp.open();\n        if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {\n            tp.m_currentColumn = -1;\n            tp.m_os << \"\\n\";\n        }\n        tp.m_currentColumn++;\n\n        auto colInfo = tp.m_columnInfos[tp.m_currentColumn];\n        auto padding = (strSize + 2 < static_cast<std::size_t>(colInfo.width))\n            ? std::string(colInfo.width - (strSize + 2), ' ')\n            : std::string();\n        if (colInfo.justification == ColumnInfo::Left)\n            tp.m_os << colStr << padding << \" \";\n        else\n            tp.m_os << padding << colStr << \" \";\n        return tp;\n    }\n\n    friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {\n        if (tp.m_currentColumn > 0) {\n            tp.m_os << \"\\n\";\n            tp.m_currentColumn = -1;\n        }\n        return tp;\n    }\n};\n\nConsoleReporter::ConsoleReporter(ReporterConfig const& config)\n    : StreamingReporterBase(config),\n    m_tablePrinter(new TablePrinter(config.stream(),\n    {\n        { \"benchmark name\", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },\n        { \"iters\", 8, ColumnInfo::Right },\n        { \"elapsed ns\", 14, ColumnInfo::Right },\n        { \"average\", 14, ColumnInfo::Right }\n    })) {}\nConsoleReporter::~ConsoleReporter() = default;\n\nstd::string ConsoleReporter::getDescription() {\n    return \"Reports test results as plain lines of text\";\n}\n\nvoid ConsoleReporter::noMatchingTestCases(std::string const& spec) {\n    stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n}\n\nvoid ConsoleReporter::assertionStarting(AssertionInfo const&) {}\n\nbool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n    AssertionResult const& result = _assertionStats.assertionResult;\n\n    bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n\n    // Drop out if result was successful but we're not printing them.\n    if (!includeResults && result.getResultType() != ResultWas::Warning)\n        return false;\n\n    lazyPrint();\n\n    ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);\n    printer.print();\n    stream << std::endl;\n    return true;\n}\n\nvoid ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {\n    m_headerPrinted = false;\n    StreamingReporterBase::sectionStarting(_sectionInfo);\n}\nvoid ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {\n    m_tablePrinter->close();\n    if (_sectionStats.missingAssertions) {\n        lazyPrint();\n        Colour colour(Colour::ResultError);\n        if (m_sectionStack.size() > 1)\n            stream << \"\\nNo assertions in section\";\n        else\n            stream << \"\\nNo assertions in test case\";\n        stream << \" '\" << _sectionStats.sectionInfo.name << \"'\\n\" << std::endl;\n    }\n    if (m_config->showDurations() == ShowDurations::Always) {\n        stream << getFormattedDuration(_sectionStats.durationInSeconds) << \" s: \" << _sectionStats.sectionInfo.name << std::endl;\n    }\n    if (m_headerPrinted) {\n        m_headerPrinted = false;\n    }\n    StreamingReporterBase::sectionEnded(_sectionStats);\n}\n\nvoid ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n    lazyPrintWithoutClosingBenchmarkTable();\n\n    auto nameCol = Column( info.name ).width( static_cast<std::size_t>( m_tablePrinter->columnInfos()[0].width - 2 ) );\n\n    bool firstLine = true;\n    for (auto line : nameCol) {\n        if (!firstLine)\n            (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n        else\n            firstLine = false;\n\n        (*m_tablePrinter) << line << ColumnBreak();\n    }\n}\nvoid ConsoleReporter::benchmarkEnded(BenchmarkStats const& stats) {\n    Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);\n    (*m_tablePrinter)\n        << stats.iterations << ColumnBreak()\n        << stats.elapsedTimeInNanoseconds << ColumnBreak()\n        << average << ColumnBreak();\n}\n\nvoid ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n    m_tablePrinter->close();\n    StreamingReporterBase::testCaseEnded(_testCaseStats);\n    m_headerPrinted = false;\n}\nvoid ConsoleReporter::testGroupEnded(TestGroupStats const& _testGroupStats) {\n    if (currentGroupInfo.used) {\n        printSummaryDivider();\n        stream << \"Summary for group '\" << _testGroupStats.groupInfo.name << \"':\\n\";\n        printTotals(_testGroupStats.totals);\n        stream << '\\n' << std::endl;\n    }\n    StreamingReporterBase::testGroupEnded(_testGroupStats);\n}\nvoid ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {\n    printTotalsDivider(_testRunStats.totals);\n    printTotals(_testRunStats.totals);\n    stream << std::endl;\n    StreamingReporterBase::testRunEnded(_testRunStats);\n}\n\nvoid ConsoleReporter::lazyPrint() {\n\n    m_tablePrinter->close();\n    lazyPrintWithoutClosingBenchmarkTable();\n}\n\nvoid ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {\n\n    if (!currentTestRunInfo.used)\n        lazyPrintRunInfo();\n    if (!currentGroupInfo.used)\n        lazyPrintGroupInfo();\n\n    if (!m_headerPrinted) {\n        printTestCaseAndSectionHeader();\n        m_headerPrinted = true;\n    }\n}\nvoid ConsoleReporter::lazyPrintRunInfo() {\n    stream << '\\n' << getLineOfChars<'~'>() << '\\n';\n    Colour colour(Colour::SecondaryText);\n    stream << currentTestRunInfo->name\n        << \" is a Catch v\" << libraryVersion() << \" host application.\\n\"\n        << \"Run with -? for options\\n\\n\";\n\n    if (m_config->rngSeed() != 0)\n        stream << \"Randomness seeded to: \" << m_config->rngSeed() << \"\\n\\n\";\n\n    currentTestRunInfo.used = true;\n}\nvoid ConsoleReporter::lazyPrintGroupInfo() {\n    if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {\n        printClosedHeader(\"Group: \" + currentGroupInfo->name);\n        currentGroupInfo.used = true;\n    }\n}\nvoid ConsoleReporter::printTestCaseAndSectionHeader() {\n    assert(!m_sectionStack.empty());\n    printOpenHeader(currentTestCaseInfo->name);\n\n    if (m_sectionStack.size() > 1) {\n        Colour colourGuard(Colour::Headers);\n\n        auto\n            it = m_sectionStack.begin() + 1, // Skip first section (test case)\n            itEnd = m_sectionStack.end();\n        for (; it != itEnd; ++it)\n            printHeaderString(it->name, 2);\n    }\n\n    SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;\n\n    if (!lineInfo.empty()) {\n        stream << getLineOfChars<'-'>() << '\\n';\n        Colour colourGuard(Colour::FileName);\n        stream << lineInfo << '\\n';\n    }\n    stream << getLineOfChars<'.'>() << '\\n' << std::endl;\n}\n\nvoid ConsoleReporter::printClosedHeader(std::string const& _name) {\n    printOpenHeader(_name);\n    stream << getLineOfChars<'.'>() << '\\n';\n}\nvoid ConsoleReporter::printOpenHeader(std::string const& _name) {\n    stream << getLineOfChars<'-'>() << '\\n';\n    {\n        Colour colourGuard(Colour::Headers);\n        printHeaderString(_name);\n    }\n}\n\n// if string has a : in first line will set indent to follow it on\n// subsequent lines\nvoid ConsoleReporter::printHeaderString(std::string const& _string, std::size_t indent) {\n    std::size_t i = _string.find(\": \");\n    if (i != std::string::npos)\n        i += 2;\n    else\n        i = 0;\n    stream << Column(_string).indent(indent + i).initialIndent(indent) << '\\n';\n}\n\nstruct SummaryColumn {\n\n    SummaryColumn( std::string _label, Colour::Code _colour )\n    :   label( std::move( _label ) ),\n        colour( _colour ) {}\n    SummaryColumn addRow( std::size_t count ) {\n        ReusableStringStream rss;\n        rss << count;\n        std::string row = rss.str();\n        for (auto& oldRow : rows) {\n            while (oldRow.size() < row.size())\n                oldRow = ' ' + oldRow;\n            while (oldRow.size() > row.size())\n                row = ' ' + row;\n        }\n        rows.push_back(row);\n        return *this;\n    }\n\n    std::string label;\n    Colour::Code colour;\n    std::vector<std::string> rows;\n\n};\n\nvoid ConsoleReporter::printTotals( Totals const& totals ) {\n    if (totals.testCases.total() == 0) {\n        stream << Colour(Colour::Warning) << \"No tests ran\\n\";\n    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {\n        stream << Colour(Colour::ResultSuccess) << \"All tests passed\";\n        stream << \" (\"\n            << pluralise(totals.assertions.passed, \"assertion\") << \" in \"\n            << pluralise(totals.testCases.passed, \"test case\") << ')'\n            << '\\n';\n    } else {\n\n        std::vector<SummaryColumn> columns;\n        columns.push_back(SummaryColumn(\"\", Colour::None)\n                          .addRow(totals.testCases.total())\n                          .addRow(totals.assertions.total()));\n        columns.push_back(SummaryColumn(\"passed\", Colour::Success)\n                          .addRow(totals.testCases.passed)\n                          .addRow(totals.assertions.passed));\n        columns.push_back(SummaryColumn(\"failed\", Colour::ResultError)\n                          .addRow(totals.testCases.failed)\n                          .addRow(totals.assertions.failed));\n        columns.push_back(SummaryColumn(\"failed as expected\", Colour::ResultExpectedFailure)\n                          .addRow(totals.testCases.failedButOk)\n                          .addRow(totals.assertions.failedButOk));\n\n        printSummaryRow(\"test cases\", columns, 0);\n        printSummaryRow(\"assertions\", columns, 1);\n    }\n}\nvoid ConsoleReporter::printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {\n    for (auto col : cols) {\n        std::string value = col.rows[row];\n        if (col.label.empty()) {\n            stream << label << \": \";\n            if (value != \"0\")\n                stream << value;\n            else\n                stream << Colour(Colour::Warning) << \"- none -\";\n        } else if (value != \"0\") {\n            stream << Colour(Colour::LightGrey) << \" | \";\n            stream << Colour(col.colour)\n                << value << ' ' << col.label;\n        }\n    }\n    stream << '\\n';\n}\n\nvoid ConsoleReporter::printTotalsDivider(Totals const& totals) {\n    if (totals.testCases.total() > 0) {\n        std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\n        std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());\n        std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());\n        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\n            findMax(failedRatio, failedButOkRatio, passedRatio)++;\n        while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)\n            findMax(failedRatio, failedButOkRatio, passedRatio)--;\n\n        stream << Colour(Colour::Error) << std::string(failedRatio, '=');\n        stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');\n        if (totals.testCases.allPassed())\n            stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');\n        else\n            stream << Colour(Colour::Success) << std::string(passedRatio, '=');\n    } else {\n        stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');\n    }\n    stream << '\\n';\n}\nvoid ConsoleReporter::printSummaryDivider() {\n    stream << getLineOfChars<'-'>() << '\\n';\n}\n\nCATCH_REGISTER_REPORTER(\"console\", ConsoleReporter)\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 11580,
        "end_line": 11816,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1d11",
        "snippet": "namespace {\n\n// Formatter impl for ConsoleReporter\nclass ConsoleAssertionPrinter {\npublic:\n    ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;\n    ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;\n    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream),\n        stats(_stats),\n        result(_stats.assertionResult),\n        colour(Colour::None),\n        message(result.getMessage()),\n        messages(_stats.infoMessages),\n        printInfoMessages(_printInfoMessages) {\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            colour = Colour::Success;\n            passOrFail = \"PASSED\";\n            //if( result.hasMessage() )\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk()) {\n                colour = Colour::Success;\n                passOrFail = \"FAILED - but was ok\";\n            } else {\n                colour = Colour::Error;\n                passOrFail = \"FAILED\";\n            }\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ThrewException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to unexpected exception with \";\n            if (_stats.infoMessages.size() == 1)\n                messageLabel += \"message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel += \"messages\";\n            break;\n        case ResultWas::FatalErrorCondition:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to a fatal error condition\";\n            break;\n        case ResultWas::DidntThrowException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"because no exception was thrown where one was expected\";\n            break;\n        case ResultWas::Info:\n            messageLabel = \"info\";\n            break;\n        case ResultWas::Warning:\n            messageLabel = \"warning\";\n            break;\n        case ResultWas::ExplicitFailure:\n            passOrFail = \"FAILED\";\n            colour = Colour::Error;\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"explicitly with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"explicitly with messages\";\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            passOrFail = \"** internal error **\";\n            colour = Colour::Error;\n            break;\n        }\n    }\n\n    void print() const {\n        printSourceInfo();\n        if (stats.totals.assertions.total() > 0) {\n            if (result.isOk())\n                stream << '\\n';\n            printResultType();\n            printOriginalExpression();\n            printReconstructedExpression();\n        } else {\n            stream << '\\n';\n        }\n        printMessage();\n    }\n\nprivate:\n    void printResultType() const {\n        if (!passOrFail.empty()) {\n            Colour colourGuard(colour);\n            stream << passOrFail << \":\\n\";\n        }\n    }\n    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            Colour colourGuard(Colour::OriginalExpression);\n            stream << \"  \";\n            stream << result.getExpressionInMacro();\n            stream << '\\n';\n        }\n    }\n    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            stream << \"with expansion:\\n\";\n            Colour colourGuard(Colour::ReconstructedExpression);\n            stream << Column(result.getExpandedExpression()).indent(2) << '\\n';\n        }\n    }\n    void printMessage() const {\n        if (!messageLabel.empty())\n            stream << messageLabel << ':' << '\\n';\n        for (auto const& msg : messages) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || msg.type != ResultWas::Info)\n                stream << Column(msg.message).indent(2) << '\\n';\n        }\n    }\n    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << \": \";\n    }\n\n    std::ostream& stream;\n    AssertionStats const& stats;\n    AssertionResult const& result;\n    Colour::Code colour;\n    std::string passOrFail;\n    std::string messageLabel;\n    std::string message;\n    std::vector<MessageInfo> messages;\n    bool printInfoMessages;\n};\n\nstd::size_t makeRatio(std::size_t number, std::size_t total) {\n    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;\n    return (ratio == 0 && number > 0) ? 1 : ratio;\n}\n\nstd::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {\n    if (i > j && i > k)\n        return i;\n    else if (j > k)\n        return j;\n    else\n        return k;\n}\n\nstruct ColumnInfo {\n    enum Justification { Left, Right };\n    std::string name;\n    int width;\n    Justification justification;\n};\nstruct ColumnBreak {};\nstruct RowBreak {};\n\nclass Duration {\n    enum class Unit {\n        Auto,\n        Nanoseconds,\n        Microseconds,\n        Milliseconds,\n        Seconds,\n        Minutes\n    };\n    static const uint64_t s_nanosecondsInAMicrosecond = 1000;\n    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;\n    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;\n    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;\n\n    uint64_t m_inNanoseconds;\n    Unit m_units;\n\npublic:\n    explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\n        : m_inNanoseconds(inNanoseconds),\n        m_units(units) {\n        if (m_units == Unit::Auto) {\n            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)\n                m_units = Unit::Nanoseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)\n                m_units = Unit::Microseconds;\n            else if (m_inNanoseconds < s_nanosecondsInASecond)\n                m_units = Unit::Milliseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMinute)\n                m_units = Unit::Seconds;\n            else\n                m_units = Unit::Minutes;\n        }\n\n    }\n\n    auto value() const -> double {\n        switch (m_units) {\n        case Unit::Microseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);\n        case Unit::Milliseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);\n        case Unit::Seconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);\n        case Unit::Minutes:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);\n        default:\n            return static_cast<double>(m_inNanoseconds);\n        }\n    }\n    auto unitsAsString() const -> std::string {\n        switch (m_units) {\n        case Unit::Nanoseconds:\n            return \"ns\";\n        case Unit::Microseconds:\n            return \"\u00b5s\";\n        case Unit::Milliseconds:\n            return \"ms\";\n        case Unit::Seconds:\n            return \"s\";\n        case Unit::Minutes:\n            return \"m\";\n        default:\n            return \"** internal error **\";\n        }\n\n    }\n    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {\n        return os << duration.value() << \" \" << duration.unitsAsString();\n    }\n};\n} // end anon namespace\n"
    },
    {
        "begin_line": 11583,
        "end_line": 11720,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ConsoleAssertionPrinter",
        "snippet": "class ConsoleAssertionPrinter {\npublic:\n    ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;\n    ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;\n    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream),\n        stats(_stats),\n        result(_stats.assertionResult),\n        colour(Colour::None),\n        message(result.getMessage()),\n        messages(_stats.infoMessages),\n        printInfoMessages(_printInfoMessages) {\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            colour = Colour::Success;\n            passOrFail = \"PASSED\";\n            //if( result.hasMessage() )\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk()) {\n                colour = Colour::Success;\n                passOrFail = \"FAILED - but was ok\";\n            } else {\n                colour = Colour::Error;\n                passOrFail = \"FAILED\";\n            }\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ThrewException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to unexpected exception with \";\n            if (_stats.infoMessages.size() == 1)\n                messageLabel += \"message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel += \"messages\";\n            break;\n        case ResultWas::FatalErrorCondition:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to a fatal error condition\";\n            break;\n        case ResultWas::DidntThrowException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"because no exception was thrown where one was expected\";\n            break;\n        case ResultWas::Info:\n            messageLabel = \"info\";\n            break;\n        case ResultWas::Warning:\n            messageLabel = \"warning\";\n            break;\n        case ResultWas::ExplicitFailure:\n            passOrFail = \"FAILED\";\n            colour = Colour::Error;\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"explicitly with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"explicitly with messages\";\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            passOrFail = \"** internal error **\";\n            colour = Colour::Error;\n            break;\n        }\n    }\n\n    void print() const {\n        printSourceInfo();\n        if (stats.totals.assertions.total() > 0) {\n            if (result.isOk())\n                stream << '\\n';\n            printResultType();\n            printOriginalExpression();\n            printReconstructedExpression();\n        } else {\n            stream << '\\n';\n        }\n        printMessage();\n    }\n\nprivate:\n    void printResultType() const {\n        if (!passOrFail.empty()) {\n            Colour colourGuard(colour);\n            stream << passOrFail << \":\\n\";\n        }\n    }\n    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            Colour colourGuard(Colour::OriginalExpression);\n            stream << \"  \";\n            stream << result.getExpressionInMacro();\n            stream << '\\n';\n        }\n    }\n    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            stream << \"with expansion:\\n\";\n            Colour colourGuard(Colour::ReconstructedExpression);\n            stream << Column(result.getExpandedExpression()).indent(2) << '\\n';\n        }\n    }\n    void printMessage() const {\n        if (!messageLabel.empty())\n            stream << messageLabel << ':' << '\\n';\n        for (auto const& msg : messages) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || msg.type != ResultWas::Info)\n                stream << Column(msg.message).indent(2) << '\\n';\n        }\n    }\n    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << \": \";\n    }\n\n    std::ostream& stream;\n    AssertionStats const& stats;\n    AssertionResult const& result;\n    Colour::Code colour;\n    std::string passOrFail;\n    std::string messageLabel;\n    std::string message;\n    std::vector<MessageInfo> messages;\n    bool printInfoMessages;\n};\n"
    },
    {
        "begin_line": 11587,
        "end_line": 11659,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ConsoleAssertionPrinter",
        "snippet": "    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)\n        : stream(_stream),\n        stats(_stats),\n        result(_stats.assertionResult),\n        colour(Colour::None),\n        message(result.getMessage()),\n        messages(_stats.infoMessages),\n        printInfoMessages(_printInfoMessages) {\n        switch (result.getResultType()) {\n        case ResultWas::Ok:\n            colour = Colour::Success;\n            passOrFail = \"PASSED\";\n            //if( result.hasMessage() )\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ExpressionFailed:\n            if (result.isOk()) {\n                colour = Colour::Success;\n                passOrFail = \"FAILED - but was ok\";\n            } else {\n                colour = Colour::Error;\n                passOrFail = \"FAILED\";\n            }\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"with messages\";\n            break;\n        case ResultWas::ThrewException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to unexpected exception with \";\n            if (_stats.infoMessages.size() == 1)\n                messageLabel += \"message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel += \"messages\";\n            break;\n        case ResultWas::FatalErrorCondition:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"due to a fatal error condition\";\n            break;\n        case ResultWas::DidntThrowException:\n            colour = Colour::Error;\n            passOrFail = \"FAILED\";\n            messageLabel = \"because no exception was thrown where one was expected\";\n            break;\n        case ResultWas::Info:\n            messageLabel = \"info\";\n            break;\n        case ResultWas::Warning:\n            messageLabel = \"warning\";\n            break;\n        case ResultWas::ExplicitFailure:\n            passOrFail = \"FAILED\";\n            colour = Colour::Error;\n            if (_stats.infoMessages.size() == 1)\n                messageLabel = \"explicitly with message\";\n            if (_stats.infoMessages.size() > 1)\n                messageLabel = \"explicitly with messages\";\n            break;\n            // These cases are here to prevent compiler warnings\n        case ResultWas::Unknown:\n        case ResultWas::FailureBit:\n        case ResultWas::Exception:\n            passOrFail = \"** internal error **\";\n            colour = Colour::Error;\n            break;\n        }\n    }\n"
    },
    {
        "begin_line": 11661,
        "end_line": 11673,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "print",
        "snippet": "    void print() const {\n        printSourceInfo();\n        if (stats.totals.assertions.total() > 0) {\n            if (result.isOk())\n                stream << '\\n';\n            printResultType();\n            printOriginalExpression();\n            printReconstructedExpression();\n        } else {\n            stream << '\\n';\n        }\n        printMessage();\n    }\n"
    },
    {
        "begin_line": 11676,
        "end_line": 11681,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printResultType",
        "snippet": "    void printResultType() const {\n        if (!passOrFail.empty()) {\n            Colour colourGuard(colour);\n            stream << passOrFail << \":\\n\";\n        }\n    }\n"
    },
    {
        "begin_line": 11682,
        "end_line": 11689,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printOriginalExpression",
        "snippet": "    void printOriginalExpression() const {\n        if (result.hasExpression()) {\n            Colour colourGuard(Colour::OriginalExpression);\n            stream << \"  \";\n            stream << result.getExpressionInMacro();\n            stream << '\\n';\n        }\n    }\n"
    },
    {
        "begin_line": 11690,
        "end_line": 11696,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printReconstructedExpression",
        "snippet": "    void printReconstructedExpression() const {\n        if (result.hasExpandedExpression()) {\n            stream << \"with expansion:\\n\";\n            Colour colourGuard(Colour::ReconstructedExpression);\n            stream << Column(result.getExpandedExpression()).indent(2) << '\\n';\n        }\n    }\n"
    },
    {
        "begin_line": 11697,
        "end_line": 11705,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printMessage",
        "snippet": "    void printMessage() const {\n        if (!messageLabel.empty())\n            stream << messageLabel << ':' << '\\n';\n        for (auto const& msg : messages) {\n            // If this assertion is a warning ignore any INFO messages\n            if (printInfoMessages || msg.type != ResultWas::Info)\n                stream << Column(msg.message).indent(2) << '\\n';\n        }\n    }\n"
    },
    {
        "begin_line": 11706,
        "end_line": 11709,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printSourceInfo",
        "snippet": "    void printSourceInfo() const {\n        Colour colourGuard(Colour::FileName);\n        stream << result.getSourceInfo() << \": \";\n    }\n"
    },
    {
        "begin_line": 11711,
        "end_line": 11711,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stream",
        "snippet": "    std::ostream& stream;\n"
    },
    {
        "begin_line": 11712,
        "end_line": 11712,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "stats",
        "snippet": "    AssertionStats const& stats;\n"
    },
    {
        "begin_line": 11713,
        "end_line": 11713,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "result",
        "snippet": "    AssertionResult const& result;\n"
    },
    {
        "begin_line": 11714,
        "end_line": 11714,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "colour",
        "snippet": "    Colour::Code colour;\n"
    },
    {
        "begin_line": 11715,
        "end_line": 11715,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "passOrFail",
        "snippet": "    std::string passOrFail;\n"
    },
    {
        "begin_line": 11716,
        "end_line": 11716,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "messageLabel",
        "snippet": "    std::string messageLabel;\n"
    },
    {
        "begin_line": 11717,
        "end_line": 11717,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "message",
        "snippet": "    std::string message;\n"
    },
    {
        "begin_line": 11718,
        "end_line": 11718,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "messages",
        "snippet": "    std::vector<MessageInfo> messages;\n"
    },
    {
        "begin_line": 11719,
        "end_line": 11719,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printInfoMessages",
        "snippet": "    bool printInfoMessages;\n"
    },
    {
        "begin_line": 11722,
        "end_line": 11725,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "makeRatio",
        "snippet": "std::size_t makeRatio(std::size_t number, std::size_t total) {\n    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;\n    return (ratio == 0 && number > 0) ? 1 : ratio;\n}\n"
    },
    {
        "begin_line": 11727,
        "end_line": 11734,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "findMax",
        "snippet": "std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {\n    if (i > j && i > k)\n        return i;\n    else if (j > k)\n        return j;\n    else\n        return k;\n}\n"
    },
    {
        "begin_line": 11736,
        "end_line": 11741,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ColumnInfo",
        "snippet": "struct ColumnInfo {\n    enum Justification { Left, Right };\n    std::string name;\n    int width;\n    Justification justification;\n};\n"
    },
    {
        "begin_line": 11737,
        "end_line": 11737,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Justification",
        "snippet": "    enum Justification { Left, Right };\n"
    },
    {
        "begin_line": 11738,
        "end_line": 11738,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "name",
        "snippet": "    std::string name;\n"
    },
    {
        "begin_line": 11739,
        "end_line": 11739,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "width",
        "snippet": "    int width;\n"
    },
    {
        "begin_line": 11740,
        "end_line": 11740,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "justification",
        "snippet": "    Justification justification;\n"
    },
    {
        "begin_line": 11742,
        "end_line": 11742,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ColumnBreak",
        "snippet": "struct ColumnBreak {};\n"
    },
    {
        "begin_line": 11743,
        "end_line": 11743,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "RowBreak",
        "snippet": "struct RowBreak {};\n"
    },
    {
        "begin_line": 11745,
        "end_line": 11815,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Duration",
        "snippet": "class Duration {\n    enum class Unit {\n        Auto,\n        Nanoseconds,\n        Microseconds,\n        Milliseconds,\n        Seconds,\n        Minutes\n    };\n    static const uint64_t s_nanosecondsInAMicrosecond = 1000;\n    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;\n    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;\n    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;\n\n    uint64_t m_inNanoseconds;\n    Unit m_units;\n\npublic:\n    explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\n        : m_inNanoseconds(inNanoseconds),\n        m_units(units) {\n        if (m_units == Unit::Auto) {\n            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)\n                m_units = Unit::Nanoseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)\n                m_units = Unit::Microseconds;\n            else if (m_inNanoseconds < s_nanosecondsInASecond)\n                m_units = Unit::Milliseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMinute)\n                m_units = Unit::Seconds;\n            else\n                m_units = Unit::Minutes;\n        }\n\n    }\n\n    auto value() const -> double {\n        switch (m_units) {\n        case Unit::Microseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);\n        case Unit::Milliseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);\n        case Unit::Seconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);\n        case Unit::Minutes:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);\n        default:\n            return static_cast<double>(m_inNanoseconds);\n        }\n    }\n    auto unitsAsString() const -> std::string {\n        switch (m_units) {\n        case Unit::Nanoseconds:\n            return \"ns\";\n        case Unit::Microseconds:\n            return \"\u00b5s\";\n        case Unit::Milliseconds:\n            return \"ms\";\n        case Unit::Seconds:\n            return \"s\";\n        case Unit::Minutes:\n            return \"m\";\n        default:\n            return \"** internal error **\";\n        }\n\n    }\n    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {\n        return os << duration.value() << \" \" << duration.unitsAsString();\n    }\n};\n"
    },
    {
        "begin_line": 11746,
        "end_line": 11753,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Unit",
        "snippet": "    enum class Unit {\n        Auto,\n        Nanoseconds,\n        Microseconds,\n        Milliseconds,\n        Seconds,\n        Minutes\n    };\n"
    },
    {
        "begin_line": 11754,
        "end_line": 11754,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "s_nanosecondsInAMicrosecond",
        "snippet": "    static const uint64_t s_nanosecondsInAMicrosecond = 1000;\n"
    },
    {
        "begin_line": 11755,
        "end_line": 11755,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "s_nanosecondsInAMillisecond",
        "snippet": "    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;\n"
    },
    {
        "begin_line": 11756,
        "end_line": 11756,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "s_nanosecondsInASecond",
        "snippet": "    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;\n"
    },
    {
        "begin_line": 11757,
        "end_line": 11757,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "s_nanosecondsInAMinute",
        "snippet": "    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;\n"
    },
    {
        "begin_line": 11759,
        "end_line": 11759,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_inNanoseconds",
        "snippet": "    uint64_t m_inNanoseconds;\n"
    },
    {
        "begin_line": 11760,
        "end_line": 11760,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_units",
        "snippet": "    Unit m_units;\n"
    },
    {
        "begin_line": 11763,
        "end_line": 11779,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Duration",
        "snippet": "    explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\n        : m_inNanoseconds(inNanoseconds),\n        m_units(units) {\n        if (m_units == Unit::Auto) {\n            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)\n                m_units = Unit::Nanoseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)\n                m_units = Unit::Microseconds;\n            else if (m_inNanoseconds < s_nanosecondsInASecond)\n                m_units = Unit::Milliseconds;\n            else if (m_inNanoseconds < s_nanosecondsInAMinute)\n                m_units = Unit::Seconds;\n            else\n                m_units = Unit::Minutes;\n        }\n\n    }\n"
    },
    {
        "begin_line": 11781,
        "end_line": 11794,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "value",
        "snippet": "    auto value() const -> double {\n        switch (m_units) {\n        case Unit::Microseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);\n        case Unit::Milliseconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);\n        case Unit::Seconds:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);\n        case Unit::Minutes:\n            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);\n        default:\n            return static_cast<double>(m_inNanoseconds);\n        }\n    }\n"
    },
    {
        "begin_line": 11795,
        "end_line": 11811,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "unitsAsString",
        "snippet": "    auto unitsAsString() const -> std::string {\n        switch (m_units) {\n        case Unit::Nanoseconds:\n            return \"ns\";\n        case Unit::Microseconds:\n            return \"\u00b5s\";\n        case Unit::Milliseconds:\n            return \"ms\";\n        case Unit::Seconds:\n            return \"s\";\n        case Unit::Minutes:\n            return \"m\";\n        default:\n            return \"** internal error **\";\n        }\n\n    }\n"
    },
    {
        "begin_line": 11812,
        "end_line": 11814,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {\n        return os << duration.value() << \" \" << duration.unitsAsString();\n    }\n"
    },
    {
        "begin_line": 11818,
        "end_line": 11888,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TablePrinter",
        "snippet": "class TablePrinter {\n    std::ostream& m_os;\n    std::vector<ColumnInfo> m_columnInfos;\n    std::ostringstream m_oss;\n    int m_currentColumn = -1;\n    bool m_isOpen = false;\n\npublic:\n    TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )\n    :   m_os( os ),\n        m_columnInfos( std::move( columnInfos ) ) {}\n\n    auto columnInfos() const -> std::vector<ColumnInfo> const& {\n        return m_columnInfos;\n    }\n\n    void open() {\n        if (!m_isOpen) {\n            m_isOpen = true;\n            *this << RowBreak();\n            for (auto const& info : m_columnInfos)\n                *this << info.name << ColumnBreak();\n            *this << RowBreak();\n            m_os << Catch::getLineOfChars<'-'>() << \"\\n\";\n        }\n    }\n    void close() {\n        if (m_isOpen) {\n            *this << RowBreak();\n            m_os << std::endl;\n            m_isOpen = false;\n        }\n    }\n\n    template<typename T>\n    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {\n        tp.m_oss << value;\n        return tp;\n    }\n\n    friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {\n        auto colStr = tp.m_oss.str();\n        // This takes account of utf8 encodings\n        auto strSize = Catch::StringRef(colStr).numberOfCharacters();\n        tp.m_oss.str(\"\");\n        tp.open();\n        if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {\n            tp.m_currentColumn = -1;\n            tp.m_os << \"\\n\";\n        }\n        tp.m_currentColumn++;\n\n        auto colInfo = tp.m_columnInfos[tp.m_currentColumn];\n        auto padding = (strSize + 2 < static_cast<std::size_t>(colInfo.width))\n            ? std::string(colInfo.width - (strSize + 2), ' ')\n            : std::string();\n        if (colInfo.justification == ColumnInfo::Left)\n            tp.m_os << colStr << padding << \" \";\n        else\n            tp.m_os << padding << colStr << \" \";\n        return tp;\n    }\n\n    friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {\n        if (tp.m_currentColumn > 0) {\n            tp.m_os << \"\\n\";\n            tp.m_currentColumn = -1;\n        }\n        return tp;\n    }\n};\n"
    },
    {
        "begin_line": 11819,
        "end_line": 11819,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_os",
        "snippet": "    std::ostream& m_os;\n"
    },
    {
        "begin_line": 11820,
        "end_line": 11820,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_columnInfos",
        "snippet": "    std::vector<ColumnInfo> m_columnInfos;\n"
    },
    {
        "begin_line": 11821,
        "end_line": 11821,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_oss",
        "snippet": "    std::ostringstream m_oss;\n"
    },
    {
        "begin_line": 11822,
        "end_line": 11822,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_currentColumn",
        "snippet": "    int m_currentColumn = -1;\n"
    },
    {
        "begin_line": 11823,
        "end_line": 11823,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "m_isOpen",
        "snippet": "    bool m_isOpen = false;\n"
    },
    {
        "begin_line": 11826,
        "end_line": 11828,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TablePrinter",
        "snippet": "    TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )\n    :   m_os( os ),\n        m_columnInfos( std::move( columnInfos ) ) {}\n"
    },
    {
        "begin_line": 11830,
        "end_line": 11832,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "columnInfos",
        "snippet": "    auto columnInfos() const -> std::vector<ColumnInfo> const& {\n        return m_columnInfos;\n    }\n"
    },
    {
        "begin_line": 11834,
        "end_line": 11843,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "open",
        "snippet": "    void open() {\n        if (!m_isOpen) {\n            m_isOpen = true;\n            *this << RowBreak();\n            for (auto const& info : m_columnInfos)\n                *this << info.name << ColumnBreak();\n            *this << RowBreak();\n            m_os << Catch::getLineOfChars<'-'>() << \"\\n\";\n        }\n    }\n"
    },
    {
        "begin_line": 11844,
        "end_line": 11850,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "close",
        "snippet": "    void close() {\n        if (m_isOpen) {\n            *this << RowBreak();\n            m_os << std::endl;\n            m_isOpen = false;\n        }\n    }\n"
    },
    {
        "begin_line": 11853,
        "end_line": 11856,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {\n        tp.m_oss << value;\n        return tp;\n    }\n"
    },
    {
        "begin_line": 11858,
        "end_line": 11879,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {\n        auto colStr = tp.m_oss.str();\n        // This takes account of utf8 encodings\n        auto strSize = Catch::StringRef(colStr).numberOfCharacters();\n        tp.m_oss.str(\"\");\n        tp.open();\n        if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {\n            tp.m_currentColumn = -1;\n            tp.m_os << \"\\n\";\n        }\n        tp.m_currentColumn++;\n\n        auto colInfo = tp.m_columnInfos[tp.m_currentColumn];\n        auto padding = (strSize + 2 < static_cast<std::size_t>(colInfo.width))\n            ? std::string(colInfo.width - (strSize + 2), ' ')\n            : std::string();\n        if (colInfo.justification == ColumnInfo::Left)\n            tp.m_os << colStr << padding << \" \";\n        else\n            tp.m_os << padding << colStr << \" \";\n        return tp;\n    }\n"
    },
    {
        "begin_line": 11881,
        "end_line": 11887,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "operator <<",
        "snippet": "    friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {\n        if (tp.m_currentColumn > 0) {\n            tp.m_os << \"\\n\";\n            tp.m_currentColumn = -1;\n        }\n        return tp;\n    }\n"
    },
    {
        "begin_line": 11890,
        "end_line": 11898,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ConsoleReporter",
        "snippet": "ConsoleReporter::ConsoleReporter(ReporterConfig const& config)\n    : StreamingReporterBase(config),\n    m_tablePrinter(new TablePrinter(config.stream(),\n    {\n        { \"benchmark name\", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },\n        { \"iters\", 8, ColumnInfo::Right },\n        { \"elapsed ns\", 14, ColumnInfo::Right },\n        { \"average\", 14, ColumnInfo::Right }\n    })) {}\n"
    },
    {
        "begin_line": 11901,
        "end_line": 11903,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getDescription",
        "snippet": "std::string ConsoleReporter::getDescription() {\n    return \"Reports test results as plain lines of text\";\n}\n"
    },
    {
        "begin_line": 11905,
        "end_line": 11907,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "noMatchingTestCases",
        "snippet": "void ConsoleReporter::noMatchingTestCases(std::string const& spec) {\n    stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n}\n"
    },
    {
        "begin_line": 11909,
        "end_line": 11909,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionStarting",
        "snippet": "void ConsoleReporter::assertionStarting(AssertionInfo const&) {}\n"
    },
    {
        "begin_line": 11911,
        "end_line": 11926,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n    AssertionResult const& result = _assertionStats.assertionResult;\n\n    bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n\n    // Drop out if result was successful but we're not printing them.\n    if (!includeResults && result.getResultType() != ResultWas::Warning)\n        return false;\n\n    lazyPrint();\n\n    ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);\n    printer.print();\n    stream << std::endl;\n    return true;\n}\n"
    },
    {
        "begin_line": 11928,
        "end_line": 11931,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionStarting",
        "snippet": "void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {\n    m_headerPrinted = false;\n    StreamingReporterBase::sectionStarting(_sectionInfo);\n}\n"
    },
    {
        "begin_line": 11932,
        "end_line": 11950,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEnded",
        "snippet": "void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {\n    m_tablePrinter->close();\n    if (_sectionStats.missingAssertions) {\n        lazyPrint();\n        Colour colour(Colour::ResultError);\n        if (m_sectionStack.size() > 1)\n            stream << \"\\nNo assertions in section\";\n        else\n            stream << \"\\nNo assertions in test case\";\n        stream << \" '\" << _sectionStats.sectionInfo.name << \"'\\n\" << std::endl;\n    }\n    if (m_config->showDurations() == ShowDurations::Always) {\n        stream << getFormattedDuration(_sectionStats.durationInSeconds) << \" s: \" << _sectionStats.sectionInfo.name << std::endl;\n    }\n    if (m_headerPrinted) {\n        m_headerPrinted = false;\n    }\n    StreamingReporterBase::sectionEnded(_sectionStats);\n}\n"
    },
    {
        "begin_line": 11952,
        "end_line": 11966,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkStarting",
        "snippet": "void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n    lazyPrintWithoutClosingBenchmarkTable();\n\n    auto nameCol = Column( info.name ).width( static_cast<std::size_t>( m_tablePrinter->columnInfos()[0].width - 2 ) );\n\n    bool firstLine = true;\n    for (auto line : nameCol) {\n        if (!firstLine)\n            (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n        else\n            firstLine = false;\n\n        (*m_tablePrinter) << line << ColumnBreak();\n    }\n}\n"
    },
    {
        "begin_line": 11967,
        "end_line": 11973,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkEnded",
        "snippet": "void ConsoleReporter::benchmarkEnded(BenchmarkStats const& stats) {\n    Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);\n    (*m_tablePrinter)\n        << stats.iterations << ColumnBreak()\n        << stats.elapsedTimeInNanoseconds << ColumnBreak()\n        << average << ColumnBreak();\n}\n"
    },
    {
        "begin_line": 11975,
        "end_line": 11979,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseEnded",
        "snippet": "void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n    m_tablePrinter->close();\n    StreamingReporterBase::testCaseEnded(_testCaseStats);\n    m_headerPrinted = false;\n}\n"
    },
    {
        "begin_line": 11980,
        "end_line": 11988,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupEnded",
        "snippet": "void ConsoleReporter::testGroupEnded(TestGroupStats const& _testGroupStats) {\n    if (currentGroupInfo.used) {\n        printSummaryDivider();\n        stream << \"Summary for group '\" << _testGroupStats.groupInfo.name << \"':\\n\";\n        printTotals(_testGroupStats.totals);\n        stream << '\\n' << std::endl;\n    }\n    StreamingReporterBase::testGroupEnded(_testGroupStats);\n}\n"
    },
    {
        "begin_line": 11989,
        "end_line": 11994,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunEnded",
        "snippet": "void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {\n    printTotalsDivider(_testRunStats.totals);\n    printTotals(_testRunStats.totals);\n    stream << std::endl;\n    StreamingReporterBase::testRunEnded(_testRunStats);\n}\n"
    },
    {
        "begin_line": 11996,
        "end_line": 12000,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lazyPrint",
        "snippet": "void ConsoleReporter::lazyPrint() {\n\n    m_tablePrinter->close();\n    lazyPrintWithoutClosingBenchmarkTable();\n}\n"
    },
    {
        "begin_line": 12002,
        "end_line": 12013,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lazyPrintWithoutClosingBenchmarkTable",
        "snippet": "void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {\n\n    if (!currentTestRunInfo.used)\n        lazyPrintRunInfo();\n    if (!currentGroupInfo.used)\n        lazyPrintGroupInfo();\n\n    if (!m_headerPrinted) {\n        printTestCaseAndSectionHeader();\n        m_headerPrinted = true;\n    }\n}\n"
    },
    {
        "begin_line": 12014,
        "end_line": 12025,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lazyPrintRunInfo",
        "snippet": "void ConsoleReporter::lazyPrintRunInfo() {\n    stream << '\\n' << getLineOfChars<'~'>() << '\\n';\n    Colour colour(Colour::SecondaryText);\n    stream << currentTestRunInfo->name\n        << \" is a Catch v\" << libraryVersion() << \" host application.\\n\"\n        << \"Run with -? for options\\n\\n\";\n\n    if (m_config->rngSeed() != 0)\n        stream << \"Randomness seeded to: \" << m_config->rngSeed() << \"\\n\\n\";\n\n    currentTestRunInfo.used = true;\n}\n"
    },
    {
        "begin_line": 12026,
        "end_line": 12031,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "lazyPrintGroupInfo",
        "snippet": "void ConsoleReporter::lazyPrintGroupInfo() {\n    if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {\n        printClosedHeader(\"Group: \" + currentGroupInfo->name);\n        currentGroupInfo.used = true;\n    }\n}\n"
    },
    {
        "begin_line": 12032,
        "end_line": 12054,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printTestCaseAndSectionHeader",
        "snippet": "void ConsoleReporter::printTestCaseAndSectionHeader() {\n    assert(!m_sectionStack.empty());\n    printOpenHeader(currentTestCaseInfo->name);\n\n    if (m_sectionStack.size() > 1) {\n        Colour colourGuard(Colour::Headers);\n\n        auto\n            it = m_sectionStack.begin() + 1, // Skip first section (test case)\n            itEnd = m_sectionStack.end();\n        for (; it != itEnd; ++it)\n            printHeaderString(it->name, 2);\n    }\n\n    SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;\n\n    if (!lineInfo.empty()) {\n        stream << getLineOfChars<'-'>() << '\\n';\n        Colour colourGuard(Colour::FileName);\n        stream << lineInfo << '\\n';\n    }\n    stream << getLineOfChars<'.'>() << '\\n' << std::endl;\n}\n"
    },
    {
        "begin_line": 12056,
        "end_line": 12059,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printClosedHeader",
        "snippet": "void ConsoleReporter::printClosedHeader(std::string const& _name) {\n    printOpenHeader(_name);\n    stream << getLineOfChars<'.'>() << '\\n';\n}\n"
    },
    {
        "begin_line": 12060,
        "end_line": 12066,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printOpenHeader",
        "snippet": "void ConsoleReporter::printOpenHeader(std::string const& _name) {\n    stream << getLineOfChars<'-'>() << '\\n';\n    {\n        Colour colourGuard(Colour::Headers);\n        printHeaderString(_name);\n    }\n}\n"
    },
    {
        "begin_line": 12070,
        "end_line": 12077,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printHeaderString",
        "snippet": "void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t indent) {\n    std::size_t i = _string.find(\": \");\n    if (i != std::string::npos)\n        i += 2;\n    else\n        i = 0;\n    stream << Column(_string).indent(indent + i).initialIndent(indent) << '\\n';\n}\n"
    },
    {
        "begin_line": 12079,
        "end_line": 12102,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SummaryColumn",
        "snippet": "struct SummaryColumn {\n\n    SummaryColumn( std::string _label, Colour::Code _colour )\n    :   label( std::move( _label ) ),\n        colour( _colour ) {}\n    SummaryColumn addRow( std::size_t count ) {\n        ReusableStringStream rss;\n        rss << count;\n        std::string row = rss.str();\n        for (auto& oldRow : rows) {\n            while (oldRow.size() < row.size())\n                oldRow = ' ' + oldRow;\n            while (oldRow.size() > row.size())\n                row = ' ' + row;\n        }\n        rows.push_back(row);\n        return *this;\n    }\n\n    std::string label;\n    Colour::Code colour;\n    std::vector<std::string> rows;\n\n};\n"
    },
    {
        "begin_line": 12081,
        "end_line": 12083,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SummaryColumn",
        "snippet": "    SummaryColumn( std::string _label, Colour::Code _colour )\n    :   label( std::move( _label ) ),\n        colour( _colour ) {}\n"
    },
    {
        "begin_line": 12084,
        "end_line": 12096,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "addRow",
        "snippet": "    SummaryColumn addRow( std::size_t count ) {\n        ReusableStringStream rss;\n        rss << count;\n        std::string row = rss.str();\n        for (auto& oldRow : rows) {\n            while (oldRow.size() < row.size())\n                oldRow = ' ' + oldRow;\n            while (oldRow.size() > row.size())\n                row = ' ' + row;\n        }\n        rows.push_back(row);\n        return *this;\n    }\n"
    },
    {
        "begin_line": 12098,
        "end_line": 12098,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "label",
        "snippet": "    std::string label;\n"
    },
    {
        "begin_line": 12099,
        "end_line": 12099,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "colour",
        "snippet": "    Colour::Code colour;\n"
    },
    {
        "begin_line": 12100,
        "end_line": 12100,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "rows",
        "snippet": "    std::vector<std::string> rows;\n"
    },
    {
        "begin_line": 12104,
        "end_line": 12132,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printTotals",
        "snippet": "void ConsoleReporter::printTotals( Totals const& totals ) {\n    if (totals.testCases.total() == 0) {\n        stream << Colour(Colour::Warning) << \"No tests ran\\n\";\n    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {\n        stream << Colour(Colour::ResultSuccess) << \"All tests passed\";\n        stream << \" (\"\n            << pluralise(totals.assertions.passed, \"assertion\") << \" in \"\n            << pluralise(totals.testCases.passed, \"test case\") << ')'\n            << '\\n';\n    } else {\n\n        std::vector<SummaryColumn> columns;\n        columns.push_back(SummaryColumn(\"\", Colour::None)\n                          .addRow(totals.testCases.total())\n                          .addRow(totals.assertions.total()));\n        columns.push_back(SummaryColumn(\"passed\", Colour::Success)\n                          .addRow(totals.testCases.passed)\n                          .addRow(totals.assertions.passed));\n        columns.push_back(SummaryColumn(\"failed\", Colour::ResultError)\n                          .addRow(totals.testCases.failed)\n                          .addRow(totals.assertions.failed));\n        columns.push_back(SummaryColumn(\"failed as expected\", Colour::ResultExpectedFailure)\n                          .addRow(totals.testCases.failedButOk)\n                          .addRow(totals.assertions.failedButOk));\n\n        printSummaryRow(\"test cases\", columns, 0);\n        printSummaryRow(\"assertions\", columns, 1);\n    }\n}\n"
    },
    {
        "begin_line": 12133,
        "end_line": 12149,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printSummaryRow",
        "snippet": "void ConsoleReporter::printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {\n    for (auto col : cols) {\n        std::string value = col.rows[row];\n        if (col.label.empty()) {\n            stream << label << \": \";\n            if (value != \"0\")\n                stream << value;\n            else\n                stream << Colour(Colour::Warning) << \"- none -\";\n        } else if (value != \"0\") {\n            stream << Colour(Colour::LightGrey) << \" | \";\n            stream << Colour(col.colour)\n                << value << ' ' << col.label;\n        }\n    }\n    stream << '\\n';\n}\n"
    },
    {
        "begin_line": 12151,
        "end_line": 12171,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printTotalsDivider",
        "snippet": "void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n    if (totals.testCases.total() > 0) {\n        std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\n        std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());\n        std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());\n        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\n            findMax(failedRatio, failedButOkRatio, passedRatio)++;\n        while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)\n            findMax(failedRatio, failedButOkRatio, passedRatio)--;\n\n        stream << Colour(Colour::Error) << std::string(failedRatio, '=');\n        stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');\n        if (totals.testCases.allPassed())\n            stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');\n        else\n            stream << Colour(Colour::Success) << std::string(passedRatio, '=');\n    } else {\n        stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');\n    }\n    stream << '\\n';\n}\n"
    },
    {
        "begin_line": 12172,
        "end_line": 12174,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "printSummaryDivider",
        "snippet": "void ConsoleReporter::printSummaryDivider() {\n    stream << getLineOfChars<'-'>() << '\\n';\n}\n"
    },
    {
        "begin_line": 12191,
        "end_line": 12417,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    namespace {\n        std::string getCurrentTimestamp() {\n            // Beware, this is not reentrant because of backward compatibility issues\n            // Also, UTC only, again because of backward compatibility (%z is C++11)\n            time_t rawtime;\n            std::time(&rawtime);\n            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &rawtime);\n#else\n            std::tm* timeInfo;\n            timeInfo = std::gmtime(&rawtime);\n#endif\n\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp);\n        }\n\n        std::string fileNameTag(const std::vector<std::string> &tags) {\n            auto it = std::find_if(begin(tags),\n                                   end(tags),\n                                   [] (std::string const& tag) {return tag.front() == '#'; });\n            if (it != tags.end())\n                return it->substr(1);\n            return std::string();\n        }\n    } // anonymous namespace\n\n    JunitReporter::JunitReporter( ReporterConfig const& _config )\n        :   CumulativeReporterBase( _config ),\n            xml( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = true;\n        }\n\n    JunitReporter::~JunitReporter() {}\n\n    std::string JunitReporter::getDescription() {\n        return \"Reports test results in an XML format that looks like Ant's junitreport target\";\n    }\n\n    void JunitReporter::noMatchingTestCases( std::string const& /*spec*/ ) {}\n\n    void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {\n        CumulativeReporterBase::testRunStarting( runInfo );\n        xml.startElement( \"testsuites\" );\n    }\n\n    void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {\n        suiteTimer.start();\n        stdOutForSuite.clear();\n        stdErrForSuite.clear();\n        unexpectedExceptions = 0;\n        CumulativeReporterBase::testGroupStarting( groupInfo );\n    }\n\n    void JunitReporter::testCaseStarting( TestCaseInfo const& testCaseInfo ) {\n        m_okToFail = testCaseInfo.okToFail();\n    }\n\n    bool JunitReporter::assertionEnded( AssertionStats const& assertionStats ) {\n        if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )\n            unexpectedExceptions++;\n        return CumulativeReporterBase::assertionEnded( assertionStats );\n    }\n\n    void JunitReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {\n        stdOutForSuite += testCaseStats.stdOut;\n        stdErrForSuite += testCaseStats.stdErr;\n        CumulativeReporterBase::testCaseEnded( testCaseStats );\n    }\n\n    void JunitReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {\n        double suiteTime = suiteTimer.getElapsedSeconds();\n        CumulativeReporterBase::testGroupEnded( testGroupStats );\n        writeGroup( *m_testGroups.back(), suiteTime );\n    }\n\n    void JunitReporter::testRunEndedCumulative() {\n        xml.endElement();\n    }\n\n    void JunitReporter::writeGroup( TestGroupNode const& groupNode, double suiteTime ) {\n        XmlWriter::ScopedElement e = xml.scopedElement( \"testsuite\" );\n        TestGroupStats const& stats = groupNode.value;\n        xml.writeAttribute( \"name\", stats.groupInfo.name );\n        xml.writeAttribute( \"errors\", unexpectedExceptions );\n        xml.writeAttribute( \"failures\", stats.totals.assertions.failed-unexpectedExceptions );\n        xml.writeAttribute( \"tests\", stats.totals.assertions.total() );\n        xml.writeAttribute( \"hostname\", \"tbd\" ); // !TBD\n        if( m_config->showDurations() == ShowDurations::Never )\n            xml.writeAttribute( \"time\", \"\" );\n        else\n            xml.writeAttribute( \"time\", suiteTime );\n        xml.writeAttribute( \"timestamp\", getCurrentTimestamp() );\n\n        // Write test cases\n        for( auto const& child : groupNode.children )\n            writeTestCase( *child );\n\n        xml.scopedElement( \"system-out\" ).writeText( trim( stdOutForSuite ), false );\n        xml.scopedElement( \"system-err\" ).writeText( trim( stdErrForSuite ), false );\n    }\n\n    void JunitReporter::writeTestCase( TestCaseNode const& testCaseNode ) {\n        TestCaseStats const& stats = testCaseNode.value;\n\n        // All test cases have exactly one section - which represents the\n        // test case itself. That section may have 0-n nested sections\n        assert( testCaseNode.children.size() == 1 );\n        SectionNode const& rootSection = *testCaseNode.children.front();\n\n        std::string className = stats.testInfo.className;\n\n        if( className.empty() ) {\n            className = fileNameTag(stats.testInfo.tags);\n            if ( className.empty() )\n                className = \"global\";\n        }\n\n        if ( !m_config->name().empty() )\n            className = m_config->name() + \".\" + className;\n\n        writeSection( className, \"\", rootSection );\n    }\n\n    void JunitReporter::writeSection(  std::string const& className,\n                        std::string const& rootName,\n                        SectionNode const& sectionNode ) {\n        std::string name = trim( sectionNode.stats.sectionInfo.name );\n        if( !rootName.empty() )\n            name = rootName + '/' + name;\n\n        if( !sectionNode.assertions.empty() ||\n            !sectionNode.stdOut.empty() ||\n            !sectionNode.stdErr.empty() ) {\n            XmlWriter::ScopedElement e = xml.scopedElement( \"testcase\" );\n            if( className.empty() ) {\n                xml.writeAttribute( \"classname\", name );\n                xml.writeAttribute( \"name\", \"root\" );\n            }\n            else {\n                xml.writeAttribute( \"classname\", className );\n                xml.writeAttribute( \"name\", name );\n            }\n            xml.writeAttribute( \"time\", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );\n\n            writeAssertions( sectionNode );\n\n            if( !sectionNode.stdOut.empty() )\n                xml.scopedElement( \"system-out\" ).writeText( trim( sectionNode.stdOut ), false );\n            if( !sectionNode.stdErr.empty() )\n                xml.scopedElement( \"system-err\" ).writeText( trim( sectionNode.stdErr ), false );\n        }\n        for( auto const& childNode : sectionNode.childSections )\n            if( className.empty() )\n                writeSection( name, \"\", *childNode );\n            else\n                writeSection( className, name, *childNode );\n    }\n\n    void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {\n        for( auto const& assertion : sectionNode.assertions )\n            writeAssertion( assertion );\n    }\n\n    void JunitReporter::writeAssertion( AssertionStats const& stats ) {\n        AssertionResult const& result = stats.assertionResult;\n        if( !result.isOk() ) {\n            std::string elementName;\n            switch( result.getResultType() ) {\n                case ResultWas::ThrewException:\n                case ResultWas::FatalErrorCondition:\n                    elementName = \"error\";\n                    break;\n                case ResultWas::ExplicitFailure:\n                    elementName = \"failure\";\n                    break;\n                case ResultWas::ExpressionFailed:\n                    elementName = \"failure\";\n                    break;\n                case ResultWas::DidntThrowException:\n                    elementName = \"failure\";\n                    break;\n\n                // We should never see these here:\n                case ResultWas::Info:\n                case ResultWas::Warning:\n                case ResultWas::Ok:\n                case ResultWas::Unknown:\n                case ResultWas::FailureBit:\n                case ResultWas::Exception:\n                    elementName = \"internalError\";\n                    break;\n            }\n\n            XmlWriter::ScopedElement e = xml.scopedElement( elementName );\n\n            xml.writeAttribute( \"message\", result.getExpandedExpression() );\n            xml.writeAttribute( \"type\", result.getTestMacroName() );\n\n            ReusableStringStream rss;\n            if( !result.getMessage().empty() )\n                rss << result.getMessage() << '\\n';\n            for( auto const& msg : stats.infoMessages )\n                if( msg.type == ResultWas::Info )\n                    rss << msg.message << '\\n';\n\n            rss << \"at \" << result.getSourceInfo();\n            xml.writeText( rss.str(), false );\n        }\n    }\n\n    CATCH_REGISTER_REPORTER( \"junit\", JunitReporter )\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 12193,
        "end_line": 12228,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1e11",
        "snippet": "    namespace {\n        std::string getCurrentTimestamp() {\n            // Beware, this is not reentrant because of backward compatibility issues\n            // Also, UTC only, again because of backward compatibility (%z is C++11)\n            time_t rawtime;\n            std::time(&rawtime);\n            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &rawtime);\n#else\n            std::tm* timeInfo;\n            timeInfo = std::gmtime(&rawtime);\n#endif\n\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp);\n        }\n\n        std::string fileNameTag(const std::vector<std::string> &tags) {\n            auto it = std::find_if(begin(tags),\n                                   end(tags),\n                                   [] (std::string const& tag) {return tag.front() == '#'; });\n            if (it != tags.end())\n                return it->substr(1);\n            return std::string();\n        }\n    } // anonymous namespace\n"
    },
    {
        "begin_line": 12194,
        "end_line": 12218,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getCurrentTimestamp",
        "snippet": "        std::string getCurrentTimestamp() {\n            // Beware, this is not reentrant because of backward compatibility issues\n            // Also, UTC only, again because of backward compatibility (%z is C++11)\n            time_t rawtime;\n            std::time(&rawtime);\n            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &rawtime);\n#else\n            std::tm* timeInfo;\n            timeInfo = std::gmtime(&rawtime);\n#endif\n\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp);\n        }\n"
    },
    {
        "begin_line": 12220,
        "end_line": 12227,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "fileNameTag",
        "snippet": "        std::string fileNameTag(const std::vector<std::string> &tags) {\n            auto it = std::find_if(begin(tags),\n                                   end(tags),\n                                   [] (std::string const& tag) {return tag.front() == '#'; });\n            if (it != tags.end())\n                return it->substr(1);\n            return std::string();\n        }\n"
    },
    {
        "begin_line": 12223,
        "end_line": 12223,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "__anon9e11652b1f02",
        "snippet": "                                   [] (std::string const& tag) {return tag.front() == '#'; });\n"
    },
    {
        "begin_line": 12230,
        "end_line": 12235,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "JunitReporter",
        "snippet": "    JunitReporter::JunitReporter( ReporterConfig const& _config )\n        :   CumulativeReporterBase( _config ),\n            xml( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = true;\n        }\n"
    },
    {
        "begin_line": 12237,
        "end_line": 12237,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "~JunitReporter",
        "snippet": "    JunitReporter::~JunitReporter() {}\n"
    },
    {
        "begin_line": 12239,
        "end_line": 12241,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getDescription",
        "snippet": "    std::string JunitReporter::getDescription() {\n        return \"Reports test results in an XML format that looks like Ant's junitreport target\";\n    }\n"
    },
    {
        "begin_line": 12243,
        "end_line": 12243,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "noMatchingTestCases",
        "snippet": "    void JunitReporter::noMatchingTestCases( std::string const& /*spec*/ ) {}\n"
    },
    {
        "begin_line": 12245,
        "end_line": 12248,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunStarting",
        "snippet": "    void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {\n        CumulativeReporterBase::testRunStarting( runInfo );\n        xml.startElement( \"testsuites\" );\n    }\n"
    },
    {
        "begin_line": 12250,
        "end_line": 12256,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupStarting",
        "snippet": "    void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {\n        suiteTimer.start();\n        stdOutForSuite.clear();\n        stdErrForSuite.clear();\n        unexpectedExceptions = 0;\n        CumulativeReporterBase::testGroupStarting( groupInfo );\n    }\n"
    },
    {
        "begin_line": 12258,
        "end_line": 12260,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseStarting",
        "snippet": "    void JunitReporter::testCaseStarting( TestCaseInfo const& testCaseInfo ) {\n        m_okToFail = testCaseInfo.okToFail();\n    }\n"
    },
    {
        "begin_line": 12262,
        "end_line": 12266,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "    bool JunitReporter::assertionEnded( AssertionStats const& assertionStats ) {\n        if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )\n            unexpectedExceptions++;\n        return CumulativeReporterBase::assertionEnded( assertionStats );\n    }\n"
    },
    {
        "begin_line": 12268,
        "end_line": 12272,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseEnded",
        "snippet": "    void JunitReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {\n        stdOutForSuite += testCaseStats.stdOut;\n        stdErrForSuite += testCaseStats.stdErr;\n        CumulativeReporterBase::testCaseEnded( testCaseStats );\n    }\n"
    },
    {
        "begin_line": 12274,
        "end_line": 12278,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupEnded",
        "snippet": "    void JunitReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {\n        double suiteTime = suiteTimer.getElapsedSeconds();\n        CumulativeReporterBase::testGroupEnded( testGroupStats );\n        writeGroup( *m_testGroups.back(), suiteTime );\n    }\n"
    },
    {
        "begin_line": 12280,
        "end_line": 12282,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunEndedCumulative",
        "snippet": "    void JunitReporter::testRunEndedCumulative() {\n        xml.endElement();\n    }\n"
    },
    {
        "begin_line": 12284,
        "end_line": 12304,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeGroup",
        "snippet": "    void JunitReporter::writeGroup( TestGroupNode const& groupNode, double suiteTime ) {\n        XmlWriter::ScopedElement e = xml.scopedElement( \"testsuite\" );\n        TestGroupStats const& stats = groupNode.value;\n        xml.writeAttribute( \"name\", stats.groupInfo.name );\n        xml.writeAttribute( \"errors\", unexpectedExceptions );\n        xml.writeAttribute( \"failures\", stats.totals.assertions.failed-unexpectedExceptions );\n        xml.writeAttribute( \"tests\", stats.totals.assertions.total() );\n        xml.writeAttribute( \"hostname\", \"tbd\" ); // !TBD\n        if( m_config->showDurations() == ShowDurations::Never )\n            xml.writeAttribute( \"time\", \"\" );\n        else\n            xml.writeAttribute( \"time\", suiteTime );\n        xml.writeAttribute( \"timestamp\", getCurrentTimestamp() );\n\n        // Write test cases\n        for( auto const& child : groupNode.children )\n            writeTestCase( *child );\n\n        xml.scopedElement( \"system-out\" ).writeText( trim( stdOutForSuite ), false );\n        xml.scopedElement( \"system-err\" ).writeText( trim( stdErrForSuite ), false );\n    }\n"
    },
    {
        "begin_line": 12306,
        "end_line": 12326,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeTestCase",
        "snippet": "    void JunitReporter::writeTestCase( TestCaseNode const& testCaseNode ) {\n        TestCaseStats const& stats = testCaseNode.value;\n\n        // All test cases have exactly one section - which represents the\n        // test case itself. That section may have 0-n nested sections\n        assert( testCaseNode.children.size() == 1 );\n        SectionNode const& rootSection = *testCaseNode.children.front();\n\n        std::string className = stats.testInfo.className;\n\n        if( className.empty() ) {\n            className = fileNameTag(stats.testInfo.tags);\n            if ( className.empty() )\n                className = \"global\";\n        }\n\n        if ( !m_config->name().empty() )\n            className = m_config->name() + \".\" + className;\n\n        writeSection( className, \"\", rootSection );\n    }\n"
    },
    {
        "begin_line": 12328,
        "end_line": 12361,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeSection",
        "snippet": "    void JunitReporter::writeSection(  std::string const& className,\n                        std::string const& rootName,\n                        SectionNode const& sectionNode ) {\n        std::string name = trim( sectionNode.stats.sectionInfo.name );\n        if( !rootName.empty() )\n            name = rootName + '/' + name;\n\n        if( !sectionNode.assertions.empty() ||\n            !sectionNode.stdOut.empty() ||\n            !sectionNode.stdErr.empty() ) {\n            XmlWriter::ScopedElement e = xml.scopedElement( \"testcase\" );\n            if( className.empty() ) {\n                xml.writeAttribute( \"classname\", name );\n                xml.writeAttribute( \"name\", \"root\" );\n            }\n            else {\n                xml.writeAttribute( \"classname\", className );\n                xml.writeAttribute( \"name\", name );\n            }\n            xml.writeAttribute( \"time\", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );\n\n            writeAssertions( sectionNode );\n\n            if( !sectionNode.stdOut.empty() )\n                xml.scopedElement( \"system-out\" ).writeText( trim( sectionNode.stdOut ), false );\n            if( !sectionNode.stdErr.empty() )\n                xml.scopedElement( \"system-err\" ).writeText( trim( sectionNode.stdErr ), false );\n        }\n        for( auto const& childNode : sectionNode.childSections )\n            if( className.empty() )\n                writeSection( name, \"\", *childNode );\n            else\n                writeSection( className, name, *childNode );\n    }\n"
    },
    {
        "begin_line": 12363,
        "end_line": 12366,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeAssertions",
        "snippet": "    void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {\n        for( auto const& assertion : sectionNode.assertions )\n            writeAssertion( assertion );\n    }\n"
    },
    {
        "begin_line": 12368,
        "end_line": 12413,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeAssertion",
        "snippet": "    void JunitReporter::writeAssertion( AssertionStats const& stats ) {\n        AssertionResult const& result = stats.assertionResult;\n        if( !result.isOk() ) {\n            std::string elementName;\n            switch( result.getResultType() ) {\n                case ResultWas::ThrewException:\n                case ResultWas::FatalErrorCondition:\n                    elementName = \"error\";\n                    break;\n                case ResultWas::ExplicitFailure:\n                    elementName = \"failure\";\n                    break;\n                case ResultWas::ExpressionFailed:\n                    elementName = \"failure\";\n                    break;\n                case ResultWas::DidntThrowException:\n                    elementName = \"failure\";\n                    break;\n\n                // We should never see these here:\n                case ResultWas::Info:\n                case ResultWas::Warning:\n                case ResultWas::Ok:\n                case ResultWas::Unknown:\n                case ResultWas::FailureBit:\n                case ResultWas::Exception:\n                    elementName = \"internalError\";\n                    break;\n            }\n\n            XmlWriter::ScopedElement e = xml.scopedElement( elementName );\n\n            xml.writeAttribute( \"message\", result.getExpandedExpression() );\n            xml.writeAttribute( \"type\", result.getTestMacroName() );\n\n            ReusableStringStream rss;\n            if( !result.getMessage().empty() )\n                rss << result.getMessage() << '\\n';\n            for( auto const& msg : stats.infoMessages )\n                if( msg.type == ResultWas::Info )\n                    rss << msg.message << '\\n';\n\n            rss << \"at \" << result.getSourceInfo();\n            xml.writeText( rss.str(), false );\n        }\n    }\n"
    },
    {
        "begin_line": 12421,
        "end_line": 12511,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n\n    void MultipleReporters::add( IStreamingReporterPtr&& reporter ) {\n        m_reporters.push_back( std::move( reporter ) );\n    }\n\n    ReporterPreferences MultipleReporters::getPreferences() const {\n        return m_reporters[0]->getPreferences();\n    }\n\n    std::set<Verbosity> MultipleReporters::getSupportedVerbosities() {\n        return std::set<Verbosity>{ };\n    }\n\n    void MultipleReporters::noMatchingTestCases( std::string const& spec ) {\n        for( auto const& reporter : m_reporters )\n            reporter->noMatchingTestCases( spec );\n    }\n\n    void MultipleReporters::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->benchmarkStarting( benchmarkInfo );\n    }\n    void MultipleReporters::benchmarkEnded( BenchmarkStats const& benchmarkStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->benchmarkEnded( benchmarkStats );\n    }\n\n    void MultipleReporters::testRunStarting( TestRunInfo const& testRunInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testRunStarting( testRunInfo );\n    }\n\n    void MultipleReporters::testGroupStarting( GroupInfo const& groupInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testGroupStarting( groupInfo );\n    }\n\n    void MultipleReporters::testCaseStarting( TestCaseInfo const& testInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testCaseStarting( testInfo );\n    }\n\n    void MultipleReporters::sectionStarting( SectionInfo const& sectionInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->sectionStarting( sectionInfo );\n    }\n\n    void MultipleReporters::assertionStarting( AssertionInfo const& assertionInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->assertionStarting( assertionInfo );\n    }\n\n    // The return value indicates if the messages buffer should be cleared:\n    bool MultipleReporters::assertionEnded( AssertionStats const& assertionStats ) {\n        bool clearBuffer = false;\n        for( auto const& reporter : m_reporters )\n            clearBuffer |= reporter->assertionEnded( assertionStats );\n        return clearBuffer;\n    }\n\n    void MultipleReporters::sectionEnded( SectionStats const& sectionStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->sectionEnded( sectionStats );\n    }\n\n    void MultipleReporters::testCaseEnded( TestCaseStats const& testCaseStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testCaseEnded( testCaseStats );\n    }\n\n    void MultipleReporters::testGroupEnded( TestGroupStats const& testGroupStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testGroupEnded( testGroupStats );\n    }\n\n    void MultipleReporters::testRunEnded( TestRunStats const& testRunStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testRunEnded( testRunStats );\n    }\n\n    void MultipleReporters::skipTest( TestCaseInfo const& testInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->skipTest( testInfo );\n    }\n\n    bool MultipleReporters::isMulti() const {\n        return true;\n    }\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 12423,
        "end_line": 12425,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "add",
        "snippet": "    void MultipleReporters::add( IStreamingReporterPtr&& reporter ) {\n        m_reporters.push_back( std::move( reporter ) );\n    }\n"
    },
    {
        "begin_line": 12427,
        "end_line": 12429,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getPreferences",
        "snippet": "    ReporterPreferences MultipleReporters::getPreferences() const {\n        return m_reporters[0]->getPreferences();\n    }\n"
    },
    {
        "begin_line": 12431,
        "end_line": 12433,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getSupportedVerbosities",
        "snippet": "    std::set<Verbosity> MultipleReporters::getSupportedVerbosities() {\n        return std::set<Verbosity>{ };\n    }\n"
    },
    {
        "begin_line": 12435,
        "end_line": 12438,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "noMatchingTestCases",
        "snippet": "    void MultipleReporters::noMatchingTestCases( std::string const& spec ) {\n        for( auto const& reporter : m_reporters )\n            reporter->noMatchingTestCases( spec );\n    }\n"
    },
    {
        "begin_line": 12440,
        "end_line": 12443,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkStarting",
        "snippet": "    void MultipleReporters::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->benchmarkStarting( benchmarkInfo );\n    }\n"
    },
    {
        "begin_line": 12444,
        "end_line": 12447,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "benchmarkEnded",
        "snippet": "    void MultipleReporters::benchmarkEnded( BenchmarkStats const& benchmarkStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->benchmarkEnded( benchmarkStats );\n    }\n"
    },
    {
        "begin_line": 12449,
        "end_line": 12452,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunStarting",
        "snippet": "    void MultipleReporters::testRunStarting( TestRunInfo const& testRunInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testRunStarting( testRunInfo );\n    }\n"
    },
    {
        "begin_line": 12454,
        "end_line": 12457,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupStarting",
        "snippet": "    void MultipleReporters::testGroupStarting( GroupInfo const& groupInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testGroupStarting( groupInfo );\n    }\n"
    },
    {
        "begin_line": 12459,
        "end_line": 12462,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseStarting",
        "snippet": "    void MultipleReporters::testCaseStarting( TestCaseInfo const& testInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testCaseStarting( testInfo );\n    }\n"
    },
    {
        "begin_line": 12464,
        "end_line": 12467,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionStarting",
        "snippet": "    void MultipleReporters::sectionStarting( SectionInfo const& sectionInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->sectionStarting( sectionInfo );\n    }\n"
    },
    {
        "begin_line": 12469,
        "end_line": 12472,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionStarting",
        "snippet": "    void MultipleReporters::assertionStarting( AssertionInfo const& assertionInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->assertionStarting( assertionInfo );\n    }\n"
    },
    {
        "begin_line": 12475,
        "end_line": 12480,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "    bool MultipleReporters::assertionEnded( AssertionStats const& assertionStats ) {\n        bool clearBuffer = false;\n        for( auto const& reporter : m_reporters )\n            clearBuffer |= reporter->assertionEnded( assertionStats );\n        return clearBuffer;\n    }\n"
    },
    {
        "begin_line": 12482,
        "end_line": 12485,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEnded",
        "snippet": "    void MultipleReporters::sectionEnded( SectionStats const& sectionStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->sectionEnded( sectionStats );\n    }\n"
    },
    {
        "begin_line": 12487,
        "end_line": 12490,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseEnded",
        "snippet": "    void MultipleReporters::testCaseEnded( TestCaseStats const& testCaseStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testCaseEnded( testCaseStats );\n    }\n"
    },
    {
        "begin_line": 12492,
        "end_line": 12495,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupEnded",
        "snippet": "    void MultipleReporters::testGroupEnded( TestGroupStats const& testGroupStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testGroupEnded( testGroupStats );\n    }\n"
    },
    {
        "begin_line": 12497,
        "end_line": 12500,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunEnded",
        "snippet": "    void MultipleReporters::testRunEnded( TestRunStats const& testRunStats ) {\n        for( auto const& reporter : m_reporters )\n            reporter->testRunEnded( testRunStats );\n    }\n"
    },
    {
        "begin_line": 12502,
        "end_line": 12505,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "skipTest",
        "snippet": "    void MultipleReporters::skipTest( TestCaseInfo const& testInfo ) {\n        for( auto const& reporter : m_reporters )\n            reporter->skipTest( testInfo );\n    }\n"
    },
    {
        "begin_line": 12507,
        "end_line": 12509,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "isMulti",
        "snippet": "    bool MultipleReporters::isMulti() const {\n        return true;\n    }\n"
    },
    {
        "begin_line": 12522,
        "end_line": 12719,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    XmlReporter::XmlReporter( ReporterConfig const& _config )\n    :   StreamingReporterBase( _config ),\n        m_xml(_config.stream())\n    {\n        m_reporterPrefs.shouldRedirectStdOut = true;\n    }\n\n    XmlReporter::~XmlReporter() = default;\n\n    std::string XmlReporter::getDescription() {\n        return \"Reports test results as an XML document\";\n    }\n\n    std::string XmlReporter::getStylesheetRef() const {\n        return std::string();\n    }\n\n    void XmlReporter::writeSourceInfo( SourceLineInfo const& sourceInfo ) {\n        m_xml\n            .writeAttribute( \"filename\", sourceInfo.file )\n            .writeAttribute( \"line\", sourceInfo.line );\n    }\n\n    void XmlReporter::noMatchingTestCases( std::string const& s ) {\n        StreamingReporterBase::noMatchingTestCases( s );\n    }\n\n    void XmlReporter::testRunStarting( TestRunInfo const& testInfo ) {\n        StreamingReporterBase::testRunStarting( testInfo );\n        std::string stylesheetRef = getStylesheetRef();\n        if( !stylesheetRef.empty() )\n            m_xml.writeStylesheetRef( stylesheetRef );\n        m_xml.startElement( \"Catch\" );\n        if( !m_config->name().empty() )\n            m_xml.writeAttribute( \"name\", m_config->name() );\n    }\n\n    void XmlReporter::testGroupStarting( GroupInfo const& groupInfo ) {\n        StreamingReporterBase::testGroupStarting( groupInfo );\n        m_xml.startElement( \"Group\" )\n            .writeAttribute( \"name\", groupInfo.name );\n    }\n\n    void XmlReporter::testCaseStarting( TestCaseInfo const& testInfo ) {\n        StreamingReporterBase::testCaseStarting(testInfo);\n        m_xml.startElement( \"TestCase\" )\n            .writeAttribute( \"name\", trim( testInfo.name ) )\n            .writeAttribute( \"description\", testInfo.description )\n            .writeAttribute( \"tags\", testInfo.tagsAsString() );\n\n        writeSourceInfo( testInfo.lineInfo );\n\n        if ( m_config->showDurations() == ShowDurations::Always )\n            m_testCaseTimer.start();\n        m_xml.ensureTagClosed();\n    }\n\n    void XmlReporter::sectionStarting( SectionInfo const& sectionInfo ) {\n        StreamingReporterBase::sectionStarting( sectionInfo );\n        if( m_sectionDepth++ > 0 ) {\n            m_xml.startElement( \"Section\" )\n                .writeAttribute( \"name\", trim( sectionInfo.name ) )\n                .writeAttribute( \"description\", sectionInfo.description );\n            writeSourceInfo( sectionInfo.lineInfo );\n            m_xml.ensureTagClosed();\n        }\n    }\n\n    void XmlReporter::assertionStarting( AssertionInfo const& ) { }\n\n    bool XmlReporter::assertionEnded( AssertionStats const& assertionStats ) {\n\n        AssertionResult const& result = assertionStats.assertionResult;\n\n        bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n\n        if( includeResults || result.getResultType() == ResultWas::Warning ) {\n            // Print any info messages in <Info> tags.\n            for( auto const& msg : assertionStats.infoMessages ) {\n                if( msg.type == ResultWas::Info && includeResults ) {\n                    m_xml.scopedElement( \"Info\" )\n                            .writeText( msg.message );\n                } else if ( msg.type == ResultWas::Warning ) {\n                    m_xml.scopedElement( \"Warning\" )\n                            .writeText( msg.message );\n                }\n            }\n        }\n\n        // Drop out if result was successful but we're not printing them.\n        if( !includeResults && result.getResultType() != ResultWas::Warning )\n            return true;\n\n        // Print the expression if there is one.\n        if( result.hasExpression() ) {\n            m_xml.startElement( \"Expression\" )\n                .writeAttribute( \"success\", result.succeeded() )\n                .writeAttribute( \"type\", result.getTestMacroName() );\n\n            writeSourceInfo( result.getSourceInfo() );\n\n            m_xml.scopedElement( \"Original\" )\n                .writeText( result.getExpression() );\n            m_xml.scopedElement( \"Expanded\" )\n                .writeText( result.getExpandedExpression() );\n        }\n\n        // And... Print a result applicable to each result type.\n        switch( result.getResultType() ) {\n            case ResultWas::ThrewException:\n                m_xml.startElement( \"Exception\" );\n                writeSourceInfo( result.getSourceInfo() );\n                m_xml.writeText( result.getMessage() );\n                m_xml.endElement();\n                break;\n            case ResultWas::FatalErrorCondition:\n                m_xml.startElement( \"FatalErrorCondition\" );\n                writeSourceInfo( result.getSourceInfo() );\n                m_xml.writeText( result.getMessage() );\n                m_xml.endElement();\n                break;\n            case ResultWas::Info:\n                m_xml.scopedElement( \"Info\" )\n                    .writeText( result.getMessage() );\n                break;\n            case ResultWas::Warning:\n                // Warning will already have been written\n                break;\n            case ResultWas::ExplicitFailure:\n                m_xml.startElement( \"Failure\" );\n                writeSourceInfo( result.getSourceInfo() );\n                m_xml.writeText( result.getMessage() );\n                m_xml.endElement();\n                break;\n            default:\n                break;\n        }\n\n        if( result.hasExpression() )\n            m_xml.endElement();\n\n        return true;\n    }\n\n    void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {\n        StreamingReporterBase::sectionEnded( sectionStats );\n        if( --m_sectionDepth > 0 ) {\n            XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResults\" );\n            e.writeAttribute( \"successes\", sectionStats.assertions.passed );\n            e.writeAttribute( \"failures\", sectionStats.assertions.failed );\n            e.writeAttribute( \"expectedFailures\", sectionStats.assertions.failedButOk );\n\n            if ( m_config->showDurations() == ShowDurations::Always )\n                e.writeAttribute( \"durationInSeconds\", sectionStats.durationInSeconds );\n\n            m_xml.endElement();\n        }\n    }\n\n    void XmlReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {\n        StreamingReporterBase::testCaseEnded( testCaseStats );\n        XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResult\" );\n        e.writeAttribute( \"success\", testCaseStats.totals.assertions.allOk() );\n\n        if ( m_config->showDurations() == ShowDurations::Always )\n            e.writeAttribute( \"durationInSeconds\", m_testCaseTimer.getElapsedSeconds() );\n\n        if( !testCaseStats.stdOut.empty() )\n            m_xml.scopedElement( \"StdOut\" ).writeText( trim( testCaseStats.stdOut ), false );\n        if( !testCaseStats.stdErr.empty() )\n            m_xml.scopedElement( \"StdErr\" ).writeText( trim( testCaseStats.stdErr ), false );\n\n        m_xml.endElement();\n    }\n\n    void XmlReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {\n        StreamingReporterBase::testGroupEnded( testGroupStats );\n        // TODO: Check testGroupStats.aborting and act accordingly.\n        m_xml.scopedElement( \"OverallResults\" )\n            .writeAttribute( \"successes\", testGroupStats.totals.assertions.passed )\n            .writeAttribute( \"failures\", testGroupStats.totals.assertions.failed )\n            .writeAttribute( \"expectedFailures\", testGroupStats.totals.assertions.failedButOk );\n        m_xml.endElement();\n    }\n\n    void XmlReporter::testRunEnded( TestRunStats const& testRunStats ) {\n        StreamingReporterBase::testRunEnded( testRunStats );\n        m_xml.scopedElement( \"OverallResults\" )\n            .writeAttribute( \"successes\", testRunStats.totals.assertions.passed )\n            .writeAttribute( \"failures\", testRunStats.totals.assertions.failed )\n            .writeAttribute( \"expectedFailures\", testRunStats.totals.assertions.failedButOk );\n        m_xml.endElement();\n    }\n\n    CATCH_REGISTER_REPORTER( \"xml\", XmlReporter )\n\n} // end namespace Catch\n"
    },
    {
        "begin_line": 12523,
        "end_line": 12528,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "XmlReporter",
        "snippet": "    XmlReporter::XmlReporter( ReporterConfig const& _config )\n    :   StreamingReporterBase( _config ),\n        m_xml(_config.stream())\n    {\n        m_reporterPrefs.shouldRedirectStdOut = true;\n    }\n"
    },
    {
        "begin_line": 12532,
        "end_line": 12534,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getDescription",
        "snippet": "    std::string XmlReporter::getDescription() {\n        return \"Reports test results as an XML document\";\n    }\n"
    },
    {
        "begin_line": 12536,
        "end_line": 12538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "getStylesheetRef",
        "snippet": "    std::string XmlReporter::getStylesheetRef() const {\n        return std::string();\n    }\n"
    },
    {
        "begin_line": 12540,
        "end_line": 12544,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "writeSourceInfo",
        "snippet": "    void XmlReporter::writeSourceInfo( SourceLineInfo const& sourceInfo ) {\n        m_xml\n            .writeAttribute( \"filename\", sourceInfo.file )\n            .writeAttribute( \"line\", sourceInfo.line );\n    }\n"
    },
    {
        "begin_line": 12546,
        "end_line": 12548,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "noMatchingTestCases",
        "snippet": "    void XmlReporter::noMatchingTestCases( std::string const& s ) {\n        StreamingReporterBase::noMatchingTestCases( s );\n    }\n"
    },
    {
        "begin_line": 12550,
        "end_line": 12558,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunStarting",
        "snippet": "    void XmlReporter::testRunStarting( TestRunInfo const& testInfo ) {\n        StreamingReporterBase::testRunStarting( testInfo );\n        std::string stylesheetRef = getStylesheetRef();\n        if( !stylesheetRef.empty() )\n            m_xml.writeStylesheetRef( stylesheetRef );\n        m_xml.startElement( \"Catch\" );\n        if( !m_config->name().empty() )\n            m_xml.writeAttribute( \"name\", m_config->name() );\n    }\n"
    },
    {
        "begin_line": 12560,
        "end_line": 12564,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupStarting",
        "snippet": "    void XmlReporter::testGroupStarting( GroupInfo const& groupInfo ) {\n        StreamingReporterBase::testGroupStarting( groupInfo );\n        m_xml.startElement( \"Group\" )\n            .writeAttribute( \"name\", groupInfo.name );\n    }\n"
    },
    {
        "begin_line": 12566,
        "end_line": 12578,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseStarting",
        "snippet": "    void XmlReporter::testCaseStarting( TestCaseInfo const& testInfo ) {\n        StreamingReporterBase::testCaseStarting(testInfo);\n        m_xml.startElement( \"TestCase\" )\n            .writeAttribute( \"name\", trim( testInfo.name ) )\n            .writeAttribute( \"description\", testInfo.description )\n            .writeAttribute( \"tags\", testInfo.tagsAsString() );\n\n        writeSourceInfo( testInfo.lineInfo );\n\n        if ( m_config->showDurations() == ShowDurations::Always )\n            m_testCaseTimer.start();\n        m_xml.ensureTagClosed();\n    }\n"
    },
    {
        "begin_line": 12580,
        "end_line": 12589,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionStarting",
        "snippet": "    void XmlReporter::sectionStarting( SectionInfo const& sectionInfo ) {\n        StreamingReporterBase::sectionStarting( sectionInfo );\n        if( m_sectionDepth++ > 0 ) {\n            m_xml.startElement( \"Section\" )\n                .writeAttribute( \"name\", trim( sectionInfo.name ) )\n                .writeAttribute( \"description\", sectionInfo.description );\n            writeSourceInfo( sectionInfo.lineInfo );\n            m_xml.ensureTagClosed();\n        }\n    }\n"
    },
    {
        "begin_line": 12591,
        "end_line": 12591,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionStarting",
        "snippet": "    void XmlReporter::assertionStarting( AssertionInfo const& ) { }\n"
    },
    {
        "begin_line": 12593,
        "end_line": 12665,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "assertionEnded",
        "snippet": "    bool XmlReporter::assertionEnded( AssertionStats const& assertionStats ) {\n\n        AssertionResult const& result = assertionStats.assertionResult;\n\n        bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n\n        if( includeResults || result.getResultType() == ResultWas::Warning ) {\n            // Print any info messages in <Info> tags.\n            for( auto const& msg : assertionStats.infoMessages ) {\n                if( msg.type == ResultWas::Info && includeResults ) {\n                    m_xml.scopedElement( \"Info\" )\n                            .writeText( msg.message );\n                } else if ( msg.type == ResultWas::Warning ) {\n                    m_xml.scopedElement( \"Warning\" )\n                            .writeText( msg.message );\n                }\n            }\n        }\n\n        // Drop out if result was successful but we're not printing them.\n        if( !includeResults && result.getResultType() != ResultWas::Warning )\n            return true;\n\n        // Print the expression if there is one.\n        if( result.hasExpression() ) {\n            m_xml.startElement( \"Expression\" )\n                .writeAttribute( \"success\", result.succeeded() )\n                .writeAttribute( \"type\", result.getTestMacroName() );\n\n            writeSourceInfo( result.getSourceInfo() );\n\n            m_xml.scopedElement( \"Original\" )\n                .writeText( result.getExpression() );\n            m_xml.scopedElement( \"Expanded\" )\n                .writeText( result.getExpandedExpression() );\n        }\n\n        // And... Print a result applicable to each result type.\n        switch( result.getResultType() ) {\n            case ResultWas::ThrewException:\n                m_xml.startElement( \"Exception\" );\n                writeSourceInfo( result.getSourceInfo() );\n                m_xml.writeText( result.getMessage() );\n                m_xml.endElement();\n                break;\n            case ResultWas::FatalErrorCondition:\n                m_xml.startElement( \"FatalErrorCondition\" );\n                writeSourceInfo( result.getSourceInfo() );\n                m_xml.writeText( result.getMessage() );\n                m_xml.endElement();\n                break;\n            case ResultWas::Info:\n                m_xml.scopedElement( \"Info\" )\n                    .writeText( result.getMessage() );\n                break;\n            case ResultWas::Warning:\n                // Warning will already have been written\n                break;\n            case ResultWas::ExplicitFailure:\n                m_xml.startElement( \"Failure\" );\n                writeSourceInfo( result.getSourceInfo() );\n                m_xml.writeText( result.getMessage() );\n                m_xml.endElement();\n                break;\n            default:\n                break;\n        }\n\n        if( result.hasExpression() )\n            m_xml.endElement();\n\n        return true;\n    }\n"
    },
    {
        "begin_line": 12667,
        "end_line": 12680,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "sectionEnded",
        "snippet": "    void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {\n        StreamingReporterBase::sectionEnded( sectionStats );\n        if( --m_sectionDepth > 0 ) {\n            XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResults\" );\n            e.writeAttribute( \"successes\", sectionStats.assertions.passed );\n            e.writeAttribute( \"failures\", sectionStats.assertions.failed );\n            e.writeAttribute( \"expectedFailures\", sectionStats.assertions.failedButOk );\n\n            if ( m_config->showDurations() == ShowDurations::Always )\n                e.writeAttribute( \"durationInSeconds\", sectionStats.durationInSeconds );\n\n            m_xml.endElement();\n        }\n    }\n"
    },
    {
        "begin_line": 12682,
        "end_line": 12696,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testCaseEnded",
        "snippet": "    void XmlReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {\n        StreamingReporterBase::testCaseEnded( testCaseStats );\n        XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResult\" );\n        e.writeAttribute( \"success\", testCaseStats.totals.assertions.allOk() );\n\n        if ( m_config->showDurations() == ShowDurations::Always )\n            e.writeAttribute( \"durationInSeconds\", m_testCaseTimer.getElapsedSeconds() );\n\n        if( !testCaseStats.stdOut.empty() )\n            m_xml.scopedElement( \"StdOut\" ).writeText( trim( testCaseStats.stdOut ), false );\n        if( !testCaseStats.stdErr.empty() )\n            m_xml.scopedElement( \"StdErr\" ).writeText( trim( testCaseStats.stdErr ), false );\n\n        m_xml.endElement();\n    }\n"
    },
    {
        "begin_line": 12698,
        "end_line": 12706,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testGroupEnded",
        "snippet": "    void XmlReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {\n        StreamingReporterBase::testGroupEnded( testGroupStats );\n        // TODO: Check testGroupStats.aborting and act accordingly.\n        m_xml.scopedElement( \"OverallResults\" )\n            .writeAttribute( \"successes\", testGroupStats.totals.assertions.passed )\n            .writeAttribute( \"failures\", testGroupStats.totals.assertions.failed )\n            .writeAttribute( \"expectedFailures\", testGroupStats.totals.assertions.failedButOk );\n        m_xml.endElement();\n    }\n"
    },
    {
        "begin_line": 12708,
        "end_line": 12715,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "testRunEnded",
        "snippet": "    void XmlReporter::testRunEnded( TestRunStats const& testRunStats ) {\n        StreamingReporterBase::testRunEnded( testRunStats );\n        m_xml.scopedElement( \"OverallResults\" )\n            .writeAttribute( \"successes\", testRunStats.totals.assertions.passed )\n            .writeAttribute( \"failures\", testRunStats.totals.assertions.failed )\n            .writeAttribute( \"expectedFailures\", testRunStats.totals.assertions.failedButOk );\n        m_xml.endElement();\n    }\n"
    },
    {
        "begin_line": 12726,
        "end_line": 12728,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "Catch",
        "snippet": "namespace Catch {\n    LeakDetector leakDetector;\n}\n"
    },
    {
        "begin_line": 12727,
        "end_line": 12727,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "leakDetector",
        "snippet": "    LeakDetector leakDetector;\n"
    },
    {
        "begin_line": 12744,
        "end_line": 12751,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "wmain",
        "snippet": "extern \"C\" int wmain (int argc, wchar_t * argv[], wchar_t * []) {\n#else\n// Standard C/C++ main entry point\nint main (int argc, char * argv[]) {\n#endif\n\n    return Catch::Session().run( argc, argv );\n}\n"
    },
    {
        "begin_line": 12756,
        "end_line": 12769,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "main",
        "snippet": "int main (int argc, char * const argv[]) {\n#if !CATCH_ARC_ENABLED\n    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n#endif\n\n    Catch::registerTestMethods();\n    int result = Catch::Session().run( argc, (char**)argv );\n\n#if !CATCH_ARC_ENABLED\n    [pool drain];\n#endif\n\n    return result;\n}\n"
    },
    {
        "begin_line": 12787,
        "end_line": 12787,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE",
        "snippet": "#define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( \"CATCH_REQUIRE\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12788,
        "end_line": 12788,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_FALSE",
        "snippet": "#define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( \"CATCH_REQUIRE_FALSE\", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12790,
        "end_line": 12790,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS",
        "snippet": "#define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( \"CATCH_REQUIRE_THROWS\", Catch::ResultDisposition::Normal, \"\", __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12791,
        "end_line": 12791,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS_AS",
        "snippet": "#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"CATCH_REQUIRE_THROWS_AS\", exceptionType, Catch::ResultDisposition::Normal, expr )\n"
    },
    {
        "begin_line": 12792,
        "end_line": 12792,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS_WITH",
        "snippet": "#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( \"CATCH_REQUIRE_THROWS_WITH\", Catch::ResultDisposition::Normal, matcher, expr )\n"
    },
    {
        "begin_line": 12794,
        "end_line": 12794,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS_MATCHES",
        "snippet": "#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( \"CATCH_REQUIRE_THROWS_MATCHES\", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )\n"
    },
    {
        "begin_line": 12796,
        "end_line": 12796,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_NOTHROW",
        "snippet": "#define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"CATCH_REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12798,
        "end_line": 12798,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK",
        "snippet": "#define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12799,
        "end_line": 12799,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_FALSE",
        "snippet": "#define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12800,
        "end_line": 12800,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECKED_IF",
        "snippet": "#define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12801,
        "end_line": 12801,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECKED_ELSE",
        "snippet": "#define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12802,
        "end_line": 12802,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_NOFAIL",
        "snippet": "#define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12804,
        "end_line": 12804,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS",
        "snippet": "#define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CATCH_CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, \"\", __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12805,
        "end_line": 12805,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS_AS",
        "snippet": "#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"CATCH_CHECK_THROWS_AS\", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )\n"
    },
    {
        "begin_line": 12806,
        "end_line": 12806,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS_WITH",
        "snippet": "#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( \"CATCH_CHECK_THROWS_WITH\", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\n"
    },
    {
        "begin_line": 12808,
        "end_line": 12808,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS_MATCHES",
        "snippet": "#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( \"CATCH_CHECK_THROWS_MATCHES\", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\n"
    },
    {
        "begin_line": 12810,
        "end_line": 12810,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_NOTHROW",
        "snippet": "#define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"CATCH_CHECK_NOTHROW\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12813,
        "end_line": 12813,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THAT",
        "snippet": "#define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"CATCH_CHECK_THAT\", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )\n"
    },
    {
        "begin_line": 12815,
        "end_line": 12815,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THAT",
        "snippet": "#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"CATCH_REQUIRE_THAT\", matcher, Catch::ResultDisposition::Normal, arg )\n"
    },
    {
        "begin_line": 12818,
        "end_line": 12818,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INFO",
        "snippet": "#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( \"CATCH_INFO\", msg )\n"
    },
    {
        "begin_line": 12819,
        "end_line": 12819,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_WARN",
        "snippet": "#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( \"CATCH_WARN\", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )\n"
    },
    {
        "begin_line": 12820,
        "end_line": 12820,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CAPTURE",
        "snippet": "#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( \"CATCH_CAPTURE\", #msg \" := \" << ::Catch::Detail::stringify(msg) )\n"
    },
    {
        "begin_line": 12822,
        "end_line": 12822,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TEST_CASE",
        "snippet": "#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12823,
        "end_line": 12823,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TEST_CASE_METHOD",
        "snippet": "#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12824,
        "end_line": 12824,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_METHOD_AS_TEST_CASE",
        "snippet": "#define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12825,
        "end_line": 12825,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REGISTER_TEST_CASE",
        "snippet": "#define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12826,
        "end_line": 12826,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SECTION",
        "snippet": "#define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12827,
        "end_line": 12827,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_FAIL",
        "snippet": "#define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12828,
        "end_line": 12828,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_FAIL_CHECK",
        "snippet": "#define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12829,
        "end_line": 12829,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SUCCEED",
        "snippet": "#define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( \"CATCH_SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12831,
        "end_line": 12831,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ANON_TEST_CASE",
        "snippet": "#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()\n"
    },
    {
        "begin_line": 12834,
        "end_line": 12834,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SCENARIO",
        "snippet": "#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12835,
        "end_line": 12835,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SCENARIO_METHOD",
        "snippet": "#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12836,
        "end_line": 12836,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_GIVEN",
        "snippet": "#define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( \"Given: \") + desc )\n"
    },
    {
        "begin_line": 12837,
        "end_line": 12837,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_WHEN",
        "snippet": "#define CATCH_WHEN( desc )     CATCH_SECTION( std::string( \" When: \") + desc )\n"
    },
    {
        "begin_line": 12838,
        "end_line": 12838,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_AND_WHEN",
        "snippet": "#define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( \"  And: \") + desc )\n"
    },
    {
        "begin_line": 12839,
        "end_line": 12839,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_THEN",
        "snippet": "#define CATCH_THEN( desc )     CATCH_SECTION( std::string( \" Then: \") + desc )\n"
    },
    {
        "begin_line": 12840,
        "end_line": 12840,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_AND_THEN",
        "snippet": "#define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( \"  And: \") + desc )\n"
    },
    {
        "begin_line": 12845,
        "end_line": 12845,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE",
        "snippet": "#define REQUIRE( ... ) INTERNAL_CATCH_TEST( \"REQUIRE\", Catch::ResultDisposition::Normal, __VA_ARGS__  )\n"
    },
    {
        "begin_line": 12846,
        "end_line": 12846,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_FALSE",
        "snippet": "#define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( \"REQUIRE_FALSE\", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12848,
        "end_line": 12848,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS",
        "snippet": "#define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( \"REQUIRE_THROWS\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12849,
        "end_line": 12849,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS_AS",
        "snippet": "#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"REQUIRE_THROWS_AS\", exceptionType, Catch::ResultDisposition::Normal, expr )\n"
    },
    {
        "begin_line": 12850,
        "end_line": 12850,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS_WITH",
        "snippet": "#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( \"REQUIRE_THROWS_WITH\", Catch::ResultDisposition::Normal, matcher, expr )\n"
    },
    {
        "begin_line": 12852,
        "end_line": 12852,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS_MATCHES",
        "snippet": "#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( \"REQUIRE_THROWS_MATCHES\", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )\n"
    },
    {
        "begin_line": 12854,
        "end_line": 12854,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_NOTHROW",
        "snippet": "#define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12856,
        "end_line": 12856,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK",
        "snippet": "#define CHECK( ... ) INTERNAL_CATCH_TEST( \"CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12857,
        "end_line": 12857,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_FALSE",
        "snippet": "#define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12858,
        "end_line": 12858,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECKED_IF",
        "snippet": "#define CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12859,
        "end_line": 12859,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECKED_ELSE",
        "snippet": "#define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12860,
        "end_line": 12860,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_NOFAIL",
        "snippet": "#define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12862,
        "end_line": 12862,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS",
        "snippet": "#define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12863,
        "end_line": 12863,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS_AS",
        "snippet": "#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"CHECK_THROWS_AS\", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )\n"
    },
    {
        "begin_line": 12864,
        "end_line": 12864,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS_WITH",
        "snippet": "#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( \"CHECK_THROWS_WITH\", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\n"
    },
    {
        "begin_line": 12866,
        "end_line": 12866,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS_MATCHES",
        "snippet": "#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( \"CHECK_THROWS_MATCHES\", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\n"
    },
    {
        "begin_line": 12868,
        "end_line": 12868,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_NOTHROW",
        "snippet": "#define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"CHECK_NOTHROW\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12871,
        "end_line": 12871,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THAT",
        "snippet": "#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"CHECK_THAT\", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )\n"
    },
    {
        "begin_line": 12873,
        "end_line": 12873,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THAT",
        "snippet": "#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"REQUIRE_THAT\", matcher, Catch::ResultDisposition::Normal, arg )\n"
    },
    {
        "begin_line": 12876,
        "end_line": 12876,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INFO",
        "snippet": "#define INFO( msg ) INTERNAL_CATCH_INFO( \"INFO\", msg )\n"
    },
    {
        "begin_line": 12877,
        "end_line": 12877,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WARN",
        "snippet": "#define WARN( msg ) INTERNAL_CATCH_MSG( \"WARN\", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )\n"
    },
    {
        "begin_line": 12878,
        "end_line": 12878,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CAPTURE",
        "snippet": "#define CAPTURE( msg ) INTERNAL_CATCH_INFO( \"CAPTURE\", #msg \" := \" << ::Catch::Detail::stringify(msg) )\n"
    },
    {
        "begin_line": 12880,
        "end_line": 12880,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TEST_CASE",
        "snippet": "#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12881,
        "end_line": 12881,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TEST_CASE_METHOD",
        "snippet": "#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12882,
        "end_line": 12882,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "METHOD_AS_TEST_CASE",
        "snippet": "#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12883,
        "end_line": 12883,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REGISTER_TEST_CASE",
        "snippet": "#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12884,
        "end_line": 12884,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SECTION",
        "snippet": "#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12885,
        "end_line": 12885,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FAIL",
        "snippet": "#define FAIL( ... ) INTERNAL_CATCH_MSG( \"FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12886,
        "end_line": 12886,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FAIL_CHECK",
        "snippet": "#define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12887,
        "end_line": 12887,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SUCCEED",
        "snippet": "#define SUCCEED( ... ) INTERNAL_CATCH_MSG( \"SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12888,
        "end_line": 12888,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ANON_TEST_CASE",
        "snippet": "#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()\n"
    },
    {
        "begin_line": 12892,
        "end_line": 12892,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TRANSLATE_EXCEPTION",
        "snippet": "#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )\n"
    },
    {
        "begin_line": 12895,
        "end_line": 12895,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SCENARIO",
        "snippet": "#define SCENARIO( ... ) TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12896,
        "end_line": 12896,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SCENARIO_METHOD",
        "snippet": "#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n"
    },
    {
        "begin_line": 12898,
        "end_line": 12898,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "GIVEN",
        "snippet": "#define GIVEN( desc )    SECTION( std::string(\"   Given: \") + desc )\n"
    },
    {
        "begin_line": 12899,
        "end_line": 12899,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WHEN",
        "snippet": "#define WHEN( desc )     SECTION( std::string(\"    When: \") + desc )\n"
    },
    {
        "begin_line": 12900,
        "end_line": 12900,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AND_WHEN",
        "snippet": "#define AND_WHEN( desc ) SECTION( std::string(\"And when: \") + desc )\n"
    },
    {
        "begin_line": 12901,
        "end_line": 12901,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "THEN",
        "snippet": "#define THEN( desc )     SECTION( std::string(\"    Then: \") + desc )\n"
    },
    {
        "begin_line": 12902,
        "end_line": 12902,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AND_THEN",
        "snippet": "#define AND_THEN( desc ) SECTION( std::string(\"     And: \") + desc )\n"
    },
    {
        "begin_line": 12911,
        "end_line": 12911,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE",
        "snippet": "#define CATCH_REQUIRE( ... )        (void)(0)\n"
    },
    {
        "begin_line": 12912,
        "end_line": 12912,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_FALSE",
        "snippet": "#define CATCH_REQUIRE_FALSE( ... )  (void)(0)\n"
    },
    {
        "begin_line": 12914,
        "end_line": 12914,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS",
        "snippet": "#define CATCH_REQUIRE_THROWS( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12915,
        "end_line": 12915,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS_AS",
        "snippet": "#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)\n"
    },
    {
        "begin_line": 12916,
        "end_line": 12916,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS_WITH",
        "snippet": "#define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)\n"
    },
    {
        "begin_line": 12918,
        "end_line": 12918,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THROWS_MATCHES",
        "snippet": "#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12920,
        "end_line": 12920,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_NOTHROW",
        "snippet": "#define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12922,
        "end_line": 12922,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK",
        "snippet": "#define CATCH_CHECK( ... )         (void)(0)\n"
    },
    {
        "begin_line": 12923,
        "end_line": 12923,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_FALSE",
        "snippet": "#define CATCH_CHECK_FALSE( ... )   (void)(0)\n"
    },
    {
        "begin_line": 12924,
        "end_line": 12924,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECKED_IF",
        "snippet": "#define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)\n"
    },
    {
        "begin_line": 12925,
        "end_line": 12925,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECKED_ELSE",
        "snippet": "#define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))\n"
    },
    {
        "begin_line": 12926,
        "end_line": 12926,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_NOFAIL",
        "snippet": "#define CATCH_CHECK_NOFAIL( ... )  (void)(0)\n"
    },
    {
        "begin_line": 12928,
        "end_line": 12928,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS",
        "snippet": "#define CATCH_CHECK_THROWS( ... )  (void)(0)\n"
    },
    {
        "begin_line": 12929,
        "end_line": 12929,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS_AS",
        "snippet": "#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)\n"
    },
    {
        "begin_line": 12930,
        "end_line": 12930,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS_WITH",
        "snippet": "#define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)\n"
    },
    {
        "begin_line": 12932,
        "end_line": 12932,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THROWS_MATCHES",
        "snippet": "#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12934,
        "end_line": 12934,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_NOTHROW",
        "snippet": "#define CATCH_CHECK_NOTHROW( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12937,
        "end_line": 12937,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CHECK_THAT",
        "snippet": "#define CATCH_CHECK_THAT( arg, matcher )   (void)(0)\n"
    },
    {
        "begin_line": 12939,
        "end_line": 12939,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REQUIRE_THAT",
        "snippet": "#define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12942,
        "end_line": 12942,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_INFO",
        "snippet": "#define CATCH_INFO( msg )    (void)(0)\n"
    },
    {
        "begin_line": 12943,
        "end_line": 12943,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_WARN",
        "snippet": "#define CATCH_WARN( msg )    (void)(0)\n"
    },
    {
        "begin_line": 12944,
        "end_line": 12944,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_CAPTURE",
        "snippet": "#define CATCH_CAPTURE( msg ) (void)(0)\n"
    },
    {
        "begin_line": 12946,
        "end_line": 12946,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TEST_CASE",
        "snippet": "#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n"
    },
    {
        "begin_line": 12947,
        "end_line": 12947,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TEST_CASE_METHOD",
        "snippet": "#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n"
    },
    {
        "begin_line": 12948,
        "end_line": 12948,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_METHOD_AS_TEST_CASE",
        "snippet": "#define CATCH_METHOD_AS_TEST_CASE( method, ... )\n"
    },
    {
        "begin_line": 12949,
        "end_line": 12949,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_REGISTER_TEST_CASE",
        "snippet": "#define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)\n"
    },
    {
        "begin_line": 12950,
        "end_line": 12950,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SECTION",
        "snippet": "#define CATCH_SECTION( ... )\n"
    },
    {
        "begin_line": 12951,
        "end_line": 12951,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_FAIL",
        "snippet": "#define CATCH_FAIL( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12952,
        "end_line": 12952,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_FAIL_CHECK",
        "snippet": "#define CATCH_FAIL_CHECK( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12953,
        "end_line": 12953,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SUCCEED",
        "snippet": "#define CATCH_SUCCEED( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12955,
        "end_line": 12955,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_ANON_TEST_CASE",
        "snippet": "#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n"
    },
    {
        "begin_line": 12958,
        "end_line": 12958,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SCENARIO",
        "snippet": "#define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n"
    },
    {
        "begin_line": 12959,
        "end_line": 12959,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_SCENARIO_METHOD",
        "snippet": "#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n"
    },
    {
        "begin_line": 12960,
        "end_line": 12960,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_GIVEN",
        "snippet": "#define CATCH_GIVEN( desc )\n"
    },
    {
        "begin_line": 12961,
        "end_line": 12961,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_WHEN",
        "snippet": "#define CATCH_WHEN( desc )\n"
    },
    {
        "begin_line": 12962,
        "end_line": 12962,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_AND_WHEN",
        "snippet": "#define CATCH_AND_WHEN( desc )\n"
    },
    {
        "begin_line": 12963,
        "end_line": 12963,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_THEN",
        "snippet": "#define CATCH_THEN( desc )\n"
    },
    {
        "begin_line": 12964,
        "end_line": 12964,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_AND_THEN",
        "snippet": "#define CATCH_AND_THEN( desc )\n"
    },
    {
        "begin_line": 12969,
        "end_line": 12969,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE",
        "snippet": "#define REQUIRE( ... )       (void)(0)\n"
    },
    {
        "begin_line": 12970,
        "end_line": 12970,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_FALSE",
        "snippet": "#define REQUIRE_FALSE( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12972,
        "end_line": 12972,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS",
        "snippet": "#define REQUIRE_THROWS( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12973,
        "end_line": 12973,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS_AS",
        "snippet": "#define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)\n"
    },
    {
        "begin_line": 12974,
        "end_line": 12974,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS_WITH",
        "snippet": "#define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12976,
        "end_line": 12976,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THROWS_MATCHES",
        "snippet": "#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12978,
        "end_line": 12978,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_NOTHROW",
        "snippet": "#define REQUIRE_NOTHROW( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12980,
        "end_line": 12980,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK",
        "snippet": "#define CHECK( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12981,
        "end_line": 12981,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_FALSE",
        "snippet": "#define CHECK_FALSE( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12982,
        "end_line": 12982,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECKED_IF",
        "snippet": "#define CHECKED_IF( ... ) if (__VA_ARGS__)\n"
    },
    {
        "begin_line": 12983,
        "end_line": 12983,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECKED_ELSE",
        "snippet": "#define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))\n"
    },
    {
        "begin_line": 12984,
        "end_line": 12984,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_NOFAIL",
        "snippet": "#define CHECK_NOFAIL( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12986,
        "end_line": 12986,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS",
        "snippet": "#define CHECK_THROWS( ... )  (void)(0)\n"
    },
    {
        "begin_line": 12987,
        "end_line": 12987,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS_AS",
        "snippet": "#define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)\n"
    },
    {
        "begin_line": 12988,
        "end_line": 12988,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS_WITH",
        "snippet": "#define CHECK_THROWS_WITH( expr, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12990,
        "end_line": 12990,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THROWS_MATCHES",
        "snippet": "#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12992,
        "end_line": 12992,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_NOTHROW",
        "snippet": "#define CHECK_NOTHROW( ... ) (void)(0)\n"
    },
    {
        "begin_line": 12995,
        "end_line": 12995,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CHECK_THAT",
        "snippet": "#define CHECK_THAT( arg, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 12997,
        "end_line": 12997,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REQUIRE_THAT",
        "snippet": "#define REQUIRE_THAT( arg, matcher ) (void)(0)\n"
    },
    {
        "begin_line": 13000,
        "end_line": 13000,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "INFO",
        "snippet": "#define INFO( msg ) (void)(0)\n"
    },
    {
        "begin_line": 13001,
        "end_line": 13001,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WARN",
        "snippet": "#define WARN( msg ) (void)(0)\n"
    },
    {
        "begin_line": 13002,
        "end_line": 13002,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CAPTURE",
        "snippet": "#define CAPTURE( msg ) (void)(0)\n"
    },
    {
        "begin_line": 13004,
        "end_line": 13004,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TEST_CASE",
        "snippet": "#define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n"
    },
    {
        "begin_line": 13005,
        "end_line": 13005,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "TEST_CASE_METHOD",
        "snippet": "#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n"
    },
    {
        "begin_line": 13006,
        "end_line": 13006,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "METHOD_AS_TEST_CASE",
        "snippet": "#define METHOD_AS_TEST_CASE( method, ... )\n"
    },
    {
        "begin_line": 13007,
        "end_line": 13007,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "REGISTER_TEST_CASE",
        "snippet": "#define REGISTER_TEST_CASE( Function, ... ) (void)(0)\n"
    },
    {
        "begin_line": 13008,
        "end_line": 13008,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SECTION",
        "snippet": "#define SECTION( ... )\n"
    },
    {
        "begin_line": 13009,
        "end_line": 13009,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FAIL",
        "snippet": "#define FAIL( ... ) (void)(0)\n"
    },
    {
        "begin_line": 13010,
        "end_line": 13010,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "FAIL_CHECK",
        "snippet": "#define FAIL_CHECK( ... ) (void)(0)\n"
    },
    {
        "begin_line": 13011,
        "end_line": 13011,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SUCCEED",
        "snippet": "#define SUCCEED( ... ) (void)(0)\n"
    },
    {
        "begin_line": 13012,
        "end_line": 13012,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "ANON_TEST_CASE",
        "snippet": "#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n"
    },
    {
        "begin_line": 13016,
        "end_line": 13016,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "CATCH_TRANSLATE_EXCEPTION",
        "snippet": "#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )\n"
    },
    {
        "begin_line": 13019,
        "end_line": 13019,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SCENARIO",
        "snippet": "#define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )\n"
    },
    {
        "begin_line": 13020,
        "end_line": 13020,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "SCENARIO_METHOD",
        "snippet": "#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n"
    },
    {
        "begin_line": 13022,
        "end_line": 13022,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "GIVEN",
        "snippet": "#define GIVEN( desc )\n"
    },
    {
        "begin_line": 13023,
        "end_line": 13023,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "WHEN",
        "snippet": "#define WHEN( desc )\n"
    },
    {
        "begin_line": 13024,
        "end_line": 13024,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AND_WHEN",
        "snippet": "#define AND_WHEN( desc )\n"
    },
    {
        "begin_line": 13025,
        "end_line": 13025,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "THEN",
        "snippet": "#define THEN( desc )\n"
    },
    {
        "begin_line": 13026,
        "end_line": 13026,
        "file_name": "./proj/cpp_peglib/buggy-1/test/catch.hh",
        "func_name": "AND_THEN",
        "snippet": "#define AND_THEN( desc )\n"
    },
    {
        "begin_line": 9,
        "end_line": 12,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(\n        u8\" ROOT \u2190 _ \"\n        \" _ <- ' ' \"\n    );\n"
    },
    {
        "begin_line": 14,
        "end_line": 14,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 21,
        "end_line": 24,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT <- _\n        _ <- ' '\n    )\");\n"
    },
    {
        "begin_line": 26,
        "end_line": 26,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 32,
        "end_line": 32,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(\"\");\n"
    },
    {
        "begin_line": 33,
        "end_line": 33,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 39,
        "end_line": 42,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n"
    },
    {
        "begin_line": 44,
        "end_line": 44,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 50,
        "end_line": 53,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT <- _\n        _ <- '\\\\'\n    )\");\n"
    },
    {
        "begin_line": 55,
        "end_line": 55,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 61,
        "end_line": 64,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT <- _\n        _ <- '\\'\n    )\");\n"
    },
    {
        "begin_line": 66,
        "end_line": 66,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 72,
        "end_line": 75,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT <- TEXT\n        TEXT <- [a-zA-Z]+\n    )\");\n"
    },
    {
        "begin_line": 77,
        "end_line": 81,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0102",
        "snippet": "    parser[\"ROOT\"] = [&](SemanticValues& sv) {\n        auto s = any_cast<std::string>(sv[0]);\n        s[0] = 'H'; // mutate\n        return std::string(std::move(s)); // move\n    };\n"
    },
    {
        "begin_line": 83,
        "end_line": 85,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0202",
        "snippet": "    parser[\"TEXT\"] = [&](SemanticValues& sv) {\n        return sv.token();\n    };\n"
    },
    {
        "begin_line": 87,
        "end_line": 87,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "val",
        "snippet": "    std::string val;\n"
    },
    {
        "begin_line": 88,
        "end_line": 88,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"hello\", val);\n"
    },
    {
        "begin_line": 95,
        "end_line": 99,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT      <-  _ ('[' TAG_NAME ']' _)*\n        TAG_NAME  <-  (!']' .)+\n        _         <-  [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 101,
        "end_line": 101,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "tags",
        "snippet": "    std::vector<std::string> tags;\n"
    },
    {
        "begin_line": 103,
        "end_line": 105,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0302",
        "snippet": "    parser[\"TAG_NAME\"] = [&](const SemanticValues& sv) {\n        tags.push_back(sv.str());\n    };\n"
    },
    {
        "begin_line": 107,
        "end_line": 107,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\" [tag1] [tag:2] [tag-3] \");\n"
    },
    {
        "begin_line": 120,
        "end_line": 120,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "tags",
        "snippet": "    std::vector<std::string> tags;\n"
    },
    {
        "begin_line": 122,
        "end_line": 122,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ROOT",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 122,
        "end_line": 122,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "TAG",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 122,
        "end_line": 122,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "TAG_NAME",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 122,
        "end_line": 122,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "WS",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 125,
        "end_line": 125,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0402",
        "snippet": "    TAG_NAME <= oom(seq(npd(chr(']')), dot())), [&](const SemanticValues& sv) { tags.push_back(sv.str()); };\n"
    },
    {
        "begin_line": 128,
        "end_line": 128,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "r",
        "snippet": "    auto r = ROOT.parse(\" [tag1] [tag:2] [tag-3] \");\n"
    },
    {
        "begin_line": 139,
        "end_line": 143,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        ROOT  <- _ TOKEN*\n        TOKEN <- '[' < (!']' .)+ > ']' _\n        _     <- [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 146,
        "end_line": 146,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "tags",
        "snippet": "    std::vector<std::string> tags;\n"
    },
    {
        "begin_line": 148,
        "end_line": 150,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0502",
        "snippet": "    pg[\"TOKEN\"] = [&](const SemanticValues& sv) {\n        tags.push_back(sv.token());\n    };\n"
    },
    {
        "begin_line": 152,
        "end_line": 152,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = pg.parse(\" [tag1] [tag:2] [tag-3] \");\n"
    },
    {
        "begin_line": 163,
        "end_line": 163,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "PARENT",
        "snippet": "    Definition PARENT;\n"
    },
    {
        "begin_line": 164,
        "end_line": 164,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "CHILD",
        "snippet": "    Definition CHILD;\n"
    },
    {
        "begin_line": 172,
        "end_line": 172,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ROOT",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 172,
        "end_line": 172,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "TAG",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 172,
        "end_line": 172,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "TAG_NAME",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 172,
        "end_line": 172,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "WS",
        "snippet": "    Definition ROOT, TAG, TAG_NAME, WS;\n"
    },
    {
        "begin_line": 179,
        "end_line": 179,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "defIds",
        "snippet": "    AssignIDToDefinition defIds;\n"
    },
    {
        "begin_line": 187,
        "end_line": 195,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _\n        TERM_OPERATOR    <-  < [-+] > _\n        FACTOR_OPERATOR  <-  < [/*] > _\n        NUMBER           <-  < [0-9]+ > _\n        _                <-  [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 206,
        "end_line": 209,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n       START <- (CHAR)*\n       CHAR  <- .\n    )\");\n"
    },
    {
        "begin_line": 211,
        "end_line": 211,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ss",
        "snippet": "    std::string ss;\n"
    },
    {
        "begin_line": 212,
        "end_line": 214,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0602",
        "snippet": "    parser[\"CHAR\"] = [&](const SemanticValues& sv) {\n        ss += *sv.c_str();\n    };\n"
    },
    {
        "begin_line": 216,
        "end_line": 216,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser.parse(\"hello\");\n"
    },
    {
        "begin_line": 223,
        "end_line": 228,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START  <- LTOKEN '=' RTOKEN\n        LTOKEN <- TOKEN\n        RTOKEN <- TOKEN\n        TOKEN  <- [A-Za-z]+\n    )\");\n"
    },
    {
        "begin_line": 230,
        "end_line": 233,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0702",
        "snippet": "    parser[\"LTOKEN\"].enter = [&](const char*, size_t, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        require_upper_case = false;\n    };\n"
    },
    {
        "begin_line": 234,
        "end_line": 237,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0802",
        "snippet": "    parser[\"LTOKEN\"].leave = [&](const char*, size_t, size_t, any&, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        require_upper_case = true;\n    };\n"
    },
    {
        "begin_line": 239,
        "end_line": 239,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "message",
        "snippet": "    auto message = \"should be upper case string...\";\n"
    },
    {
        "begin_line": 241,
        "end_line": 249,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0902",
        "snippet": "    parser[\"TOKEN\"] = [&](const SemanticValues& sv, any& dt) {\n        auto& require_upper_case = *any_cast<bool*>(dt);\n        if (require_upper_case) {\n            const auto& s = sv.str();\n            if (!std::all_of(s.begin(), s.end(), ::isupper)) {\n                throw parse_error(message);\n            }\n        }\n    };\n"
    },
    {
        "begin_line": 251,
        "end_line": 251,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "require_upper_case",
        "snippet": "    bool require_upper_case = false;\n"
    },
    {
        "begin_line": 252,
        "end_line": 252,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "dt",
        "snippet": "    any dt = &require_upper_case;\n"
    },
    {
        "begin_line": 258,
        "end_line": 262,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0a02",
        "snippet": "    parser.log = [&](size_t ln, size_t col, const std::string& msg) {\n        REQUIRE(ln == 1);\n        REQUIRE(col == 7);\n        REQUIRE(msg == message);\n    };\n"
    },
    {
        "begin_line": 268,
        "end_line": 278,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        # Rules\n        ROOT         <-  ITEM (',' ITEM)*\n        ITEM         <-  WORD / PHRASE\n\n        # Tokens\n        WORD         <-  < [a-zA-Z0-9_]+ >\n        PHRASE       <-  < '\"' (!'\"' .)* '\"' >\n\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 280,
        "end_line": 280,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(R\"(  one, \t \"two, three\",   four  )\");\n"
    },
    {
        "begin_line": 287,
        "end_line": 295,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        # Rules\n        ROOT         <-  ITEM (',' ITEM)*\n        ITEM         <-  '[' < [a-zA-Z0-9_]+ > ']'\n\n        %whitespace  <-  (SPACE / TAB)*\n        SPACE        <-  ' '\n        TAB          <-  '\\t'\n    )\");\n"
    },
    {
        "begin_line": 297,
        "end_line": 297,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "items",
        "snippet": "    std::vector<std::string> items;\n"
    },
    {
        "begin_line": 298,
        "end_line": 300,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0b02",
        "snippet": "    parser[\"ITEM\"] = [&](const SemanticValues& sv) {\n        items.push_back(sv.token());\n    };\n"
    },
    {
        "begin_line": 302,
        "end_line": 302,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(R\"([one], \t[two] ,[three] )\");\n"
    },
    {
        "begin_line": 312,
        "end_line": 318,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        StrQuot      <- < '\"' < (StrEscape / StrChars)* > '\"' >\n        StrEscape    <- '\\\\' any\n        StrChars     <- (!'\"' !'\\\\' any)+\n        any          <- .\n        %whitespace  <- [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 320,
        "end_line": 322,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0c02",
        "snippet": "    parser[\"StrQuot\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == R\"(  aaa \\\" bbb  )\");\n    };\n"
    },
    {
        "begin_line": 324,
        "end_line": 324,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(R\"( \"  aaa \\\" bbb  \" )\");\n"
    },
    {
        "begin_line": 329,
        "end_line": 335,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT         <-  HELLO OPE WORLD\n        HELLO        <-  'hello'\n        OPE          <-  < [-+] >\n        WORLD        <-  'world' / 'WORLD'\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 337,
        "end_line": 339,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0d02",
        "snippet": "    parser[\"HELLO\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"hello\");\n    };\n"
    },
    {
        "begin_line": 341,
        "end_line": 343,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0e02",
        "snippet": "    parser[\"OPE\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"+\");\n    };\n"
    },
    {
        "begin_line": 345,
        "end_line": 347,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f0f02",
        "snippet": "    parser[\"WORLD\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"world\");\n    };\n"
    },
    {
        "begin_line": 349,
        "end_line": 349,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"  hello + world  \");\n"
    },
    {
        "begin_line": 354,
        "end_line": 358,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT         <-  'hello' ','? 'world'\n        %whitespace  <-  [ \\t\\r\\n]*\n        %word        <-  [a-z]+\n    )\");\n"
    },
    {
        "begin_line": 369,
        "end_line": 373,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(\n        \"  ROOT  <-  _ ITEM (',' _ ITEM _)* \"\n        \"  ITEM  <-  ([a-z0-9])+  \"\n        \"  ~_    <-  [ \\t]*    \"\n    );\n"
    },
    {
        "begin_line": 375,
        "end_line": 377,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1002",
        "snippet": "    parser[\"ROOT\"] = [&](const SemanticValues& sv) {\n        REQUIRE(sv.size() == 2);\n    };\n"
    },
    {
        "begin_line": 379,
        "end_line": 379,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\" item1, item2 \");\n"
    },
    {
        "begin_line": 386,
        "end_line": 390,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT        <-  ITEM (',' ITEM)*\n        ITEM        <-  < ([a-z0-9])+ >\n        %whitespace <-  [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 392,
        "end_line": 394,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1102",
        "snippet": "    parser[\"ROOT\"] = [&](const SemanticValues& sv) {\n        REQUIRE(sv.size() == 2);\n    };\n"
    },
    {
        "begin_line": 396,
        "end_line": 396,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\" item1, item2 \");\n"
    },
    {
        "begin_line": 403,
        "end_line": 403,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "CustomType",
        "snippet": "\tstruct CustomType {};\n"
    },
    {
        "begin_line": 406,
        "end_line": 410,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT <- _ TEXT*\n        TEXT <- [a-zA-Z]+ _\n        _ <- [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 413,
        "end_line": 413,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<CustomAst> ast;\n"
    },
    {
        "begin_line": 414,
        "end_line": 414,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser.parse(\"a b c\", ast);\n"
    },
    {
        "begin_line": 421,
        "end_line": 426,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n       START <- PAT1 / PAT2\n       PAT1  <- HELLO ' One'\n       PAT2  <- HELLO ' Two'\n       HELLO <- 'Hello'\n    )\");\n"
    },
    {
        "begin_line": 428,
        "end_line": 428,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "count",
        "snippet": "    size_t count = 0;\n"
    },
    {
        "begin_line": 429,
        "end_line": 431,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1202",
        "snippet": "    parser[\"HELLO\"] = [&](const SemanticValues& /*sv*/) {\n        count++;\n    };\n"
    },
    {
        "begin_line": 435,
        "end_line": 435,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser.parse(\"Hello Two\");\n"
    },
    {
        "begin_line": 442,
        "end_line": 446,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        S <- A? B (A B)* A\n        A <- 'a'\n        B <- 'b'\n    )\");\n"
    },
    {
        "begin_line": 449,
        "end_line": 449,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 450,
        "end_line": 450,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser.parse(\"ba\", ast);\n"
    },
    {
        "begin_line": 457,
        "end_line": 459,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(\n        R\"( ROOT <- '\\132\\x7a\\u30f3' )\"\n    );\n"
    },
    {
        "begin_line": 461,
        "end_line": 461,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"Zz\u30f3\");\n"
    },
    {
        "begin_line": 467,
        "end_line": 472,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT         <-  HELLO WORLD\n        HELLO        <-  'hello'i\n        WORLD        <-  'world'i\n        %whitespace  <-  [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 474,
        "end_line": 476,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1302",
        "snippet": "    parser[\"HELLO\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"Hello\");\n    };\n"
    },
    {
        "begin_line": 478,
        "end_line": 480,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1402",
        "snippet": "    parser[\"WORLD\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.token() == \"World\");\n    };\n"
    },
    {
        "begin_line": 482,
        "end_line": 482,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"  Hello World  \");\n"
    },
    {
        "begin_line": 488,
        "end_line": 488,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "vec",
        "snippet": "    std::vector<std::string> vec;\n"
    },
    {
        "begin_line": 490,
        "end_line": 490,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "pg",
        "snippet": "    parser pg(\"ROOT <- 'mutable lambda test'\");\n"
    },
    {
        "begin_line": 493,
        "end_line": 495,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1502",
        "snippet": "    pg[\"TOKEN\"] = [=](const SemanticValues& sv) mutable {\n        vec.push_back(sv.str());\n    };\n"
    },
    {
        "begin_line": 500,
        "end_line": 505,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        Additive  <- Multitive '+' Additive / Multitive\n        Multitive <- Primary '*' Multitive / Primary\n        Primary   <- '(' Additive ')' / Number\n        Number    <- [0-9]+\n    )\");\n"
    },
    {
        "begin_line": 507,
        "end_line": 514,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1602",
        "snippet": "    parser[\"Additive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:\n            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);\n        default:\n            return any_cast<int>(sv[0]);\n        }\n    };\n"
    },
    {
        "begin_line": 516,
        "end_line": 523,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1702",
        "snippet": "    parser[\"Multitive\"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:\n            return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);\n        default:\n            return any_cast<int>(sv[0]);\n        }\n    };\n"
    },
    {
        "begin_line": 525,
        "end_line": 527,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1802",
        "snippet": "    parser[\"Number\"] = [](const SemanticValues& sv) {\n        return atoi(sv.c_str());\n    };\n"
    },
    {
        "begin_line": 529,
        "end_line": 529,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "val",
        "snippet": "    int val;\n"
    },
    {
        "begin_line": 538,
        "end_line": 538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "EXPRESSION",
        "snippet": "    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n"
    },
    {
        "begin_line": 538,
        "end_line": 538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "TERM",
        "snippet": "    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n"
    },
    {
        "begin_line": 538,
        "end_line": 538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "FACTOR",
        "snippet": "    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n"
    },
    {
        "begin_line": 538,
        "end_line": 538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "TERM_OPERATOR",
        "snippet": "    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n"
    },
    {
        "begin_line": 538,
        "end_line": 538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "FACTOR_OPERATOR",
        "snippet": "    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n"
    },
    {
        "begin_line": 538,
        "end_line": 538,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "NUMBER",
        "snippet": "    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;\n"
    },
    {
        "begin_line": 548,
        "end_line": 560,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1902",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n"
    },
    {
        "begin_line": 548,
        "end_line": 560,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "reduce",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n"
    },
    {
        "begin_line": 564,
        "end_line": 564,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1a02",
        "snippet": "    TERM_OPERATOR   = [](const SemanticValues& sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 565,
        "end_line": 565,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1b02",
        "snippet": "    FACTOR_OPERATOR = [](const SemanticValues& sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 566,
        "end_line": 566,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1c02",
        "snippet": "    NUMBER          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n"
    },
    {
        "begin_line": 569,
        "end_line": 569,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "val",
        "snippet": "    long val;\n"
    },
    {
        "begin_line": 570,
        "end_line": 570,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "r",
        "snippet": "    auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);\n"
    },
    {
        "begin_line": 579,
        "end_line": 587,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "syntax",
        "snippet": "    auto syntax = R\"(\n        # Grammar for Calculator...\n        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' EXPRESSION ')'\n        TERM_OPERATOR    <-  [-+]\n        FACTOR_OPERATOR  <-  [/*]\n        NUMBER           <-  [0-9]+\n    )\";\n"
    },
    {
        "begin_line": 589,
        "end_line": 589,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "start",
        "snippet": "    std::string start;\n"
    },
    {
        "begin_line": 590,
        "end_line": 590,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "grammar",
        "snippet": "    auto grammar = ParserGenerator::parse(syntax, strlen(syntax), start, nullptr);\n"
    },
    {
        "begin_line": 591,
        "end_line": 591,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "g",
        "snippet": "    auto& g = *grammar;\n"
    },
    {
        "begin_line": 594,
        "end_line": 606,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1d02",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n"
    },
    {
        "begin_line": 594,
        "end_line": 606,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "reduce",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n"
    },
    {
        "begin_line": 610,
        "end_line": 610,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1e02",
        "snippet": "    g[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 611,
        "end_line": 611,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f1f02",
        "snippet": "    g[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 612,
        "end_line": 612,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2002",
        "snippet": "    g[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n"
    },
    {
        "begin_line": 615,
        "end_line": 615,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "val",
        "snippet": "    long val;\n"
    },
    {
        "begin_line": 616,
        "end_line": 616,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "r",
        "snippet": "    auto r = g[start].parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);\n"
    },
    {
        "begin_line": 625,
        "end_line": 633,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        # Grammar for Calculator...\n        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' EXPRESSION ')'\n        TERM_OPERATOR    <-  [-+]\n        FACTOR_OPERATOR  <-  [/*]\n        NUMBER           <-  [0-9]+\n    )\");\n"
    },
    {
        "begin_line": 635,
        "end_line": 647,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2102",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n"
    },
    {
        "begin_line": 635,
        "end_line": 647,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "reduce",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        long ret = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            switch (any_cast<char>(sv[i])) {\n                case '+': ret += num; break;\n                case '-': ret -= num; break;\n                case '*': ret *= num; break;\n                case '/': ret /= num; break;\n            }\n        }\n        return ret;\n    };\n"
    },
    {
        "begin_line": 652,
        "end_line": 652,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2202",
        "snippet": "    parser[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n"
    },
    {
        "begin_line": 653,
        "end_line": 653,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2302",
        "snippet": "    parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n"
    },
    {
        "begin_line": 654,
        "end_line": 654,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2402",
        "snippet": "    parser[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };\n"
    },
    {
        "begin_line": 657,
        "end_line": 657,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "val",
        "snippet": "    long val;\n"
    },
    {
        "begin_line": 658,
        "end_line": 658,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", val);\n"
    },
    {
        "begin_line": 666,
        "end_line": 674,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _\n        TERM_OPERATOR    <-  < [-+] > _\n        FACTOR_OPERATOR  <-  < [/*] > _\n        NUMBER           <-  < [0-9]+ > _\n        ~_               <-  [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 678,
        "end_line": 696,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2502",
        "snippet": "    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            for (auto i = 1u; i < nodes.size(); i += 2) {\n                auto num = eval(*nodes[i + 1]);\n                auto ope = nodes[i]->token[0];\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n"
    },
    {
        "begin_line": 678,
        "end_line": 696,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "eval",
        "snippet": "    std::function<long (const Ast&)> eval = [&](const Ast& ast) {\n        if (ast.name == \"NUMBER\") {\n            return stol(ast.token);\n        } else {\n            const auto& nodes = ast.nodes;\n            auto result = eval(*nodes[0]);\n            for (auto i = 1u; i < nodes.size(); i += 2) {\n                auto num = eval(*nodes[i + 1]);\n                auto ope = nodes[i]->token[0];\n                switch (ope) {\n                    case '+': result += num; break;\n                    case '-': result -= num; break;\n                    case '*': result *= num; break;\n                    case '/': result /= num; break;\n                }\n            }\n            return result;\n        }\n    };\n"
    },
    {
        "begin_line": 698,
        "end_line": 698,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 699,
        "end_line": 699,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", ast);\n"
    },
    {
        "begin_line": 701,
        "end_line": 701,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "val",
        "snippet": "    auto val = eval(*ast);\n"
    },
    {
        "begin_line": 718,
        "end_line": 736,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2602",
        "snippet": "  std::function<long(const Ast &)> eval = [&](const Ast &ast) {\n    if (ast.name == \"NUMBER\") {\n      return stol(ast.token);\n    } else {\n      const auto &nodes = ast.nodes;\n      auto result = eval(*nodes[0]);\n      for (auto i = 1u; i < nodes.size(); i += 2) {\n        auto num = eval(*nodes[i + 1]);\n        auto ope = nodes[i]->token[0];\n        switch (ope) {\n        case '+': result += num; break;\n        case '-': result -= num; break;\n        case '*': result *= num; break;\n        case '/': result /= num; break;\n        }\n      }\n      return result;\n    }\n  };\n"
    },
    {
        "begin_line": 718,
        "end_line": 736,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "eval",
        "snippet": "  std::function<long(const Ast &)> eval = [&](const Ast &ast) {\n    if (ast.name == \"NUMBER\") {\n      return stol(ast.token);\n    } else {\n      const auto &nodes = ast.nodes;\n      auto result = eval(*nodes[0]);\n      for (auto i = 1u; i < nodes.size(); i += 2) {\n        auto num = eval(*nodes[i + 1]);\n        auto ope = nodes[i]->token[0];\n        switch (ope) {\n        case '+': result += num; break;\n        case '-': result -= num; break;\n        case '*': result *= num; break;\n        case '/': result /= num; break;\n        }\n      }\n      return result;\n    }\n  };\n"
    },
    {
        "begin_line": 738,
        "end_line": 738,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "  std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 739,
        "end_line": 739,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "r",
        "snippet": "  auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", ast);\n"
    },
    {
        "begin_line": 741,
        "end_line": 741,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "val",
        "snippet": "  auto val = eval(*ast);\n"
    },
    {
        "begin_line": 749,
        "end_line": 754,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n       START <-  ~HELLO WORLD\n       HELLO <- 'Hello' _\n       WORLD <- 'World' _\n       _     <- [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 758,
        "end_line": 758,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 759,
        "end_line": 759,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"Hello World\", ast);\n"
    },
    {
        "begin_line": 768,
        "end_line": 774,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n       START       <- _ !DUMMY HELLO_WORLD '.'\n       HELLO_WORLD <- HELLO 'World' _\n       HELLO       <- 'Hello' _\n       DUMMY       <- 'dummy' _\n       ~_          <- [ \\t\\r\\n]*\n   )\");\n"
    },
    {
        "begin_line": 778,
        "end_line": 778,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 779,
        "end_line": 779,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"Hello World.\", ast);\n"
    },
    {
        "begin_line": 788,
        "end_line": 793,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n       START       <- _ &HELLO HELLO_WORLD '.'\n       HELLO_WORLD <- HELLO 'World' _\n       HELLO       <- 'Hello' _\n       ~_          <- [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 797,
        "end_line": 797,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 798,
        "end_line": 798,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"Hello World.\", ast);\n"
    },
    {
        "begin_line": 807,
        "end_line": 809,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        STRING_LITERAL  <- '\"' (('\\\\\"' / '\\\\t' / '\\\\n') / (![\"] .))* '\"'\n    )\");\n"
    },
    {
        "begin_line": 812,
        "end_line": 812,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 813,
        "end_line": 813,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n"
    },
    {
        "begin_line": 823,
        "end_line": 827,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        STRING_LITERAL  <-  '\"' (ESC / CHAR)* '\"'\n        ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')\n        CHAR            <-  (![\"] .)\n    )\");\n"
    },
    {
        "begin_line": 830,
        "end_line": 830,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 831,
        "end_line": 831,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n"
    },
    {
        "begin_line": 841,
        "end_line": 845,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        STRING_LITERAL  <-  < '\"' (ESC / CHAR)* '\"' >\n        ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')\n        CHAR            <-  (![\"] .)\n    )\");\n"
    },
    {
        "begin_line": 848,
        "end_line": 848,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ast",
        "snippet": "    std::shared_ptr<Ast> ast;\n"
    },
    {
        "begin_line": 849,
        "end_line": 849,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(R\"(\"a\\tb\")\", ast);\n"
    },
    {
        "begin_line": 859,
        "end_line": 861,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        A <- B C\n    )\");\n"
    },
    {
        "begin_line": 868,
        "end_line": 871,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        A <- ''\n        A <- ''\n    )\");\n"
    },
    {
        "begin_line": 878,
        "end_line": 884,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        term <- ( a b c x )? a b c\n        a <- 'a'\n        b <- 'b'\n        c <- 'c'\n        x <- 'x'\n    )\");\n"
    },
    {
        "begin_line": 886,
        "end_line": 886,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "rule",
        "snippet": "\tfor (const auto& rule: parser.get_rule_names()){\n"
    },
    {
        "begin_line": 887,
        "end_line": 896,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2702",
        "snippet": "\t\tparser[rule.c_str()] = [rule](const SemanticValues& sv, any&) {\n            if (rule == \"term\") {\n                REQUIRE(any_cast<std::string>(sv[0]) == \"a at 0\");\n                REQUIRE(any_cast<std::string>(sv[1]) == \"b at 1\");\n                REQUIRE(any_cast<std::string>(sv[2]) == \"c at 2\");\n                return std::string();\n            } else {\n                return rule + \" at \" + std::to_string(sv.c_str() - sv.ss);\n            }\n\t\t};\n"
    },
    {
        "begin_line": 904,
        "end_line": 906,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        S <- 'a' / 'b'\n    )\");\n"
    },
    {
        "begin_line": 908,
        "end_line": 911,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2802",
        "snippet": "    parser[\"S\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.choice() == 1);\n        REQUIRE(sv.choice_count() == 2);\n    };\n"
    },
    {
        "begin_line": 918,
        "end_line": 920,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        S <- ('a' / 'b')*\n    )\");\n"
    },
    {
        "begin_line": 922,
        "end_line": 925,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2902",
        "snippet": "    parser[\"S\"] = [](const SemanticValues& sv) {\n        REQUIRE(sv.choice() == 0);\n        REQUIRE(sv.choice_count() == 0);\n    };\n"
    },
    {
        "begin_line": 932,
        "end_line": 937,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        S <- A? B* C?\n        A <- 'a'\n        B <- 'b'\n        C <- 'c'\n    )\");\n"
    },
    {
        "begin_line": 941,
        "end_line": 945,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2a02",
        "snippet": "        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 1);\n            REQUIRE(sv.tags.size() == 1);\n            REQUIRE(sv.tags[0] == \"C\"_);\n        };\n"
    },
    {
        "begin_line": 946,
        "end_line": 946,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "        auto ret = parser.parse(\"c\");\n"
    },
    {
        "begin_line": 952,
        "end_line": 957,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2b02",
        "snippet": "        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 2);\n            REQUIRE(sv.tags.size() == 2);\n            REQUIRE(sv.tags[0] == \"B\"_);\n            REQUIRE(sv.tags[1] == \"B\"_);\n        };\n"
    },
    {
        "begin_line": 958,
        "end_line": 958,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "        auto ret = parser.parse(\"bb\");\n"
    },
    {
        "begin_line": 964,
        "end_line": 969,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "__anon8119c98f2c02",
        "snippet": "        parser[\"S\"] = [](const SemanticValues& sv) {\n            REQUIRE(sv.size() == 2);\n            REQUIRE(sv.tags.size() == 2);\n            REQUIRE(sv.tags[0] == \"A\"_);\n            REQUIRE(sv.tags[1] == \"C\"_);\n        };\n"
    },
    {
        "begin_line": 970,
        "end_line": 970,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "        auto ret = parser.parse(\"ac\");\n"
    },
    {
        "begin_line": 977,
        "end_line": 979,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT <- [^a-z_]+\n    )\");\n"
    },
    {
        "begin_line": 981,
        "end_line": 981,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test1.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 8,
        "end_line": 12,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        ROOT  <- WH TOKEN* WH\n        TOKEN <- [a-z0-9]*\n        WH    <- [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 19,
        "end_line": 23,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        ROOT  <- WH TOKEN+ WH\n        TOKEN <- [a-z0-9]*\n        WH    <- [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 30,
        "end_line": 34,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        ROOT  <- WH TOKEN* WH\n        TOKEN <- !'word1'\n        WH    <- [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 41,
        "end_line": 45,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        ROOT  <- WH TOKEN* WH\n        TOKEN <- &'word1'\n        WH    <- [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 52,
        "end_line": 57,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        Numbers <- Number*\n        Number <- [0-9]+ / Spacing\n        Spacing <- ' ' / '\\t' / '\\n' / EOF # EOF is empty\n        EOF <- !.\n    )\");\n"
    },
    {
        "begin_line": 64,
        "end_line": 66,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        S <- ''*\n    )\");\n"
    },
    {
        "begin_line": 73,
        "end_line": 76,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        S <- A*\n        A <- ''\n    )\");\n"
    },
    {
        "begin_line": 83,
        "end_line": 88,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        Numbers <- Number* EOF\n        Number <- [0-9]+ / Spacing\n        Spacing <- ' ' / '\\t' / '\\n'\n        EOF <- !.\n    )\");\n"
    },
    {
        "begin_line": 95,
        "end_line": 100,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        ROOT      <-  _ ('[' TAG_NAME ']' _)*\n        # In a sequence operator, if there is at least one non-empty element, we can treat it as non-empty\n        TAG_NAME  <-  (!']' .)+\n        _         <-  [ \\t]*\n    )\");\n"
    },
    {
        "begin_line": 107,
        "end_line": 115,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "pg",
        "snippet": "    parser pg(R\"(\n        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*\n        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*\n        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _ # Recursive...\n        TERM_OPERATOR    <-  < [-+] > _\n        FACTOR_OPERATOR  <-  < [/*] > _\n        NUMBER           <-  < [0-9]+ > _\n        _                <-  [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 122,
        "end_line": 134,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START            <-  _ EXPRESSION\n        EXPRESSION       <-  ATOM (OPERATOR ATOM)* {\n                               precedence\n                                 L + -\n                                 L * /\n                             }\n        ATOM             <-  NUMBER / T('(') EXPRESSION T(')')\n        OPERATOR         <-  T([-+/*])\n        NUMBER           <-  T('-'? [0-9]+)\n\t\t~_               <-  [ \\t]*\n\t\tT(S)             <-  < S > _\n\t)\");\n"
    },
    {
        "begin_line": 139,
        "end_line": 152,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00102",
        "snippet": "    parser[\"EXPRESSION\"] = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        if (sv.size() > 1) {\n            auto ope = any_cast<char>(sv[1]);\n            auto num = any_cast<long>(sv[2]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n"
    },
    {
        "begin_line": 153,
        "end_line": 153,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00202",
        "snippet": "    parser[\"OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 154,
        "end_line": 154,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00302",
        "snippet": "    parser[\"NUMBER\"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };\n"
    },
    {
        "begin_line": 156,
        "end_line": 156,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 160,
        "end_line": 160,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "expr",
        "snippet": "        auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";\n"
    },
    {
        "begin_line": 161,
        "end_line": 161,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "val",
        "snippet": "        long val = 0;\n"
    },
    {
        "begin_line": 169,
        "end_line": 169,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "expr",
        "snippet": "      auto expr = \"-1+-2--3\"; // -1 + -2 - -3 = 0\n"
    },
    {
        "begin_line": 170,
        "end_line": 170,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "val",
        "snippet": "      long val = 0;\n"
    },
    {
        "begin_line": 181,
        "end_line": 192,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        EXPRESSION             <-  INFIX_EXPRESSION(ATOM, OPERATOR)\n        INFIX_EXPRESSION(A, O) <-  A (O A)* {\n                                     precedence\n                                       L + -\n                                       L * /\n                                   }\n        ATOM                   <-  NUMBER / '(' EXPRESSION ')'\n        OPERATOR               <-  < [-+/*] >\n        NUMBER                 <-  < '-'? [0-9]+ >\n        %whitespace            <-  [ \\t]*\n\t)\");\n"
    },
    {
        "begin_line": 196,
        "end_line": 196,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 200,
        "end_line": 213,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00402",
        "snippet": "    parser[\"INFIX_EXPRESSION\"] = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        if (sv.size() > 1) {\n            auto ope = any_cast<char>(sv[1]);\n            auto num = any_cast<long>(sv[2]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n"
    },
    {
        "begin_line": 214,
        "end_line": 214,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00502",
        "snippet": "    parser[\"OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };\n"
    },
    {
        "begin_line": 215,
        "end_line": 215,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00602",
        "snippet": "    parser[\"NUMBER\"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };\n"
    },
    {
        "begin_line": 218,
        "end_line": 218,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "expr",
        "snippet": "        auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";\n"
    },
    {
        "begin_line": 219,
        "end_line": 219,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "val",
        "snippet": "        long val = 0;\n"
    },
    {
        "begin_line": 227,
        "end_line": 227,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "expr",
        "snippet": "      auto expr = \"-1+-2--3\"; // -1 + -2 - -3 = 0\n"
    },
    {
        "begin_line": 228,
        "end_line": 228,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "val",
        "snippet": "      long val = 0;\n"
    },
    {
        "begin_line": 238,
        "end_line": 251,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START            <-  _ EXPRESSION\n        EXPRESSION       <-  ATOM (OPERATOR ATOM1)* {\n                               precedence\n                                 L + -\n                                 L * /\n                             }\n        ATOM             <-  NUMBER / T('(') EXPRESSION T(')')\n        ATOM1            <-  NUMBER / T('(') EXPRESSION T(')')\n        OPERATOR         <-  T([-+/*])\n        NUMBER           <-  T('-'? [0-9]+)\n\t\t~_               <-  [ \\t]*\n\t\tT(S)             <-  < S > _\n\t)\");\n"
    },
    {
        "begin_line": 253,
        "end_line": 253,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 259,
        "end_line": 271,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START            <-  _ EXPRESSION\n        EXPRESSION       <-  ATOM OPERATOR ATOM {\n                               precedence\n                                 L + -\n                                 L * /\n                             }\n        ATOM             <-  NUMBER / T('(') EXPRESSION T(')')\n        OPERATOR         <-  T([-+/*])\n        NUMBER           <-  T('-'? [0-9]+)\n\t\t~_               <-  [ \\t]*\n\t\tT(S)             <-  < S > _\n\t)\");\n"
    },
    {
        "begin_line": 273,
        "end_line": 273,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 278,
        "end_line": 289,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        EXPRESSION               <-  PRECEDENCE_PARSING(ATOM, OPERATOR)\n        PRECEDENCE_PARSING(A, O) <-  A (O A)+ {\n                                       precedence\n                                         L + -\n                                         L * /\n                                     }\n        ATOM                     <-  NUMBER / '(' EXPRESSION ')'\n        OPERATOR                 <-  < [-+/*] >\n        NUMBER                   <-  < '-'? [0-9]+ >\n        %whitespace              <-  [ \\t]*\n\t)\");\n"
    },
    {
        "begin_line": 291,
        "end_line": 291,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 296,
        "end_line": 300,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    peg::parser parser(R\"(\n        ROOT         <-  'a'\n        %whitespace  <-  SPACE*\n        SPACE        <-  ' '\n    )\");\n"
    },
    {
        "begin_line": 304,
        "end_line": 304,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\"a\");\n"
    },
    {
        "begin_line": 310,
        "end_line": 320,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)\n        TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)\n        FACTOR           <-  NUMBER / T('(') EXPRESSION T(')')\n        TERM_OPERATOR    <-  T([-+])\n        FACTOR_OPERATOR  <-  T([/*])\n        NUMBER           <-  T([0-9]+)\n\t\t~_               <-  [ \\t]*\n\t\tLIST(I, D)       <-  I (D I)*\n\t\tT(S)             <-  < S > _\n\t)\");\n"
    },
    {
        "begin_line": 324,
        "end_line": 324,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    auto ret = parser.parse(\" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \");\n"
    },
    {
        "begin_line": 329,
        "end_line": 335,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "  peg::parser parser(R\"(\n    Expression  <- Atom (Operator Atom)* { precedence L + - L * / }\n    Atom        <- _? Number _?\n    Number      <- [0-9]+\n    Operator    <- '+' / '-' / '*' / '/'\n    _           <- ' '+\n  )\");\n"
    },
    {
        "begin_line": 337,
        "end_line": 337,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "  bool ret = parser;\n"
    },
    {
        "begin_line": 348,
        "end_line": 353,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START  <- _ LQUOTE < (!RQUOTE .)* > RQUOTE _\n        LQUOTE <- 'R\"' $delm< [a-zA-Z]* > '('\n        RQUOTE <- ')' $delm '\"'\n        ~_     <- [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 355,
        "end_line": 355,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "token",
        "snippet": "    std::string token;\n"
    },
    {
        "begin_line": 356,
        "end_line": 358,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00702",
        "snippet": "    parser[\"START\"] = [&](const SemanticValues& sv) {\n        token = sv.token();\n    };\n"
    },
    {
        "begin_line": 362,
        "end_line": 364,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "        auto ret = parser.parse(R\"delm(\n            R\"(\"hello world\")\"\n        )delm\");\n"
    },
    {
        "begin_line": 372,
        "end_line": 374,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "        auto ret = parser.parse(R\"delm(\n            R\"foo(\"(hello world)\")foo\"\n        )delm\");\n"
    },
    {
        "begin_line": 382,
        "end_line": 384,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "        auto ret = parser.parse(R\"delm(\n            R\"foo(\"(hello world)foo\")foo\"\n        )delm\");\n"
    },
    {
        "begin_line": 392,
        "end_line": 394,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "        auto ret = parser.parse(R\"delm(\n            R\"foo(\"(hello world)\")bar\"\n        )delm\");\n"
    },
    {
        "begin_line": 403,
        "end_line": 408,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START  <- _ LQUOTE (!RQUOTE .)* RQUOTE _\n        LQUOTE <- 'R\"' $delm< [a-zA-Z]* > '('\n        RQUOTE <- ')' $delm2 '\"'\n        ~_     <- [ \\t\\r\\n]*\n    )\");\n"
    },
    {
        "begin_line": 420,
        "end_line": 429,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        ROOT      <- CONTENT\n        CONTENT   <- (ELEMENT / TEXT)*\n        ELEMENT   <- $(STAG CONTENT ETAG)\n        STAG      <- '<' $tag< TAG_NAME > '>'\n        ETAG      <- '</' $tag '>'\n        TAG_NAME  <- 'b' / 'u'\n        TEXT      <- TEXT_DATA\n        TEXT_DATA <- ![<] .\n    )\");\n"
    },
    {
        "begin_line": 439,
        "end_line": 449,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        TREE           <- WRONG_BRANCH / CORRECT_BRANCH\n        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG\n        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT\n        BRANCH         <- 'branch'\n        THAT           <- 'that'\n        IS_capture     <- $ref<..>\n        IS_backref     <- $ref\n        WRONG          <- 'wrong'\n        CORRECT        <- 'correct'\n    )\");\n"
    },
    {
        "begin_line": 456,
        "end_line": 466,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        TREE           <- WRONG_BRANCH* CORRECT_BRANCH\n        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG\n        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT\n        BRANCH         <- 'branch'\n        THAT           <- 'that'\n        IS_capture     <- $ref<..>\n        IS_backref     <- $ref\n        WRONG          <- 'wrong'\n        CORRECT        <- 'correct'\n    )\");\n"
    },
    {
        "begin_line": 478,
        "end_line": 488,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        TREE           <- WRONG_BRANCH+ CORRECT_BRANCH\n        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG\n        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT\n        BRANCH         <- 'branch'\n        THAT           <- 'that'\n        IS_capture     <- $ref<..>\n        IS_backref     <- $ref\n        WRONG          <- 'wrong'\n        CORRECT        <- 'correct'\n    )\");\n"
    },
    {
        "begin_line": 500,
        "end_line": 510,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        TREE           <- WRONG_BRANCH? CORRECT_BRANCH\n        WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG\n        CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT\n        BRANCH         <- 'branch'\n        THAT           <- 'that'\n        IS_capture     <- $ref<..>\n        IS_backref     <- $ref\n        WRONG          <- 'wrong'\n        CORRECT        <- 'correct'\n    )\");\n"
    },
    {
        "begin_line": 522,
        "end_line": 525,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START <- '(' DIGIT{3} ') ' DIGIT{3} '-' DIGIT{4}\n        DIGIT <- [0-9]\n    )\");\n"
    },
    {
        "begin_line": 534,
        "end_line": 537,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START <- DIGIT{2,4}\n        DIGIT <- [0-9]\n    )\");\n"
    },
    {
        "begin_line": 547,
        "end_line": 550,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START <- DIGIT{2,1} # invalid range\n        DIGIT <- [0-9]\n    )\");\n"
    },
    {
        "begin_line": 558,
        "end_line": 561,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START <- DIGIT{2,}\n        DIGIT <- [0-9]\n    )\");\n"
    },
    {
        "begin_line": 570,
        "end_line": 573,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START <- DIGIT{,2}\n        DIGIT <- [0-9]\n    )\");\n"
    },
    {
        "begin_line": 582,
        "end_line": 585,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        A <- A 'a'\n        B <- A 'a'\n    )\");\n"
    },
    {
        "begin_line": 592,
        "end_line": 595,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        A  <- 'a' / 'b'? B 'c'\n        B  <- A\n    )\");\n"
    },
    {
        "begin_line": 602,
        "end_line": 604,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        A <- 'a'* A*\n    )\");\n"
    },
    {
        "begin_line": 611,
        "end_line": 615,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        A <- B\n        B <- _ A\n        _ <- ' '* # Zero or more\n    )\");\n"
    },
    {
        "begin_line": 622,
        "end_line": 624,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(\n        \" A <- '' A\"\n    );\n"
    },
    {
        "begin_line": 636,
        "end_line": 644,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00802",
        "snippet": "            \"NAME\", usr([](const char* s, size_t n, SemanticValues& /*sv*/, any& /*dt*/) -> size_t {\n                static std::vector<std::string> names = { \"PEG\", \"BNF\" };\n                for (const auto& name: names) {\n                    if (name.size() <= n && !name.compare(0, name.size(), s, name.size())) {\n                        return name.size();\n                    }\n                }\n                return static_cast<size_t>(-1);\n            })\n"
    },
    {
        "begin_line": 631,
        "end_line": 649,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "g",
        "snippet": "    auto g = parser(R\"(\n        ROOT <- _ 'Hello' _ NAME '!' _\n    )\",\n    {\n        {\n            \"NAME\", usr([](const char* s, size_t n, SemanticValues& /*sv*/, any& /*dt*/) -> size_t {\n                static std::vector<std::string> names = { \"PEG\", \"BNF\" };\n                for (const auto& name: names) {\n                    if (name.size() <= n && !name.compare(0, name.size(), s, name.size())) {\n                        return name.size();\n                    }\n                }\n                return static_cast<size_t>(-1);\n            })\n        },\n        {\n            \"~_\", zom(cls(\" \\t\\r\\n\"))\n        }\n    });\n"
    },
    {
        "begin_line": 656,
        "end_line": 656,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(\"NUMBER  <-  [0-9]+\");\n"
    },
    {
        "begin_line": 658,
        "end_line": 664,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00902",
        "snippet": "    parser[\"NUMBER\"] = [](const SemanticValues& sv) {\n        auto val = stol(sv.token(), nullptr, 10);\n        if (val != 100) {\n            throw parse_error(\"value error!!\");\n        }\n        return val;\n    };\n"
    },
    {
        "begin_line": 666,
        "end_line": 666,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "val",
        "snippet": "    long val;\n"
    },
    {
        "begin_line": 670,
        "end_line": 674,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00a02",
        "snippet": "    parser.log = [](size_t line, size_t col, const std::string& msg) {\n        REQUIRE(line == 1);\n        REQUIRE(col == 1);\n        REQUIRE(msg == \"value error!!\");\n    };\n"
    },
    {
        "begin_line": 680,
        "end_line": 689,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    peg::parser parser(u8R\"(\n        \u6587 <- \u4fee\u98fe\u8a9e? \u4e3b\u8a9e \u8ff0\u8a9e '\u3002'\n        \u4e3b\u8a9e <- \u540d\u8a5e \u52a9\u8a5e\n        \u8ff0\u8a9e <- \u52d5\u8a5e \u52a9\u8a5e\n        \u4fee\u98fe\u8a9e <- \u5f62\u5bb9\u8a5e\n        \u540d\u8a5e <- '\u30b5\u30fc\u30d0\u30fc' / '\u30af\u30e9\u30a4\u30a2\u30f3\u30c8'\n        \u5f62\u5bb9\u8a5e <- '\u53e4\u3044' / '\u65b0\u3057\u3044'\n        \u52d5\u8a5e <- '\u843d\u3061' / '\u5fa9\u65e7\u3057'\n        \u52a9\u8a5e <- '\u304c' / '\u3092' / '\u305f' / '\u307e\u3059' / '\u306b'\n    )\");\n"
    },
    {
        "begin_line": 691,
        "end_line": 691,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 699,
        "end_line": 699,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    peg::parser parser(\" S <- 'a' . 'b' \");\n"
    },
    {
        "begin_line": 705,
        "end_line": 705,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    peg::parser parser(\" S <- 'a' . 'b' \");\n"
    },
    {
        "begin_line": 711,
        "end_line": 713,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    peg::parser parser(R\"(\n        S <- 'a' [\u3044-\u304aA\u3055C-E\u305f-\u3068\u306f] 'b'\n    )\");\n"
    },
    {
        "begin_line": 715,
        "end_line": 715,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 746,
        "end_line": 751,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS     <- HELLO WORLD\n\t\tHELLO <- T('hello')\n\t\tWORLD <- T('world')\n\t\tT(a)  <- a [ \\t]*\n\t)\");\n"
    },
    {
        "begin_line": 758,
        "end_line": 762,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS           <- HELLO_WORLD\n\t\tHELLO_WORLD <- T('hello', 'world')\n\t\tT(a, b)     <- a [ \\t]* b [ \\t]*\n\t)\");\n"
    },
    {
        "begin_line": 769,
        "end_line": 772,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS     <- T('hello')\n\t\tT (a) <- a [ \\t]*\n\t)\");\n"
    },
    {
        "begin_line": 774,
        "end_line": 774,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 780,
        "end_line": 783,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS       <- T ('hello')\n\t\tT(a, b) <- a [ \\t]* b\n\t)\");\n"
    },
    {
        "begin_line": 785,
        "end_line": 785,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 791,
        "end_line": 794,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS    <- T ('hello')\n\t\tT(a) <- a [ \\t]*\n\t)\");\n"
    },
    {
        "begin_line": 796,
        "end_line": 796,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 802,
        "end_line": 805,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS <- T('hello')\n\t\tT <- 'world'\n\t)\");\n"
    },
    {
        "begin_line": 807,
        "end_line": 807,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 814,
        "end_line": 825,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        # Grammar for simple calculator...\n        EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)\n        TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)\n        FACTOR           <-  NUMBER / T('(') EXPRESSION T(')')\n        TERM_OPERATOR    <-  T([-+])\n        FACTOR_OPERATOR  <-  T([/*])\n        NUMBER           <-  T([0-9]+)\n\t\t~_               <-  [ \\t]*\n\t\tLIST(I, D)       <-  I (D I)*\n\t\tT(S)             <-  < S > _\n\t)\");\n"
    },
    {
        "begin_line": 828,
        "end_line": 841,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00b02",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            auto ope = any_cast<char>(sv[i]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n"
    },
    {
        "begin_line": 828,
        "end_line": 841,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "reduce",
        "snippet": "    auto reduce = [](const SemanticValues& sv) -> long {\n        auto result = any_cast<long>(sv[0]);\n        for (auto i = 1u; i < sv.size(); i += 2) {\n            auto num = any_cast<long>(sv[i + 1]);\n            auto ope = any_cast<char>(sv[i]);\n            switch (ope) {\n                case '+': result += num; break;\n                case '-': result -= num; break;\n                case '*': result *= num; break;\n                case '/': result /= num; break;\n            }\n        }\n        return result;\n    };\n"
    },
    {
        "begin_line": 845,
        "end_line": 845,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00c02",
        "snippet": "    parser[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n"
    },
    {
        "begin_line": 846,
        "end_line": 846,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00d02",
        "snippet": "    parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };\n"
    },
    {
        "begin_line": 847,
        "end_line": 847,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00e02",
        "snippet": "    parser[\"NUMBER\"]          = [](const SemanticValues& sv) { return atol(sv.c_str()); };\n"
    },
    {
        "begin_line": 849,
        "end_line": 849,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 852,
        "end_line": 852,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "expr",
        "snippet": "\tauto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";\n"
    },
    {
        "begin_line": 853,
        "end_line": 853,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "val",
        "snippet": "    long val = 0;\n"
    },
    {
        "begin_line": 862,
        "end_line": 865,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS             <- M('hello' / 'Hello', 'world' / 'World')\n\t\tM(arg0, arg1) <- arg0 [ \\t]+ arg1\n\t)\");\n"
    },
    {
        "begin_line": 872,
        "end_line": 875,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS    <- M('abc')\n\t\tM(s) <- !s / s ' ' M(s / '123') / s\n\t)\");\n"
    },
    {
        "begin_line": 895,
        "end_line": 895,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "syntax",
        "snippet": "\tfor (const auto& syntax: syntaxes) {\n"
    },
    {
        "begin_line": 903,
        "end_line": 912,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n\t\tS                   <- Modifiers(!\"\") _\n\t\tModifiers(Appeared) <- (!Appeared) (\n\t\t\t\t\t\t\t\t   Token('public') Modifiers(Appeared / 'public') /\n\t\t\t\t\t\t\t\t   Token('static') Modifiers(Appeared / 'static') /\n\t\t\t\t\t\t\t\t   Token('final') Modifiers(Appeared / 'final') /\n\t\t\t\t\t\t\t\t   \"\")\n\t\tToken(t)            <- t _\n\t\t_                   <- [ \\t\\r\\n]*\n\t)\");\n"
    },
    {
        "begin_line": 924,
        "end_line": 935,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        # Grammar for simple calculator...\n        EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)\n        TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)\n        FACTOR           <-  NUMBER / T('(') EXPRESSION T(')')\n        TERM_OPERATOR    <-  T([-+])\n        FACTOR_OPERATOR  <-  T([/*])\n        NUMBER           <-  T([0-9]+)\n\t\t~_               <-  [ \\t]*\n\t\tLIST(I, D)       <-  I (D I)*\n\t\tT(S)             <-  < S > _\n\t)\");\n"
    },
    {
        "begin_line": 948,
        "end_line": 953,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "  parser parser(R\"(\n        A    <- B(C)\n        B(D) <- D\n        C    <- 'c'\n        D    <- 'd'\n\t)\");\n"
    },
    {
        "begin_line": 959,
        "end_line": 964,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "  parser parser(R\"(\n        A    <- B(T)\n        B(X) <- C(X)\n        C(Y) <- Y\n        T    <- 'val'\n\t)\");\n"
    },
    {
        "begin_line": 971,
        "end_line": 975,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START           <- A('TestVal1', 'TestVal2')+\n        A(Aarg1, Aarg2) <- B(Aarg1) '#End'\n        B(Barg1)        <- '#' Barg1\n\t)\");\n"
    },
    {
        "begin_line": 981,
        "end_line": 985,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        S    <- _ (WORD _)+\n        WORD <- [A-Za-z]+\n        ~_   <- [ \\t\\r\\n]+\n    )\");\n"
    },
    {
        "begin_line": 987,
        "end_line": 987,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "locations",
        "snippet": "    std::vector<std::pair<size_t, size_t>> locations;\n"
    },
    {
        "begin_line": 988,
        "end_line": 990,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "__anon811a55f00f02",
        "snippet": "    parser[\"WORD\"] = [&](const peg::SemanticValues& sv) {\n        locations.push_back(sv.line_info());\n    };\n"
    },
    {
        "begin_line": 992,
        "end_line": 992,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 1009,
        "end_line": 1012,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START <- 'This month is ' MONTH '.'\n        MONTH <- 'Jan' | 'January' | 'Feb' | 'February'\n\t)\");\n"
    },
    {
        "begin_line": 1022,
        "end_line": 1025,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "parser",
        "snippet": "    parser parser(R\"(\n        START <- 'This month is ' MONTH '.'\n        MONTH <- 'Jan' | 'January' | [a-z]+ | 'Feb' | 'February'\n\t)\");\n"
    },
    {
        "begin_line": 1027,
        "end_line": 1027,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test2.cc",
        "func_name": "ret",
        "snippet": "    bool ret = parser;\n"
    },
    {
        "begin_line": 6,
        "end_line": 10,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "exact",
        "snippet": "inline bool exact(Grammar& g, const char* d, const char* s) {\n    auto n = strlen(s);\n    auto r = g[d].parse(s, n);\n    return r.ret && r.len == n;\n}\n"
    },
    {
        "begin_line": 12,
        "end_line": 14,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "make_peg_grammar",
        "snippet": "inline Grammar& make_peg_grammar() {\n    return ParserGenerator::grammar();\n}\n"
    },
    {
        "begin_line": 18,
        "end_line": 18,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 24,
        "end_line": 24,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 38,
        "end_line": 38,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 49,
        "end_line": 49,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 59,
        "end_line": 59,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 69,
        "end_line": 69,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 90,
        "end_line": 90,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 106,
        "end_line": 106,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 117,
        "end_line": 117,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 128,
        "end_line": 128,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 139,
        "end_line": 139,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 161,
        "end_line": 161,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 183,
        "end_line": 183,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 205,
        "end_line": 205,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 216,
        "end_line": 216,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 249,
        "end_line": 249,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 264,
        "end_line": 264,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 273,
        "end_line": 273,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 283,
        "end_line": 283,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    auto g = ParserGenerator::grammar();\n"
    },
    {
        "begin_line": 294,
        "end_line": 294,
        "file_name": "./proj/cpp_peglib/buggy-1/test/test3.cc",
        "func_name": "g",
        "snippet": "    Grammar g = make_peg_grammar();\n"
    }
]